import { r as t, c as n, h as e, g as r } from './p-9031eb6a.js';
import { c as i } from './p-eab67c09.js';
import { g as o } from './p-54ad2682.js';
import { t as u } from './p-6a46bf1b.js';
import './p-8a133b9b.js';
/*!
 * https://github.com/Starcounter-Jack/JSON-Patch
 * (c) 2017-2022 Joachim Wester
 * MIT licensed
 */ var s,
  a =
    ((s = function (t, n) {
      return (
        (s =
          Object.setPrototypeOf ||
          ({ __proto__: [] } instanceof Array &&
            function (t, n) {
              t.__proto__ = n;
            }) ||
          function (t, n) {
            for (var e in n) n.hasOwnProperty(e) && (t[e] = n[e]);
          }),
        s(t, n)
      );
    }),
    function (t, n) {
      function e() {
        this.constructor = t;
      }
      s(t, n), (t.prototype = null === n ? Object.create(n) : ((e.prototype = n.prototype), new e()));
    }),
  c = Object.prototype.hasOwnProperty;
function l(t, n) {
  return c.call(t, n);
}
function f(t) {
  if (Array.isArray(t)) {
    for (var n = new Array(t.length), e = 0; e < n.length; e++) n[e] = '' + e;
    return n;
  }
  if (Object.keys) return Object.keys(t);
  var r = [];
  for (var i in t) l(t, i) && r.push(i);
  return r;
}
function h(t) {
  switch (typeof t) {
    case 'object':
      return JSON.parse(JSON.stringify(t));
    case 'undefined':
      return null;
    default:
      return t;
  }
}
function d(t) {
  for (var n, e = 0, r = t.length; e < r; ) {
    if (!((n = t.charCodeAt(e)) >= 48 && n <= 57)) return !1;
    e++;
  }
  return !0;
}
function p(t) {
  return -1 === t.indexOf('/') && -1 === t.indexOf('~') ? t : t.replace(/~/g, '~0').replace(/\//g, '~1');
}
function m(t) {
  return t.replace(/~1/g, '/').replace(/~0/g, '~');
}
function v(t) {
  if (void 0 === t) return !0;
  if (t)
    if (Array.isArray(t)) {
      for (var n = 0, e = t.length; n < e; n++) if (v(t[n])) return !0;
    } else if ('object' == typeof t) for (var r = f(t), i = r.length, o = 0; o < i; o++) if (v(t[r[o]])) return !0;
  return !1;
}
function g(t, n) {
  var e = [t];
  for (var r in n) {
    var i = 'object' == typeof n[r] ? JSON.stringify(n[r], null, 2) : n[r];
    void 0 !== i && e.push(r + ': ' + i);
  }
  return e.join('\n');
}
var b = (function (t) {
    function n(n, e, r, i, o) {
      var u = this.constructor,
        s = t.call(this, g(n, { name: e, index: r, operation: i, tree: o })) || this;
      return (
        (s.name = e),
        (s.index = r),
        (s.operation = i),
        (s.tree = o),
        Object.setPrototypeOf(s, u.prototype),
        (s.message = g(n, { name: e, index: r, operation: i, tree: o })),
        s
      );
    }
    return a(n, t), n;
  })(Error),
  y = b,
  w = {
    add: function (t, n, e) {
      return (t[n] = this.value), { newDocument: e };
    },
    remove: function (t, n, e) {
      var r = t[n];
      return delete t[n], { newDocument: e, removed: r };
    },
    replace: function (t, n, e) {
      var r = t[n];
      return (t[n] = this.value), { newDocument: e, removed: r };
    },
    move: function (t, n, e) {
      var r = O(e, this.path);
      r && (r = h(r));
      var i = k(e, { op: 'remove', path: this.from }).removed;
      return k(e, { op: 'add', path: this.path, value: i }), { newDocument: e, removed: r };
    },
    copy: function (t, n, e) {
      var r = O(e, this.from);
      return k(e, { op: 'add', path: this.path, value: h(r) }), { newDocument: e };
    },
    test: function (t, n, e) {
      return { newDocument: e, test: j(t[n], this.value) };
    },
    _get: function (t, n, e) {
      return (this.value = t[n]), { newDocument: e };
    },
  },
  x = {
    add: function (t, n, e) {
      return d(n) ? t.splice(n, 0, this.value) : (t[n] = this.value), { newDocument: e, index: n };
    },
    remove: function (t, n, e) {
      return { newDocument: e, removed: t.splice(n, 1)[0] };
    },
    replace: function (t, n, e) {
      var r = t[n];
      return (t[n] = this.value), { newDocument: e, removed: r };
    },
    move: w.move,
    copy: w.copy,
    test: w.test,
    _get: w._get,
  };
function O(t, n) {
  if ('' == n) return t;
  var e = { op: '_get', path: n };
  return k(t, e), e.value;
}
function k(t, n, e, r, i, o) {
  if (
    (void 0 === e && (e = !1),
    void 0 === r && (r = !0),
    void 0 === i && (i = !0),
    void 0 === o && (o = 0),
    e && ('function' == typeof e ? e(n, 0, t, n.path) : $(n, 0)),
    '' === n.path)
  ) {
    var u = { newDocument: t };
    if ('add' === n.op) return (u.newDocument = n.value), u;
    if ('replace' === n.op) return (u.newDocument = n.value), (u.removed = t), u;
    if ('move' === n.op || 'copy' === n.op)
      return (u.newDocument = O(t, n.from)), 'move' === n.op && (u.removed = t), u;
    if ('test' === n.op) {
      if (((u.test = j(t, n.value)), !1 === u.test))
        throw new y('Test operation failed', 'TEST_OPERATION_FAILED', o, n, t);
      return (u.newDocument = t), u;
    }
    if ('remove' === n.op) return (u.removed = t), (u.newDocument = null), u;
    if ('_get' === n.op) return (n.value = t), u;
    if (e)
      throw new y(
        'Operation `op` property is not one of operations defined in RFC-6902',
        'OPERATION_OP_INVALID',
        o,
        n,
        t,
      );
    return u;
  }
  r || (t = h(t));
  var s = (n.path || '').split('/'),
    a = t,
    c = 1,
    l = s.length,
    f = void 0,
    p = void 0,
    v = void 0;
  for (v = 'function' == typeof e ? e : $; ; ) {
    if (
      ((p = s[c]) && -1 != p.indexOf('~') && (p = m(p)),
      i && ('__proto__' == p || ('prototype' == p && c > 0 && 'constructor' == s[c - 1])))
    )
      throw new TypeError(
        'JSON-Patch: modifying `__proto__` or `constructor/prototype` prop is banned for security reasons, if this was on purpose, please set `banPrototypeModifications` flag false and pass it to this function. More info in fast-json-patch README',
      );
    if (
      (e &&
        void 0 === f &&
        (void 0 === a[p] ? (f = s.slice(0, c).join('/')) : c == l - 1 && (f = n.path), void 0 !== f && v(n, 0, t, f)),
      c++,
      Array.isArray(a))
    ) {
      if ('-' === p) p = a.length;
      else {
        if (e && !d(p))
          throw new y(
            'Expected an unsigned base-10 integer value, making the new referenced value the array element with the zero-based index',
            'OPERATION_PATH_ILLEGAL_ARRAY_INDEX',
            o,
            n,
            t,
          );
        d(p) && (p = ~~p);
      }
      if (c >= l) {
        if (e && 'add' === n.op && p > a.length)
          throw new y(
            'The specified index MUST NOT be greater than the number of elements in the array',
            'OPERATION_VALUE_OUT_OF_BOUNDS',
            o,
            n,
            t,
          );
        if (!1 === (u = x[n.op].call(n, a, p, t)).test)
          throw new y('Test operation failed', 'TEST_OPERATION_FAILED', o, n, t);
        return u;
      }
    } else if (c >= l) {
      if (!1 === (u = w[n.op].call(n, a, p, t)).test)
        throw new y('Test operation failed', 'TEST_OPERATION_FAILED', o, n, t);
      return u;
    }
    if (((a = a[p]), e && c < l && (!a || 'object' != typeof a)))
      throw new y('Cannot perform operation at the desired path', 'OPERATION_PATH_UNRESOLVABLE', o, n, t);
  }
}
function A(t, n, e, r, i) {
  if ((void 0 === r && (r = !0), void 0 === i && (i = !0), e && !Array.isArray(n)))
    throw new y('Patch sequence must be an array', 'SEQUENCE_NOT_AN_ARRAY');
  r || (t = h(t));
  for (var o = new Array(n.length), u = 0, s = n.length; u < s; u++)
    (o[u] = k(t, n[u], e, !0, i, u)), (t = o[u].newDocument);
  return (o.newDocument = t), o;
}
function $(t, n, e, r) {
  if ('object' != typeof t || null === t || Array.isArray(t))
    throw new y('Operation is not an object', 'OPERATION_NOT_AN_OBJECT', n, t, e);
  if (!w[t.op])
    throw new y(
      'Operation `op` property is not one of operations defined in RFC-6902',
      'OPERATION_OP_INVALID',
      n,
      t,
      e,
    );
  if ('string' != typeof t.path)
    throw new y('Operation `path` property is not a string', 'OPERATION_PATH_INVALID', n, t, e);
  if (0 !== t.path.indexOf('/') && t.path.length > 0)
    throw new y('Operation `path` property must start with "/"', 'OPERATION_PATH_INVALID', n, t, e);
  if (('move' === t.op || 'copy' === t.op) && 'string' != typeof t.from)
    throw new y(
      'Operation `from` property is not present (applicable in `move` and `copy` operations)',
      'OPERATION_FROM_REQUIRED',
      n,
      t,
      e,
    );
  if (('add' === t.op || 'replace' === t.op || 'test' === t.op) && void 0 === t.value)
    throw new y(
      'Operation `value` property is not present (applicable in `add`, `replace` and `test` operations)',
      'OPERATION_VALUE_REQUIRED',
      n,
      t,
      e,
    );
  if (('add' === t.op || 'replace' === t.op || 'test' === t.op) && v(t.value))
    throw new y(
      'Operation `value` property is not present (applicable in `add`, `replace` and `test` operations)',
      'OPERATION_VALUE_CANNOT_CONTAIN_UNDEFINED',
      n,
      t,
      e,
    );
  if (e)
    if ('add' == t.op) {
      var i = t.path.split('/').length,
        o = r.split('/').length;
      if (i !== o + 1 && i !== o)
        throw new y('Cannot perform an `add` operation at the desired path', 'OPERATION_PATH_CANNOT_ADD', n, t, e);
    } else if ('replace' === t.op || 'remove' === t.op || '_get' === t.op) {
      if (t.path !== r)
        throw new y(
          'Cannot perform the operation at a path that does not exist',
          'OPERATION_PATH_UNRESOLVABLE',
          n,
          t,
          e,
        );
    } else if ('move' === t.op || 'copy' === t.op) {
      var u = M([{ op: '_get', path: t.from, value: void 0 }], e);
      if (u && 'OPERATION_PATH_UNRESOLVABLE' === u.name)
        throw new y(
          'Cannot perform the operation from a path that does not exist',
          'OPERATION_FROM_UNRESOLVABLE',
          n,
          t,
          e,
        );
    }
}
function M(t, n, e) {
  try {
    if (!Array.isArray(t)) throw new y('Patch sequence must be an array', 'SEQUENCE_NOT_AN_ARRAY');
    if (n) A(h(n), h(t), e || !0);
    else {
      e = e || $;
      for (var r = 0; r < t.length; r++) e(t[r], r, n, void 0);
    }
  } catch (t) {
    if (t instanceof y) return t;
    throw t;
  }
}
function j(t, n) {
  if (t === n) return !0;
  if (t && n && 'object' == typeof t && 'object' == typeof n) {
    var e,
      r,
      i,
      o = Array.isArray(t),
      u = Array.isArray(n);
    if (o && u) {
      if ((r = t.length) != n.length) return !1;
      for (e = r; 0 != e--; ) if (!j(t[e], n[e])) return !1;
      return !0;
    }
    if (o != u) return !1;
    var s = Object.keys(t);
    if ((r = s.length) !== Object.keys(n).length) return !1;
    for (e = r; 0 != e--; ) if (!n.hasOwnProperty(s[e])) return !1;
    for (e = r; 0 != e--; ) if (!j(t[(i = s[e])], n[i])) return !1;
    return !0;
  }
  return t != t && n != n;
}
const D = Object.freeze({
  __proto__: null,
  JsonPatchError: y,
  deepClone: h,
  getValueByPointer: O,
  applyOperation: k,
  applyPatch: A,
  applyReducer: function (t, n, e) {
    var r = k(t, n);
    if (!1 === r.test) throw new y('Test operation failed', 'TEST_OPERATION_FAILED', e, n, t);
    return r.newDocument;
  },
  validator: $,
  validate: M,
  _areEquals: j,
});
/*!
 * https://github.com/Starcounter-Jack/JSON-Patch
 * (c) 2017-2021 Joachim Wester
 * MIT license
 */ var F = new WeakMap(),
  E = function (t) {
    (this.observers = new Map()), (this.obj = t);
  },
  S = function (t, n) {
    (this.callback = t), (this.observer = n);
  };
function C(t, n) {
  void 0 === n && (n = !1);
  var e = F.get(t.object);
  N(e.value, t.object, t.patches, '', n), t.patches.length && A(e.value, t.patches);
  var r = t.patches;
  return r.length > 0 && ((t.patches = []), t.callback && t.callback(r)), r;
}
function N(t, n, e, r, i) {
  if (n !== t) {
    'function' == typeof n.toJSON && (n = n.toJSON());
    for (var o = f(n), u = f(t), s = !1, a = u.length - 1; a >= 0; a--) {
      var c = t[(m = u[a])];
      if (!l(n, m) || (void 0 === n[m] && void 0 !== c && !1 === Array.isArray(n)))
        Array.isArray(t) === Array.isArray(n)
          ? (i && e.push({ op: 'test', path: r + '/' + p(m), value: h(c) }),
            e.push({ op: 'remove', path: r + '/' + p(m) }),
            (s = !0))
          : (i && e.push({ op: 'test', path: r, value: t }), e.push({ op: 'replace', path: r, value: n }));
      else {
        var d = n[m];
        'object' == typeof c && null != c && 'object' == typeof d && null != d && Array.isArray(c) === Array.isArray(d)
          ? N(c, d, e, r + '/' + p(m), i)
          : c !== d &&
            (i && e.push({ op: 'test', path: r + '/' + p(m), value: h(c) }),
            e.push({ op: 'replace', path: r + '/' + p(m), value: h(d) }));
      }
    }
    if (s || o.length != u.length)
      for (a = 0; a < o.length; a++) {
        var m;
        l(t, (m = o[a])) || void 0 === n[m] || e.push({ op: 'add', path: r + '/' + p(m), value: h(n[m]) });
      }
  }
}
Object.assign(
  {},
  D,
  Object.freeze({
    __proto__: null,
    unobserve: function (t, n) {
      n.unobserve();
    },
    observe: function (t, n) {
      var e,
        r = (function (t) {
          return F.get(t);
        })(t);
      if (r) {
        var i = (function (t, n) {
          return t.observers.get(n);
        })(r, n);
        e = i && i.observer;
      } else (r = new E(t)), F.set(t, r);
      if (e) return e;
      if (((e = {}), (r.value = h(t)), n)) {
        (e.callback = n), (e.next = null);
        var o = function () {
            C(e);
          },
          u = function () {
            clearTimeout(e.next), (e.next = setTimeout(o));
          };
        'undefined' != typeof window &&
          (window.addEventListener('mouseup', u),
          window.addEventListener('keyup', u),
          window.addEventListener('mousedown', u),
          window.addEventListener('keydown', u),
          window.addEventListener('change', u));
      }
      return (
        (e.patches = []),
        (e.object = t),
        (e.unobserve = function () {
          C(e),
            clearTimeout(e.next),
            (function (t, n) {
              t.observers.delete(n.callback);
            })(r, e),
            'undefined' != typeof window &&
              (window.removeEventListener('mouseup', u),
              window.removeEventListener('keyup', u),
              window.removeEventListener('mousedown', u),
              window.removeEventListener('keydown', u),
              window.removeEventListener('change', u));
        }),
        r.observers.set(n, new S(n, e)),
        e
      );
    },
    generate: C,
    compare: function (t, n, e) {
      void 0 === e && (e = !1);
      var r = [];
      return N(t, n, r, '', e), r;
    },
  }),
  { JsonPatchError: b, deepClone: h, escapePathComponent: p, unescapePathComponent: m },
);
var B = /("(?:[^\\"]|\\.)*")|[:,]/g,
  _ = function (t, n) {
    var e, r, i;
    return (
      (n = n || {}),
      (e = JSON.stringify([1], void 0, void 0 === n.indent ? 2 : n.indent).slice(2, -3)),
      (r = '' === e ? 1 / 0 : void 0 === n.maxLength ? 80 : n.maxLength),
      (i = n.replacer),
      (function t(n, o, u) {
        var s, a, c, l, f, h, d, p, m, v, g, b;
        if ((n && 'function' == typeof n.toJSON && (n = n.toJSON()), void 0 === (g = JSON.stringify(n, i)))) return g;
        if (
          g.length <= (d = r - o.length - u) &&
          ((m = g.replace(B, function (t, n) {
            return n || t + ' ';
          })),
          m.length <= d)
        )
          return m;
        if ((null != i && ((n = JSON.parse(g)), (i = void 0)), 'object' == typeof n && null !== n)) {
          if (((p = o + e), (c = []), (a = 0), Array.isArray(n)))
            for (v = '[', s = ']', d = n.length; a < d; a++) c.push(t(n[a], p, a === d - 1 ? 0 : 1) || 'null');
          else
            for (v = '{', s = '}', d = (h = Object.keys(n)).length; a < d; a++)
              (l = h[a]),
                (f = JSON.stringify(l) + ': '),
                void 0 !== (b = t(n[l], p, f.length + (a === d - 1 ? 0 : 1))) && c.push(f + b);
          if (c.length > 0) return [v, e + c.join(',\n' + p), s].join('\n' + o);
        }
        return g;
      })(t, '', 0)
    );
  };
function z(t, n, e) {
  return (t.fields = n || []), (t.fname = e), t;
}
function T(t) {
  return null == t ? null : t.fname;
}
function P(t) {
  return null == t ? null : t.fields;
}
function R(t) {
  return 1 === t.length ? L(t[0]) : q(t);
}
const L = t =>
    function (n) {
      return n[t];
    },
  q = t => {
    const n = t.length;
    return function (e) {
      for (let r = 0; r < n; ++r) e = e[t[r]];
      return e;
    };
  };
function I(t) {
  throw Error(t);
}
function U(t) {
  const n = [],
    e = t.length;
  let r,
    i,
    o,
    u = null,
    s = 0,
    a = '';
  function c() {
    n.push(a + t.substring(r, i)), (a = ''), (r = i + 1);
  }
  for (t += '', r = i = 0; i < e; ++i)
    if (((o = t[i]), '\\' === o)) (a += t.substring(r, i)), (a += t.substring(++i, ++i)), (r = i);
    else if (o === u) c(), (u = null), (s = -1);
    else {
      if (u) continue;
      (r === s && '"' === o) || (r === s && "'" === o)
        ? ((r = i + 1), (u = o))
        : '.' !== o || s
        ? '[' === o
          ? (i > r && c(), (s = r = i + 1))
          : ']' === o && (s || I('Access path missing open bracket: ' + t), s > 0 && c(), (s = 0), (r = i + 1))
        : i > r
        ? c()
        : (r = i + 1);
    }
  return (
    s && I('Access path missing closing bracket: ' + t),
    u && I('Access path missing closing quote: ' + t),
    i > r && (i++, c()),
    n
  );
}
function W(t, n, e) {
  const r = U(t);
  return (t = 1 === r.length ? r[0] : t), z(((e && e.get) || R)(r), [t], n || t);
}
const H = W('id'),
  G = z(t => t, [], 'identity'),
  V = z(() => 0, [], 'zero'),
  Y = z(() => 1, [], 'one'),
  X = z(() => !0, [], 'true'),
  J = z(() => !1, [], 'false');
function Q(t, n, e) {
  const r = [n].concat([].slice.call(e));
  console[t].apply(console, r);
}
function Z(t, n, e = Q) {
  let r = t || 0;
  return {
    level(t) {
      return arguments.length ? ((r = +t), this) : r;
    },
    error() {
      return r >= 1 && e(n || 'error', 'ERROR', arguments), this;
    },
    warn() {
      return r >= 2 && e(n || 'warn', 'WARN', arguments), this;
    },
    info() {
      return r >= 3 && e(n || 'log', 'INFO', arguments), this;
    },
    debug() {
      return r >= 4 && e(n || 'log', 'DEBUG', arguments), this;
    },
  };
}
var K = Array.isArray;
function tt(t) {
  return t === Object(t);
}
const nt = t => '__proto__' !== t;
function et(...t) {
  return t.reduce((t, n) => {
    for (const e in n)
      'signals' === e
        ? (t.signals = it(t.signals, n.signals))
        : rt(t, e, n[e], 'legend' === e ? { layout: 1 } : 'style' === e || null);
    return t;
  }, {});
}
function rt(t, n, e, r) {
  if (!nt(n)) return;
  let i, o;
  if (tt(e) && !K(e))
    for (i in ((o = tt(t[n]) ? t[n] : (t[n] = {})), e))
      r && (!0 === r || r[i]) ? rt(o, i, e[i]) : nt(i) && (o[i] = e[i]);
  else t[n] = e;
}
function it(t, n) {
  if (null == t) return n;
  const e = {},
    r = [];
  function i(t) {
    e[t.name] || ((e[t.name] = 1), r.push(t));
  }
  return n.forEach(i), t.forEach(i), r;
}
function ot(t) {
  return t[t.length - 1];
}
function ut(t) {
  return null == t || '' === t ? null : +t;
}
const st = t => n => t * Math.exp(n),
  at = t => n => Math.log(t * n),
  ct = t => n => Math.sign(n) * Math.log1p(Math.abs(n / t)),
  lt = t => n => Math.sign(n) * Math.expm1(Math.abs(n)) * t,
  ft = t => n => (n < 0 ? -Math.pow(-n, t) : Math.pow(n, t));
function ht(t, n, e, r) {
  const i = e(t[0]),
    o = e(ot(t)),
    u = (o - i) * n;
  return [r(i - u), r(o - u)];
}
function dt(t, n) {
  return ht(t, n, ut, G);
}
function pt(t, n) {
  var e = Math.sign(t[0]);
  return ht(t, n, at(e), st(e));
}
function mt(t, n, e) {
  return ht(t, n, ft(e), ft(1 / e));
}
function vt(t, n, e) {
  return ht(t, n, ct(e), lt(e));
}
function gt(t, n, e, r, i) {
  const o = r(t[0]),
    u = r(ot(t)),
    s = null != n ? r(n) : (o + u) / 2;
  return [i(s + (o - s) * e), i(s + (u - s) * e)];
}
function bt(t, n, e) {
  return gt(t, n, e, ut, G);
}
function yt(t, n, e) {
  const r = Math.sign(t[0]);
  return gt(t, n, e, at(r), st(r));
}
function wt(t, n, e, r) {
  return gt(t, n, e, ft(r), ft(1 / r));
}
function xt(t, n, e, r) {
  return gt(t, n, e, ct(r), lt(r));
}
function Ot(t) {
  return 1 + ~~(new Date(t).getMonth() / 3);
}
function kt(t) {
  return 1 + ~~(new Date(t).getUTCMonth() / 3);
}
function At(t) {
  return null != t ? (K(t) ? t : [t]) : [];
}
function $t(t, n, e) {
  let r,
    i = t[0],
    o = t[1];
  return (
    o < i && ((r = o), (o = i), (i = r)),
    (r = o - i),
    r >= e - n ? [n, e] : [(i = Math.min(Math.max(i, n), e - r)), i + r]
  );
}
function Mt(t) {
  return 'function' == typeof t;
}
function jt(t, n, e) {
  (e = e || {}), (n = At(n) || []);
  const r = [],
    i = [],
    o = {},
    u = e.comparator || Ft;
  return (
    At(t).forEach((t, u) => {
      null != t &&
        (r.push('descending' === n[u] ? -1 : 1),
        i.push((t = Mt(t) ? t : W(t, null, e))),
        (P(t) || []).forEach(t => (o[t] = 1)));
    }),
    0 === i.length ? null : z(u(i, r), Object.keys(o))
  );
}
const Dt = (t, n) =>
    (t < n || null == t) && null != n
      ? -1
      : (t > n || null == n) && null != t
      ? 1
      : ((n = n instanceof Date ? +n : n),
        (t = t instanceof Date ? +t : t) !== t && n == n ? -1 : n != n && t == t ? 1 : 0),
  Ft = (t, n) => (1 === t.length ? Et(t[0], n[0]) : St(t, n, t.length)),
  Et = (t, n) =>
    function (e, r) {
      return Dt(t(e), t(r)) * n;
    },
  St = (t, n, e) => (
    n.push(0),
    function (r, i) {
      let o,
        u = 0,
        s = -1;
      for (; 0 === u && ++s < e; ) (o = t[s]), (u = Dt(o(r), o(i)));
      return u * n[s];
    }
  );
function Ct(t) {
  return Mt(t) ? t : () => t;
}
function Nt(t, n) {
  let e;
  return r => {
    e && clearTimeout(e), (e = setTimeout(() => (n(r), (e = null)), t));
  };
}
function Bt(t) {
  for (let n, e, r = 1, i = arguments.length; r < i; ++r) for (e in ((n = arguments[r]), n)) t[e] = n[e];
  return t;
}
function _t(t, n) {
  let e,
    r,
    i,
    o,
    u = 0;
  if (t && (e = t.length))
    if (null == n) {
      for (r = t[u]; u < e && (null == r || r != r); r = t[++u]);
      for (i = o = r; u < e; ++u) (r = t[u]), null != r && (r < i && (i = r), r > o && (o = r));
    } else {
      for (r = n(t[u]); u < e && (null == r || r != r); r = n(t[++u]));
      for (i = o = r; u < e; ++u) (r = n(t[u])), null != r && (r < i && (i = r), r > o && (o = r));
    }
  return [i, o];
}
function zt(t, n) {
  const e = t.length;
  let r,
    i,
    o,
    u,
    s,
    a = -1;
  if (null == n) {
    for (; ++a < e; )
      if (((i = t[a]), null != i && i >= i)) {
        r = o = i;
        break;
      }
    if (a === e) return [-1, -1];
    for (u = s = a; ++a < e; ) (i = t[a]), null != i && (r > i && ((r = i), (u = a)), o < i && ((o = i), (s = a)));
  } else {
    for (; ++a < e; )
      if (((i = n(t[a], a, t)), null != i && i >= i)) {
        r = o = i;
        break;
      }
    if (a === e) return [-1, -1];
    for (u = s = a; ++a < e; )
      (i = n(t[a], a, t)), null != i && (r > i && ((r = i), (u = a)), o < i && ((o = i), (s = a)));
  }
  return [u, s];
}
const Tt = Object.prototype.hasOwnProperty;
function Pt(t, n) {
  return Tt.call(t, n);
}
const Rt = {};
function Lt(t) {
  let n,
    e = {};
  function r(t) {
    return Pt(e, t) && e[t] !== Rt;
  }
  const i = {
    size: 0,
    empty: 0,
    object: e,
    has: r,
    get: t => (r(t) ? e[t] : void 0),
    set(t, n) {
      return r(t) || (++i.size, e[t] === Rt && --i.empty), (e[t] = n), this;
    },
    delete(t) {
      return r(t) && (--i.size, ++i.empty, (e[t] = Rt)), this;
    },
    clear() {
      (i.size = i.empty = 0), (i.object = e = {});
    },
    test(t) {
      return arguments.length ? ((n = t), i) : n;
    },
    clean() {
      const t = {};
      let r = 0;
      for (const i in e) {
        const o = e[i];
        o === Rt || (n && n(o)) || ((t[i] = o), ++r);
      }
      (i.size = r), (i.empty = 0), (i.object = e = t);
    },
  };
  return (
    t &&
      Object.keys(t).forEach(n => {
        i.set(n, t[n]);
      }),
    i
  );
}
function qt(t, n, e, r, i, o) {
  if (!e && 0 !== e) return o;
  const u = +e;
  let s,
    a = t[0],
    c = ot(t);
  c < a && ((s = a), (a = c), (c = s)), (s = Math.abs(n - a));
  const l = Math.abs(c - n);
  return s < l && s <= u ? r : l <= u ? i : o;
}
function It(t, n, e) {
  const r = (t.prototype = Object.create(n.prototype));
  return (
    Object.defineProperty(r, 'constructor', { value: t, writable: !0, enumerable: !0, configurable: !0 }), Bt(r, e)
  );
}
function Ut(t, n, e, r) {
  let i,
    o = n[0],
    u = n[n.length - 1];
  return (
    o > u && ((i = o), (o = u), (u = i)),
    (r = void 0 === r || r),
    ((e = void 0 === e || e) ? o <= t : o < t) && (r ? t <= u : t < u)
  );
}
function Wt(t) {
  return 'boolean' == typeof t;
}
function Ht(t) {
  return '[object Date]' === Object.prototype.toString.call(t);
}
function Gt(t) {
  return t && Mt(t[Symbol.iterator]);
}
function Vt(t) {
  return 'number' == typeof t;
}
function Yt(t) {
  return '[object RegExp]' === Object.prototype.toString.call(t);
}
function Xt(t) {
  return 'string' == typeof t;
}
function Jt(t, n, e) {
  t && (t = n ? At(t).map(t => t.replace(/\\(.)/g, '$1')) : At(t));
  const r = t && t.length,
    i = (e && e.get) || R,
    o = t => i(n ? [t] : U(t));
  let u;
  if (r)
    if (1 === r) {
      const n = o(t[0]);
      u = function (t) {
        return '' + n(t);
      };
    } else {
      const n = t.map(o);
      u = function (t) {
        let e = '' + n[0](t),
          i = 0;
        for (; ++i < r; ) e += '|' + n[i](t);
        return e;
      };
    }
  else
    u = function () {
      return '';
    };
  return z(u, t, 'key');
}
function Qt(t, n) {
  const e = t[0],
    r = ot(t),
    i = +n;
  return i ? (1 === i ? r : e + i * (r - e)) : e;
}
function Zt(t) {
  let n, e, r;
  t = +t || 1e4;
  const i = () => {
      (n = {}), (e = {}), (r = 0);
    },
    o = (i, o) => (++r > t && ((e = n), (n = {}), (r = 1)), (n[i] = o));
  return (
    i(),
    {
      clear: i,
      has: t => Pt(n, t) || Pt(e, t),
      get: t => (Pt(n, t) ? n[t] : Pt(e, t) ? o(t, e[t]) : void 0),
      set: (t, e) => (Pt(n, t) ? (n[t] = e) : o(t, e)),
    }
  );
}
function Kt(t, n, e, r) {
  const i = n.length,
    o = e.length;
  if (!o) return n;
  if (!i) return e;
  const u = r || new n.constructor(i + o);
  let s = 0,
    a = 0,
    c = 0;
  for (; s < i && a < o; ++c) u[c] = t(n[s], e[a]) > 0 ? e[a++] : n[s++];
  for (; s < i; ++s, ++c) u[c] = n[s];
  for (; a < o; ++a, ++c) u[c] = e[a];
  return u;
}
function tn(t, n) {
  let e = '';
  for (; --n >= 0; ) e += t;
  return e;
}
function nn(t, n, e, r) {
  const i = e || ' ',
    o = t + '',
    u = n - o.length;
  return u <= 0
    ? o
    : 'left' === r
    ? tn(i, u) + o
    : 'center' === r
    ? tn(i, ~~(u / 2)) + o + tn(i, Math.ceil(u / 2))
    : o + tn(i, u);
}
function en(t) {
  return (t && ot(t) - t[0]) || 0;
}
function rn(t) {
  return K(t)
    ? '[' + t.map(rn) + ']'
    : tt(t) || Xt(t)
    ? JSON.stringify(t).replace('\u2028', '\\u2028').replace('\u2029', '\\u2029')
    : t;
}
function on(t) {
  return null == t || '' === t ? null : !(!t || 'false' === t || '0' === t || !t);
}
const un = t => (Vt(t) || Ht(t) ? t : Date.parse(t));
function sn(t, n) {
  return (n = n || un), null == t || '' === t ? null : n(t);
}
function an(t) {
  return null == t || '' === t ? null : t + '';
}
function cn(t) {
  const n = {},
    e = t.length;
  for (let r = 0; r < e; ++r) n[t[r]] = !0;
  return n;
}
function ln(t, n, e, r) {
  const i = null != r ? r : '…',
    o = t + '',
    u = o.length,
    s = Math.max(0, n - i.length);
  return u <= n
    ? o
    : 'left' === e
    ? i + o.slice(u - s)
    : 'center' === e
    ? o.slice(0, Math.ceil(s / 2)) + i + o.slice(u - ~~(s / 2))
    : o.slice(0, s) + i;
}
function fn(t, n, e) {
  if (t)
    if (n) {
      const r = t.length;
      for (let i = 0; i < r; ++i) {
        const r = n(t[i]);
        r && e(r, i, t);
      }
    } else t.forEach(e);
}
var hn = {},
  dn = {};
function pn(t) {
  return new Function(
    'd',
    'return {' +
      t
        .map(function (t, n) {
          return JSON.stringify(t) + ': d[' + n + '] || ""';
        })
        .join(',') +
      '}',
  );
}
function mn(t) {
  var n = Object.create(null),
    e = [];
  return (
    t.forEach(function (t) {
      for (var r in t) r in n || e.push((n[r] = r));
    }),
    e
  );
}
function vn(t, n) {
  var e = t + '',
    r = e.length;
  return r < n ? new Array(n - r + 1).join(0) + e : e;
}
function gn(t) {
  var n = new RegExp('["' + t + '\n\r]'),
    e = t.charCodeAt(0);
  function r(t, n) {
    var r,
      i = [],
      o = t.length,
      u = 0,
      s = 0,
      a = o <= 0,
      c = !1;
    function l() {
      if (a) return dn;
      if (c) return (c = !1), hn;
      var n,
        r,
        i = u;
      if (34 === t.charCodeAt(i)) {
        for (; (u++ < o && 34 !== t.charCodeAt(u)) || 34 === t.charCodeAt(++u); );
        return (
          (n = u) >= o
            ? (a = !0)
            : 10 === (r = t.charCodeAt(u++))
            ? (c = !0)
            : 13 === r && ((c = !0), 10 === t.charCodeAt(u) && ++u),
          t.slice(i + 1, n - 1).replace(/""/g, '"')
        );
      }
      for (; u < o; ) {
        if (10 === (r = t.charCodeAt((n = u++)))) c = !0;
        else if (13 === r) (c = !0), 10 === t.charCodeAt(u) && ++u;
        else if (r !== e) continue;
        return t.slice(i, n);
      }
      return (a = !0), t.slice(i, o);
    }
    for (10 === t.charCodeAt(o - 1) && --o, 13 === t.charCodeAt(o - 1) && --o; (r = l()) !== dn; ) {
      for (var f = []; r !== hn && r !== dn; ) f.push(r), (r = l());
      (n && null == (f = n(f, s++))) || i.push(f);
    }
    return i;
  }
  function i(n, e) {
    return n.map(function (n) {
      return e
        .map(function (t) {
          return u(n[t]);
        })
        .join(t);
    });
  }
  function o(n) {
    return n.map(u).join(t);
  }
  function u(t) {
    return null == t
      ? ''
      : t instanceof Date
      ? (function (t) {
          var n,
            e = t.getUTCHours(),
            r = t.getUTCMinutes(),
            i = t.getUTCSeconds(),
            o = t.getUTCMilliseconds();
          return isNaN(t)
            ? 'Invalid Date'
            : ((n = t.getUTCFullYear()) < 0 ? '-' + vn(-n, 6) : n > 9999 ? '+' + vn(n, 6) : vn(n, 4)) +
                '-' +
                vn(t.getUTCMonth() + 1, 2) +
                '-' +
                vn(t.getUTCDate(), 2) +
                (o
                  ? 'T' + vn(e, 2) + ':' + vn(r, 2) + ':' + vn(i, 2) + '.' + vn(o, 3) + 'Z'
                  : i
                  ? 'T' + vn(e, 2) + ':' + vn(r, 2) + ':' + vn(i, 2) + 'Z'
                  : r || e
                  ? 'T' + vn(e, 2) + ':' + vn(r, 2) + 'Z'
                  : '');
        })(t)
      : n.test((t += ''))
      ? '"' + t.replace(/"/g, '""') + '"'
      : t;
  }
  return {
    parse: function (t, n) {
      var e,
        i,
        o = r(t, function (t, r) {
          if (e) return e(t, r - 1);
          (i = t),
            (e = n
              ? (function (t, n) {
                  var e = pn(t);
                  return function (r, i) {
                    return n(e(r), i, t);
                  };
                })(t, n)
              : pn(t));
        });
      return (o.columns = i || []), o;
    },
    parseRows: r,
    format: function (n, e) {
      return null == e && (e = mn(n)), [e.map(u).join(t)].concat(i(n, e)).join('\n');
    },
    formatBody: function (t, n) {
      return null == n && (n = mn(t)), i(t, n).join('\n');
    },
    formatRows: function (t) {
      return t.map(o).join('\n');
    },
    formatRow: o,
    formatValue: u,
  };
}
function bn(t) {
  return t;
}
function yn(t, n) {
  return (
    'string' == typeof n && (n = t.objects[n]),
    'GeometryCollection' === n.type
      ? {
          type: 'FeatureCollection',
          features: n.geometries.map(function (n) {
            return wn(t, n);
          }),
        }
      : wn(t, n)
  );
}
function wn(t, n) {
  var e = n.id,
    r = n.bbox,
    i = null == n.properties ? {} : n.properties,
    o = xn(t, n);
  return null == e && null == r
    ? { type: 'Feature', properties: i, geometry: o }
    : null == r
    ? { type: 'Feature', id: e, properties: i, geometry: o }
    : { type: 'Feature', id: e, bbox: r, properties: i, geometry: o };
}
function xn(t, n) {
  var e = (function (t) {
      if (null == t) return bn;
      var n,
        e,
        r = t.scale[0],
        i = t.scale[1],
        o = t.translate[0],
        u = t.translate[1];
      return function (t, s) {
        s || (n = e = 0);
        var a = 2,
          c = t.length,
          l = new Array(c);
        for (l[0] = (n += t[0]) * r + o, l[1] = (e += t[1]) * i + u; a < c; ) (l[a] = t[a]), ++a;
        return l;
      };
    })(t.transform),
    r = t.arcs;
  function i(t, n) {
    n.length && n.pop();
    for (var i = r[t < 0 ? ~t : t], o = 0, u = i.length; o < u; ++o) n.push(e(i[o], o));
    t < 0 &&
      (function (t, n) {
        for (var e, r = t.length, i = r - n; i < --r; ) (e = t[i]), (t[i++] = t[r]), (t[r] = e);
      })(n, u);
  }
  function o(t) {
    return e(t);
  }
  function u(t) {
    for (var n = [], e = 0, r = t.length; e < r; ++e) i(t[e], n);
    return n.length < 2 && n.push(n[0]), n;
  }
  function s(t) {
    for (var n = u(t); n.length < 4; ) n.push(n[0]);
    return n;
  }
  function a(t) {
    return t.map(s);
  }
  return (function t(n) {
    var e,
      r = n.type;
    switch (r) {
      case 'GeometryCollection':
        return { type: r, geometries: n.geometries.map(t) };
      case 'Point':
        e = o(n.coordinates);
        break;
      case 'MultiPoint':
        e = n.coordinates.map(o);
        break;
      case 'LineString':
        e = u(n.arcs);
        break;
      case 'MultiLineString':
        e = n.arcs.map(u);
        break;
      case 'Polygon':
        e = a(n.arcs);
        break;
      case 'MultiPolygon':
        e = n.arcs.map(a);
        break;
      default:
        return null;
    }
    return { type: r, coordinates: e };
  })(n);
}
function On(t, n) {
  var e = {},
    r = {},
    i = {},
    o = [],
    u = -1;
  function s(t, n) {
    for (var r in t) {
      var i = t[r];
      delete n[i.start],
        delete i.start,
        delete i.end,
        i.forEach(function (t) {
          e[t < 0 ? ~t : t] = 1;
        }),
        o.push(i);
    }
  }
  return (
    n.forEach(function (e, r) {
      var i,
        o = t.arcs[e < 0 ? ~e : e];
      o.length < 3 && !o[1][0] && !o[1][1] && ((i = n[++u]), (n[u] = e), (n[r] = i));
    }),
    n.forEach(function (n) {
      var e,
        o,
        u = (function (n) {
          var e,
            r = t.arcs[n < 0 ? ~n : n],
            i = r[0];
          return (
            t.transform
              ? ((e = [0, 0]),
                r.forEach(function (t) {
                  (e[0] += t[0]), (e[1] += t[1]);
                }))
              : (e = r[r.length - 1]),
            n < 0 ? [e, i] : [i, e]
          );
        })(n),
        s = u[0],
        a = u[1];
      if ((e = i[s]))
        if ((delete i[e.end], e.push(n), (e.end = a), (o = r[a]))) {
          delete r[o.start];
          var c = o === e ? e : e.concat(o);
          r[(c.start = e.start)] = i[(c.end = o.end)] = c;
        } else r[e.start] = i[e.end] = e;
      else if ((e = r[a]))
        if ((delete r[e.start], e.unshift(n), (e.start = s), (o = i[s]))) {
          delete i[o.end];
          var l = o === e ? e : o.concat(e);
          r[(l.start = o.start)] = i[(l.end = e.end)] = l;
        } else r[e.start] = i[e.end] = e;
      else r[((e = [n]).start = s)] = i[(e.end = a)] = e;
    }),
    s(i, r),
    s(r, i),
    n.forEach(function (t) {
      e[t < 0 ? ~t : t] || o.push([t]);
    }),
    o
  );
}
function kn(t) {
  return xn(t, An.apply(this, arguments));
}
function An(t, n, e) {
  var r, i, o;
  if (arguments.length > 1) r = $n(0, n, e);
  else for (i = 0, r = new Array((o = t.arcs.length)); i < o; ++i) r[i] = i;
  return { type: 'MultiLineString', arcs: On(t, r) };
}
function $n(t, n, e) {
  var r,
    i = [],
    o = [];
  function u(t) {
    var n = t < 0 ? ~t : t;
    (o[n] || (o[n] = [])).push({ i: t, g: r });
  }
  function s(t) {
    t.forEach(u);
  }
  function a(t) {
    t.forEach(s);
  }
  return (
    (function t(n) {
      switch (((r = n), n.type)) {
        case 'GeometryCollection':
          n.geometries.forEach(t);
          break;
        case 'LineString':
          s(n.arcs);
          break;
        case 'MultiLineString':
        case 'Polygon':
          a(n.arcs);
          break;
        case 'MultiPolygon':
          !(function (t) {
            t.forEach(a);
          })(n.arcs);
      }
    })(n),
    o.forEach(
      null == e
        ? function (t) {
            i.push(t[0].i);
          }
        : function (t) {
            e(t[0].g, t[t.length - 1].g) && i.push(t[0].i);
          },
    ),
    i
  );
}
function Mn(t, n) {
  return null == t || null == n ? NaN : t < n ? -1 : t > n ? 1 : t >= n ? 0 : NaN;
}
function jn(t, n) {
  return null == t || null == n ? NaN : n < t ? -1 : n > t ? 1 : n >= t ? 0 : NaN;
}
function Dn(t) {
  let n, e, r;
  function i(t, r, i = 0, o = t.length) {
    if (i < o) {
      if (0 !== n(r, r)) return o;
      do {
        const n = (i + o) >>> 1;
        e(t[n], r) < 0 ? (i = n + 1) : (o = n);
      } while (i < o);
    }
    return i;
  }
  return (
    2 !== t.length
      ? ((n = Mn), (e = (n, e) => Mn(t(n), e)), (r = (n, e) => t(n) - e))
      : ((n = t === Mn || t === jn ? t : Fn), (e = t), (r = t)),
    {
      left: i,
      center: function (t, n, e = 0, o = t.length) {
        const u = i(t, n, e, o - 1);
        return u > e && r(t[u - 1], n) > -r(t[u], n) ? u - 1 : u;
      },
      right: function (t, r, i = 0, o = t.length) {
        if (i < o) {
          if (0 !== n(r, r)) return o;
          do {
            const n = (i + o) >>> 1;
            e(t[n], r) <= 0 ? (i = n + 1) : (o = n);
          } while (i < o);
        }
        return i;
      },
    }
  );
}
function Fn() {
  return 0;
}
function En(t) {
  return null === t ? NaN : +t;
}
const Sn = Dn(Mn),
  Cn = Sn.right,
  Nn = Sn.left;
Dn(En);
class Bn {
  constructor() {
    (this._partials = new Float64Array(32)), (this._n = 0);
  }
  add(t) {
    const n = this._partials;
    let e = 0;
    for (let r = 0; r < this._n && r < 32; r++) {
      const i = n[r],
        o = t + i,
        u = Math.abs(t) < Math.abs(i) ? t - (o - i) : i - (o - t);
      u && (n[e++] = u), (t = o);
    }
    return (n[e] = t), (this._n = e + 1), this;
  }
  valueOf() {
    const t = this._partials;
    let n,
      e,
      r,
      i = this._n,
      o = 0;
    if (i > 0) {
      for (o = t[--i]; i > 0 && ((n = o), (e = t[--i]), (o = n + e), (r = e - (o - n)), !r); );
      i > 0 &&
        ((r < 0 && t[i - 1] < 0) || (r > 0 && t[i - 1] > 0)) &&
        ((e = 2 * r), (n = o + e), e == n - o && (o = n));
    }
    return o;
  }
}
class _n extends Map {
  constructor(t, n = Ln) {
    if ((super(), Object.defineProperties(this, { _intern: { value: new Map() }, _key: { value: n } }), null != t))
      for (const [n, e] of t) this.set(n, e);
  }
  get(t) {
    return super.get(Tn(this, t));
  }
  has(t) {
    return super.has(Tn(this, t));
  }
  set(t, n) {
    return super.set(Pn(this, t), n);
  }
  delete(t) {
    return super.delete(Rn(this, t));
  }
}
class zn extends Set {
  constructor(t, n = Ln) {
    if ((super(), Object.defineProperties(this, { _intern: { value: new Map() }, _key: { value: n } }), null != t))
      for (const n of t) this.add(n);
  }
  has(t) {
    return super.has(Tn(this, t));
  }
  add(t) {
    return super.add(Pn(this, t));
  }
  delete(t) {
    return super.delete(Rn(this, t));
  }
}
function Tn({ _intern: t, _key: n }, e) {
  const r = n(e);
  return t.has(r) ? t.get(r) : e;
}
function Pn({ _intern: t, _key: n }, e) {
  const r = n(e);
  return t.has(r) ? t.get(r) : (t.set(r, e), e);
}
function Rn({ _intern: t, _key: n }, e) {
  const r = n(e);
  return t.has(r) && ((e = t.get(r)), t.delete(r)), e;
}
function Ln(t) {
  return null !== t && 'object' == typeof t ? t.valueOf() : t;
}
function qn(t, n) {
  return (null == t || !(t >= t)) - (null == n || !(n >= n)) || (t < n ? -1 : t > n ? 1 : 0);
}
const In = Math.sqrt(50),
  Un = Math.sqrt(10),
  Wn = Math.sqrt(2);
function Hn(t, n, e) {
  const r = (n - t) / Math.max(0, e),
    i = Math.floor(Math.log10(r)),
    o = r / Math.pow(10, i),
    u = o >= In ? 10 : o >= Un ? 5 : o >= Wn ? 2 : 1;
  let s, a, c;
  return (
    i < 0
      ? ((c = Math.pow(10, -i) / u),
        (s = Math.round(t * c)),
        (a = Math.round(n * c)),
        s / c < t && ++s,
        a / c > n && --a,
        (c = -c))
      : ((c = Math.pow(10, i) * u),
        (s = Math.round(t / c)),
        (a = Math.round(n / c)),
        s * c < t && ++s,
        a * c > n && --a),
    a < s && 0.5 <= e && e < 2 ? Hn(t, n, 2 * e) : [s, a, c]
  );
}
function Gn(t, n, e) {
  if (!((e = +e) > 0)) return [];
  if ((t = +t) == (n = +n)) return [t];
  const r = n < t,
    [i, o, u] = r ? Hn(n, t, e) : Hn(t, n, e);
  if (!(o >= i)) return [];
  const s = o - i + 1,
    a = new Array(s);
  if (r)
    if (u < 0) for (let t = 0; t < s; ++t) a[t] = (o - t) / -u;
    else for (let t = 0; t < s; ++t) a[t] = (o - t) * u;
  else if (u < 0) for (let t = 0; t < s; ++t) a[t] = (i + t) / -u;
  else for (let t = 0; t < s; ++t) a[t] = (i + t) * u;
  return a;
}
function Vn(t, n, e) {
  return Hn((t = +t), (n = +n), (e = +e))[2];
}
function Yn(t, n, e) {
  e = +e;
  const r = (n = +n) < (t = +t),
    i = r ? Vn(n, t, e) : Vn(t, n, e);
  return (r ? -1 : 1) * (i < 0 ? 1 / -i : i);
}
function Xn(t, n) {
  let e;
  if (void 0 === n) for (const n of t) null != n && (e < n || (void 0 === e && n >= n)) && (e = n);
  else {
    let r = -1;
    for (let i of t) null != (i = n(i, ++r, t)) && (e < i || (void 0 === e && i >= i)) && (e = i);
  }
  return e;
}
function Jn(t, n) {
  let e;
  if (void 0 === n) for (const n of t) null != n && (e > n || (void 0 === e && n >= n)) && (e = n);
  else {
    let r = -1;
    for (let i of t) null != (i = n(i, ++r, t)) && (e > i || (void 0 === e && i >= i)) && (e = i);
  }
  return e;
}
function Qn(t, n, e = 0, r = 1 / 0, i) {
  if (
    ((n = Math.floor(n)),
    (e = Math.floor(Math.max(0, e))),
    (r = Math.floor(Math.min(t.length - 1, r))),
    !(e <= n && n <= r))
  )
    return t;
  for (
    i =
      void 0 === i
        ? qn
        : (function (t = Mn) {
            if (t === Mn) return qn;
            if ('function' != typeof t) throw new TypeError('compare is not a function');
            return (n, e) => {
              const r = t(n, e);
              return r || 0 === r ? r : (0 === t(e, e)) - (0 === t(n, n));
            };
          })(i);
    r > e;

  ) {
    if (r - e > 600) {
      const o = r - e + 1,
        u = n - e + 1,
        s = Math.log(o),
        a = 0.5 * Math.exp((2 * s) / 3),
        c = 0.5 * Math.sqrt((s * a * (o - a)) / o) * (u - o / 2 < 0 ? -1 : 1);
      Qn(t, n, Math.max(e, Math.floor(n - (u * a) / o + c)), Math.min(r, Math.floor(n + ((o - u) * a) / o + c)), i);
    }
    const o = t[n];
    let u = e,
      s = r;
    for (Zn(t, e, n), i(t[r], o) > 0 && Zn(t, e, r); u < s; ) {
      for (Zn(t, u, s), ++u, --s; i(t[u], o) < 0; ) ++u;
      for (; i(t[s], o) > 0; ) --s;
    }
    0 === i(t[e], o) ? Zn(t, e, s) : (++s, Zn(t, s, r)), s <= n && (e = s + 1), n <= s && (r = s - 1);
  }
  return t;
}
function Zn(t, n, e) {
  const r = t[n];
  (t[n] = t[e]), (t[e] = r);
}
function Kn(t, n, e) {
  if (
    ((t = Float64Array.from(
      (function* (t, n) {
        if (void 0 === n) for (let n of t) null != n && (n = +n) >= n && (yield n);
        else {
          let e = -1;
          for (let r of t) null != (r = n(r, ++e, t)) && (r = +r) >= r && (yield r);
        }
      })(t, e),
    )),
    (r = t.length) && !isNaN((n = +n)))
  ) {
    if (n <= 0 || r < 2) return Jn(t);
    if (n >= 1) return Xn(t);
    var r,
      i = (r - 1) * n,
      o = Math.floor(i),
      u = Xn(Qn(t, o).subarray(0, o + 1));
    return u + (Jn(t.subarray(o + 1)) - u) * (i - o);
  }
}
function te(t, n, e = En) {
  if ((r = t.length) && !isNaN((n = +n))) {
    if (n <= 0 || r < 2) return +e(t[0], 0, t);
    if (n >= 1) return +e(t[r - 1], r - 1, t);
    var r,
      i = (r - 1) * n,
      o = Math.floor(i),
      u = +e(t[o], o, t);
    return u + (+e(t[o + 1], o + 1, t) - u) * (i - o);
  }
}
function ne(t, n) {
  return Kn(t, 0.5, n);
}
function ee(t) {
  return Array.from(
    (function* (t) {
      for (const n of t) yield* n;
    })(t),
  );
}
function re(t, n, e) {
  (t = +t), (n = +n), (e = (i = arguments.length) < 2 ? ((n = t), (t = 0), 1) : i < 3 ? 1 : +e);
  for (var r = -1, i = 0 | Math.max(0, Math.ceil((n - t) / e)), o = new Array(i); ++r < i; ) o[r] = t + r * e;
  return o;
}
function ie(t, n) {
  let e = 0;
  if (void 0 === n) for (let n of t) (n = +n) && (e += n);
  else {
    let r = -1;
    for (let i of t) (i = +n(i, ++r, t)) && (e += i);
  }
  return e;
}
function oe(t, n) {
  if ((e = (t = n ? t.toExponential(n - 1) : t.toExponential()).indexOf('e')) < 0) return null;
  var e,
    r = t.slice(0, e);
  return [r.length > 1 ? r[0] + r.slice(2) : r, +t.slice(e + 1)];
}
function ue(t) {
  return (t = oe(Math.abs(t))) ? t[1] : NaN;
}
var se,
  ae = /^(?:(.)?([<>=^]))?([+\-( ])?([$#])?(0)?(\d+)?(,)?(\.\d+)?(~)?([a-z%])?$/i;
function ce(t) {
  if (!(n = ae.exec(t))) throw new Error('invalid format: ' + t);
  var n;
  return new le({
    fill: n[1],
    align: n[2],
    sign: n[3],
    symbol: n[4],
    zero: n[5],
    width: n[6],
    comma: n[7],
    precision: n[8] && n[8].slice(1),
    trim: n[9],
    type: n[10],
  });
}
function le(t) {
  (this.fill = void 0 === t.fill ? ' ' : t.fill + ''),
    (this.align = void 0 === t.align ? '>' : t.align + ''),
    (this.sign = void 0 === t.sign ? '-' : t.sign + ''),
    (this.symbol = void 0 === t.symbol ? '' : t.symbol + ''),
    (this.zero = !!t.zero),
    (this.width = void 0 === t.width ? void 0 : +t.width),
    (this.comma = !!t.comma),
    (this.precision = void 0 === t.precision ? void 0 : +t.precision),
    (this.trim = !!t.trim),
    (this.type = void 0 === t.type ? '' : t.type + '');
}
function fe(t, n) {
  var e = oe(t, n);
  if (!e) return t + '';
  var r = e[0],
    i = e[1];
  return i < 0
    ? '0.' + new Array(-i).join('0') + r
    : r.length > i + 1
    ? r.slice(0, i + 1) + '.' + r.slice(i + 1)
    : r + new Array(i - r.length + 2).join('0');
}
(ce.prototype = le.prototype),
  (le.prototype.toString = function () {
    return (
      this.fill +
      this.align +
      this.sign +
      this.symbol +
      (this.zero ? '0' : '') +
      (void 0 === this.width ? '' : Math.max(1, 0 | this.width)) +
      (this.comma ? ',' : '') +
      (void 0 === this.precision ? '' : '.' + Math.max(0, 0 | this.precision)) +
      (this.trim ? '~' : '') +
      this.type
    );
  });
const he = {
  '%': (t, n) => (100 * t).toFixed(n),
  b: t => Math.round(t).toString(2),
  c: t => t + '',
  d: function (t) {
    return Math.abs((t = Math.round(t))) >= 1e21 ? t.toLocaleString('en').replace(/,/g, '') : t.toString(10);
  },
  e: (t, n) => t.toExponential(n),
  f: (t, n) => t.toFixed(n),
  g: (t, n) => t.toPrecision(n),
  o: t => Math.round(t).toString(8),
  p: (t, n) => fe(100 * t, n),
  r: fe,
  s: function (t, n) {
    var e = oe(t, n);
    if (!e) return t + '';
    var r = e[0],
      i = e[1],
      o = i - (se = 3 * Math.max(-8, Math.min(8, Math.floor(i / 3)))) + 1,
      u = r.length;
    return o === u
      ? r
      : o > u
      ? r + new Array(o - u + 1).join('0')
      : o > 0
      ? r.slice(0, o) + '.' + r.slice(o)
      : '0.' + new Array(1 - o).join('0') + oe(t, Math.max(0, n + o - 1))[0];
  },
  X: t => Math.round(t).toString(16).toUpperCase(),
  x: t => Math.round(t).toString(16),
};
function de(t) {
  return t;
}
var pe,
  me,
  ve,
  ge = Array.prototype.map,
  be = ['y', 'z', 'a', 'f', 'p', 'n', 'µ', 'm', '', 'k', 'M', 'G', 'T', 'P', 'E', 'Z', 'Y'];
function ye(t) {
  var n,
    e,
    r =
      void 0 === t.grouping || void 0 === t.thousands
        ? de
        : ((n = ge.call(t.grouping, Number)),
          (e = t.thousands + ''),
          function (t, r) {
            for (
              var i = t.length, o = [], u = 0, s = n[0], a = 0;
              i > 0 &&
              s > 0 &&
              (a + s + 1 > r && (s = Math.max(1, r - a)), o.push(t.substring((i -= s), i + s)), !((a += s + 1) > r));

            )
              s = n[(u = (u + 1) % n.length)];
            return o.reverse().join(e);
          }),
    i = void 0 === t.currency ? '' : t.currency[0] + '',
    o = void 0 === t.currency ? '' : t.currency[1] + '',
    u = void 0 === t.decimal ? '.' : t.decimal + '',
    s =
      void 0 === t.numerals
        ? de
        : (function (t) {
            return function (n) {
              return n.replace(/[0-9]/g, function (n) {
                return t[+n];
              });
            };
          })(ge.call(t.numerals, String)),
    a = void 0 === t.percent ? '%' : t.percent + '',
    c = void 0 === t.minus ? '−' : t.minus + '',
    l = void 0 === t.nan ? 'NaN' : t.nan + '';
  function f(t) {
    var n = (t = ce(t)).fill,
      e = t.align,
      f = t.sign,
      h = t.symbol,
      d = t.zero,
      p = t.width,
      m = t.comma,
      v = t.precision,
      g = t.trim,
      b = t.type;
    'n' === b ? ((m = !0), (b = 'g')) : he[b] || (void 0 === v && (v = 12), (g = !0), (b = 'g')),
      (d || ('0' === n && '=' === e)) && ((d = !0), (n = '0'), (e = '='));
    var y = '$' === h ? i : '#' === h && /[boxX]/.test(b) ? '0' + b.toLowerCase() : '',
      w = '$' === h ? o : /[%p]/.test(b) ? a : '',
      x = he[b],
      O = /[defgprs%]/.test(b);
    function k(t) {
      var i,
        o,
        a,
        h = y,
        k = w;
      if ('c' === b) (k = x(t) + k), (t = '');
      else {
        var A = (t = +t) < 0 || 1 / t < 0;
        if (
          ((t = isNaN(t) ? l : x(Math.abs(t), v)),
          g &&
            (t = (function (t) {
              t: for (var n, e = t.length, r = 1, i = -1; r < e; ++r)
                switch (t[r]) {
                  case '.':
                    i = n = r;
                    break;
                  case '0':
                    0 === i && (i = r), (n = r);
                    break;
                  default:
                    if (!+t[r]) break t;
                    i > 0 && (i = 0);
                }
              return i > 0 ? t.slice(0, i) + t.slice(n + 1) : t;
            })(t)),
          A && 0 == +t && '+' !== f && (A = !1),
          (h = (A ? ('(' === f ? f : c) : '-' === f || '(' === f ? '' : f) + h),
          (k = ('s' === b ? be[8 + se / 3] : '') + k + (A && '(' === f ? ')' : '')),
          O)
        )
          for (i = -1, o = t.length; ++i < o; )
            if (48 > (a = t.charCodeAt(i)) || a > 57) {
              (k = (46 === a ? u + t.slice(i + 1) : t.slice(i)) + k), (t = t.slice(0, i));
              break;
            }
      }
      m && !d && (t = r(t, 1 / 0));
      var $ = h.length + t.length + k.length,
        M = $ < p ? new Array(p - $ + 1).join(n) : '';
      switch ((m && d && ((t = r(M + t, M.length ? p - k.length : 1 / 0)), (M = '')), e)) {
        case '<':
          t = h + t + k + M;
          break;
        case '=':
          t = h + M + t + k;
          break;
        case '^':
          t = M.slice(0, ($ = M.length >> 1)) + h + t + k + M.slice($);
          break;
        default:
          t = M + h + t + k;
      }
      return s(t);
    }
    return (
      (v = void 0 === v ? 6 : /[gprs]/.test(b) ? Math.max(1, Math.min(21, v)) : Math.max(0, Math.min(20, v))),
      (k.toString = function () {
        return t + '';
      }),
      k
    );
  }
  return {
    format: f,
    formatPrefix: function (t, n) {
      var e = f((((t = ce(t)).type = 'f'), t)),
        r = 3 * Math.max(-8, Math.min(8, Math.floor(ue(n) / 3))),
        i = Math.pow(10, -r),
        o = be[8 + r / 3];
      return function (t) {
        return e(i * t) + o;
      };
    },
  };
}
function we(t) {
  return Math.max(0, -ue(Math.abs(t)));
}
function xe(t, n) {
  return Math.max(0, 3 * Math.max(-8, Math.min(8, Math.floor(ue(n) / 3))) - ue(Math.abs(t)));
}
function Oe(t, n) {
  return (t = Math.abs(t)), (n = Math.abs(n) - t), Math.max(0, ue(n) - ue(t)) + 1;
}
(pe = ye({ thousands: ',', grouping: [3], currency: ['$', ''] })), (me = pe.format), (ve = pe.formatPrefix);
const ke = new Date(),
  Ae = new Date();
function $e(t, n, e, r) {
  function i(n) {
    return t((n = 0 === arguments.length ? new Date() : new Date(+n))), n;
  }
  return (
    (i.floor = n => (t((n = new Date(+n))), n)),
    (i.ceil = e => (t((e = new Date(e - 1))), n(e, 1), t(e), e)),
    (i.round = t => {
      const n = i(t),
        e = i.ceil(t);
      return t - n < e - t ? n : e;
    }),
    (i.offset = (t, e) => (n((t = new Date(+t)), null == e ? 1 : Math.floor(e)), t)),
    (i.range = (e, r, o) => {
      const u = [];
      if (((e = i.ceil(e)), (o = null == o ? 1 : Math.floor(o)), !(e < r && o > 0))) return u;
      let s;
      do {
        u.push((s = new Date(+e))), n(e, o), t(e);
      } while (s < e && e < r);
      return u;
    }),
    (i.filter = e =>
      $e(
        n => {
          if (n >= n) for (; t(n), !e(n); ) n.setTime(n - 1);
        },
        (t, r) => {
          if (t >= t)
            if (r < 0) for (; ++r <= 0; ) for (; n(t, -1), !e(t); );
            else for (; --r >= 0; ) for (; n(t, 1), !e(t); );
        },
      )),
    e &&
      ((i.count = (n, r) => (ke.setTime(+n), Ae.setTime(+r), t(ke), t(Ae), Math.floor(e(ke, Ae)))),
      (i.every = t => (
        (t = Math.floor(t)),
        isFinite(t) && t > 0 ? (t > 1 ? i.filter(r ? n => r(n) % t == 0 : n => i.count(0, n) % t == 0) : i) : null
      ))),
    i
  );
}
const Me = $e(
  () => {},
  (t, n) => {
    t.setTime(+t + n);
  },
  (t, n) => n - t,
);
Me.every = t => (
  (t = Math.floor(t)),
  isFinite(t) && t > 0
    ? t > 1
      ? $e(
          n => {
            n.setTime(Math.floor(n / t) * t);
          },
          (n, e) => {
            n.setTime(+n + e * t);
          },
          (n, e) => (e - n) / t,
        )
      : Me
    : null
);
const je = 1e3,
  De = 6e4,
  Fe = 36e5,
  Ee = 864e5,
  Se = 6048e5,
  Ce = 31536e6,
  Ne = $e(
    t => {
      t.setTime(t - t.getMilliseconds());
    },
    (t, n) => {
      t.setTime(+t + n * je);
    },
    (t, n) => (n - t) / je,
    t => t.getUTCSeconds(),
  ),
  Be = $e(
    t => {
      t.setTime(t - t.getMilliseconds() - t.getSeconds() * je);
    },
    (t, n) => {
      t.setTime(+t + n * De);
    },
    (t, n) => (n - t) / De,
    t => t.getMinutes(),
  ),
  _e = $e(
    t => {
      t.setUTCSeconds(0, 0);
    },
    (t, n) => {
      t.setTime(+t + n * De);
    },
    (t, n) => (n - t) / De,
    t => t.getUTCMinutes(),
  ),
  ze = $e(
    t => {
      t.setTime(t - t.getMilliseconds() - t.getSeconds() * je - t.getMinutes() * De);
    },
    (t, n) => {
      t.setTime(+t + n * Fe);
    },
    (t, n) => (n - t) / Fe,
    t => t.getHours(),
  ),
  Te = $e(
    t => {
      t.setUTCMinutes(0, 0, 0);
    },
    (t, n) => {
      t.setTime(+t + n * Fe);
    },
    (t, n) => (n - t) / Fe,
    t => t.getUTCHours(),
  ),
  Pe = $e(
    t => t.setHours(0, 0, 0, 0),
    (t, n) => t.setDate(t.getDate() + n),
    (t, n) => (n - t - (n.getTimezoneOffset() - t.getTimezoneOffset()) * De) / Ee,
    t => t.getDate() - 1,
  ),
  Re = $e(
    t => {
      t.setUTCHours(0, 0, 0, 0);
    },
    (t, n) => {
      t.setUTCDate(t.getUTCDate() + n);
    },
    (t, n) => (n - t) / Ee,
    t => t.getUTCDate() - 1,
  ),
  Le = $e(
    t => {
      t.setUTCHours(0, 0, 0, 0);
    },
    (t, n) => {
      t.setUTCDate(t.getUTCDate() + n);
    },
    (t, n) => (n - t) / Ee,
    t => Math.floor(t / Ee),
  );
function qe(t) {
  return $e(
    n => {
      n.setDate(n.getDate() - ((n.getDay() + 7 - t) % 7)), n.setHours(0, 0, 0, 0);
    },
    (t, n) => {
      t.setDate(t.getDate() + 7 * n);
    },
    (t, n) => (n - t - (n.getTimezoneOffset() - t.getTimezoneOffset()) * De) / Se,
  );
}
const Ie = qe(0),
  Ue = qe(1);
qe(2), qe(3);
const We = qe(4);
function He(t) {
  return $e(
    n => {
      n.setUTCDate(n.getUTCDate() - ((n.getUTCDay() + 7 - t) % 7)), n.setUTCHours(0, 0, 0, 0);
    },
    (t, n) => {
      t.setUTCDate(t.getUTCDate() + 7 * n);
    },
    (t, n) => (n - t) / Se,
  );
}
qe(5), qe(6);
const Ge = He(0),
  Ve = He(1);
He(2), He(3);
const Ye = He(4);
He(5), He(6);
const Xe = $e(
    t => {
      t.setDate(1), t.setHours(0, 0, 0, 0);
    },
    (t, n) => {
      t.setMonth(t.getMonth() + n);
    },
    (t, n) => n.getMonth() - t.getMonth() + 12 * (n.getFullYear() - t.getFullYear()),
    t => t.getMonth(),
  ),
  Je = $e(
    t => {
      t.setUTCDate(1), t.setUTCHours(0, 0, 0, 0);
    },
    (t, n) => {
      t.setUTCMonth(t.getUTCMonth() + n);
    },
    (t, n) => n.getUTCMonth() - t.getUTCMonth() + 12 * (n.getUTCFullYear() - t.getUTCFullYear()),
    t => t.getUTCMonth(),
  ),
  Qe = $e(
    t => {
      t.setMonth(0, 1), t.setHours(0, 0, 0, 0);
    },
    (t, n) => {
      t.setFullYear(t.getFullYear() + n);
    },
    (t, n) => n.getFullYear() - t.getFullYear(),
    t => t.getFullYear(),
  );
Qe.every = t =>
  isFinite((t = Math.floor(t))) && t > 0
    ? $e(
        n => {
          n.setFullYear(Math.floor(n.getFullYear() / t) * t), n.setMonth(0, 1), n.setHours(0, 0, 0, 0);
        },
        (n, e) => {
          n.setFullYear(n.getFullYear() + e * t);
        },
      )
    : null;
const Ze = $e(
  t => {
    t.setUTCMonth(0, 1), t.setUTCHours(0, 0, 0, 0);
  },
  (t, n) => {
    t.setUTCFullYear(t.getUTCFullYear() + n);
  },
  (t, n) => n.getUTCFullYear() - t.getUTCFullYear(),
  t => t.getUTCFullYear(),
);
function Ke(t, n, e, r, i, o) {
  const u = [
    [Ne, 1, je],
    [Ne, 5, 5e3],
    [Ne, 15, 15e3],
    [Ne, 30, 3e4],
    [o, 1, De],
    [o, 5, 3e5],
    [o, 15, 9e5],
    [o, 30, 18e5],
    [i, 1, Fe],
    [i, 3, 108e5],
    [i, 6, 216e5],
    [i, 12, 432e5],
    [r, 1, Ee],
    [r, 2, 1728e5],
    [e, 1, Se],
    [n, 1, 2592e6],
    [n, 3, 7776e6],
    [t, 1, Ce],
  ];
  function s(n, e, r) {
    const i = Math.abs(e - n) / r,
      o = Dn(([, , t]) => t).right(u, i);
    if (o === u.length) return t.every(Yn(n / Ce, e / Ce, r));
    if (0 === o) return Me.every(Math.max(Yn(n, e, r), 1));
    const [s, a] = u[i / u[o - 1][2] < u[o][2] / i ? o - 1 : o];
    return s.every(a);
  }
  return [
    function (t, n, e) {
      const r = n < t;
      r && ([t, n] = [n, t]);
      const i = e && 'function' == typeof e.range ? e : s(t, n, e),
        o = i ? i.range(t, +n + 1) : [];
      return r ? o.reverse() : o;
    },
    s,
  ];
}
Ze.every = t =>
  isFinite((t = Math.floor(t))) && t > 0
    ? $e(
        n => {
          n.setUTCFullYear(Math.floor(n.getUTCFullYear() / t) * t), n.setUTCMonth(0, 1), n.setUTCHours(0, 0, 0, 0);
        },
        (n, e) => {
          n.setUTCFullYear(n.getUTCFullYear() + e * t);
        },
      )
    : null;
const [tr, nr] = Ke(Ze, Je, Ge, Le, Te, _e),
  [er, rr] = Ke(Qe, Xe, Ie, Pe, ze, Be),
  ir = 'year',
  or = 'quarter',
  ur = 'month',
  sr = 'week',
  ar = 'date',
  cr = 'day',
  lr = 'dayofyear',
  fr = 'hours',
  hr = 'minutes',
  dr = 'seconds',
  pr = 'milliseconds',
  mr = [ir, or, ur, sr, ar, cr, lr, fr, hr, dr, pr],
  vr = mr.reduce((t, n, e) => ((t[n] = 1 + e), t), {});
function gr(t) {
  const n = At(t).slice(),
    e = {};
  return (
    n.length || I('Missing time unit.'),
    n.forEach(t => {
      Pt(vr, t) ? (e[t] = 1) : I('Invalid time unit: '.concat(t, '.'));
    }),
    (e[sr] || e[cr] ? 1 : 0) + (e[or] || e[ur] || e[ar] ? 1 : 0) + (e[lr] ? 1 : 0) > 1 &&
      I('Incompatible time units: '.concat(t)),
    n.sort((t, n) => vr[t] - vr[n]),
    n
  );
}
const br = {
  [ir]: '%Y ',
  [or]: 'Q%q ',
  [ur]: '%b ',
  [ar]: '%d ',
  [sr]: 'W%U ',
  [cr]: '%a ',
  [lr]: '%j ',
  [fr]: '%H:00',
  [hr]: '00:%M',
  [dr]: ':%S',
  [pr]: '.%L',
  [''.concat(ir, '-').concat(ur)]: '%Y-%m ',
  [''.concat(ir, '-').concat(ur, '-').concat(ar)]: '%Y-%m-%d ',
  [''.concat(fr, '-').concat(hr)]: '%H:%M',
};
function yr(t, n) {
  const e = Bt({}, br, n),
    r = gr(t),
    i = r.length;
  let o,
    u,
    s = '',
    a = 0;
  for (a = 0; a < i; )
    for (o = r.length; o > a; --o)
      if (((u = r.slice(a, o).join('-')), null != e[u])) {
        (s += e[u]), (a = o);
        break;
      }
  return s.trim();
}
const wr = new Date();
function xr(t) {
  return wr.setFullYear(t), wr.setMonth(0), wr.setDate(1), wr.setHours(0, 0, 0, 0), wr;
}
function Or(t) {
  return Ar(new Date(t));
}
function kr(t) {
  return $r(new Date(t));
}
function Ar(t) {
  return Pe.count(xr(t.getFullYear()) - 1, t);
}
function $r(t) {
  return Ie.count(xr(t.getFullYear()) - 1, t);
}
function Mr(t) {
  return xr(t).getDay();
}
function jr(t, n, e, r, i, o, u) {
  if (0 <= t && t < 100) {
    const s = new Date(-1, n, e, r, i, o, u);
    return s.setFullYear(t), s;
  }
  return new Date(t, n, e, r, i, o, u);
}
function Dr(t) {
  return Er(new Date(t));
}
function Fr(t) {
  return Sr(new Date(t));
}
function Er(t) {
  const n = Date.UTC(t.getUTCFullYear(), 0, 1);
  return Re.count(n - 1, t);
}
function Sr(t) {
  const n = Date.UTC(t.getUTCFullYear(), 0, 1);
  return Ge.count(n - 1, t);
}
function Cr(t) {
  return wr.setTime(Date.UTC(t, 0, 1)), wr.getUTCDay();
}
function Nr(t, n, e, r, i, o, u) {
  if (0 <= t && t < 100) {
    const t = new Date(Date.UTC(-1, n, e, r, i, o, u));
    return t.setUTCFullYear(e.y), t;
  }
  return new Date(Date.UTC(t, n, e, r, i, o, u));
}
function Br(t, n, e, r, i) {
  const o = n || 1,
    u = ot(t),
    s = (t, n, i) =>
      (function (t, n, e, r) {
        const i =
          e <= 1 ? t : r ? (n, i) => r + e * Math.floor((t(n, i) - r) / e) : (n, r) => e * Math.floor(t(n, r) / e);
        return n ? (t, e) => n(i(t, e), e) : i;
      })(e[(i = i || t)], r[i], t === u && o, n),
    a = new Date(),
    c = cn(t),
    l = c[ir] ? s(ir) : Ct(2012),
    f = c[ur] ? s(ur) : c[or] ? s(or) : V,
    h =
      c[sr] && c[cr]
        ? s(cr, 1, sr + cr)
        : c[sr]
        ? s(sr, 1)
        : c[cr]
        ? s(cr, 1)
        : c[ar]
        ? s(ar, 1)
        : c[lr]
        ? s(lr, 1)
        : Y,
    d = c[fr] ? s(fr) : V,
    p = c[hr] ? s(hr) : V,
    m = c[dr] ? s(dr) : V,
    v = c[pr] ? s(pr) : V;
  return function (t) {
    a.setTime(+t);
    const n = l(a);
    return i(n, f(a), h(a, n), d(a), p(a), m(a), v(a));
  };
}
function _r(t, n, e) {
  return n + 7 * t - ((e + 6) % 7);
}
const zr = {
    [ir]: t => t.getFullYear(),
    [or]: t => Math.floor(t.getMonth() / 3),
    [ur]: t => t.getMonth(),
    [ar]: t => t.getDate(),
    [fr]: t => t.getHours(),
    [hr]: t => t.getMinutes(),
    [dr]: t => t.getSeconds(),
    [pr]: t => t.getMilliseconds(),
    [lr]: t => Ar(t),
    [sr]: t => $r(t),
    [sr + cr]: (t, n) => _r($r(t), t.getDay(), Mr(n)),
    [cr]: (t, n) => _r(1, t.getDay(), Mr(n)),
  },
  Tr = { [or]: t => 3 * t, [sr]: (t, n) => _r(t, 0, Mr(n)) };
function Pr(t, n) {
  return Br(t, n || 1, zr, Tr, jr);
}
const Rr = {
    [ir]: t => t.getUTCFullYear(),
    [or]: t => Math.floor(t.getUTCMonth() / 3),
    [ur]: t => t.getUTCMonth(),
    [ar]: t => t.getUTCDate(),
    [fr]: t => t.getUTCHours(),
    [hr]: t => t.getUTCMinutes(),
    [dr]: t => t.getUTCSeconds(),
    [pr]: t => t.getUTCMilliseconds(),
    [lr]: t => Er(t),
    [sr]: t => Sr(t),
    [cr]: (t, n) => _r(1, t.getUTCDay(), Cr(n)),
    [sr + cr]: (t, n) => _r(Sr(t), t.getUTCDay(), Cr(n)),
  },
  Lr = { [or]: t => 3 * t, [sr]: (t, n) => _r(t, 0, Cr(n)) };
function qr(t, n) {
  return Br(t, n || 1, Rr, Lr, Nr);
}
const Ir = {
    [ir]: Qe,
    [or]: Xe.every(3),
    [ur]: Xe,
    [sr]: Ie,
    [ar]: Pe,
    [cr]: Pe,
    [lr]: Pe,
    [fr]: ze,
    [hr]: Be,
    [dr]: Ne,
    [pr]: Me,
  },
  Ur = {
    [ir]: Ze,
    [or]: Je.every(3),
    [ur]: Je,
    [sr]: Ge,
    [ar]: Re,
    [cr]: Re,
    [lr]: Re,
    [fr]: Te,
    [hr]: _e,
    [dr]: Ne,
    [pr]: Me,
  };
function Wr(t) {
  return Ir[t];
}
function Hr(t) {
  return Ur[t];
}
function Gr(t, n, e) {
  return t ? t.offset(n, e) : void 0;
}
function Vr(t, n, e) {
  return Gr(Wr(t), n, e);
}
function Yr(t, n, e) {
  return Gr(Hr(t), n, e);
}
function Xr(t, n, e, r) {
  return t ? t.range(n, e, r) : void 0;
}
function Jr(t, n, e, r) {
  return Xr(Wr(t), n, e, r);
}
function Qr(t, n, e, r) {
  return Xr(Hr(t), n, e, r);
}
const Zr = 31536e6,
  Kr = [ir, ur, ar, fr, hr, dr, pr],
  ti = Kr.slice(0, -1),
  ni = ti.slice(0, -1),
  ei = ni.slice(0, -1),
  ri = ei.slice(0, -1),
  ii = [ir, ur],
  oi = [ir],
  ui = [
    [ti, 1, 1e3],
    [ti, 5, 5e3],
    [ti, 15, 15e3],
    [ti, 30, 3e4],
    [ni, 1, 6e4],
    [ni, 5, 3e5],
    [ni, 15, 9e5],
    [ni, 30, 18e5],
    [ei, 1, 36e5],
    [ei, 3, 108e5],
    [ei, 6, 216e5],
    [ei, 12, 432e5],
    [ri, 1, 864e5],
    [[ir, sr], 1, 6048e5],
    [ii, 1, 2592e6],
    [ii, 3, 7776e6],
    [oi, 1, Zr],
  ];
function si(t) {
  const n = t.extent,
    e = t.maxbins || 40,
    r = Math.abs(en(n)) / e;
  let i,
    o,
    u = Dn(t => t[2]).right(ui, r);
  return (
    u === ui.length
      ? ((i = oi), (o = Yn(n[0] / Zr, n[1] / Zr, e)))
      : u
      ? ((u = ui[r / ui[u - 1][2] < ui[u][2] / r ? u - 1 : u]), (i = u[0]), (o = u[1]))
      : ((i = Kr), (o = Math.max(Yn(n[0], n[1], e), 1))),
    { units: i, step: o }
  );
}
function ai(t) {
  if (0 <= t.y && t.y < 100) {
    var n = new Date(-1, t.m, t.d, t.H, t.M, t.S, t.L);
    return n.setFullYear(t.y), n;
  }
  return new Date(t.y, t.m, t.d, t.H, t.M, t.S, t.L);
}
function ci(t) {
  if (0 <= t.y && t.y < 100) {
    var n = new Date(Date.UTC(-1, t.m, t.d, t.H, t.M, t.S, t.L));
    return n.setUTCFullYear(t.y), n;
  }
  return new Date(Date.UTC(t.y, t.m, t.d, t.H, t.M, t.S, t.L));
}
function li(t, n, e) {
  return { y: t, m: n, d: e, H: 0, M: 0, S: 0, L: 0 };
}
function fi(t) {
  var n = t.dateTime,
    e = t.date,
    r = t.time,
    i = t.periods,
    o = t.days,
    u = t.shortDays,
    s = t.months,
    a = t.shortMonths,
    c = ki(i),
    l = Ai(i),
    f = ki(o),
    h = Ai(o),
    d = ki(u),
    p = Ai(u),
    m = ki(s),
    v = Ai(s),
    g = ki(a),
    b = Ai(a),
    y = {
      a: function (t) {
        return u[t.getDay()];
      },
      A: function (t) {
        return o[t.getDay()];
      },
      b: function (t) {
        return a[t.getMonth()];
      },
      B: function (t) {
        return s[t.getMonth()];
      },
      c: null,
      d: Hi,
      e: Hi,
      f: Ji,
      g: so,
      G: co,
      H: Gi,
      I: Vi,
      j: Yi,
      L: Xi,
      m: Qi,
      M: Zi,
      p: function (t) {
        return i[+(t.getHours() >= 12)];
      },
      q: function (t) {
        return 1 + ~~(t.getMonth() / 3);
      },
      Q: No,
      s: Bo,
      S: Ki,
      u: to,
      U: no,
      V: ro,
      w: io,
      W: oo,
      x: null,
      X: null,
      y: uo,
      Y: ao,
      Z: lo,
      '%': Co,
    },
    w = {
      a: function (t) {
        return u[t.getUTCDay()];
      },
      A: function (t) {
        return o[t.getUTCDay()];
      },
      b: function (t) {
        return a[t.getUTCMonth()];
      },
      B: function (t) {
        return s[t.getUTCMonth()];
      },
      c: null,
      d: fo,
      e: fo,
      f: go,
      g: Do,
      G: Eo,
      H: ho,
      I: po,
      j: mo,
      L: vo,
      m: bo,
      M: yo,
      p: function (t) {
        return i[+(t.getUTCHours() >= 12)];
      },
      q: function (t) {
        return 1 + ~~(t.getUTCMonth() / 3);
      },
      Q: No,
      s: Bo,
      S: wo,
      u: xo,
      U: Oo,
      V: Ao,
      w: $o,
      W: Mo,
      x: null,
      X: null,
      y: jo,
      Y: Fo,
      Z: So,
      '%': Co,
    },
    x = {
      a: function (t, n, e) {
        var r = d.exec(n.slice(e));
        return r ? ((t.w = p.get(r[0].toLowerCase())), e + r[0].length) : -1;
      },
      A: function (t, n, e) {
        var r = f.exec(n.slice(e));
        return r ? ((t.w = h.get(r[0].toLowerCase())), e + r[0].length) : -1;
      },
      b: function (t, n, e) {
        var r = g.exec(n.slice(e));
        return r ? ((t.m = b.get(r[0].toLowerCase())), e + r[0].length) : -1;
      },
      B: function (t, n, e) {
        var r = m.exec(n.slice(e));
        return r ? ((t.m = v.get(r[0].toLowerCase())), e + r[0].length) : -1;
      },
      c: function (t, e, r) {
        return A(t, n, e, r);
      },
      d: _i,
      e: _i,
      f: qi,
      g: Si,
      G: Ei,
      H: Ti,
      I: Ti,
      j: zi,
      L: Li,
      m: Bi,
      M: Pi,
      p: function (t, n, e) {
        var r = c.exec(n.slice(e));
        return r ? ((t.p = l.get(r[0].toLowerCase())), e + r[0].length) : -1;
      },
      q: Ni,
      Q: Ui,
      s: Wi,
      S: Ri,
      u: Mi,
      U: ji,
      V: Di,
      w: $i,
      W: Fi,
      x: function (t, n, r) {
        return A(t, e, n, r);
      },
      X: function (t, n, e) {
        return A(t, r, n, e);
      },
      y: Si,
      Y: Ei,
      Z: Ci,
      '%': Ii,
    };
  function O(t, n) {
    return function (e) {
      var r,
        i,
        o,
        u = [],
        s = -1,
        a = 0,
        c = t.length;
      for (e instanceof Date || (e = new Date(+e)); ++s < c; )
        37 === t.charCodeAt(s) &&
          (u.push(t.slice(a, s)),
          null != (i = gi[(r = t.charAt(++s))]) ? (r = t.charAt(++s)) : (i = 'e' === r ? ' ' : '0'),
          (o = n[r]) && (r = o(e, i)),
          u.push(r),
          (a = s + 1));
      return u.push(t.slice(a, s)), u.join('');
    };
  }
  function k(t, n) {
    return function (e) {
      var r,
        i,
        o = li(1900, void 0, 1);
      if (A(o, t, (e += ''), 0) != e.length) return null;
      if ('Q' in o) return new Date(o.Q);
      if ('s' in o) return new Date(1e3 * o.s + ('L' in o ? o.L : 0));
      if (
        (n && !('Z' in o) && (o.Z = 0),
        'p' in o && (o.H = (o.H % 12) + 12 * o.p),
        void 0 === o.m && (o.m = 'q' in o ? o.q : 0),
        'V' in o)
      ) {
        if (o.V < 1 || o.V > 53) return null;
        'w' in o || (o.w = 1),
          'Z' in o
            ? ((i = (r = ci(li(o.y, 0, 1))).getUTCDay()),
              (r = i > 4 || 0 === i ? Ve.ceil(r) : Ve(r)),
              (r = Re.offset(r, 7 * (o.V - 1))),
              (o.y = r.getUTCFullYear()),
              (o.m = r.getUTCMonth()),
              (o.d = r.getUTCDate() + ((o.w + 6) % 7)))
            : ((i = (r = ai(li(o.y, 0, 1))).getDay()),
              (r = i > 4 || 0 === i ? Ue.ceil(r) : Ue(r)),
              (r = Pe.offset(r, 7 * (o.V - 1))),
              (o.y = r.getFullYear()),
              (o.m = r.getMonth()),
              (o.d = r.getDate() + ((o.w + 6) % 7)));
      } else
        ('W' in o || 'U' in o) &&
          ('w' in o || (o.w = 'u' in o ? o.u % 7 : 'W' in o ? 1 : 0),
          (i = 'Z' in o ? ci(li(o.y, 0, 1)).getUTCDay() : ai(li(o.y, 0, 1)).getDay()),
          (o.m = 0),
          (o.d = 'W' in o ? ((o.w + 6) % 7) + 7 * o.W - ((i + 5) % 7) : o.w + 7 * o.U - ((i + 6) % 7)));
      return 'Z' in o ? ((o.H += (o.Z / 100) | 0), (o.M += o.Z % 100), ci(o)) : ai(o);
    };
  }
  function A(t, n, e, r) {
    for (var i, o, u = 0, s = n.length, a = e.length; u < s; ) {
      if (r >= a) return -1;
      if (37 === (i = n.charCodeAt(u++))) {
        if (((i = n.charAt(u++)), !(o = x[i in gi ? n.charAt(u++) : i]) || (r = o(t, e, r)) < 0)) return -1;
      } else if (i != e.charCodeAt(r++)) return -1;
    }
    return r;
  }
  return (
    (y.x = O(e, y)),
    (y.X = O(r, y)),
    (y.c = O(n, y)),
    (w.x = O(e, w)),
    (w.X = O(r, w)),
    (w.c = O(n, w)),
    {
      format: function (t) {
        var n = O((t += ''), y);
        return (
          (n.toString = function () {
            return t;
          }),
          n
        );
      },
      parse: function (t) {
        var n = k((t += ''), !1);
        return (
          (n.toString = function () {
            return t;
          }),
          n
        );
      },
      utcFormat: function (t) {
        var n = O((t += ''), w);
        return (
          (n.toString = function () {
            return t;
          }),
          n
        );
      },
      utcParse: function (t) {
        var n = k((t += ''), !0);
        return (
          (n.toString = function () {
            return t;
          }),
          n
        );
      },
    }
  );
}
var hi,
  di,
  pi,
  mi,
  vi,
  gi = { '-': '', _: ' ', 0: '0' },
  bi = /^\s*\d+/,
  yi = /^%/,
  wi = /[\\^$*+?|[\]().{}]/g;
function xi(t, n, e) {
  var r = t < 0 ? '-' : '',
    i = (r ? -t : t) + '',
    o = i.length;
  return r + (o < e ? new Array(e - o + 1).join(n) + i : i);
}
function Oi(t) {
  return t.replace(wi, '\\$&');
}
function ki(t) {
  return new RegExp('^(?:' + t.map(Oi).join('|') + ')', 'i');
}
function Ai(t) {
  return new Map(t.map((t, n) => [t.toLowerCase(), n]));
}
function $i(t, n, e) {
  var r = bi.exec(n.slice(e, e + 1));
  return r ? ((t.w = +r[0]), e + r[0].length) : -1;
}
function Mi(t, n, e) {
  var r = bi.exec(n.slice(e, e + 1));
  return r ? ((t.u = +r[0]), e + r[0].length) : -1;
}
function ji(t, n, e) {
  var r = bi.exec(n.slice(e, e + 2));
  return r ? ((t.U = +r[0]), e + r[0].length) : -1;
}
function Di(t, n, e) {
  var r = bi.exec(n.slice(e, e + 2));
  return r ? ((t.V = +r[0]), e + r[0].length) : -1;
}
function Fi(t, n, e) {
  var r = bi.exec(n.slice(e, e + 2));
  return r ? ((t.W = +r[0]), e + r[0].length) : -1;
}
function Ei(t, n, e) {
  var r = bi.exec(n.slice(e, e + 4));
  return r ? ((t.y = +r[0]), e + r[0].length) : -1;
}
function Si(t, n, e) {
  var r = bi.exec(n.slice(e, e + 2));
  return r ? ((t.y = +r[0] + (+r[0] > 68 ? 1900 : 2e3)), e + r[0].length) : -1;
}
function Ci(t, n, e) {
  var r = /^(Z)|([+-]\d\d)(?::?(\d\d))?/.exec(n.slice(e, e + 6));
  return r ? ((t.Z = r[1] ? 0 : -(r[2] + (r[3] || '00'))), e + r[0].length) : -1;
}
function Ni(t, n, e) {
  var r = bi.exec(n.slice(e, e + 1));
  return r ? ((t.q = 3 * r[0] - 3), e + r[0].length) : -1;
}
function Bi(t, n, e) {
  var r = bi.exec(n.slice(e, e + 2));
  return r ? ((t.m = r[0] - 1), e + r[0].length) : -1;
}
function _i(t, n, e) {
  var r = bi.exec(n.slice(e, e + 2));
  return r ? ((t.d = +r[0]), e + r[0].length) : -1;
}
function zi(t, n, e) {
  var r = bi.exec(n.slice(e, e + 3));
  return r ? ((t.m = 0), (t.d = +r[0]), e + r[0].length) : -1;
}
function Ti(t, n, e) {
  var r = bi.exec(n.slice(e, e + 2));
  return r ? ((t.H = +r[0]), e + r[0].length) : -1;
}
function Pi(t, n, e) {
  var r = bi.exec(n.slice(e, e + 2));
  return r ? ((t.M = +r[0]), e + r[0].length) : -1;
}
function Ri(t, n, e) {
  var r = bi.exec(n.slice(e, e + 2));
  return r ? ((t.S = +r[0]), e + r[0].length) : -1;
}
function Li(t, n, e) {
  var r = bi.exec(n.slice(e, e + 3));
  return r ? ((t.L = +r[0]), e + r[0].length) : -1;
}
function qi(t, n, e) {
  var r = bi.exec(n.slice(e, e + 6));
  return r ? ((t.L = Math.floor(r[0] / 1e3)), e + r[0].length) : -1;
}
function Ii(t, n, e) {
  var r = yi.exec(n.slice(e, e + 1));
  return r ? e + r[0].length : -1;
}
function Ui(t, n, e) {
  var r = bi.exec(n.slice(e));
  return r ? ((t.Q = +r[0]), e + r[0].length) : -1;
}
function Wi(t, n, e) {
  var r = bi.exec(n.slice(e));
  return r ? ((t.s = +r[0]), e + r[0].length) : -1;
}
function Hi(t, n) {
  return xi(t.getDate(), n, 2);
}
function Gi(t, n) {
  return xi(t.getHours(), n, 2);
}
function Vi(t, n) {
  return xi(t.getHours() % 12 || 12, n, 2);
}
function Yi(t, n) {
  return xi(1 + Pe.count(Qe(t), t), n, 3);
}
function Xi(t, n) {
  return xi(t.getMilliseconds(), n, 3);
}
function Ji(t, n) {
  return Xi(t, n) + '000';
}
function Qi(t, n) {
  return xi(t.getMonth() + 1, n, 2);
}
function Zi(t, n) {
  return xi(t.getMinutes(), n, 2);
}
function Ki(t, n) {
  return xi(t.getSeconds(), n, 2);
}
function to(t) {
  var n = t.getDay();
  return 0 === n ? 7 : n;
}
function no(t, n) {
  return xi(Ie.count(Qe(t) - 1, t), n, 2);
}
function eo(t) {
  var n = t.getDay();
  return n >= 4 || 0 === n ? We(t) : We.ceil(t);
}
function ro(t, n) {
  return (t = eo(t)), xi(We.count(Qe(t), t) + (4 === Qe(t).getDay()), n, 2);
}
function io(t) {
  return t.getDay();
}
function oo(t, n) {
  return xi(Ue.count(Qe(t) - 1, t), n, 2);
}
function uo(t, n) {
  return xi(t.getFullYear() % 100, n, 2);
}
function so(t, n) {
  return xi((t = eo(t)).getFullYear() % 100, n, 2);
}
function ao(t, n) {
  return xi(t.getFullYear() % 1e4, n, 4);
}
function co(t, n) {
  var e = t.getDay();
  return xi((t = e >= 4 || 0 === e ? We(t) : We.ceil(t)).getFullYear() % 1e4, n, 4);
}
function lo(t) {
  var n = t.getTimezoneOffset();
  return (n > 0 ? '-' : ((n *= -1), '+')) + xi((n / 60) | 0, '0', 2) + xi(n % 60, '0', 2);
}
function fo(t, n) {
  return xi(t.getUTCDate(), n, 2);
}
function ho(t, n) {
  return xi(t.getUTCHours(), n, 2);
}
function po(t, n) {
  return xi(t.getUTCHours() % 12 || 12, n, 2);
}
function mo(t, n) {
  return xi(1 + Re.count(Ze(t), t), n, 3);
}
function vo(t, n) {
  return xi(t.getUTCMilliseconds(), n, 3);
}
function go(t, n) {
  return vo(t, n) + '000';
}
function bo(t, n) {
  return xi(t.getUTCMonth() + 1, n, 2);
}
function yo(t, n) {
  return xi(t.getUTCMinutes(), n, 2);
}
function wo(t, n) {
  return xi(t.getUTCSeconds(), n, 2);
}
function xo(t) {
  var n = t.getUTCDay();
  return 0 === n ? 7 : n;
}
function Oo(t, n) {
  return xi(Ge.count(Ze(t) - 1, t), n, 2);
}
function ko(t) {
  var n = t.getUTCDay();
  return n >= 4 || 0 === n ? Ye(t) : Ye.ceil(t);
}
function Ao(t, n) {
  return (t = ko(t)), xi(Ye.count(Ze(t), t) + (4 === Ze(t).getUTCDay()), n, 2);
}
function $o(t) {
  return t.getUTCDay();
}
function Mo(t, n) {
  return xi(Ve.count(Ze(t) - 1, t), n, 2);
}
function jo(t, n) {
  return xi(t.getUTCFullYear() % 100, n, 2);
}
function Do(t, n) {
  return xi((t = ko(t)).getUTCFullYear() % 100, n, 2);
}
function Fo(t, n) {
  return xi(t.getUTCFullYear() % 1e4, n, 4);
}
function Eo(t, n) {
  var e = t.getUTCDay();
  return xi((t = e >= 4 || 0 === e ? Ye(t) : Ye.ceil(t)).getUTCFullYear() % 1e4, n, 4);
}
function So() {
  return '+0000';
}
function Co() {
  return '%';
}
function No(t) {
  return +t;
}
function Bo(t) {
  return Math.floor(+t / 1e3);
}
function _o(t) {
  const n = {};
  return e => n[e] || (n[e] = t(e));
}
function zo(t) {
  const n = _o(t.format),
    e = t.formatPrefix;
  return {
    format: n,
    formatPrefix: e,
    formatFloat(t) {
      const e = ce(t || ',');
      if (null == e.precision) {
        switch (((e.precision = 12), e.type)) {
          case '%':
            e.precision -= 2;
            break;
          case 'e':
            e.precision -= 1;
        }
        return (function (t, n) {
          return e => {
            const r = t(e),
              i = r.indexOf(n);
            if (i < 0) return r;
            let o = (function (t, n) {
              let e,
                r = t.lastIndexOf('e');
              if (r > 0) return r;
              for (r = t.length; --r > n; ) if (((e = t.charCodeAt(r)), e >= 48 && e <= 57)) return r + 1;
            })(r, i);
            const u = o < r.length ? r.slice(o) : '';
            for (; --o > i; )
              if ('0' !== r[o]) {
                ++o;
                break;
              }
            return r.slice(0, o) + u;
          };
        })(n(e), n('.1f')(1)[1]);
      }
      return n(e);
    },
    formatSpan(t, r, i, o) {
      o = ce(null == o ? ',f' : o);
      const u = Yn(t, r, i),
        s = Math.max(Math.abs(t), Math.abs(r));
      let a;
      if (null == o.precision)
        switch (o.type) {
          case 's':
            return isNaN((a = xe(u, s))) || (o.precision = a), e(o, s);
          case '':
          case 'e':
          case 'g':
          case 'p':
          case 'r':
            isNaN((a = Oe(u, s))) || (o.precision = a - ('e' === o.type));
            break;
          case 'f':
          case '%':
            isNaN((a = we(u))) || (o.precision = a - 2 * ('%' === o.type));
        }
      return n(o);
    },
  };
}
let To, Po;
function Ro() {
  return (To = zo({ format: me, formatPrefix: ve }));
}
function Lo(t) {
  return zo(ye(t));
}
function qo(t) {
  return arguments.length ? (To = Lo(t)) : To;
}
function Io(t, n, e) {
  tt((e = e || {})) || I('Invalid time multi-format specifier: '.concat(e));
  const r = n(dr),
    i = n(hr),
    o = n(fr),
    u = n(ar),
    s = n(sr),
    a = n(ur),
    c = n(or),
    l = n(ir),
    f = t(e[pr] || '.%L'),
    h = t(e[dr] || ':%S'),
    d = t(e[hr] || '%I:%M'),
    p = t(e[fr] || '%I %p'),
    m = t(e[ar] || e[cr] || '%a %d'),
    v = t(e[sr] || '%b %d'),
    g = t(e[ur] || '%B'),
    b = t(e[or] || '%B'),
    y = t(e[ir] || '%Y');
  return t =>
    (r(t) < t
      ? f
      : i(t) < t
      ? h
      : o(t) < t
      ? d
      : u(t) < t
      ? p
      : a(t) < t
      ? s(t) < t
        ? m
        : v
      : l(t) < t
      ? c(t) < t
        ? g
        : b
      : y)(t);
}
function Uo(t) {
  const n = _o(t.format),
    e = _o(t.utcFormat);
  return {
    timeFormat: t => (Xt(t) ? n(t) : Io(n, Wr, t)),
    utcFormat: t => (Xt(t) ? e(t) : Io(e, Hr, t)),
    timeParse: _o(t.parse),
    utcParse: _o(t.utcParse),
  };
}
function Wo() {
  return (Po = Uo({ format: di, parse: pi, utcFormat: mi, utcParse: vi }));
}
function Ho(t) {
  return Uo(fi(t));
}
function Go(t) {
  return arguments.length ? (Po = Ho(t)) : Po;
}
(hi = fi({
  dateTime: '%x, %X',
  date: '%-m/%-d/%Y',
  time: '%-I:%M:%S %p',
  periods: ['AM', 'PM'],
  days: ['Sunday', 'Monday', 'Tuesday', 'Wednesday', 'Thursday', 'Friday', 'Saturday'],
  shortDays: ['Sun', 'Mon', 'Tue', 'Wed', 'Thu', 'Fri', 'Sat'],
  months: [
    'January',
    'February',
    'March',
    'April',
    'May',
    'June',
    'July',
    'August',
    'September',
    'October',
    'November',
    'December',
  ],
  shortMonths: ['Jan', 'Feb', 'Mar', 'Apr', 'May', 'Jun', 'Jul', 'Aug', 'Sep', 'Oct', 'Nov', 'Dec'],
})),
  (di = hi.format),
  (pi = hi.parse),
  (mi = hi.utcFormat),
  (vi = hi.utcParse),
  Ro(),
  Wo();
const Vo = (t, n) => Bt({}, t, n);
function Yo(t, n) {
  const e = t ? Lo(t) : qo(),
    r = n ? Ho(n) : Go();
  return Vo(e, r);
}
function Xo(t, n) {
  const e = arguments.length;
  return (
    e && 2 !== e && I('defaultLocale expects either zero or two arguments.'), e ? Vo(qo(t), Go(n)) : Vo(qo(), Go())
  );
}
const Jo = /^(data:|([A-Za-z]+:)?\/\/)/,
  Qo = /^(?:(?:(?:f|ht)tps?|mailto|tel|callto|cid|xmpp|file|data):|[^a-z]|[a-z+.\-]+(?:[^a-z+.\-:]|$))/i,
  Zo = /[\u0000-\u0020\u00A0\u1680\u180E\u2000-\u2029\u205f\u3000]/g,
  Ko = 'file://';
async function tu(t, n) {
  const e = await this.sanitize(t, n),
    r = e.href;
  return e.localFile ? this.file(r) : this.http(r, n);
}
async function nu(t, n) {
  n = Bt({}, this.options, n);
  const e = this.fileAccess,
    r = { href: null };
  let i, o, u;
  const s = Qo.test(t.replace(Zo, ''));
  (null != t && 'string' == typeof t && s) || I('Sanitize failure, invalid URI: ' + rn(t));
  const a = Jo.test(t);
  return (
    (u = n.baseURL) && !a && (t.startsWith('/') || u.endsWith('/') || (t = '/' + t), (t = u + t)),
    (o = (i = t.startsWith(Ko)) || 'file' === n.mode || ('http' !== n.mode && !a && e)),
    i
      ? (t = t.slice(Ko.length))
      : t.startsWith('//') &&
        ('file' === n.defaultProtocol ? ((t = t.slice(2)), (o = !0)) : (t = (n.defaultProtocol || 'http') + ':' + t)),
    Object.defineProperty(r, 'localFile', { value: !!o }),
    (r.href = t),
    n.target && (r.target = n.target + ''),
    n.rel && (r.rel = n.rel + ''),
    'image' === n.context && n.crossOrigin && (r.crossOrigin = n.crossOrigin + ''),
    r
  );
}
function eu(t) {
  return t
    ? n =>
        new Promise((e, r) => {
          t.readFile(n, (t, n) => {
            t ? r(t) : e(n);
          });
        })
    : ru;
}
async function ru() {
  I('No file system access.');
}
function iu(t) {
  return t
    ? async function (n, e) {
        const r = Bt({}, this.options.http, e),
          i = e && e.response,
          o = await t(n, r);
        return o.ok ? (Mt(o[i]) ? o[i]() : o.text()) : I(o.status + '' + o.statusText);
      }
    : ou;
}
async function ou() {
  I('No HTTP fetch method available.');
}
const uu = t => !(Number.isNaN(+t) || t instanceof Date),
  su = { boolean: on, integer: ut, number: ut, date: sn, string: an, unknown: G },
  au = [
    t => 'true' === t || 'false' === t || !0 === t || !1 === t,
    t => uu(t) && Number.isInteger(+t),
    uu,
    t => !Number.isNaN(Date.parse(t)),
  ],
  cu = ['boolean', 'integer', 'number', 'date'];
function lu(t, n) {
  if (!t || !t.length) return 'unknown';
  const e = t.length,
    r = au.length,
    i = au.map((t, n) => n + 1);
  for (let u, s, a = 0, c = 0; a < e; ++a)
    for (s = n ? t[a][n] : t[a], u = 0; u < r; ++u)
      if (i[u] && null != (o = s) && o == o && !au[u](s) && ((i[u] = 0), ++c, c === au.length)) return 'string';
  var o;
  return cu[i.reduce((t, n) => (0 === t ? n : t), 0) - 1];
}
function fu(t, n) {
  return n.reduce((n, e) => ((n[e] = lu(t, e)), n), {});
}
function hu(t) {
  const n = function (n, e) {
    const r = { delimiter: t };
    return du(n, e ? Bt(e, r) : r);
  };
  return (n.responseType = 'text'), n;
}
function du(t, n) {
  return n.header && (t = n.header.map(rn).join(n.delimiter) + '\n' + t), gn(n.delimiter).parse(t + '');
}
function pu(t, n) {
  const e = n && n.property ? W(n.property) : G;
  return !tt(t) || ((r = t), 'function' == typeof Buffer && Mt(Buffer.isBuffer) && Buffer.isBuffer(r))
    ? e(JSON.parse(t))
    : (function (t, n) {
        return !K(t) && Gt(t) && (t = [...t]), n && n.copy ? JSON.parse(JSON.stringify(t)) : t;
      })(e(t), n);
  var r;
}
(du.responseType = 'text'), (pu.responseType = 'json');
const mu = { interior: (t, n) => t !== n, exterior: (t, n) => t === n };
function vu(t, n) {
  let e, r, i, o;
  return (
    (t = pu(t, n)),
    n && n.feature
      ? ((e = yn), (i = n.feature))
      : n && n.mesh
      ? ((e = kn), (i = n.mesh), (o = mu[n.filter]))
      : I('Missing TopoJSON feature or mesh parameter.'),
    (r = (r = t.objects[i]) ? e(t, r, o) : I('Invalid TopoJSON object: ' + i)),
    (r && r.features) || [r]
  );
}
vu.responseType = 'json';
const gu = { dsv: du, csv: hu(','), tsv: hu('\t'), json: pu, topojson: vu };
function bu(t, n) {
  return arguments.length > 1 ? ((gu[t] = n), this) : Pt(gu, t) ? gu[t] : null;
}
function yu(t) {
  const n = bu(t);
  return (n && n.responseType) || 'text';
}
function wu(t, n, e, r) {
  const i = bu((n = n || {}).type || 'json');
  return (
    i || I('Unknown data format type: ' + n.type),
    (t = i(t, n)),
    n.parse &&
      (function (t, n, e, r) {
        if (!t.length) return;
        const i = Go();
        (e = e || i.timeParse), (r = r || i.utcParse);
        let o,
          u,
          s,
          a,
          c,
          l,
          f = t.columns || Object.keys(t[0]);
        'auto' === n && (n = fu(t, f)), (f = Object.keys(n));
        const h = f.map(t => {
          const i = n[t];
          let o, u;
          if (i && (i.startsWith('date:') || i.startsWith('utc:')))
            return (
              (o = i.split(/:(.+)?/, 2)),
              (u = o[1]),
              (("'" === u[0] && "'" === u[u.length - 1]) || ('"' === u[0] && '"' === u[u.length - 1])) &&
                (u = u.slice(1, -1)),
              ('utc' === o[0] ? r : e)(u)
            );
          if (!su[i]) throw Error('Illegal format pattern: ' + t + ':' + i);
          return su[i];
        });
        for (s = 0, c = t.length, l = f.length; s < c; ++s)
          for (o = t[s], a = 0; a < l; ++a) (u = f[a]), (o[u] = h[a](o[u]));
      })(t, n.parse, e, r),
    Pt(t, 'columns') && delete t.columns,
    t
  );
}
const xu = (function (t) {
  return n => ({ options: n || {}, sanitize: nu, load: tu, fileAccess: !1, file: eu(null), http: iu(t) });
})('undefined' != typeof fetch && fetch);
function Ou(t) {
  const n = t || G,
    e = [],
    r = {};
  return (
    (e.add = t => {
      const i = n(t);
      return r[i] || ((r[i] = 1), e.push(t)), e;
    }),
    (e.remove = t => {
      const i = n(t);
      if (r[i]) {
        r[i] = 0;
        const n = e.indexOf(t);
        n >= 0 && e.splice(n, 1);
      }
      return e;
    }),
    e
  );
}
async function ku(t, n) {
  try {
    await n(t);
  } catch (n) {
    t.error(n);
  }
}
const Au = Symbol('vega_id');
let $u = 1;
function Mu(t) {
  return !(!t || !ju(t));
}
function ju(t) {
  return t[Au];
}
function Du(t, n) {
  return (t[Au] = n), t;
}
function Fu(t) {
  const n = t === Object(t) ? t : { data: t };
  return ju(n) ? n : Du(n, $u++);
}
function Eu(t) {
  return Su(t, Fu({}));
}
function Su(t, n) {
  for (const e in t) n[e] = t[e];
  return n;
}
function Cu(t, n) {
  return Du(n, ju(t));
}
function Nu(t, n) {
  return t ? (n ? (e, r) => t(e, r) || ju(n(e)) - ju(n(r)) : (n, e) => t(n, e) || ju(n) - ju(e)) : null;
}
function Bu(t) {
  return t && t.constructor === _u;
}
function _u() {
  const t = [],
    n = [],
    e = [],
    r = [],
    i = [];
  let o = null,
    u = !1;
  return {
    constructor: _u,
    insert(n) {
      const e = At(n),
        r = e.length;
      for (let n = 0; n < r; ++n) t.push(e[n]);
      return this;
    },
    remove(t) {
      const e = Mt(t) ? r : n,
        i = At(t),
        o = i.length;
      for (let t = 0; t < o; ++t) e.push(i[t]);
      return this;
    },
    modify(t, n, r) {
      const o = { field: n, value: Ct(r) };
      return Mt(t) ? ((o.filter = t), i.push(o)) : ((o.tuple = t), e.push(o)), this;
    },
    encode(t, n) {
      return Mt(t) ? i.push({ filter: t, field: n }) : e.push({ tuple: t, field: n }), this;
    },
    clean(t) {
      return (o = t), this;
    },
    reflow() {
      return (u = !0), this;
    },
    pulse(s, a) {
      const c = {},
        l = {};
      let f, h, d, p, m, v;
      for (f = 0, h = a.length; f < h; ++f) c[ju(a[f])] = 1;
      for (f = 0, h = n.length; f < h; ++f) (m = n[f]), (c[ju(m)] = -1);
      for (f = 0, h = r.length; f < h; ++f)
        (p = r[f]),
          a.forEach(t => {
            p(t) && (c[ju(t)] = -1);
          });
      for (f = 0, h = t.length; f < h; ++f) (m = t[f]), (v = ju(m)), c[v] ? (c[v] = 1) : s.add.push(Fu(t[f]));
      for (f = 0, h = a.length; f < h; ++f) (m = a[f]), c[ju(m)] < 0 && s.rem.push(m);
      function g(t, n, e) {
        e ? (t[n] = e(t)) : (s.encode = n), u || (l[ju(t)] = t);
      }
      for (f = 0, h = e.length; f < h; ++f)
        (d = e[f]), (m = d.tuple), (p = d.field), (v = c[ju(m)]), v > 0 && (g(m, p, d.value), s.modifies(p));
      for (f = 0, h = i.length; f < h; ++f)
        (d = i[f]),
          (p = d.filter),
          a.forEach(t => {
            p(t) && c[ju(t)] > 0 && g(t, d.field, d.value);
          }),
          s.modifies(d.field);
      if (u) s.mod = n.length || r.length ? a.filter(t => c[ju(t)] > 0) : a.slice();
      else for (v in l) s.mod.push(l[v]);
      return (o || (null == o && (n.length || r.length))) && s.clean(!0), s;
    },
  };
}
const zu = '_:mod:_';
function Tu() {
  Object.defineProperty(this, zu, { writable: !0, value: {} });
}
Tu.prototype = {
  set(t, n, e, r) {
    const i = this,
      o = i[t],
      u = i[zu];
    return (
      null != n && n >= 0
        ? (o[n] !== e || r) && ((o[n] = e), (u[n + ':' + t] = -1), (u[t] = -1))
        : (o !== e || r) && ((i[t] = e), (u[t] = K(e) ? 1 + e.length : -1)),
      i
    );
  },
  modified(t, n) {
    const e = this[zu];
    if (!arguments.length) {
      for (const t in e) if (e[t]) return !0;
      return !1;
    }
    if (K(t)) {
      for (let n = 0; n < t.length; ++n) if (e[t[n]]) return !0;
      return !1;
    }
    return null != n && n >= 0 ? n + 1 < e[t] || !!e[n + ':' + t] : !!e[t];
  },
  clear() {
    return (this[zu] = {}), this;
  },
};
let Pu = 0;
const Ru = new Tu();
function Lu(t, n, e, r) {
  (this.id = ++Pu),
    (this.value = t),
    (this.stamp = -1),
    (this.rank = -1),
    (this.qrank = -1),
    (this.flags = 0),
    n && (this._update = n),
    e && this.parameters(e, r);
}
function qu(t) {
  return function (n) {
    const e = this.flags;
    return 0 === arguments.length ? !!(e & t) : ((this.flags = n ? e | t : e & ~t), this);
  };
}
Lu.prototype = {
  targets() {
    return this._targets || (this._targets = Ou(H));
  },
  set(t) {
    return this.value !== t ? ((this.value = t), 1) : 0;
  },
  skip: qu(1),
  modified: qu(2),
  parameters(t, n, e) {
    n = !1 !== n;
    const r = (this._argval = this._argval || new Tu()),
      i = (this._argops = this._argops || []),
      o = [];
    let u, s, a, c;
    const l = (t, e, u) => {
      u instanceof Lu
        ? (u !== this && (n && u.targets().add(this), o.push(u)), i.push({ op: u, name: t, index: e }))
        : r.set(t, e, u);
    };
    for (u in t)
      if (((s = t[u]), 'pulse' === u))
        At(s).forEach(t => {
          t instanceof Lu
            ? t !== this && (t.targets().add(this), o.push(t))
            : I('Pulse parameters must be operator instances.');
        }),
          (this.source = s);
      else if (K(s)) for (r.set(u, -1, Array((a = s.length))), c = 0; c < a; ++c) l(u, c, s[c]);
      else l(u, -1, s);
    return this.marshall().clear(), e && (i.initonly = !0), o;
  },
  marshall(t) {
    const n = this._argval || Ru,
      e = this._argops;
    let r, i, o, u;
    if (e) {
      const s = e.length;
      for (i = 0; i < s; ++i)
        (r = e[i]), (o = r.op), (u = o.modified() && o.stamp === t), n.set(r.name, r.index, o.value, u);
      if (e.initonly) {
        for (i = 0; i < s; ++i) (r = e[i]), r.op.targets().remove(this);
        (this._argops = null), (this._update = null);
      }
    }
    return n;
  },
  detach() {
    const t = this._argops;
    let n, e, r, i;
    if (t) for (n = 0, e = t.length; n < e; ++n) (r = t[n]), (i = r.op), i._targets && i._targets.remove(this);
    (this.pulse = null), (this.source = null);
  },
  evaluate(t) {
    const n = this._update;
    if (n) {
      const e = this.marshall(t.stamp),
        r = n.call(this, e, t);
      if ((e.clear(), r !== this.value)) this.value = r;
      else if (!this.modified()) return t.StopPropagation;
    }
  },
  run(t) {
    if (t.stamp < this.stamp) return t.StopPropagation;
    let n;
    return this.skip() ? (this.skip(!1), (n = 0)) : (n = this.evaluate(t)), (this.pulse = n || t);
  },
};
let Iu = 0;
function Uu(t, n, e) {
  (this.id = ++Iu), (this.value = null), e && (this.receive = e), t && (this._filter = t), n && (this._apply = n);
}
function Wu(t, n, e) {
  return new Uu(t, n, e);
}
Uu.prototype = {
  _filter: X,
  _apply: G,
  targets() {
    return this._targets || (this._targets = Ou(H));
  },
  consume(t) {
    return arguments.length ? ((this._consume = !!t), this) : !!this._consume;
  },
  receive(t) {
    if (this._filter(t)) {
      const n = (this.value = this._apply(t)),
        e = this._targets,
        r = e ? e.length : 0;
      for (let t = 0; t < r; ++t) e[t].receive(n);
      this._consume && (t.preventDefault(), t.stopPropagation());
    }
  },
  filter(t) {
    const n = Wu(t);
    return this.targets().add(n), n;
  },
  apply(t) {
    const n = Wu(null, t);
    return this.targets().add(n), n;
  },
  merge() {
    const t = Wu();
    this.targets().add(t);
    for (let n = 0, e = arguments.length; n < e; ++n) arguments[n].targets().add(t);
    return t;
  },
  throttle(t) {
    let n = -1;
    return this.filter(() => {
      const e = Date.now();
      return e - n > t ? ((n = e), 1) : 0;
    });
  },
  debounce(t) {
    const n = Wu();
    return (
      this.targets().add(
        Wu(
          null,
          null,
          Nt(t, t => {
            const e = t.dataflow;
            n.receive(t), e && e.run && e.run();
          }),
        ),
      ),
      n
    );
  },
  between(t, n) {
    let e = !1;
    return (
      t.targets().add(Wu(null, null, () => (e = !0))),
      n.targets().add(Wu(null, null, () => (e = !1))),
      this.filter(() => e)
    );
  },
  detach() {
    (this._filter = X), (this._targets = null);
  },
};
const Hu = { skip: !0 };
function Gu(t, n, e, r, i, o) {
  const u = Bt({}, o, Hu);
  let s, a;
  Mt(e) || (e = Ct(e)),
    void 0 === r
      ? (s = n => t.touch(e(n)))
      : Mt(r)
      ? ((a = new Lu(null, r, i, !1)),
        (s = n => {
          a.evaluate(n);
          const r = e(n),
            i = a.value;
          Bu(i) ? t.pulse(r, i, o) : t.update(r, i, u);
        }))
      : (s = n => t.update(e(n), r, u)),
    n.apply(s);
}
function Vu(t, n, e, r, i, o) {
  if (void 0 === r) n.targets().add(e);
  else {
    const u = o || {},
      s = new Lu(
        null,
        (function (t, n) {
          return (
            (n = Mt(n) ? n : Ct(n)),
            t
              ? function (e, r) {
                  const i = n(e, r);
                  return t.skip() || (t.skip(i !== this.value).value = i), i;
                }
              : n
          );
        })(e, r),
        i,
        !1,
      );
    s.modified(u.force),
      (s.rank = n.rank),
      n.targets().add(s),
      e && (s.skip(!0), (s.value = e.value), s.targets().add(e), t.connect(e, [s]));
  }
}
const Yu = {};
function Xu(t, n, e) {
  (this.dataflow = t),
    (this.stamp = null == n ? -1 : n),
    (this.add = []),
    (this.rem = []),
    (this.mod = []),
    (this.fields = null),
    (this.encode = e || null);
}
function Ju(t, n) {
  const e = [];
  return fn(t, n, t => e.push(t)), e;
}
function Qu(t, n) {
  const e = {};
  return (
    t.visit(n, t => {
      e[ju(t)] = 1;
    }),
    t => (e[ju(t)] ? null : t)
  );
}
function Zu(t, n) {
  return t ? (e, r) => t(e, r) && n(e, r) : n;
}
function Ku(t, n, e, r) {
  const i = this,
    o = e.length;
  let u = 0;
  (this.dataflow = t), (this.stamp = n), (this.fields = null), (this.encode = r || null), (this.pulses = e);
  for (let t = 0; t < o; ++t) {
    const r = e[t];
    if (r.stamp === n) {
      if (r.fields) {
        const t = i.fields || (i.fields = {});
        for (const n in r.fields) t[n] = 1;
      }
      r.changed(i.ADD) && (u |= i.ADD), r.changed(i.REM) && (u |= i.REM), r.changed(i.MOD) && (u |= i.MOD);
    }
  }
  this.changes = u;
}
function ts(t) {
  return t.error('Dataflow already running. Use runAsync() to chain invocations.'), t;
}
(Xu.prototype = {
  StopPropagation: Yu,
  ADD: 1,
  REM: 2,
  MOD: 4,
  ADD_REM: 3,
  ADD_MOD: 5,
  ALL: 7,
  REFLOW: 8,
  SOURCE: 16,
  NO_SOURCE: 32,
  NO_FIELDS: 64,
  fork(t) {
    return new Xu(this.dataflow).init(this, t);
  },
  clone() {
    const t = this.fork(7);
    return (
      (t.add = t.add.slice()),
      (t.rem = t.rem.slice()),
      (t.mod = t.mod.slice()),
      t.source && (t.source = t.source.slice()),
      t.materialize(23)
    );
  },
  addAll() {
    let t = this;
    return (
      !t.source ||
        t.add === t.rem ||
        (!t.rem.length && t.source.length === t.add.length) ||
        ((t = new Xu(this.dataflow).init(this)), (t.add = t.source), (t.rem = [])),
      t
    );
  },
  init(t, n) {
    const e = this;
    return (
      (e.stamp = t.stamp),
      (e.encode = t.encode),
      !t.fields || 64 & n || (e.fields = t.fields),
      1 & n ? ((e.addF = t.addF), (e.add = t.add)) : ((e.addF = null), (e.add = [])),
      2 & n ? ((e.remF = t.remF), (e.rem = t.rem)) : ((e.remF = null), (e.rem = [])),
      4 & n ? ((e.modF = t.modF), (e.mod = t.mod)) : ((e.modF = null), (e.mod = [])),
      32 & n
        ? ((e.srcF = null), (e.source = null))
        : ((e.srcF = t.srcF), (e.source = t.source), t.cleans && (e.cleans = t.cleans)),
      e
    );
  },
  runAfter(t) {
    this.dataflow.runAfter(t);
  },
  changed(t) {
    const n = t || 7;
    return (1 & n && this.add.length) || (2 & n && this.rem.length) || (4 & n && this.mod.length);
  },
  reflow(t) {
    if (t) return this.fork(7).reflow();
    const n = this.add.length,
      e = this.source && this.source.length;
    return e && e !== n && ((this.mod = this.source), n && this.filter(4, Qu(this, 1))), this;
  },
  clean(t) {
    return arguments.length ? ((this.cleans = !!t), this) : this.cleans;
  },
  modifies(t) {
    const n = this.fields || (this.fields = {});
    return K(t) ? t.forEach(t => (n[t] = !0)) : (n[t] = !0), this;
  },
  modified(t, n) {
    const e = this.fields;
    return !((!n && !this.mod.length) || !e) && (arguments.length ? (K(t) ? t.some(t => e[t]) : e[t]) : !!e);
  },
  filter(t, n) {
    const e = this;
    return (
      1 & t && (e.addF = Zu(e.addF, n)),
      2 & t && (e.remF = Zu(e.remF, n)),
      4 & t && (e.modF = Zu(e.modF, n)),
      16 & t && (e.srcF = Zu(e.srcF, n)),
      e
    );
  },
  materialize(t) {
    const n = this;
    return (
      1 & (t = t || 7) && n.addF && ((n.add = Ju(n.add, n.addF)), (n.addF = null)),
      2 & t && n.remF && ((n.rem = Ju(n.rem, n.remF)), (n.remF = null)),
      4 & t && n.modF && ((n.mod = Ju(n.mod, n.modF)), (n.modF = null)),
      16 & t && n.srcF && ((n.source = n.source.filter(n.srcF)), (n.srcF = null)),
      n
    );
  },
  visit(t, n) {
    const e = this,
      r = n;
    if (16 & t) return fn(e.source, e.srcF, r), e;
    1 & t && fn(e.add, e.addF, r), 2 & t && fn(e.rem, e.remF, r), 4 & t && fn(e.mod, e.modF, r);
    const i = e.source;
    if (8 & t && i) {
      const t = e.add.length + e.mod.length;
      t === i.length || fn(i, t ? Qu(e, 5) : e.srcF, r);
    }
    return e;
  },
}),
  It(Ku, Xu, {
    fork(t) {
      const n = new Xu(this.dataflow).init(this, t & this.NO_FIELDS);
      return (
        void 0 !== t &&
          (t & n.ADD && this.visit(n.ADD, t => n.add.push(t)),
          t & n.REM && this.visit(n.REM, t => n.rem.push(t)),
          t & n.MOD && this.visit(n.MOD, t => n.mod.push(t))),
        n
      );
    },
    changed(t) {
      return this.changes & t;
    },
    modified(t) {
      const n = this,
        e = n.fields;
      return e && n.changes & n.MOD ? (K(t) ? t.some(t => e[t]) : e[t]) : 0;
    },
    filter() {
      I('MultiPulse does not support filtering.');
    },
    materialize() {
      I('MultiPulse does not support materialization.');
    },
    visit(t, n) {
      const e = this,
        r = e.pulses,
        i = r.length;
      let o = 0;
      if (t & e.SOURCE) for (; o < i; ++o) r[o].visit(t, n);
      else for (; o < i; ++o) r[o].stamp === e.stamp && r[o].visit(t, n);
      return e;
    },
  });
const ns = { skip: !1, force: !1 };
function es(t, n, e, r) {
  let i, o;
  const u = t[e];
  for (; e > n && ((o = (e - 1) >> 1), (i = t[o]), r(u, i) < 0); ) (t[e] = i), (e = o);
  return (t[e] = u);
}
function rs() {
  this.logger(Z()), this.logLevel(1), (this._clock = 0), (this._rank = 0), (this._locale = Xo());
  try {
    this._loader = xu();
  } catch (t) {}
  (this._touched = Ou(H)),
    (this._input = {}),
    (this._pulse = null),
    (this._heap = (function (t) {
      let n = [];
      return {
        clear: () => (n = []),
        size: () => n.length,
        peek: () => n[0],
        push: e => (n.push(e), es(n, 0, n.length - 1, t)),
        pop: () => {
          const e = n.pop();
          let r;
          return (
            n.length
              ? ((r = n[0]),
                (n[0] = e),
                (function (t, n, e) {
                  const r = n,
                    i = t.length,
                    o = t[n];
                  let u,
                    s = 1 + (n << 1);
                  for (; s < i; )
                    (u = s + 1), u < i && e(t[s], t[u]) >= 0 && (s = u), (t[n] = t[s]), (s = 1 + ((n = s) << 1));
                  (t[n] = o), es(t, r, n, e);
                })(n, 0, t))
              : (r = e),
            r
          );
        },
      };
    })((t, n) => t.qrank - n.qrank)),
    (this._postrun = []);
}
function is(t) {
  return function () {
    return this._log[t].apply(this, arguments);
  };
}
function os(t, n) {
  Lu.call(this, t, null, n);
}
(rs.prototype = {
  stamp() {
    return this._clock;
  },
  loader(t) {
    return arguments.length ? ((this._loader = t), this) : this._loader;
  },
  locale(t) {
    return arguments.length ? ((this._locale = t), this) : this._locale;
  },
  logger(t) {
    return arguments.length ? ((this._log = t), this) : this._log;
  },
  error: is('error'),
  warn: is('warn'),
  info: is('info'),
  debug: is('debug'),
  logLevel: is('level'),
  cleanThreshold: 1e4,
  add: function (t, n, e, r) {
    let i,
      o = 1;
    return (
      t instanceof Lu
        ? (i = t)
        : t && t.prototype instanceof Lu
        ? (i = new t())
        : Mt(t)
        ? (i = new Lu(null, t))
        : ((o = 0), (i = new Lu(t, n))),
      this.rank(i),
      o && ((r = e), (e = n)),
      e && this.connect(i, i.parameters(e, r)),
      this.touch(i),
      i
    );
  },
  connect: function (t, n) {
    const e = t.rank,
      r = n.length;
    for (let i = 0; i < r; ++i) if (e < n[i].rank) return void this.rerank(t);
  },
  rank: function (t) {
    t.rank = ++this._rank;
  },
  rerank: function (t) {
    const n = [t];
    let e, r, i;
    for (; n.length; )
      if ((this.rank((e = n.pop())), (r = e._targets)))
        for (i = r.length; --i >= 0; ) n.push((e = r[i])), e === t && I('Cycle detected in dataflow graph.');
  },
  pulse: function (t, n, e) {
    this.touch(t, e || ns);
    const r = new Xu(this, this._clock + (this._pulse ? 0 : 1)),
      i = (t.pulse && t.pulse.source) || [];
    return (r.target = t), (this._input[t.id] = n.pulse(r, i)), this;
  },
  touch: function (t, n) {
    const e = n || ns;
    return this._pulse ? this._enqueue(t) : this._touched.add(t), e.skip && t.skip(!0), this;
  },
  update: function (t, n, e) {
    const r = e || ns;
    return (t.set(n) || r.force) && this.touch(t, r), this;
  },
  changeset: _u,
  ingest: function (t, n, e) {
    return (n = this.parse(n, e)), this.pulse(t, this.changeset().insert(n));
  },
  parse: function (t, n) {
    const e = this.locale();
    return wu(t, n, e.timeParse, e.utcParse);
  },
  preload: async function (t, n, e) {
    const r = this,
      i =
        r._pending ||
        (function (t) {
          let n;
          const e = new Promise(t => (n = t));
          return (
            (e.requests = 0),
            (e.done = () => {
              0 == --e.requests && ((t._pending = null), n(t));
            }),
            (t._pending = e)
          );
        })(r);
    i.requests += 1;
    const o = await r.request(n, e);
    return (
      r.pulse(
        t,
        r
          .changeset()
          .remove(X)
          .insert(o.data || []),
      ),
      i.done(),
      o
    );
  },
  request: async function (t, n) {
    const e = this;
    let r,
      i = 0;
    try {
      r = await e.loader().load(t, { context: 'dataflow', response: yu(n && n.type) });
      try {
        r = e.parse(r, n);
      } catch (n) {
        (i = -2), e.warn('Data ingestion failed', t, n);
      }
    } catch (n) {
      (i = -1), e.warn('Loading failed', t, n);
    }
    return { data: r, status: i };
  },
  events: function (t, n, e, r) {
    const i = this,
      o = Wu(e, r),
      u = function (t) {
        t.dataflow = i;
        try {
          o.receive(t);
        } catch (t) {
          i.error(t);
        } finally {
          i.run();
        }
      };
    let s;
    s = 'string' == typeof t && 'undefined' != typeof document ? document.querySelectorAll(t) : At(t);
    const a = s.length;
    for (let t = 0; t < a; ++t) s[t].addEventListener(n, u);
    return o;
  },
  on: function (t, n, e, r, i) {
    return (t instanceof Lu ? Vu : Gu)(this, t, n, e, r, i), this;
  },
  evaluate: async function (t, n, e) {
    const r = this,
      i = [];
    if (r._pulse) return ts(r);
    if ((r._pending && (await r._pending), n && (await ku(r, n)), !r._touched.length))
      return r.debug('Dataflow invoked, but nothing to do.'), r;
    const o = ++r._clock;
    (r._pulse = new Xu(r, o, t)), r._touched.forEach(t => r._enqueue(t, !0)), (r._touched = Ou(H));
    let u,
      s,
      a,
      c = 0;
    try {
      for (; r._heap.size() > 0; )
        (u = r._heap.pop()),
          u.rank === u.qrank
            ? ((s = u.run(r._getPulse(u, t))),
              s.then ? (s = await s) : s.async && (i.push(s.async), (s = Yu)),
              s !== Yu && u._targets && u._targets.forEach(t => r._enqueue(t)),
              ++c)
            : r._enqueue(u, !0);
    } catch (t) {
      r._heap.clear(), (a = t);
    }
    if (
      ((r._input = {}),
      (r._pulse = null),
      r.debug(`Pulse ${o}: ${c} operators`),
      a && ((r._postrun = []), r.error(a)),
      r._postrun.length)
    ) {
      const t = r._postrun.sort((t, n) => n.priority - t.priority);
      r._postrun = [];
      for (let n = 0; n < t.length; ++n) await ku(r, t[n].callback);
    }
    return (
      e && (await ku(r, e)),
      i.length &&
        Promise.all(i).then(t =>
          r.runAsync(null, () => {
            t.forEach(t => {
              try {
                t(r);
              } catch (t) {
                r.error(t);
              }
            });
          }),
        ),
      r
    );
  },
  run: function (t, n, e) {
    return this._pulse ? ts(this) : (this.evaluate(t, n, e), this);
  },
  runAsync: async function (t, n, e) {
    for (; this._running; ) await this._running;
    const r = () => (this._running = null);
    return (this._running = this.evaluate(t, n, e)).then(r, r), this._running;
  },
  runAfter: function (t, n, e) {
    if (this._pulse || n) this._postrun.push({ priority: e || 0, callback: t });
    else
      try {
        t(this);
      } catch (t) {
        this.error(t);
      }
  },
  _enqueue: function (t, n) {
    const e = t.stamp < this._clock;
    e && (t.stamp = this._clock), (e || n) && ((t.qrank = t.rank), this._heap.push(t));
  },
  _getPulse: function (t, n) {
    const e = t.source,
      r = this._clock;
    return e && K(e)
      ? new Ku(
          this,
          r,
          e.map(t => t.pulse),
          n,
        )
      : this._input[t.id] ||
          (function (t, n) {
            return n && n.stamp === t.stamp ? n : ((t = t.fork()), n && n !== Yu && (t.source = n.source), t);
          })(this._pulse, e && e.pulse);
  },
}),
  It(os, Lu, {
    run(t) {
      if (t.stamp < this.stamp) return t.StopPropagation;
      let n;
      return (
        this.skip() ? this.skip(!1) : (n = this.evaluate(t)),
        (n = n || t),
        n.then ? (n = n.then(t => (this.pulse = t))) : n !== t.StopPropagation && (this.pulse = n),
        n
      );
    },
    evaluate(t) {
      const n = this.marshall(t.stamp),
        e = this.transform(n, t);
      return n.clear(), e;
    },
    transform() {},
  });
const us = {};
function ss(t) {
  const n = as(t);
  return (n && n.Definition) || null;
}
function as(t) {
  return (t = t && t.toLowerCase()), Pt(us, t) ? us[t] : null;
}
function* cs(t, n) {
  if (null == n) for (let n of t) null != n && '' !== n && (n = +n) >= n && (yield n);
  else {
    let e = -1;
    for (let r of t) (r = n(r, ++e, t)), null != r && '' !== r && (r = +r) >= r && (yield r);
  }
}
function ls(t, n, e) {
  const r = Float64Array.from(cs(t, e));
  return r.sort(Mn), n.map(t => te(r, t));
}
function fs(t, n) {
  return ls(t, [0.25, 0.5, 0.75], n);
}
function hs(t, n) {
  const e = t.length,
    r = (function (t, n) {
      const e = (function (t, n) {
        let e,
          r = 0,
          i = 0,
          o = 0;
        if (void 0 === n)
          for (let n of t) null != n && (n = +n) >= n && ((e = n - i), (i += e / ++r), (o += e * (n - i)));
        else {
          let u = -1;
          for (let s of t)
            null != (s = n(s, ++u, t)) && (s = +s) >= s && ((e = s - i), (i += e / ++r), (o += e * (s - i)));
        }
        if (r > 1) return o / (r - 1);
      })(t, n);
      return e ? Math.sqrt(e) : e;
    })(t, n),
    i = fs(t, n);
  return 1.06 * (Math.min(r, (i[2] - i[0]) / 1.34) || r || Math.abs(i[0]) || 1) * Math.pow(e, -0.2);
}
function ds(t) {
  const n = t.maxbins || 20,
    e = t.base || 10,
    r = Math.log(e),
    i = t.divide || [5, 2];
  let o,
    u,
    s,
    a,
    c,
    l,
    f = t.extent[0],
    h = t.extent[1];
  const d = t.span || h - f || Math.abs(f) || 1;
  if (t.step) o = t.step;
  else if (t.steps) {
    for (a = d / n, c = 0, l = t.steps.length; c < l && t.steps[c] < a; ++c);
    o = t.steps[Math.max(0, c - 1)];
  } else {
    for (
      u = Math.ceil(Math.log(n) / r), s = t.minstep || 0, o = Math.max(s, Math.pow(e, Math.round(Math.log(d) / r) - u));
      Math.ceil(d / o) > n;

    )
      o *= e;
    for (c = 0, l = i.length; c < l; ++c) (a = o / i[c]), a >= s && d / a <= n && (o = a);
  }
  a = Math.log(o);
  const p = Math.pow(e, -(a >= 0 ? 0 : 1 + ~~(-a / r)) - 1);
  return (
    (t.nice || void 0 === t.nice) &&
      ((a = Math.floor(f / o + p) * o), (f = f < a ? a - o : a), (h = Math.ceil(h / o) * o)),
    { start: f, stop: h === f ? f + o : h, step: o }
  );
}
var ps = Math.random;
function ms(t, n, e, r) {
  if (!t.length) return [void 0, void 0];
  const i = Float64Array.from(cs(t, r)),
    o = i.length,
    u = n;
  let s, a, c, l;
  for (c = 0, l = Array(u); c < u; ++c) {
    for (s = 0, a = 0; a < o; ++a) s += i[~~(ps() * o)];
    l[c] = s / o;
  }
  return l.sort(Mn), [Kn(l, e / 2), Kn(l, 1 - e / 2)];
}
function vs(t, n, e, r) {
  r = r || (t => t);
  const i = t.length,
    o = new Float64Array(i);
  let u,
    s = 0,
    a = 1,
    c = r(t[0]),
    l = c,
    f = c + n;
  for (; a < i; ++a) {
    if (((u = r(t[a])), u >= f)) {
      for (l = (c + l) / 2; s < a; ++s) o[s] = l;
      (f = u + n), (c = u);
    }
    l = u;
  }
  for (l = (c + l) / 2; s < a; ++s) o[s] = l;
  return e
    ? (function (t, n) {
        const e = t.length;
        let r,
          i,
          o = 0,
          u = 1;
        for (; t[o] === t[u]; ) ++u;
        for (; u < e; ) {
          for (r = u + 1; t[u] === t[r]; ) ++r;
          if (t[u] - t[u - 1] < n) {
            for (i = u + ((o + r - u - u) >> 1); i < u; ) t[i++] = t[u];
            for (; i > u; ) t[i--] = t[o];
          }
          (o = u), (u = r);
        }
        return t;
      })(o, n + n / 4)
    : o;
}
const gs = Math.sqrt(2 * Math.PI),
  bs = Math.SQRT2;
let ys = NaN;
function ws(t, n) {
  (t = t || 0), (n = null == n ? 1 : n);
  let e,
    r,
    i = 0,
    o = 0;
  if (ys == ys) (i = ys), (ys = NaN);
  else {
    do {
      (i = 2 * ps() - 1), (o = 2 * ps() - 1), (e = i * i + o * o);
    } while (0 === e || e > 1);
    (r = Math.sqrt((-2 * Math.log(e)) / e)), (i *= r), (ys = o * r);
  }
  return t + i * n;
}
function xs(t, n, e) {
  const r = (t - (n || 0)) / (e = null == e ? 1 : e);
  return Math.exp(-0.5 * r * r) / (e * gs);
}
function Os(t, n, e) {
  const r = (t - (n = n || 0)) / (e = null == e ? 1 : e),
    i = Math.abs(r);
  let o;
  if (i > 37) o = 0;
  else {
    const t = Math.exp((-i * i) / 2);
    let n;
    i < 7.07106781186547
      ? ((n = 0.0352624965998911 * i + 0.700383064443688),
        (n = n * i + 6.37396220353165),
        (n = n * i + 33.912866078383),
        (n = n * i + 112.079291497871),
        (n = n * i + 221.213596169931),
        (n = n * i + 220.206867912376),
        (o = t * n),
        (n = 0.0883883476483184 * i + 1.75566716318264),
        (n = n * i + 16.064177579207),
        (n = n * i + 86.7807322029461),
        (n = n * i + 296.564248779674),
        (n = n * i + 637.333633378831),
        (n = n * i + 793.826512519948),
        (n = n * i + 440.413735824752),
        (o /= n))
      : ((n = i + 0.65),
        (n = i + 4 / n),
        (n = i + 3 / n),
        (n = i + 2 / n),
        (n = i + 1 / n),
        (o = t / n / 2.506628274631));
  }
  return r > 0 ? 1 - o : o;
}
function ks(t, n, e) {
  return t < 0 || t > 1
    ? NaN
    : (n || 0) +
        (null == e ? 1 : e) *
          bs *
          (function (t) {
            let n,
              e = -Math.log((1 - t) * (1 + t));
            return (
              e < 6.25
                ? ((e -= 3.125),
                  (n = -364441206401782e-35),
                  (n = n * e - 16850591381820166e-35),
                  (n = 128584807152564e-32 + n * e),
                  (n = 11157877678025181e-33 + n * e),
                  (n = n * e - 1333171662854621e-31),
                  (n = 20972767875968562e-33 + n * e),
                  (n = 6637638134358324e-30 + n * e),
                  (n = n * e - 4054566272975207e-29),
                  (n = n * e - 8151934197605472e-29),
                  (n = 26335093153082323e-28 + n * e),
                  (n = n * e - 12975133253453532e-27),
                  (n = n * e - 5415412054294628e-26),
                  (n = 1.0512122733215323e-9 + n * e),
                  (n = n * e - 4.112633980346984e-9),
                  (n = n * e - 2.9070369957882005e-8),
                  (n = 4.2347877827932404e-7 + n * e),
                  (n = n * e - 13654692000834679e-22),
                  (n = n * e - 13882523362786469e-21),
                  (n = 0.00018673420803405714 + n * e),
                  (n = n * e - 0.000740702534166267),
                  (n = n * e - 0.006033670871430149),
                  (n = 0.24015818242558962 + n * e),
                  (n = 1.6536545626831027 + n * e))
                : e < 16
                ? ((e = Math.sqrt(e) - 3.25),
                  (n = 2.2137376921775787e-9),
                  (n = 9.075656193888539e-8 + n * e),
                  (n = n * e - 2.7517406297064545e-7),
                  (n = 1.8239629214389228e-8 + n * e),
                  (n = 15027403968909828e-22 + n * e),
                  (n = n * e - 4013867526981546e-21),
                  (n = 29234449089955446e-22 + n * e),
                  (n = 12475304481671779e-21 + n * e),
                  (n = n * e - 47318229009055734e-21),
                  (n = 6828485145957318e-20 + n * e),
                  (n = 24031110387097894e-21 + n * e),
                  (n = n * e - 0.0003550375203628475),
                  (n = 0.0009532893797373805 + n * e),
                  (n = n * e - 0.0016882755560235047),
                  (n = 0.002491442096107851 + n * e),
                  (n = n * e - 0.003751208507569241),
                  (n = 0.005370914553590064 + n * e),
                  (n = 1.0052589676941592 + n * e),
                  (n = 3.0838856104922208 + n * e))
                : Number.isFinite(e)
                ? ((e = Math.sqrt(e) - 5),
                  (n = -27109920616438573e-27),
                  (n = n * e - 2.555641816996525e-10),
                  (n = 1.5076572693500548e-9 + n * e),
                  (n = n * e - 3.789465440126737e-9),
                  (n = 7.61570120807834e-9 + n * e),
                  (n = n * e - 1.496002662714924e-8),
                  (n = 2.914795345090108e-8 + n * e),
                  (n = n * e - 6.771199775845234e-8),
                  (n = 2.2900482228026655e-7 + n * e),
                  (n = n * e - 9.9298272942317e-7),
                  (n = 4526062597223154e-21 + n * e),
                  (n = n * e - 1968177810553167e-20),
                  (n = 7599527703001776e-20 + n * e),
                  (n = n * e - 0.00021503011930044477),
                  (n = n * e - 0.00013871931833623122),
                  (n = 1.0103004648645344 + n * e),
                  (n = 4.849906401408584 + n * e))
                : (n = 1 / 0),
              n * t
            );
          })(2 * t - 1);
}
function As(t, n) {
  let e, r;
  const i = {
    mean(t) {
      return arguments.length ? ((e = t || 0), i) : e;
    },
    stdev(t) {
      return arguments.length ? ((r = null == t ? 1 : t), i) : r;
    },
    sample: () => ws(e, r),
    pdf: t => xs(t, e, r),
    cdf: t => Os(t, e, r),
    icdf: t => ks(t, e, r),
  };
  return i.mean(t).stdev(n);
}
function $s(t, n) {
  const e = As();
  let r = 0;
  const i = {
    data(e) {
      return arguments.length ? ((t = e), (r = e ? e.length : 0), i.bandwidth(n)) : t;
    },
    bandwidth(e) {
      return arguments.length ? (!(n = e) && t && (n = hs(t)), i) : n;
    },
    sample: () => t[~~(ps() * r)] + n * e.sample(),
    pdf(i) {
      let o = 0,
        u = 0;
      for (; u < r; ++u) o += e.pdf((i - t[u]) / n);
      return o / n / r;
    },
    cdf(i) {
      let o = 0,
        u = 0;
      for (; u < r; ++u) o += e.cdf((i - t[u]) / n);
      return o / r;
    },
    icdf() {
      throw Error('KDE icdf not supported.');
    },
  };
  return i.data(t);
}
function Ms(t, n) {
  return (t = t || 0), (n = null == n ? 1 : n), Math.exp(t + ws() * n);
}
function js(t, n, e) {
  if (t <= 0) return 0;
  (n = n || 0), (e = null == e ? 1 : e);
  const r = (Math.log(t) - n) / e;
  return Math.exp(-0.5 * r * r) / (e * gs * t);
}
function Ds(t, n, e) {
  return Os(Math.log(t), n, e);
}
function Fs(t, n, e) {
  return Math.exp(ks(t, n, e));
}
function Es(t, n) {
  let e, r;
  const i = {
    mean(t) {
      return arguments.length ? ((e = t || 0), i) : e;
    },
    stdev(t) {
      return arguments.length ? ((r = null == t ? 1 : t), i) : r;
    },
    sample: () => Ms(e, r),
    pdf: t => js(t, e, r),
    cdf: t => Ds(t, e, r),
    icdf: t => Fs(t, e, r),
  };
  return i.mean(t).stdev(n);
}
function Ss(t, n) {
  let e,
    r = 0;
  const i = {
    weights(t) {
      return arguments.length
        ? ((e = (function (t) {
            const n = [];
            let e,
              i = 0;
            for (e = 0; e < r; ++e) i += n[e] = null == t[e] ? 1 : +t[e];
            for (e = 0; e < r; ++e) n[e] /= i;
            return n;
          })((n = t || []))),
          i)
        : n;
    },
    distributions(e) {
      return arguments.length ? (e ? ((r = e.length), (t = e)) : ((r = 0), (t = [])), i.weights(n)) : t;
    },
    sample() {
      const n = ps();
      let i = t[r - 1],
        o = e[0],
        u = 0;
      for (; u < r - 1; o += e[++u])
        if (n < o) {
          i = t[u];
          break;
        }
      return i.sample();
    },
    pdf(n) {
      let i = 0,
        o = 0;
      for (; o < r; ++o) i += e[o] * t[o].pdf(n);
      return i;
    },
    cdf(n) {
      let i = 0,
        o = 0;
      for (; o < r; ++o) i += e[o] * t[o].cdf(n);
      return i;
    },
    icdf() {
      throw Error('Mixture icdf not supported.');
    },
  };
  return i.distributions(t).weights(n);
}
function Cs(t, n) {
  return null == n && ((n = null == t ? 1 : t), (t = 0)), t + (n - t) * ps();
}
function Ns(t, n, e) {
  return null == e && ((e = null == n ? 1 : n), (n = 0)), t >= n && t <= e ? 1 / (e - n) : 0;
}
function Bs(t, n, e) {
  return null == e && ((e = null == n ? 1 : n), (n = 0)), t < n ? 0 : t > e ? 1 : (t - n) / (e - n);
}
function _s(t, n, e) {
  return null == e && ((e = null == n ? 1 : n), (n = 0)), t >= 0 && t <= 1 ? n + t * (e - n) : NaN;
}
function zs(t, n) {
  let e, r;
  const i = {
    min(t) {
      return arguments.length ? ((e = t || 0), i) : e;
    },
    max(t) {
      return arguments.length ? ((r = null == t ? 1 : t), i) : r;
    },
    sample: () => Cs(e, r),
    pdf: t => Ns(t, e, r),
    cdf: t => Bs(t, e, r),
    icdf: t => _s(t, e, r),
  };
  return null == n && ((n = null == t ? 1 : t), (t = 0)), i.min(t).max(n);
}
function Ts(t, n, e, r) {
  const i = r - t * t,
    o = Math.abs(i) < 1e-24 ? 0 : (e - t * n) / i;
  return [n - o * t, o];
}
function Ps(t, n, e, r) {
  (t = t.filter(t => {
    let r = n(t),
      i = e(t);
    return null != r && (r = +r) >= r && null != i && (i = +i) >= i;
  })),
    r && t.sort((t, e) => n(t) - n(e));
  const i = t.length,
    o = new Float64Array(i),
    u = new Float64Array(i);
  let s,
    a,
    c,
    l = 0,
    f = 0,
    h = 0;
  for (c of t) (o[l] = s = +n(c)), (u[l] = a = +e(c)), ++l, (f += (s - f) / l), (h += (a - h) / l);
  for (l = 0; l < i; ++l) (o[l] -= f), (u[l] -= h);
  return [o, u, f, h];
}
function Rs(t, n, e, r) {
  let i,
    o,
    u = -1;
  for (const s of t) (i = n(s)), (o = e(s)), null != i && (i = +i) >= i && null != o && (o = +o) >= o && r(i, o, ++u);
}
function Ls(t, n, e, r, i) {
  let o = 0,
    u = 0;
  return (
    Rs(t, n, e, (t, n) => {
      const e = n - i(t),
        s = n - r;
      (o += e * e), (u += s * s);
    }),
    1 - o / u
  );
}
function qs(t, n, e) {
  let r = 0,
    i = 0,
    o = 0,
    u = 0,
    s = 0;
  Rs(t, n, e, (t, n) => {
    ++s, (r += (t - r) / s), (i += (n - i) / s), (o += (t * n - o) / s), (u += (t * t - u) / s);
  });
  const a = Ts(r, i, o, u),
    c = t => a[0] + a[1] * t;
  return { coef: a, predict: c, rSquared: Ls(t, n, e, i, c) };
}
function Is(t, n, e) {
  let r = 0,
    i = 0,
    o = 0,
    u = 0,
    s = 0;
  Rs(t, n, e, (t, n) => {
    ++s, (t = Math.log(t)), (r += (t - r) / s), (i += (n - i) / s), (o += (t * n - o) / s), (u += (t * t - u) / s);
  });
  const a = Ts(r, i, o, u),
    c = t => a[0] + a[1] * Math.log(t);
  return { coef: a, predict: c, rSquared: Ls(t, n, e, i, c) };
}
function Us(t, n, e) {
  const [r, i, o, u] = Ps(t, n, e);
  let s,
    a,
    c,
    l = 0,
    f = 0,
    h = 0,
    d = 0,
    p = 0;
  Rs(t, n, e, (t, n) => {
    (s = r[p++]),
      (a = Math.log(n)),
      (c = s * n),
      (l += (n * a - l) / p),
      (f += (c - f) / p),
      (h += (c * a - h) / p),
      (d += (s * c - d) / p);
  });
  const [m, v] = Ts(f / u, l / u, h / u, d / u),
    g = t => Math.exp(m + v * (t - o));
  return { coef: [Math.exp(m - v * o), v], predict: g, rSquared: Ls(t, n, e, u, g) };
}
function Ws(t, n, e) {
  let r = 0,
    i = 0,
    o = 0,
    u = 0,
    s = 0,
    a = 0;
  Rs(t, n, e, (t, n) => {
    const e = Math.log(t),
      c = Math.log(n);
    ++a, (r += (e - r) / a), (i += (c - i) / a), (o += (e * c - o) / a), (u += (e * e - u) / a), (s += (n - s) / a);
  });
  const c = Ts(r, i, o, u),
    l = t => c[0] * Math.pow(t, c[1]);
  return (c[0] = Math.exp(c[0])), { coef: c, predict: l, rSquared: Ls(t, n, e, s, l) };
}
function Hs(t, n, e) {
  const [r, i, o, u] = Ps(t, n, e),
    s = r.length;
  let a,
    c,
    l,
    f,
    h = 0,
    d = 0,
    p = 0,
    m = 0,
    v = 0;
  for (a = 0; a < s; )
    (c = r[a]),
      (l = i[a++]),
      (f = c * c),
      (h += (f - h) / a),
      (d += (f * c - d) / a),
      (p += (f * f - p) / a),
      (m += (c * l - m) / a),
      (v += (f * l - v) / a);
  const g = p - h * h,
    b = h * g - d * d,
    y = (v * h - m * d) / b,
    w = (m * g - v * d) / b,
    x = -y * h,
    O = t => y * (t -= o) * t + w * t + x + u;
  return { coef: [x - w * o + y * o * o + u, w - 2 * y * o, y], predict: O, rSquared: Ls(t, n, e, u, O) };
}
function Gs(t, n, e, r) {
  if (1 === r) return qs(t, n, e);
  if (2 === r) return Hs(t, n, e);
  const [i, o, u, s] = Ps(t, n, e),
    a = i.length,
    c = [],
    l = [],
    f = r + 1;
  let h, d, p, m, v;
  for (h = 0; h < f; ++h) {
    for (p = 0, m = 0; p < a; ++p) m += Math.pow(i[p], h) * o[p];
    for (c.push(m), v = new Float64Array(f), d = 0; d < f; ++d) {
      for (p = 0, m = 0; p < a; ++p) m += Math.pow(i[p], h + d);
      v[d] = m;
    }
    l.push(v);
  }
  l.push(c);
  const g = (function (t) {
      const n = t.length - 1,
        e = [];
      let r, i, o, u, s;
      for (r = 0; r < n; ++r) {
        for (u = r, i = r + 1; i < n; ++i) Math.abs(t[r][i]) > Math.abs(t[r][u]) && (u = i);
        for (o = r; o < n + 1; ++o) (s = t[o][r]), (t[o][r] = t[o][u]), (t[o][u] = s);
        for (i = r + 1; i < n; ++i) for (o = n; o >= r; o--) t[o][i] -= (t[o][r] * t[r][i]) / t[r][r];
      }
      for (i = n - 1; i >= 0; --i) {
        for (s = 0, o = i + 1; o < n; ++o) s += t[o][i] * e[o];
        e[i] = (t[n][i] - s) / t[i][i];
      }
      return e;
    })(l),
    b = t => {
      let n = s + g[0] + g[1] * (t -= u) + g[2] * t * t;
      for (h = 3; h < f; ++h) n += g[h] * Math.pow(t, h);
      return n;
    };
  return { coef: Vs(f, g, -u, s), predict: b, rSquared: Ls(t, n, e, s, b) };
}
function Vs(t, n, e, r) {
  const i = Array(t);
  let o, u, s, a;
  for (o = 0; o < t; ++o) i[o] = 0;
  for (o = t - 1; o >= 0; --o)
    for (s = n[o], a = 1, i[o] += s, u = 1; u <= o; ++u) (a *= (o + 1 - u) / u), (i[o - u] += s * Math.pow(e, u) * a);
  return (i[0] += r), i;
}
function Ys(t, n, e, r) {
  const [i, o, u, s] = Ps(t, n, e, !0),
    a = i.length,
    c = Math.max(2, ~~(r * a)),
    l = new Float64Array(a),
    f = new Float64Array(a),
    h = new Float64Array(a).fill(1);
  for (let t = -1; ++t <= 2; ) {
    const n = [0, c - 1];
    for (let t = 0; t < a; ++t) {
      const e = i[t],
        r = n[0],
        u = n[1];
      let s = 0,
        a = 0,
        c = 0,
        d = 0,
        p = 0;
      const m = 1 / Math.abs(i[e - i[r] > i[u] - e ? r : u] - e || 1);
      for (let t = r; t <= u; ++t) {
        const n = i[t],
          r = o[t],
          u = Xs(Math.abs(e - n) * m) * h[t],
          l = n * u;
        (s += u), (a += l), (c += r * u), (d += r * l), (p += n * l);
      }
      const [v, g] = Ts(a / s, c / s, d / s, p / s);
      (l[t] = v + g * e), (f[t] = Math.abs(o[t] - l[t])), Js(i, t + 1, n);
    }
    if (2 === t) break;
    const e = ne(f);
    if (Math.abs(e) < 1e-12) break;
    for (let t, n, r = 0; r < a; ++r) (t = f[r] / (6 * e)), (h[r] = t >= 1 ? 1e-12 : (n = 1 - t * t) * n);
  }
  return (function (t, n, e, r) {
    const i = t.length,
      o = [];
    let u,
      s = 0,
      a = 0,
      c = [];
    for (; s < i; ++s)
      (u = t[s] + e), c[0] === u ? (c[1] += (n[s] - c[1]) / ++a) : ((a = 0), (c[1] += r), (c = [u, n[s]]), o.push(c));
    return (c[1] += r), o;
  })(i, l, u, s);
}
function Xs(t) {
  return (t = 1 - t * t * t) * t * t;
}
function Js(t, n, e) {
  const r = t[n];
  let i = e[0],
    o = e[1] + 1;
  if (!(o >= t.length)) for (; n > i && t[o] - r <= r - t[i]; ) (e[0] = ++i), (e[1] = o), ++o;
}
const Qs = (0.5 * Math.PI) / 180;
function Zs(t, n, e, r) {
  (e = e || 25), (r = Math.max(e, r || 200));
  const i = n => [n, t(n)],
    o = n[0],
    u = n[1],
    s = u - o,
    a = s / r,
    c = [i(o)],
    l = [];
  if (e === r) {
    for (let t = 1; t < r; ++t) c.push(i(o + (t / e) * s));
    return c.push(i(u)), c;
  }
  l.push(i(u));
  for (let t = e; --t > 0; ) l.push(i(o + (t / e) * s));
  let f = c[0],
    h = l[l.length - 1];
  const d = 1 / s,
    p = (function (t, n) {
      let e = t,
        r = t;
      const i = n.length;
      for (let t = 0; t < i; ++t) {
        const i = n[t][1];
        i < e && (e = i), i > r && (r = i);
      }
      return 1 / (r - e);
    })(f[1], l);
  for (; h; ) {
    const t = i((f[0] + h[0]) / 2);
    t[0] - f[0] >= a && Ks(f, t, h, d, p) > Qs ? l.push(t) : ((f = h), c.push(h), l.pop()), (h = l[l.length - 1]);
  }
  return c;
}
function Ks(t, n, e, r, i) {
  const o = Math.atan2(i * (e[1] - t[1]), r * (e[0] - t[0])),
    u = Math.atan2(i * (n[1] - t[1]), r * (n[0] - t[0]));
  return Math.abs(o - u);
}
function ta(t) {
  return t && t.length
    ? 1 === t.length
      ? t[0]
      : ((n = t),
        t => {
          const e = n.length;
          let r = 1,
            i = String(n[0](t));
          for (; r < e; ++r) i += '|' + n[r](t);
          return i;
        })
    : function () {
        return '';
      };
  var n;
}
function na(t, n, e) {
  return e || t + (n ? '_' + n : '');
}
const ea = () => {},
  ra = { init: ea, add: ea, rem: ea, idx: 0 },
  ia = {
    values: { init: t => (t.cell.store = !0), value: t => t.cell.data.values(), idx: -1 },
    count: { value: t => t.cell.num },
    __count__: { value: t => t.missing + t.valid },
    missing: { value: t => t.missing },
    valid: { value: t => t.valid },
    sum: { init: t => (t.sum = 0), value: t => t.sum, add: (t, n) => (t.sum += +n), rem: (t, n) => (t.sum -= n) },
    product: {
      init: t => (t.product = 1),
      value: t => (t.valid ? t.product : void 0),
      add: (t, n) => (t.product *= n),
      rem: (t, n) => (t.product /= n),
    },
    mean: {
      init: t => (t.mean = 0),
      value: t => (t.valid ? t.mean : void 0),
      add: (t, n) => ((t.mean_d = n - t.mean), (t.mean += t.mean_d / t.valid)),
      rem: (t, n) => ((t.mean_d = n - t.mean), (t.mean -= t.valid ? t.mean_d / t.valid : t.mean)),
    },
    average: { value: t => (t.valid ? t.mean : void 0), req: ['mean'], idx: 1 },
    variance: {
      init: t => (t.dev = 0),
      value: t => (t.valid > 1 ? t.dev / (t.valid - 1) : void 0),
      add: (t, n) => (t.dev += t.mean_d * (n - t.mean)),
      rem: (t, n) => (t.dev -= t.mean_d * (n - t.mean)),
      req: ['mean'],
      idx: 1,
    },
    variancep: { value: t => (t.valid > 1 ? t.dev / t.valid : void 0), req: ['variance'], idx: 2 },
    stdev: { value: t => (t.valid > 1 ? Math.sqrt(t.dev / (t.valid - 1)) : void 0), req: ['variance'], idx: 2 },
    stdevp: { value: t => (t.valid > 1 ? Math.sqrt(t.dev / t.valid) : void 0), req: ['variance'], idx: 2 },
    stderr: {
      value: t => (t.valid > 1 ? Math.sqrt(t.dev / (t.valid * (t.valid - 1))) : void 0),
      req: ['variance'],
      idx: 2,
    },
    distinct: { value: t => t.cell.data.distinct(t.get), req: ['values'], idx: 3 },
    ci0: { value: t => t.cell.data.ci0(t.get), req: ['values'], idx: 3 },
    ci1: { value: t => t.cell.data.ci1(t.get), req: ['values'], idx: 3 },
    median: { value: t => t.cell.data.q2(t.get), req: ['values'], idx: 3 },
    q1: { value: t => t.cell.data.q1(t.get), req: ['values'], idx: 3 },
    q3: { value: t => t.cell.data.q3(t.get), req: ['values'], idx: 3 },
    min: {
      init: t => (t.min = void 0),
      value: t => (t.min = Number.isNaN(t.min) ? t.cell.data.min(t.get) : t.min),
      add: (t, n) => {
        (n < t.min || void 0 === t.min) && (t.min = n);
      },
      rem: (t, n) => {
        n <= t.min && (t.min = NaN);
      },
      req: ['values'],
      idx: 4,
    },
    max: {
      init: t => (t.max = void 0),
      value: t => (t.max = Number.isNaN(t.max) ? t.cell.data.max(t.get) : t.max),
      add: (t, n) => {
        (n > t.max || void 0 === t.max) && (t.max = n);
      },
      rem: (t, n) => {
        n >= t.max && (t.max = NaN);
      },
      req: ['values'],
      idx: 4,
    },
    argmin: {
      init: t => (t.argmin = void 0),
      value: t => t.argmin || t.cell.data.argmin(t.get),
      add: (t, n, e) => {
        n < t.min && (t.argmin = e);
      },
      rem: (t, n) => {
        n <= t.min && (t.argmin = void 0);
      },
      req: ['min', 'values'],
      idx: 3,
    },
    argmax: {
      init: t => (t.argmax = void 0),
      value: t => t.argmax || t.cell.data.argmax(t.get),
      add: (t, n, e) => {
        n > t.max && (t.argmax = e);
      },
      rem: (t, n) => {
        n >= t.max && (t.argmax = void 0);
      },
      req: ['max', 'values'],
      idx: 3,
    },
  },
  oa = Object.keys(ia);
function ua(t, n) {
  return ia[t](n);
}
function sa(t, n) {
  return t.idx - n.idx;
}
function aa() {
  (this.valid = 0), (this.missing = 0), this._ops.forEach(t => t.init(this));
}
function ca(t, n) {
  null != t && '' !== t ? t == t && (++this.valid, this._ops.forEach(e => e.add(this, t, n))) : ++this.missing;
}
function la(t, n) {
  null != t && '' !== t ? t == t && (--this.valid, this._ops.forEach(e => e.rem(this, t, n))) : --this.missing;
}
function fa(t) {
  return this._out.forEach(n => (t[n.out] = n.value(this))), t;
}
function ha(t, n) {
  const e = n || G,
    r = (function (t) {
      const n = {};
      t.forEach(t => (n[t.name] = t));
      const e = t => {
        t.req &&
          t.req.forEach(t => {
            n[t] || e((n[t] = ia[t]()));
          });
      };
      return t.forEach(e), Object.values(n).sort(sa);
    })(t),
    i = t.slice().sort(sa);
  function o(t) {
    (this._ops = r), (this._out = i), (this.cell = t), this.init();
  }
  return (
    (o.prototype.init = aa),
    (o.prototype.add = ca),
    (o.prototype.rem = la),
    (o.prototype.set = fa),
    (o.prototype.get = e),
    (o.fields = t.map(t => t.out)),
    o
  );
}
function da(t) {
  (this._key = t ? W(t) : ju), this.reset();
}
oa.forEach(t => {
  ia[t] = (function (t, n) {
    return e => Bt({ name: t, out: e || t }, ra, n);
  })(t, ia[t]);
});
const pa = da.prototype;
function ma(t) {
  os.call(this, null, t),
    (this._adds = []),
    (this._mods = []),
    (this._alen = 0),
    (this._mlen = 0),
    (this._drop = !0),
    (this._cross = !1),
    (this._dims = []),
    (this._dnames = []),
    (this._measures = []),
    (this._countOnly = !1),
    (this._counts = null),
    (this._prev = null),
    (this._inputs = null),
    (this._outputs = null);
}
function va(t) {
  os.call(this, null, t);
}
function ga(t, n, e) {
  const r = t;
  let i = n || [],
    o = e || [],
    u = {},
    s = 0;
  return {
    add: t => o.push(t),
    remove: t => (u[r(t)] = ++s),
    size: () => i.length,
    data: (t, n) => (
      s && ((i = i.filter(t => !u[r(t)])), (u = {}), (s = 0)),
      n && t && i.sort(t),
      o.length && ((i = t ? Kt(t, i, o.sort(t)) : i.concat(o)), (o = [])),
      i
    ),
  };
}
function ba(t) {
  os.call(this, [], t);
}
function ya(t) {
  Lu.call(this, null, wa, t);
}
function wa(t) {
  return this.value && !t.modified() ? this.value : jt(t.fields, t.orders);
}
function xa(t) {
  os.call(this, null, t);
}
function Oa(t) {
  os.call(this, null, t);
}
(pa.reset = function () {
  (this._add = []), (this._rem = []), (this._ext = null), (this._get = null), (this._q = null);
}),
  (pa.add = function (t) {
    this._add.push(t);
  }),
  (pa.rem = function (t) {
    this._rem.push(t);
  }),
  (pa.values = function () {
    if (((this._get = null), 0 === this._rem.length)) return this._add;
    const t = this._add,
      n = this._rem,
      e = this._key,
      r = t.length,
      i = n.length,
      o = Array(r - i),
      u = {};
    let s, a, c;
    for (s = 0; s < i; ++s) u[e(n[s])] = 1;
    for (s = 0, a = 0; s < r; ++s) u[e((c = t[s]))] ? (u[e(c)] = 0) : (o[a++] = c);
    return (this._rem = []), (this._add = o);
  }),
  (pa.distinct = function (t) {
    const n = this.values(),
      e = {};
    let r,
      i = n.length,
      o = 0;
    for (; --i >= 0; ) (r = t(n[i]) + ''), Pt(e, r) || ((e[r] = 1), ++o);
    return o;
  }),
  (pa.extent = function (t) {
    if (this._get !== t || !this._ext) {
      const n = this.values(),
        e = zt(n, t);
      (this._ext = [n[e[0]], n[e[1]]]), (this._get = t);
    }
    return this._ext;
  }),
  (pa.argmin = function (t) {
    return this.extent(t)[0] || {};
  }),
  (pa.argmax = function (t) {
    return this.extent(t)[1] || {};
  }),
  (pa.min = function (t) {
    const n = this.extent(t)[0];
    return null != n ? t(n) : void 0;
  }),
  (pa.max = function (t) {
    const n = this.extent(t)[1];
    return null != n ? t(n) : void 0;
  }),
  (pa.quartile = function (t) {
    return (this._get === t && this._q) || ((this._q = fs(this.values(), t)), (this._get = t)), this._q;
  }),
  (pa.q1 = function (t) {
    return this.quartile(t)[0];
  }),
  (pa.q2 = function (t) {
    return this.quartile(t)[1];
  }),
  (pa.q3 = function (t) {
    return this.quartile(t)[2];
  }),
  (pa.ci = function (t) {
    return (this._get === t && this._ci) || ((this._ci = ms(this.values(), 1e3, 0.05, t)), (this._get = t)), this._ci;
  }),
  (pa.ci0 = function (t) {
    return this.ci(t)[0];
  }),
  (pa.ci1 = function (t) {
    return this.ci(t)[1];
  }),
  (ma.Definition = {
    type: 'Aggregate',
    metadata: { generates: !0, changes: !0 },
    params: [
      { name: 'groupby', type: 'field', array: !0 },
      { name: 'ops', type: 'enum', array: !0, values: oa },
      { name: 'fields', type: 'field', null: !0, array: !0 },
      { name: 'as', type: 'string', null: !0, array: !0 },
      { name: 'drop', type: 'boolean', default: !0 },
      { name: 'cross', type: 'boolean', default: !1 },
      { name: 'key', type: 'field' },
    ],
  }),
  It(ma, os, {
    transform(t, n) {
      const e = this,
        r = n.fork(n.NO_SOURCE | n.NO_FIELDS),
        i = t.modified();
      return (
        (e.stamp = r.stamp),
        e.value && (i || n.modified(e._inputs, !0))
          ? ((e._prev = e.value), (e.value = i ? e.init(t) : {}), n.visit(n.SOURCE, t => e.add(t)))
          : ((e.value = e.value || e.init(t)), n.visit(n.REM, t => e.rem(t)), n.visit(n.ADD, t => e.add(t))),
        r.modifies(e._outputs),
        (e._drop = !1 !== t.drop),
        t.cross && e._dims.length > 1 && ((e._drop = !1), e.cross()),
        n.clean() && e._drop && r.clean(!0).runAfter(() => this.clean()),
        e.changes(r)
      );
    },
    cross() {
      const t = this,
        n = t.value,
        e = t._dnames,
        r = e.map(() => ({})),
        i = e.length;
      function o(t) {
        let n, o, u, s;
        for (n in t) for (u = t[n].tuple, o = 0; o < i; ++o) r[o][(s = u[e[o]])] = s;
      }
      o(t._prev),
        o(n),
        (function o(u, s, a) {
          const c = e[a],
            l = r[a++];
          for (const e in l) {
            const r = u ? u + '|' + e : e;
            (s[c] = l[e]), a < i ? o(r, s, a) : n[r] || t.cell(r, s);
          }
        })('', {}, 0);
    },
    init(t) {
      const n = (this._inputs = []),
        e = (this._outputs = []),
        r = {};
      function i(t) {
        const e = At(P(t)),
          i = e.length;
        let o,
          u = 0;
        for (; u < i; ++u) r[(o = e[u])] || ((r[o] = 1), n.push(o));
      }
      (this._dims = At(t.groupby)),
        (this._dnames = this._dims.map(t => {
          const n = T(t);
          return i(t), e.push(n), n;
        })),
        (this.cellkey = t.key ? t.key : ta(this._dims)),
        (this._countOnly = !0),
        (this._counts = []),
        (this._measures = []);
      const o = t.fields || [null],
        u = t.ops || ['count'],
        s = t.as || [],
        a = o.length,
        c = {};
      let l, f, h, d, p, m;
      for (a !== u.length && I('Unmatched number of fields and aggregate ops.'), m = 0; m < a; ++m)
        (l = o[m]),
          (f = u[m]),
          null == l && 'count' !== f && I('Null aggregate field specified.'),
          (d = T(l)),
          (p = na(f, d, s[m])),
          e.push(p),
          'count' !== f
            ? ((h = c[d]),
              h || (i(l), (h = c[d] = []), (h.field = l), this._measures.push(h)),
              'count' !== f && (this._countOnly = !1),
              h.push(ua(f, p)))
            : this._counts.push(p);
      return (this._measures = this._measures.map(t => ha(t, t.field))), {};
    },
    cellkey: ta(),
    cell(t, n) {
      let e = this.value[t];
      return (
        e
          ? 0 === e.num && this._drop && e.stamp < this.stamp
            ? ((e.stamp = this.stamp), (this._adds[this._alen++] = e))
            : e.stamp < this.stamp && ((e.stamp = this.stamp), (this._mods[this._mlen++] = e))
          : ((e = this.value[t] = this.newcell(t, n)), (this._adds[this._alen++] = e)),
        e
      );
    },
    newcell(t, n) {
      const e = {
        key: t,
        num: 0,
        agg: null,
        tuple: this.newtuple(n, this._prev && this._prev[t]),
        stamp: this.stamp,
        store: !1,
      };
      if (!this._countOnly) {
        const t = this._measures,
          n = t.length;
        e.agg = Array(n);
        for (let r = 0; r < n; ++r) e.agg[r] = new t[r](e);
      }
      return e.store && (e.data = new da()), e;
    },
    newtuple(t, n) {
      const e = this._dnames,
        r = this._dims,
        i = r.length,
        o = {};
      for (let n = 0; n < i; ++n) o[e[n]] = r[n](t);
      return n ? Cu(n.tuple, o) : Fu(o);
    },
    clean() {
      const t = this.value;
      for (const n in t) 0 === t[n].num && delete t[n];
    },
    add(t) {
      const n = this.cellkey(t),
        e = this.cell(n, t);
      if (((e.num += 1), this._countOnly)) return;
      e.store && e.data.add(t);
      const r = e.agg;
      for (let n = 0, e = r.length; n < e; ++n) r[n].add(r[n].get(t), t);
    },
    rem(t) {
      const n = this.cellkey(t),
        e = this.cell(n, t);
      if (((e.num -= 1), this._countOnly)) return;
      e.store && e.data.rem(t);
      const r = e.agg;
      for (let n = 0, e = r.length; n < e; ++n) r[n].rem(r[n].get(t), t);
    },
    celltuple(t) {
      const n = t.tuple,
        e = this._counts;
      t.store && t.data.values();
      for (let r = 0, i = e.length; r < i; ++r) n[e[r]] = t.num;
      if (!this._countOnly) {
        const e = t.agg;
        for (let t = 0, r = e.length; t < r; ++t) e[t].set(n);
      }
      return n;
    },
    changes(t) {
      const n = this._adds,
        e = this._mods,
        r = this._prev,
        i = this._drop,
        o = t.add,
        u = t.rem,
        s = t.mod;
      let a, c, l, f;
      if (r) for (c in r) (a = r[c]), (i && !a.num) || u.push(a.tuple);
      for (l = 0, f = this._alen; l < f; ++l) o.push(this.celltuple(n[l])), (n[l] = null);
      for (l = 0, f = this._mlen; l < f; ++l)
        (a = e[l]), (0 === a.num && i ? u : s).push(this.celltuple(a)), (e[l] = null);
      return (this._alen = this._mlen = 0), (this._prev = null), t;
    },
  }),
  (va.Definition = {
    type: 'Bin',
    metadata: { modifies: !0 },
    params: [
      { name: 'field', type: 'field', required: !0 },
      { name: 'interval', type: 'boolean', default: !0 },
      { name: 'anchor', type: 'number' },
      { name: 'maxbins', type: 'number', default: 20 },
      { name: 'base', type: 'number', default: 10 },
      { name: 'divide', type: 'number', array: !0, default: [5, 2] },
      { name: 'extent', type: 'number', array: !0, length: 2, required: !0 },
      { name: 'span', type: 'number' },
      { name: 'step', type: 'number' },
      { name: 'steps', type: 'number', array: !0 },
      { name: 'minstep', type: 'number', default: 0 },
      { name: 'nice', type: 'boolean', default: !0 },
      { name: 'name', type: 'string' },
      { name: 'as', type: 'string', array: !0, length: 2, default: ['bin0', 'bin1'] },
    ],
  }),
  It(va, os, {
    transform(t, n) {
      const e = !1 !== t.interval,
        r = this._bins(t),
        i = r.start,
        o = r.step,
        u = t.as || ['bin0', 'bin1'],
        s = u[0],
        a = u[1];
      let c;
      return (
        (c = t.modified() ? (n = n.reflow(!0)).SOURCE : n.modified(P(t.field)) ? n.ADD_MOD : n.ADD),
        n.visit(
          c,
          e
            ? t => {
                const n = r(t);
                (t[s] = n), (t[a] = null == n ? null : i + o * (1 + (n - i) / o));
              }
            : t => (t[s] = r(t)),
        ),
        n.modifies(e ? u : s)
      );
    },
    _bins(t) {
      if (this.value && !t.modified()) return this.value;
      const n = t.field,
        e = ds(t),
        r = e.step;
      let i,
        o,
        u = e.start,
        s = u + Math.ceil((e.stop - u) / r) * r;
      null != (i = t.anchor) && ((o = i - (u + r * Math.floor((i - u) / r))), (u += o), (s += o));
      const a = function (t) {
        let e = ut(n(t));
        return null == e
          ? null
          : e < u
          ? -1 / 0
          : e > s
          ? 1 / 0
          : ((e = Math.max(u, Math.min(e, s - r))), u + r * Math.floor(1e-14 + (e - u) / r));
      };
      return (a.start = u), (a.stop = e.stop), (a.step = r), (this.value = z(a, P(n), t.name || 'bin_' + T(n)));
    },
  }),
  (ba.Definition = { type: 'Collect', metadata: { source: !0 }, params: [{ name: 'sort', type: 'compare' }] }),
  It(ba, os, {
    transform(t, n) {
      const e = n.fork(n.ALL),
        r = ga(ju, this.value, e.materialize(e.ADD).add),
        i = t.sort,
        o = n.changed() || (i && (t.modified('sort') || n.modified(i.fields)));
      return (
        e.visit(e.REM, r.remove),
        this.modified(o),
        (this.value = e.source = r.data(Nu(i), o)),
        n.source && n.source.root && (this.value.root = n.source.root),
        e
      );
    },
  }),
  It(ya, Lu),
  (xa.Definition = {
    type: 'CountPattern',
    metadata: { generates: !0, changes: !0 },
    params: [
      { name: 'field', type: 'field', required: !0 },
      { name: 'case', type: 'enum', values: ['upper', 'lower', 'mixed'], default: 'mixed' },
      { name: 'pattern', type: 'string', default: '[\\w"]+' },
      { name: 'stopwords', type: 'string', default: '' },
      { name: 'as', type: 'string', array: !0, length: 2, default: ['text', 'count'] },
    ],
  }),
  It(xa, os, {
    transform(t, n) {
      const e = n => e => {
          for (
            var r,
              i =
                (function (t, n, e) {
                  switch (n) {
                    case 'upper':
                      t = t.toUpperCase();
                      break;
                    case 'lower':
                      t = t.toLowerCase();
                  }
                  return t.match(e);
                })(s(e), t.case, o) || [],
              a = 0,
              c = i.length;
            a < c;
            ++a
          )
            u.test((r = i[a])) || n(r);
        },
        r = this._parameterCheck(t, n),
        i = this._counts,
        o = this._match,
        u = this._stop,
        s = t.field,
        a = t.as || ['text', 'count'],
        c = e(t => (i[t] = 1 + (i[t] || 0))),
        l = e(t => (i[t] -= 1));
      return r ? n.visit(n.SOURCE, c) : (n.visit(n.ADD, c), n.visit(n.REM, l)), this._finish(n, a);
    },
    _parameterCheck(t, n) {
      let e = !1;
      return (
        (!t.modified('stopwords') && this._stop) ||
          ((this._stop = new RegExp('^' + (t.stopwords || '') + '$', 'i')), (e = !0)),
        (!t.modified('pattern') && this._match) || ((this._match = new RegExp(t.pattern || "[\\w']+", 'g')), (e = !0)),
        (t.modified('field') || n.modified(t.field.fields)) && (e = !0),
        e && (this._counts = {}),
        e
      );
    },
    _finish(t, n) {
      const e = this._counts,
        r = this._tuples || (this._tuples = {}),
        i = n[0],
        o = n[1],
        u = t.fork(t.NO_SOURCE | t.NO_FIELDS);
      let s, a, c;
      for (s in e)
        (a = r[s]),
          (c = e[s] || 0),
          !a && c
            ? ((r[s] = a = Fu({})), (a[i] = s), (a[o] = c), u.add.push(a))
            : 0 === c
            ? (a && u.rem.push(a), (e[s] = null), (r[s] = null))
            : a[o] !== c && ((a[o] = c), u.mod.push(a));
      return u.modifies(n);
    },
  }),
  (Oa.Definition = {
    type: 'Cross',
    metadata: { generates: !0 },
    params: [
      { name: 'filter', type: 'expr' },
      { name: 'as', type: 'string', array: !0, length: 2, default: ['a', 'b'] },
    ],
  }),
  It(Oa, os, {
    transform(t, n) {
      const e = n.fork(n.NO_SOURCE),
        r = t.as || ['a', 'b'],
        i = r[0],
        o = r[1],
        u = !this.value || n.changed(n.ADD_REM) || t.modified('as') || t.modified('filter');
      let s = this.value;
      return (
        u
          ? (s && (e.rem = s),
            (s = n.materialize(n.SOURCE).source),
            (e.add = this.value =
              (function (t, n, e, r) {
                for (var i, o, u = [], s = {}, a = t.length, c = 0; c < a; ++c)
                  for (s[n] = o = t[c], i = 0; i < a; ++i) (s[e] = t[i]), r(s) && (u.push(Fu(s)), ((s = {})[n] = o));
                return u;
              })(s, i, o, t.filter || X)))
          : (e.mod = s),
        (e.source = this.value),
        e.modifies(r)
      );
    },
  });
const ka = { kde: $s, mixture: Ss, normal: As, lognormal: Es, uniform: zs },
  Aa = 'function';
function $a(t, n) {
  const e = t[Aa];
  Pt(ka, e) || I('Unknown distribution function: ' + e);
  const r = ka[e]();
  for (const e in t)
    'field' === e
      ? r.data((t.from || n()).map(t[e]))
      : 'distributions' === e
      ? r[e](t[e].map(t => $a(t, n)))
      : typeof r[e] === Aa && r[e](t[e]);
  return r;
}
function Ma(t) {
  os.call(this, null, t);
}
const ja = [
  {
    key: { function: 'normal' },
    params: [
      { name: 'mean', type: 'number', default: 0 },
      { name: 'stdev', type: 'number', default: 1 },
    ],
  },
  {
    key: { function: 'lognormal' },
    params: [
      { name: 'mean', type: 'number', default: 0 },
      { name: 'stdev', type: 'number', default: 1 },
    ],
  },
  {
    key: { function: 'uniform' },
    params: [
      { name: 'min', type: 'number', default: 0 },
      { name: 'max', type: 'number', default: 1 },
    ],
  },
  {
    key: { function: 'kde' },
    params: [
      { name: 'field', type: 'field', required: !0 },
      { name: 'from', type: 'data' },
      { name: 'bandwidth', type: 'number', default: 0 },
    ],
  },
];
function Da(t, n) {
  return t ? t.map((t, e) => n[e] || T(t)) : null;
}
function Fa(t, n, e) {
  const r = [],
    i = t => t(a);
  let o, u, s, a, c, l;
  if (null == n) r.push(t.map(e));
  else
    for (o = {}, u = 0, s = t.length; u < s; ++u)
      (a = t[u]), (c = n.map(i)), (l = o[c]), l || ((o[c] = l = []), (l.dims = c), r.push(l)), l.push(e(a));
  return r;
}
function Ea(t) {
  os.call(this, null, t);
}
function Sa(t) {
  Lu.call(this, null, Ca, t), this.modified(!0);
}
function Ca(t) {
  const n = t.expr;
  return this.value && !t.modified('expr') ? this.value : z(e => n(e, t), P(n), T(n));
}
function Na(t) {
  os.call(this, [void 0, void 0], t);
}
function Ba(t, n) {
  Lu.call(this, t), (this.parent = n), (this.count = 0);
}
function _a(t) {
  os.call(this, {}, t), (this._keys = Lt());
  const n = (this._targets = []);
  (n.active = 0),
    (n.forEach = t => {
      for (let e = 0, r = n.active; e < r; ++e) t(n[e], e, n);
    });
}
function za(t) {
  Lu.call(this, null, Ta, t);
}
function Ta(t) {
  return this.value && !t.modified() ? this.value : K(t.name) ? At(t.name).map(t => W(t)) : W(t.name, t.as);
}
function Pa(t) {
  os.call(this, Lt(), t);
}
function Ra(t) {
  os.call(this, [], t);
}
function La(t) {
  os.call(this, [], t);
}
function qa(t) {
  os.call(this, null, t);
}
function Ia(t) {
  os.call(this, [], t);
}
(Ma.Definition = {
  type: 'Density',
  metadata: { generates: !0 },
  params: [
    { name: 'extent', type: 'number', array: !0, length: 2 },
    { name: 'steps', type: 'number' },
    { name: 'minsteps', type: 'number', default: 25 },
    { name: 'maxsteps', type: 'number', default: 200 },
    { name: 'method', type: 'string', default: 'pdf', values: ['pdf', 'cdf'] },
    {
      name: 'distribution',
      type: 'param',
      params: ja.concat({
        key: { function: 'mixture' },
        params: [
          { name: 'distributions', type: 'param', array: !0, params: ja },
          { name: 'weights', type: 'number', array: !0 },
        ],
      }),
    },
    { name: 'as', type: 'string', array: !0, default: ['value', 'density'] },
  ],
}),
  It(Ma, os, {
    transform(t, n) {
      const e = n.fork(n.NO_SOURCE | n.NO_FIELDS);
      if (!this.value || n.changed() || t.modified()) {
        const r = $a(
            t.distribution,
            (function (t) {
              return () => t.materialize(t.SOURCE).source;
            })(n),
          ),
          i = t.steps || t.minsteps || 25,
          o = t.steps || t.maxsteps || 200;
        let u = t.method || 'pdf';
        'pdf' !== u && 'cdf' !== u && I('Invalid density method: ' + u),
          t.extent || r.data || I('Missing density extent parameter.'),
          (u = r[u]);
        const s = t.as || ['value', 'density'],
          a = Zs(u, t.extent || _t(r.data()), i, o).map(t => {
            const n = {};
            return (n[s[0]] = t[0]), (n[s[1]] = t[1]), Fu(n);
          });
        this.value && (e.rem = this.value), (this.value = e.add = e.source = a);
      }
      return e;
    },
  }),
  (Ea.Definition = {
    type: 'DotBin',
    metadata: { modifies: !0 },
    params: [
      { name: 'field', type: 'field', required: !0 },
      { name: 'groupby', type: 'field', array: !0 },
      { name: 'step', type: 'number' },
      { name: 'smooth', type: 'boolean', default: !1 },
      { name: 'as', type: 'string', default: 'bin' },
    ],
  }),
  It(Ea, os, {
    transform(t, n) {
      if (this.value && !t.modified() && !n.changed()) return n;
      const e = n.materialize(n.SOURCE).source,
        r = Fa(n.source, t.groupby, G),
        i = t.smooth || !1,
        o = t.field,
        u = t.step || ((t, n) => en(_t(t, n)) / 30)(e, o),
        s = Nu((t, n) => o(t) - o(n)),
        a = t.as || 'bin',
        c = r.length;
      let l,
        f = 1 / 0,
        h = -1 / 0,
        d = 0;
      for (; d < c; ++d) {
        const t = r[d].sort(s);
        l = -1;
        for (const n of vs(t, u, i, o)) n < f && (f = n), n > h && (h = n), (t[++l][a] = n);
      }
      return (this.value = { start: f, stop: h, step: u }), n.reflow(!0).modifies(a);
    },
  }),
  It(Sa, Lu),
  (Na.Definition = { type: 'Extent', metadata: {}, params: [{ name: 'field', type: 'field', required: !0 }] }),
  It(Na, os, {
    transform(t, n) {
      const e = this.value,
        r = t.field,
        i = n.changed() || n.modified(r.fields) || t.modified('field');
      let o = e[0],
        u = e[1];
      if (
        ((i || null == o) && ((o = 1 / 0), (u = -1 / 0)),
        n.visit(i ? n.SOURCE : n.ADD, t => {
          const n = ut(r(t));
          null != n && (n < o && (o = n), n > u && (u = n));
        }),
        !Number.isFinite(o) || !Number.isFinite(u))
      ) {
        let t = T(r);
        t && (t = ' for field "'.concat(t, '"')),
          n.dataflow.warn('Infinite extent'.concat(t, ': [').concat(o, ', ').concat(u, ']')),
          (o = u = void 0);
      }
      this.value = [o, u];
    },
  }),
  It(Ba, Lu, {
    connect(t) {
      return (this.detachSubflow = t.detachSubflow), this.targets().add(t), (t.source = this);
    },
    add(t) {
      (this.count += 1), this.value.add.push(t);
    },
    rem(t) {
      (this.count -= 1), this.value.rem.push(t);
    },
    mod(t) {
      this.value.mod.push(t);
    },
    init(t) {
      this.value.init(t, t.NO_SOURCE);
    },
    evaluate() {
      return this.value;
    },
  }),
  It(_a, os, {
    activate(t) {
      this._targets[this._targets.active++] = t;
    },
    subflow(t, n, e, r) {
      const i = this.value;
      let o,
        u,
        s = Pt(i, t) && i[t];
      return (
        s
          ? s.value.stamp < e.stamp && (s.init(e), this.activate(s))
          : ((u = r || ((u = this._group[t]) && u.tuple)),
            (o = e.dataflow),
            (s = new Ba(e.fork(e.NO_SOURCE), this)),
            o.add(s).connect(n(o, t, u)),
            (i[t] = s),
            this.activate(s)),
        s
      );
    },
    clean() {
      const t = this.value;
      let n = 0;
      for (const e in t)
        if (0 === t[e].count) {
          const r = t[e].detachSubflow;
          r && r(), delete t[e], ++n;
        }
      if (n) {
        const t = this._targets.filter(t => t && t.count > 0);
        this.initTargets(t);
      }
    },
    initTargets(t) {
      const n = this._targets,
        e = n.length,
        r = t ? t.length : 0;
      let i = 0;
      for (; i < r; ++i) n[i] = t[i];
      for (; i < e && null != n[i]; ++i) n[i] = null;
      n.active = r;
    },
    transform(t, n) {
      const e = n.dataflow,
        r = t.key,
        i = t.subflow,
        o = this._keys,
        u = t.modified('key'),
        s = t => this.subflow(t, i, n);
      return (
        (this._group = t.group || {}),
        this.initTargets(),
        n.visit(n.REM, t => {
          const n = ju(t),
            e = o.get(n);
          void 0 !== e && (o.delete(n), s(e).rem(t));
        }),
        n.visit(n.ADD, t => {
          const n = r(t);
          o.set(ju(t), n), s(n).add(t);
        }),
        u || n.modified(r.fields)
          ? n.visit(n.MOD, t => {
              const n = ju(t),
                e = o.get(n),
                i = r(t);
              e === i ? s(i).mod(t) : (o.set(n, i), s(e).rem(t), s(i).add(t));
            })
          : n.changed(n.MOD) &&
            n.visit(n.MOD, t => {
              s(o.get(ju(t))).mod(t);
            }),
        u &&
          n.visit(n.REFLOW, t => {
            const n = ju(t),
              e = o.get(n),
              i = r(t);
            e !== i && (o.set(n, i), s(e).rem(t), s(i).add(t));
          }),
        n.clean()
          ? e.runAfter(() => {
              this.clean(), o.clean();
            })
          : o.empty > e.cleanThreshold && e.runAfter(o.clean),
        n
      );
    },
  }),
  It(za, Lu),
  (Pa.Definition = {
    type: 'Filter',
    metadata: { changes: !0 },
    params: [{ name: 'expr', type: 'expr', required: !0 }],
  }),
  It(Pa, os, {
    transform(t, n) {
      const e = n.dataflow,
        r = this.value,
        i = n.fork(),
        o = i.add,
        u = i.rem,
        s = i.mod,
        a = t.expr;
      let c = !0;
      function l(n) {
        const e = ju(n),
          i = a(n, t),
          l = r.get(e);
        i && l ? (r.delete(e), o.push(n)) : i || l ? c && i && !l && s.push(n) : (r.set(e, 1), u.push(n));
      }
      return (
        n.visit(n.REM, t => {
          const n = ju(t);
          r.has(n) ? r.delete(n) : u.push(t);
        }),
        n.visit(n.ADD, n => {
          a(n, t) ? o.push(n) : r.set(ju(n), 1);
        }),
        n.visit(n.MOD, l),
        t.modified() && ((c = !1), n.visit(n.REFLOW, l)),
        r.empty > e.cleanThreshold && e.runAfter(r.clean),
        i
      );
    },
  }),
  (Ra.Definition = {
    type: 'Flatten',
    metadata: { generates: !0 },
    params: [
      { name: 'fields', type: 'field', array: !0, required: !0 },
      { name: 'index', type: 'string' },
      { name: 'as', type: 'string', array: !0 },
    ],
  }),
  It(Ra, os, {
    transform(t, n) {
      const e = n.fork(n.NO_SOURCE),
        r = t.fields,
        i = Da(r, t.as || []),
        o = t.index || null,
        u = i.length;
      return (
        (e.rem = this.value),
        n.visit(n.SOURCE, t => {
          const n = r.map(n => n(t)),
            s = n.reduce((t, n) => Math.max(t, n.length), 0);
          let a,
            c,
            l,
            f = 0;
          for (; f < s; ++f) {
            for (c = Eu(t), a = 0; a < u; ++a) c[i[a]] = null == (l = n[a][f]) ? null : l;
            o && (c[o] = f), e.add.push(c);
          }
        }),
        (this.value = e.source = e.add),
        o && e.modifies(o),
        e.modifies(i)
      );
    },
  }),
  (La.Definition = {
    type: 'Fold',
    metadata: { generates: !0 },
    params: [
      { name: 'fields', type: 'field', array: !0, required: !0 },
      { name: 'as', type: 'string', array: !0, length: 2, default: ['key', 'value'] },
    ],
  }),
  It(La, os, {
    transform(t, n) {
      const e = n.fork(n.NO_SOURCE),
        r = t.fields,
        i = r.map(T),
        o = t.as || ['key', 'value'],
        u = o[0],
        s = o[1],
        a = r.length;
      return (
        (e.rem = this.value),
        n.visit(n.SOURCE, t => {
          for (let n, o = 0; o < a; ++o) (n = Eu(t)), (n[u] = i[o]), (n[s] = r[o](t)), e.add.push(n);
        }),
        (this.value = e.source = e.add),
        e.modifies(o)
      );
    },
  }),
  (qa.Definition = {
    type: 'Formula',
    metadata: { modifies: !0 },
    params: [
      { name: 'expr', type: 'expr', required: !0 },
      { name: 'as', type: 'string', required: !0 },
      { name: 'initonly', type: 'boolean' },
    ],
  }),
  It(qa, os, {
    transform(t, n) {
      const e = t.expr,
        r = t.as,
        i = t.modified(),
        o = t.initonly ? n.ADD : i ? n.SOURCE : n.modified(e.fields) || n.modified(r) ? n.ADD_MOD : n.ADD;
      return i && (n = n.materialize().reflow(!0)), t.initonly || n.modifies(r), n.visit(o, n => (n[r] = e(n, t)));
    },
  }),
  It(Ia, os, {
    transform(t, n) {
      const e = n.fork(n.ALL),
        r = t.generator;
      let i,
        o,
        u,
        s = this.value,
        a = t.size - s.length;
      if (a > 0) {
        for (i = []; --a >= 0; ) i.push((u = Fu(r(t)))), s.push(u);
        e.add = e.add.length ? e.materialize(e.ADD).add.concat(i) : i;
      } else (o = s.slice(0, -a)), (e.rem = e.rem.length ? e.materialize(e.REM).rem.concat(o) : o), (s = s.slice(-a));
      return (e.source = this.value = s), e;
    },
  });
const Ua = {
    value: 'value',
    median: ne,
    mean: function (t, n) {
      let e = 0,
        r = 0;
      if (void 0 === n) for (let n of t) null != n && (n = +n) >= n && (++e, (r += n));
      else {
        let i = -1;
        for (let o of t) null != (o = n(o, ++i, t)) && (o = +o) >= o && (++e, (r += o));
      }
      if (e) return r / e;
    },
    min: Jn,
    max: Xn,
  },
  Wa = [];
function Ha(t) {
  os.call(this, [], t);
}
function Ga(t) {
  ma.call(this, t);
}
function Va(t) {
  os.call(this, null, t);
}
function Ya(t) {
  Lu.call(this, null, Xa, t);
}
function Xa(t) {
  return this.value && !t.modified() ? this.value : Jt(t.fields, t.flat);
}
function Ja(t) {
  os.call(this, [], t), (this._pending = null);
}
function Qa(t, n, e) {
  e.forEach(Fu);
  const r = n.fork(n.NO_FIELDS & n.NO_SOURCE);
  return (r.rem = t.value), (t.value = r.source = r.add = e), (t._pending = null), r.rem.length && r.clean(!0), r;
}
function Za(t) {
  os.call(this, {}, t);
}
function Ka(t) {
  Lu.call(this, null, tc, t);
}
function tc(t) {
  if (this.value && !t.modified()) return this.value;
  const n = t.extents,
    e = n.length;
  let r,
    i,
    o = 1 / 0,
    u = -1 / 0;
  for (r = 0; r < e; ++r) (i = n[r]), i[0] < o && (o = i[0]), i[1] > u && (u = i[1]);
  return [o, u];
}
function nc(t) {
  Lu.call(this, null, ec, t);
}
function ec(t) {
  return this.value && !t.modified() ? this.value : t.values.reduce((t, n) => t.concat(n), []);
}
function rc(t) {
  os.call(this, null, t);
}
function ic(t) {
  ma.call(this, t);
}
function oc(t) {
  _a.call(this, t);
}
function uc(t) {
  os.call(this, null, t);
}
function sc(t) {
  os.call(this, null, t);
}
function ac(t) {
  os.call(this, null, t);
}
function cc(t) {
  os.call(this, null, t);
}
function lc(t) {
  os.call(this, [], t), (this.count = 0);
}
function fc(t) {
  os.call(this, null, t);
}
function hc(t) {
  os.call(this, null, t), this.modified(!0);
}
function dc(t) {
  os.call(this, null, t);
}
(Ha.Definition = {
  type: 'Impute',
  metadata: { changes: !0 },
  params: [
    { name: 'field', type: 'field', required: !0 },
    { name: 'key', type: 'field', required: !0 },
    { name: 'keyvals', array: !0 },
    { name: 'groupby', type: 'field', array: !0 },
    { name: 'method', type: 'enum', default: 'value', values: ['value', 'mean', 'median', 'max', 'min'] },
    { name: 'value', default: 0 },
  ],
}),
  It(Ha, os, {
    transform(t, n) {
      var e,
        r,
        i,
        o,
        u,
        s,
        a,
        c,
        l,
        f,
        h = n.fork(n.ALL),
        d = (function (t) {
          var n,
            e = t.method || Ua.value;
          if (null != Ua[e]) return e === Ua.value ? ((n = void 0 !== t.value ? t.value : 0), () => n) : Ua[e];
          I('Unrecognized imputation method: ' + e);
        })(t),
        p = (function (t) {
          const n = t.field;
          return t => (t ? n(t) : NaN);
        })(t),
        m = T(t.field),
        v = T(t.key),
        g = (t.groupby || []).map(T),
        b = (function (t, n, e, r) {
          var i,
            o,
            u,
            s,
            a,
            c,
            l,
            f,
            h = t => t(f),
            d = [],
            p = r ? r.slice() : [],
            m = {},
            v = {};
          for (p.forEach((t, n) => (m[t] = n + 1)), s = 0, l = t.length; s < l; ++s)
            (c = e((f = t[s]))),
              (a = m[c] || (m[c] = p.push(c))),
              (u = v[(o = (i = n ? n.map(h) : Wa) + '')]) || ((u = v[o] = []), d.push(u), (u.values = i)),
              (u[a - 1] = f);
          return (d.domain = p), d;
        })(n.source, t.groupby, t.key, t.keyvals),
        y = [],
        w = this.value,
        x = b.domain.length;
      for (u = 0, c = b.length; u < c; ++u)
        for (i = (e = b[u]).values, r = NaN, a = 0; a < x; ++a)
          if (null == e[a]) {
            for (o = b.domain[a], f = { _impute: !0 }, s = 0, l = i.length; s < l; ++s) f[g[s]] = i[s];
            (f[v] = o), (f[m] = Number.isNaN(r) ? (r = d(e, p)) : r), y.push(Fu(f));
          }
      return (
        y.length && (h.add = h.materialize(h.ADD).add.concat(y)),
        w.length && (h.rem = h.materialize(h.REM).rem.concat(w)),
        (this.value = y),
        h
      );
    },
  }),
  (Ga.Definition = {
    type: 'JoinAggregate',
    metadata: { modifies: !0 },
    params: [
      { name: 'groupby', type: 'field', array: !0 },
      { name: 'fields', type: 'field', null: !0, array: !0 },
      { name: 'ops', type: 'enum', array: !0, values: oa },
      { name: 'as', type: 'string', null: !0, array: !0 },
      { name: 'key', type: 'field' },
    ],
  }),
  It(Ga, ma, {
    transform(t, n) {
      const e = this,
        r = t.modified();
      let i;
      return (
        e.value && (r || n.modified(e._inputs, !0))
          ? ((i = e.value = r ? e.init(t) : {}), n.visit(n.SOURCE, t => e.add(t)))
          : ((i = e.value = e.value || this.init(t)), n.visit(n.REM, t => e.rem(t)), n.visit(n.ADD, t => e.add(t))),
        e.changes(),
        n.visit(n.SOURCE, t => {
          Bt(t, i[e.cellkey(t)].tuple);
        }),
        n.reflow(r).modifies(this._outputs)
      );
    },
    changes() {
      const t = this._adds,
        n = this._mods;
      let e, r;
      for (e = 0, r = this._alen; e < r; ++e) this.celltuple(t[e]), (t[e] = null);
      for (e = 0, r = this._mlen; e < r; ++e) this.celltuple(n[e]), (n[e] = null);
      this._alen = this._mlen = 0;
    },
  }),
  (Va.Definition = {
    type: 'KDE',
    metadata: { generates: !0 },
    params: [
      { name: 'groupby', type: 'field', array: !0 },
      { name: 'field', type: 'field', required: !0 },
      { name: 'cumulative', type: 'boolean', default: !1 },
      { name: 'counts', type: 'boolean', default: !1 },
      { name: 'bandwidth', type: 'number', default: 0 },
      { name: 'extent', type: 'number', array: !0, length: 2 },
      { name: 'resolve', type: 'enum', values: ['shared', 'independent'], default: 'independent' },
      { name: 'steps', type: 'number' },
      { name: 'minsteps', type: 'number', default: 25 },
      { name: 'maxsteps', type: 'number', default: 200 },
      { name: 'as', type: 'string', array: !0, default: ['value', 'density'] },
    ],
  }),
  It(Va, os, {
    transform(t, n) {
      const e = n.fork(n.NO_SOURCE | n.NO_FIELDS);
      if (!this.value || n.changed() || t.modified()) {
        const r = n.materialize(n.SOURCE).source,
          i = Fa(r, t.groupby, t.field),
          o = (t.groupby || []).map(T),
          u = t.bandwidth,
          s = t.cumulative ? 'cdf' : 'pdf',
          a = t.as || ['value', 'density'],
          c = [];
        let l = t.extent,
          f = t.steps || t.minsteps || 25,
          h = t.steps || t.maxsteps || 200;
        'pdf' !== s && 'cdf' !== s && I('Invalid density method: ' + s),
          'shared' === t.resolve && (l || (l = _t(r, t.field)), (f = h = t.steps || h)),
          i.forEach(n => {
            const e = $s(n, u)[s],
              r = t.counts ? n.length : 1;
            Zs(e, l || _t(n), f, h).forEach(t => {
              const e = {};
              for (let t = 0; t < o.length; ++t) e[o[t]] = n.dims[t];
              (e[a[0]] = t[0]), (e[a[1]] = t[1] * r), c.push(Fu(e));
            });
          }),
          this.value && (e.rem = this.value),
          (this.value = e.add = e.source = c);
      }
      return e;
    },
  }),
  It(Ya, Lu),
  It(Ja, os, {
    transform(t, n) {
      const e = n.dataflow;
      if (this._pending) return Qa(this, n, this._pending);
      if (
        (function (t) {
          return t.modified('async') && !(t.modified('values') || t.modified('url') || t.modified('format'));
        })(t)
      )
        return n.StopPropagation;
      if (t.values) return Qa(this, n, e.parse(t.values, t.format));
      if (t.async) {
        const n = e.request(t.url, t.format).then(t => ((this._pending = At(t.data)), t => t.touch(this)));
        return { async: n };
      }
      return e.request(t.url, t.format).then(t => Qa(this, n, At(t.data)));
    },
  }),
  (Za.Definition = {
    type: 'Lookup',
    metadata: { modifies: !0 },
    params: [
      {
        name: 'index',
        type: 'index',
        params: [
          { name: 'from', type: 'data', required: !0 },
          { name: 'key', type: 'field', required: !0 },
        ],
      },
      { name: 'values', type: 'field', array: !0 },
      { name: 'fields', type: 'field', array: !0, required: !0 },
      { name: 'as', type: 'string', array: !0 },
      { name: 'default', default: null },
    ],
  }),
  It(Za, os, {
    transform(t, n) {
      const e = t.fields,
        r = t.index,
        i = t.values,
        o = null == t.default ? null : t.default,
        u = t.modified(),
        s = e.length;
      let a,
        c,
        l,
        f = u ? n.SOURCE : n.ADD,
        h = n,
        d = t.as;
      return (
        i
          ? ((c = i.length),
            s > 1 && !d && I('Multi-field lookup requires explicit "as" parameter.'),
            d && d.length !== s * c && I('The "as" parameter has too few output field names.'),
            (d = d || i.map(T)),
            (a = function (t) {
              for (var n, u, a = 0, l = 0; a < s; ++a)
                if (null == (u = r.get(e[a](t)))) for (n = 0; n < c; ++n, ++l) t[d[l]] = o;
                else for (n = 0; n < c; ++n, ++l) t[d[l]] = i[n](u);
            }))
          : (d || I('Missing output field names.'),
            (a = function (t) {
              for (var n, i = 0; i < s; ++i) (n = r.get(e[i](t))), (t[d[i]] = null == n ? o : n);
            })),
        u ? (h = n.reflow(!0)) : ((l = e.some(t => n.modified(t.fields))), (f |= l ? n.MOD : 0)),
        n.visit(f, a),
        h.modifies(d)
      );
    },
  }),
  It(Ka, Lu),
  It(nc, Lu),
  It(rc, os, {
    transform(t, n) {
      return this.modified(t.modified()), (this.value = t), n.fork(n.NO_SOURCE | n.NO_FIELDS);
    },
  }),
  (ic.Definition = {
    type: 'Pivot',
    metadata: { generates: !0, changes: !0 },
    params: [
      { name: 'groupby', type: 'field', array: !0 },
      { name: 'field', type: 'field', required: !0 },
      { name: 'value', type: 'field', required: !0 },
      { name: 'op', type: 'enum', values: oa, default: 'sum' },
      { name: 'limit', type: 'number', default: 0 },
      { name: 'key', type: 'field' },
    ],
  }),
  It(ic, ma, {
    _transform: ma.prototype.transform,
    transform(t, n) {
      return this._transform(
        (function (t, n) {
          const e = t.field,
            r = t.value,
            i = ('count' === t.op ? '__count__' : t.op) || 'sum',
            o = P(e).concat(P(r)),
            u = (function (t, n, e) {
              const r = {},
                i = [];
              return (
                e.visit(e.SOURCE, n => {
                  const e = t(n);
                  r[e] || ((r[e] = 1), i.push(e));
                }),
                i.sort(Dt),
                n ? i.slice(0, n) : i
              );
            })(e, t.limit || 0, n);
          return (
            n.changed() && t.set('__pivot__', null, null, !0),
            {
              key: t.key,
              groupby: t.groupby,
              ops: u.map(() => i),
              fields: u.map(t =>
                (function (t, n, e, r) {
                  return z(r => (n(r) === t ? e(r) : NaN), r, t + '');
                })(t, e, r, o),
              ),
              as: u.map(t => t + ''),
              modified: t.modified.bind(t),
            }
          );
        })(t, n),
        n,
      );
    },
  }),
  It(oc, _a, {
    transform(t, n) {
      const e = t.subflow,
        r = t.field,
        i = t => this.subflow(ju(t), e, n, t);
      return (
        (t.modified('field') || (r && n.modified(P(r)))) && I('PreFacet does not support field modification.'),
        this.initTargets(),
        r
          ? (n.visit(n.MOD, t => {
              const n = i(t);
              r(t).forEach(t => n.mod(t));
            }),
            n.visit(n.ADD, t => {
              const n = i(t);
              r(t).forEach(t => n.add(Fu(t)));
            }),
            n.visit(n.REM, t => {
              const n = i(t);
              r(t).forEach(t => n.rem(t));
            }))
          : (n.visit(n.MOD, t => i(t).mod(t)), n.visit(n.ADD, t => i(t).add(t)), n.visit(n.REM, t => i(t).rem(t))),
        n.clean() && n.runAfter(() => this.clean()),
        n
      );
    },
  }),
  (uc.Definition = {
    type: 'Project',
    metadata: { generates: !0, changes: !0 },
    params: [
      { name: 'fields', type: 'field', array: !0 },
      { name: 'as', type: 'string', null: !0, array: !0 },
    ],
  }),
  It(uc, os, {
    transform(t, n) {
      const e = n.fork(n.NO_SOURCE),
        r = t.fields,
        i = Da(t.fields, t.as || []),
        o = r
          ? (t, n) =>
              (function (t, n, e, r) {
                for (let i = 0, o = e.length; i < o; ++i) n[r[i]] = e[i](t);
                return n;
              })(t, n, r, i)
          : Su;
      let u;
      return (
        this.value ? (u = this.value) : ((n = n.addAll()), (u = this.value = {})),
        n.visit(n.REM, t => {
          const n = ju(t);
          e.rem.push(u[n]), (u[n] = null);
        }),
        n.visit(n.ADD, t => {
          const n = o(t, Fu({}));
          (u[ju(t)] = n), e.add.push(n);
        }),
        n.visit(n.MOD, t => {
          e.mod.push(o(t, u[ju(t)]));
        }),
        e
      );
    },
  }),
  It(sc, os, {
    transform(t, n) {
      return (this.value = t.value), t.modified('value') ? n.fork(n.NO_SOURCE | n.NO_FIELDS) : n.StopPropagation;
    },
  }),
  (ac.Definition = {
    type: 'Quantile',
    metadata: { generates: !0, changes: !0 },
    params: [
      { name: 'groupby', type: 'field', array: !0 },
      { name: 'field', type: 'field', required: !0 },
      { name: 'probs', type: 'number', array: !0 },
      { name: 'step', type: 'number', default: 0.01 },
      { name: 'as', type: 'string', array: !0, default: ['prob', 'value'] },
    ],
  }),
  It(ac, os, {
    transform(t, n) {
      const e = n.fork(n.NO_SOURCE | n.NO_FIELDS),
        r = t.as || ['prob', 'value'];
      if (this.value && !t.modified() && !n.changed()) return (e.source = this.value), e;
      const i = Fa(n.materialize(n.SOURCE).source, t.groupby, t.field),
        o = (t.groupby || []).map(T),
        u = [],
        s = t.step || 0.01,
        a = t.probs || re(s / 2, 1 - 1e-14, s),
        c = a.length;
      return (
        i.forEach(t => {
          const n = ls(t, a);
          for (let e = 0; e < c; ++e) {
            const i = {};
            for (let n = 0; n < o.length; ++n) i[o[n]] = t.dims[n];
            (i[r[0]] = a[e]), (i[r[1]] = n[e]), u.push(Fu(i));
          }
        }),
        this.value && (e.rem = this.value),
        (this.value = e.add = e.source = u),
        e
      );
    },
  }),
  It(cc, os, {
    transform(t, n) {
      let e, r;
      return (
        this.value ? (r = this.value) : ((e = n = n.addAll()), (r = this.value = {})),
        t.derive &&
          ((e = n.fork(n.NO_SOURCE)),
          n.visit(n.REM, t => {
            const n = ju(t);
            e.rem.push(r[n]), (r[n] = null);
          }),
          n.visit(n.ADD, t => {
            const n = Eu(t);
            (r[ju(t)] = n), e.add.push(n);
          }),
          n.visit(n.MOD, t => {
            const n = r[ju(t)];
            for (const r in t) (n[r] = t[r]), e.modifies(r);
            e.mod.push(n);
          })),
        e
      );
    },
  }),
  (lc.Definition = { type: 'Sample', metadata: {}, params: [{ name: 'size', type: 'number', default: 1e3 }] }),
  It(lc, os, {
    transform(t, n) {
      const e = n.fork(n.NO_SOURCE),
        r = t.modified('size'),
        i = t.size,
        o = this.value.reduce((t, n) => ((t[ju(n)] = 1), t), {});
      let u = this.value,
        s = this.count,
        a = 0;
      function c(t) {
        let n, r;
        u.length < i
          ? u.push(t)
          : ((r = ~~((s + 1) * ps())), r < u.length && r >= a && ((n = u[r]), o[ju(n)] && e.rem.push(n), (u[r] = t))),
          ++s;
      }
      if (
        (n.rem.length &&
          (n.visit(n.REM, t => {
            const n = ju(t);
            o[n] && ((o[n] = -1), e.rem.push(t)), --s;
          }),
          (u = u.filter(t => -1 !== o[ju(t)]))),
        (n.rem.length || r) &&
          u.length < i &&
          n.source &&
          ((a = s = u.length),
          n.visit(n.SOURCE, t => {
            o[ju(t)] || c(t);
          }),
          (a = -1)),
        r && u.length > i)
      ) {
        const t = u.length - i;
        for (let n = 0; n < t; ++n) (o[ju(u[n])] = -1), e.rem.push(u[n]);
        u = u.slice(t);
      }
      return (
        n.mod.length &&
          n.visit(n.MOD, t => {
            o[ju(t)] && e.mod.push(t);
          }),
        n.add.length && n.visit(n.ADD, c),
        (n.add.length || a < 0) && (e.add = u.filter(t => !o[ju(t)])),
        (this.count = s),
        (this.value = e.source = u),
        e
      );
    },
  }),
  (fc.Definition = {
    type: 'Sequence',
    metadata: { generates: !0, changes: !0 },
    params: [
      { name: 'start', type: 'number', required: !0 },
      { name: 'stop', type: 'number', required: !0 },
      { name: 'step', type: 'number', default: 1 },
      { name: 'as', type: 'string', default: 'data' },
    ],
  }),
  It(fc, os, {
    transform(t, n) {
      if (this.value && !t.modified()) return;
      const e = n.materialize().fork(n.MOD),
        r = t.as || 'data';
      return (
        (e.rem = this.value ? n.rem.concat(this.value) : n.rem),
        (this.value = re(t.start, t.stop, t.step || 1).map(t => {
          const n = {};
          return (n[r] = t), Fu(n);
        })),
        (e.add = n.add.concat(this.value)),
        e
      );
    },
  }),
  It(hc, os, {
    transform(t, n) {
      return (this.value = n.source), n.changed() ? n.fork(n.NO_SOURCE | n.NO_FIELDS) : n.StopPropagation;
    },
  });
const pc = ['unit0', 'unit1'];
function mc(t) {
  os.call(this, Lt(), t);
}
function vc(t) {
  os.call(this, null, t);
}
(dc.Definition = {
  type: 'TimeUnit',
  metadata: { modifies: !0 },
  params: [
    { name: 'field', type: 'field', required: !0 },
    { name: 'interval', type: 'boolean', default: !0 },
    { name: 'units', type: 'enum', values: mr, array: !0 },
    { name: 'step', type: 'number', default: 1 },
    { name: 'maxbins', type: 'number', default: 40 },
    { name: 'extent', type: 'date', array: !0 },
    { name: 'timezone', type: 'enum', default: 'local', values: ['local', 'utc'] },
    { name: 'as', type: 'string', array: !0, length: 2, default: pc },
  ],
}),
  It(dc, os, {
    transform(t, n) {
      const e = t.field,
        r = !1 !== t.interval,
        i = 'utc' === t.timezone,
        o = this._floor(t, n),
        u = (i ? Hr : Wr)(o.unit).offset,
        s = t.as || pc,
        a = s[0],
        c = s[1],
        l = o.step;
      let f = o.start || 1 / 0,
        h = o.stop || -1 / 0,
        d = n.ADD;
      return (
        (t.modified() || n.changed(n.REM) || n.modified(P(e))) &&
          ((d = (n = n.reflow(!0)).SOURCE), (f = 1 / 0), (h = -1 / 0)),
        n.visit(d, t => {
          const n = e(t);
          let i, s;
          null == n
            ? ((t[a] = null), r && (t[c] = null))
            : ((t[a] = i = s = o(n)), r && (t[c] = s = u(i, l)), i < f && (f = i), s > h && (h = s));
        }),
        (o.start = f),
        (o.stop = h),
        n.modifies(r ? s : a)
      );
    },
    _floor(t, n) {
      const e = 'utc' === t.timezone,
        { units: r, step: i } = t.units
          ? { units: t.units, step: t.step || 1 }
          : si({ extent: t.extent || _t(n.materialize(n.SOURCE).source, t.field), maxbins: t.maxbins }),
        o = gr(r),
        u = this.value || {},
        s = (e ? qr : Pr)(o, i);
      return (s.unit = ot(o)), (s.units = o), (s.step = i), (s.start = u.start), (s.stop = u.stop), (this.value = s);
    },
  }),
  It(mc, os, {
    transform(t, n) {
      const e = n.dataflow,
        r = t.field,
        i = this.value,
        o = t => i.set(r(t), t);
      let u = !0;
      return (
        t.modified('field') || n.modified(r.fields)
          ? (i.clear(), n.visit(n.SOURCE, o))
          : n.changed()
          ? (n.visit(n.REM, t => i.delete(r(t))), n.visit(n.ADD, o))
          : (u = !1),
        this.modified(u),
        i.empty > e.cleanThreshold && e.runAfter(i.clean),
        n.fork()
      );
    },
  }),
  It(vc, os, {
    transform(t, n) {
      (!this.value ||
        t.modified('field') ||
        t.modified('sort') ||
        n.changed() ||
        (t.sort && n.modified(t.sort.fields))) &&
        (this.value = (t.sort ? n.source.slice().sort(Nu(t.sort)) : n.source).map(t.field));
    },
  });
const gc = {
    row_number: function () {
      return { next: t => t.index + 1 };
    },
    rank: function () {
      let t;
      return {
        init: () => (t = 1),
        next: n => {
          const e = n.index,
            r = n.data;
          return e && n.compare(r[e - 1], r[e]) ? (t = e + 1) : t;
        },
      };
    },
    dense_rank: function () {
      let t;
      return {
        init: () => (t = 1),
        next: n => {
          const e = n.index,
            r = n.data;
          return e && n.compare(r[e - 1], r[e]) ? ++t : t;
        },
      };
    },
    percent_rank: function () {
      const t = gc.rank(),
        n = t.next;
      return { init: t.init, next: t => (n(t) - 1) / (t.data.length - 1) };
    },
    cume_dist: function () {
      let t;
      return {
        init: () => (t = 0),
        next: n => {
          const e = n.data,
            r = n.compare;
          let i = n.index;
          if (t < i) {
            for (; i + 1 < e.length && !r(e[i], e[i + 1]); ) ++i;
            t = i;
          }
          return (1 + t) / e.length;
        },
      };
    },
    ntile: function (t, n) {
      (n = +n) > 0 || I('ntile num must be greater than zero.');
      const e = gc.cume_dist(),
        r = e.next;
      return { init: e.init, next: t => Math.ceil(n * r(t)) };
    },
    lag: function (t, n) {
      return (
        (n = +n || 1),
        {
          next: e => {
            const r = e.index - n;
            return r >= 0 ? t(e.data[r]) : null;
          },
        }
      );
    },
    lead: function (t, n) {
      return (
        (n = +n || 1),
        {
          next: e => {
            const r = e.index + n,
              i = e.data;
            return r < i.length ? t(i[r]) : null;
          },
        }
      );
    },
    first_value: function (t) {
      return { next: n => t(n.data[n.i0]) };
    },
    last_value: function (t) {
      return { next: n => t(n.data[n.i1 - 1]) };
    },
    nth_value: function (t, n) {
      return (
        (n = +n) > 0 || I('nth_value nth must be greater than zero.'),
        {
          next: e => {
            const r = e.i0 + (n - 1);
            return r < e.i1 ? t(e.data[r]) : null;
          },
        }
      );
    },
    prev_value: function (t) {
      let n;
      return {
        init: () => (n = null),
        next: e => {
          const r = t(e.data[e.index]);
          return null != r ? (n = r) : n;
        },
      };
    },
    next_value: function (t) {
      let n, e;
      return {
        init: () => ((n = null), (e = -1)),
        next: r => {
          const i = r.data;
          return r.index <= e
            ? n
            : (e = (function (t, n, e) {
                for (let r = n.length; e < r; ++e) if (null != t(n[e])) return e;
                return -1;
              })(t, i, r.index)) < 0
            ? ((e = i.length), (n = null))
            : (n = t(i[e]));
        },
      };
    },
  },
  bc = Object.keys(gc);
function yc(t) {
  const n = At(t.ops),
    e = At(t.fields),
    r = At(t.params),
    i = At(t.as),
    o = (this.outputs = []),
    u = (this.windows = []),
    s = {},
    a = {},
    c = [],
    l = [];
  let f = !0;
  function h(t) {
    At(P(t)).forEach(t => (s[t] = 1));
  }
  h(t.sort),
    n.forEach((t, n) => {
      const s = e[n],
        d = T(s),
        p = na(t, d, i[n]);
      if ((h(s), o.push(p), Pt(gc, t)))
        u.push(
          (function (t, n, e, r) {
            const i = gc[t](n, e);
            return {
              init: i.init || V,
              update: function (t, n) {
                n[r] = i.next(t);
              },
            };
          })(t, e[n], r[n], p),
        );
      else {
        if ((null == s && 'count' !== t && I('Null aggregate field specified.'), 'count' === t)) return void c.push(p);
        f = !1;
        let n = a[d];
        n || ((n = a[d] = []), (n.field = s), l.push(n)), n.push(ua(t, p));
      }
    }),
    (c.length || l.length) &&
      (this.cell = (function (t, n, e) {
        t = t.map(t => ha(t, t.field));
        const r = { num: 0, agg: null, store: !1, count: n };
        if (!e) for (var i = t.length, o = (r.agg = Array(i)), u = 0; u < i; ++u) o[u] = new t[u](r);
        if (r.store) var s = (r.data = new da());
        return (
          (r.add = function (t) {
            if (((r.num += 1), !e)) {
              s && s.add(t);
              for (let n = 0; n < i; ++n) o[n].add(o[n].get(t), t);
            }
          }),
          (r.rem = function (t) {
            if (((r.num -= 1), !e)) {
              s && s.rem(t);
              for (let n = 0; n < i; ++n) o[n].rem(o[n].get(t), t);
            }
          }),
          (r.set = function (t) {
            let i, u;
            for (s && s.values(), i = 0, u = n.length; i < u; ++i) t[n[i]] = r.num;
            if (!e) for (i = 0, u = o.length; i < u; ++i) o[i].set(t);
          }),
          (r.init = function () {
            (r.num = 0), s && s.reset();
            for (let t = 0; t < i; ++t) o[t].init();
          }),
          r
        );
      })(l, c, f)),
    (this.inputs = Object.keys(s));
}
const wc = yc.prototype;
function xc(t) {
  os.call(this, {}, t), (this._mlen = 0), (this._mods = []);
}
function Oc(t, n, e, r) {
  const i = r.sort,
    o = i && !r.ignorePeers,
    u = r.frame || [null, 0],
    s = t.data(e),
    a = s.length,
    c = o ? Dn(i) : null,
    l = { i0: 0, i1: 0, p0: 0, p1: 0, index: 0, data: s, compare: i || Ct(-1) };
  n.init();
  for (let t = 0; t < a; ++t) kc(l, u, t, a), o && Ac(l, c), n.update(l, s[t]);
}
function kc(t, n, e, r) {
  (t.p0 = t.i0),
    (t.p1 = t.i1),
    (t.i0 = null == n[0] ? 0 : Math.max(0, e - Math.abs(n[0]))),
    (t.i1 = null == n[1] ? r : Math.min(r, e + Math.abs(n[1]) + 1)),
    (t.index = e);
}
function Ac(t, n) {
  const e = t.i0,
    r = t.i1 - 1,
    i = t.compare,
    o = t.data,
    u = o.length - 1;
  e > 0 && !i(o[e], o[e - 1]) && (t.i0 = n.left(o, o[e])), r < u && !i(o[r], o[r + 1]) && (t.i1 = n.right(o, o[r]));
}
(wc.init = function () {
  this.windows.forEach(t => t.init()), this.cell && this.cell.init();
}),
  (wc.update = function (t, n) {
    const e = this.cell,
      r = this.windows,
      i = t.data,
      o = r && r.length;
    let u;
    if (e) {
      for (u = t.p0; u < t.i0; ++u) e.rem(i[u]);
      for (u = t.p1; u < t.i1; ++u) e.add(i[u]);
      e.set(n);
    }
    for (u = 0; u < o; ++u) r[u].update(t, n);
  }),
  (xc.Definition = {
    type: 'Window',
    metadata: { modifies: !0 },
    params: [
      { name: 'sort', type: 'compare' },
      { name: 'groupby', type: 'field', array: !0 },
      { name: 'ops', type: 'enum', array: !0, values: bc.concat(oa) },
      { name: 'params', type: 'number', null: !0, array: !0 },
      { name: 'fields', type: 'field', null: !0, array: !0 },
      { name: 'as', type: 'string', null: !0, array: !0 },
      { name: 'frame', type: 'number', null: !0, array: !0, length: 2, default: [null, 0] },
      { name: 'ignorePeers', type: 'boolean', default: !1 },
    ],
  }),
  It(xc, os, {
    transform(t, n) {
      this.stamp = n.stamp;
      const e = t.modified(),
        r = Nu(t.sort),
        i = ta(t.groupby),
        o = t => this.group(i(t));
      let u = this.state;
      (u && !e) || (u = this.state = new yc(t)),
        e || n.modified(u.inputs)
          ? ((this.value = {}), n.visit(n.SOURCE, t => o(t).add(t)))
          : (n.visit(n.REM, t => o(t).remove(t)), n.visit(n.ADD, t => o(t).add(t)));
      for (let n = 0, e = this._mlen; n < e; ++n) Oc(this._mods[n], u, r, t);
      return (this._mlen = 0), (this._mods = []), n.reflow(e).modifies(u.outputs);
    },
    group(t) {
      let n = this.value[t];
      return (
        n || ((n = this.value[t] = ga(ju)), (n.stamp = -1)),
        n.stamp < this.stamp && ((n.stamp = this.stamp), (this._mods[this._mlen++] = n)),
        n
      );
    },
  });
const $c = Object.freeze({
  __proto__: null,
  aggregate: ma,
  bin: va,
  collect: ba,
  compare: ya,
  countpattern: xa,
  cross: Oa,
  density: Ma,
  dotbin: Ea,
  expression: Sa,
  extent: Na,
  facet: _a,
  field: za,
  filter: Pa,
  flatten: Ra,
  fold: La,
  formula: qa,
  generate: Ia,
  impute: Ha,
  joinaggregate: Ga,
  kde: Va,
  key: Ya,
  load: Ja,
  lookup: Za,
  multiextent: Ka,
  multivalues: nc,
  params: rc,
  pivot: ic,
  prefacet: oc,
  project: uc,
  proxy: sc,
  quantile: ac,
  relay: cc,
  sample: lc,
  sequence: fc,
  sieve: hc,
  subflow: Ba,
  timeunit: dc,
  tupleindex: mc,
  values: vc,
  window: xc,
});
function Mc(t) {
  return function () {
    return t;
  };
}
const jc = Math.abs,
  Dc = Math.atan2,
  Fc = Math.cos,
  Ec = Math.max,
  Sc = Math.min,
  Cc = Math.sin,
  Nc = Math.sqrt,
  Bc = 1e-12,
  _c = Math.PI,
  zc = _c / 2,
  Tc = 2 * _c;
function Pc(t) {
  return t > 1 ? 0 : t < -1 ? _c : Math.acos(t);
}
function Rc(t) {
  return t >= 1 ? zc : t <= -1 ? -zc : Math.asin(t);
}
const Lc = Math.PI,
  qc = 2 * Lc,
  Ic = 1e-6,
  Uc = qc - Ic;
function Wc(t) {
  this._ += t[0];
  for (let n = 1, e = t.length; n < e; ++n) this._ += arguments[n] + t[n];
}
class Hc {
  constructor(t) {
    (this._x0 = this._y0 = this._x1 = this._y1 = null),
      (this._ = ''),
      (this._append =
        null == t
          ? Wc
          : (function (t) {
              let n = Math.floor(t);
              if (!(n >= 0)) throw new Error(`invalid digits: ${t}`);
              if (n > 15) return Wc;
              const e = 10 ** n;
              return function (t) {
                this._ += t[0];
                for (let n = 1, r = t.length; n < r; ++n) this._ += Math.round(arguments[n] * e) / e + t[n];
              };
            })(t));
  }
  moveTo(t, n) {
    this._append`M${(this._x0 = this._x1 = +t)},${(this._y0 = this._y1 = +n)}`;
  }
  closePath() {
    null !== this._x1 && ((this._x1 = this._x0), (this._y1 = this._y0), this._append`Z`);
  }
  lineTo(t, n) {
    this._append`L${(this._x1 = +t)},${(this._y1 = +n)}`;
  }
  quadraticCurveTo(t, n, e, r) {
    this._append`Q${+t},${+n},${(this._x1 = +e)},${(this._y1 = +r)}`;
  }
  bezierCurveTo(t, n, e, r, i, o) {
    this._append`C${+t},${+n},${+e},${+r},${(this._x1 = +i)},${(this._y1 = +o)}`;
  }
  arcTo(t, n, e, r, i) {
    if (((t = +t), (n = +n), (e = +e), (r = +r), (i = +i) < 0)) throw new Error(`negative radius: ${i}`);
    let o = this._x1,
      u = this._y1,
      s = e - t,
      a = r - n,
      c = o - t,
      l = u - n,
      f = c * c + l * l;
    if (null === this._x1) this._append`M${(this._x1 = t)},${(this._y1 = n)}`;
    else if (f > Ic)
      if (Math.abs(l * s - a * c) > Ic && i) {
        let h = e - o,
          d = r - u,
          p = s * s + a * a,
          m = h * h + d * d,
          v = Math.sqrt(p),
          g = Math.sqrt(f),
          b = i * Math.tan((Lc - Math.acos((p + f - m) / (2 * v * g))) / 2),
          y = b / g,
          w = b / v;
        Math.abs(y - 1) > Ic && this._append`L${t + y * c},${n + y * l}`,
          this._append`A${i},${i},0,0,${+(l * h > c * d)},${(this._x1 = t + w * s)},${(this._y1 = n + w * a)}`;
      } else this._append`L${(this._x1 = t)},${(this._y1 = n)}`;
  }
  arc(t, n, e, r, i, o) {
    if (((t = +t), (n = +n), (o = !!o), (e = +e) < 0)) throw new Error(`negative radius: ${e}`);
    let u = e * Math.cos(r),
      s = e * Math.sin(r),
      a = t + u,
      c = n + s,
      l = 1 ^ o,
      f = o ? r - i : i - r;
    null === this._x1
      ? this._append`M${a},${c}`
      : (Math.abs(this._x1 - a) > Ic || Math.abs(this._y1 - c) > Ic) && this._append`L${a},${c}`,
      e &&
        (f < 0 && (f = (f % qc) + qc),
        f > Uc
          ? this._append`A${e},${e},0,1,${l},${t - u},${n - s}A${e},${e},0,1,${l},${(this._x1 = a)},${(this._y1 = c)}`
          : f > Ic &&
            this._append`A${e},${e},0,${+(f >= Lc)},${l},${(this._x1 = t + e * Math.cos(i))},${(this._y1 =
              n + e * Math.sin(i))}`);
  }
  rect(t, n, e, r) {
    this._append`M${(this._x0 = this._x1 = +t)},${(this._y0 = this._y1 = +n)}h${(e = +e)}v${+r}h${-e}Z`;
  }
  toString() {
    return this._;
  }
}
function Gc() {
  return new Hc();
}
function Vc(t) {
  let n = 3;
  return (
    (t.digits = function (e) {
      if (!arguments.length) return n;
      if (null == e) n = null;
      else {
        const t = Math.floor(e);
        if (!(t >= 0)) throw new RangeError(`invalid digits: ${e}`);
        n = t;
      }
      return t;
    }),
    () => new Hc(n)
  );
}
function Yc(t) {
  return t.innerRadius;
}
function Xc(t) {
  return t.outerRadius;
}
function Jc(t) {
  return t.startAngle;
}
function Qc(t) {
  return t.endAngle;
}
function Zc(t) {
  return t && t.padAngle;
}
function Kc(t, n, e, r, i, o, u, s) {
  var a = e - t,
    c = r - n,
    l = u - i,
    f = s - o,
    h = f * a - l * c;
  if (!(h * h < Bc)) return [t + (h = (l * (n - o) - f * (t - i)) / h) * a, n + h * c];
}
function tl(t, n, e, r, i, o, u) {
  var s = t - e,
    a = n - r,
    c = (u ? o : -o) / Nc(s * s + a * a),
    l = c * a,
    f = -c * s,
    h = t + l,
    d = n + f,
    p = e + l,
    m = r + f,
    v = (h + p) / 2,
    g = (d + m) / 2,
    b = p - h,
    y = m - d,
    w = b * b + y * y,
    x = i - o,
    O = h * m - p * d,
    k = (y < 0 ? -1 : 1) * Nc(Ec(0, x * x * w - O * O)),
    A = (O * y - b * k) / w,
    $ = (-O * b - y * k) / w,
    M = (O * y + b * k) / w,
    j = (-O * b + y * k) / w,
    D = A - v,
    F = $ - g,
    E = M - v,
    S = j - g;
  return (
    D * D + F * F > E * E + S * S && ((A = M), ($ = j)),
    { cx: A, cy: $, x01: -l, y01: -f, x11: A * (i / x - 1), y11: $ * (i / x - 1) }
  );
}
function nl(t) {
  return 'object' == typeof t && 'length' in t ? t : Array.from(t);
}
function el(t) {
  this._context = t;
}
function rl(t) {
  return new el(t);
}
function il(t) {
  return t[0];
}
function ol(t) {
  return t[1];
}
function ul(t, n) {
  var e = Mc(!0),
    r = null,
    i = rl,
    o = null,
    u = Vc(s);
  function s(s) {
    var a,
      c,
      l,
      f = (s = nl(s)).length,
      h = !1;
    for (null == r && (o = i((l = u()))), a = 0; a <= f; ++a)
      !(a < f && e((c = s[a]), a, s)) === h && ((h = !h) ? o.lineStart() : o.lineEnd()),
        h && o.point(+t(c, a, s), +n(c, a, s));
    if (l) return (o = null), l + '' || null;
  }
  return (
    (t = 'function' == typeof t ? t : void 0 === t ? il : Mc(t)),
    (n = 'function' == typeof n ? n : void 0 === n ? ol : Mc(n)),
    (s.x = function (n) {
      return arguments.length ? ((t = 'function' == typeof n ? n : Mc(+n)), s) : t;
    }),
    (s.y = function (t) {
      return arguments.length ? ((n = 'function' == typeof t ? t : Mc(+t)), s) : n;
    }),
    (s.defined = function (t) {
      return arguments.length ? ((e = 'function' == typeof t ? t : Mc(!!t)), s) : e;
    }),
    (s.curve = function (t) {
      return arguments.length ? ((i = t), null != r && (o = i(r)), s) : i;
    }),
    (s.context = function (t) {
      return arguments.length ? (null == t ? (r = o = null) : (o = i((r = t))), s) : r;
    }),
    s
  );
}
function sl(t, n, e) {
  var r = null,
    i = Mc(!0),
    o = null,
    u = rl,
    s = null,
    a = Vc(c);
  function c(c) {
    var l,
      f,
      h,
      d,
      p,
      m = (c = nl(c)).length,
      v = !1,
      g = new Array(m),
      b = new Array(m);
    for (null == o && (s = u((p = a()))), l = 0; l <= m; ++l) {
      if (!(l < m && i((d = c[l]), l, c)) === v)
        if ((v = !v)) (f = l), s.areaStart(), s.lineStart();
        else {
          for (s.lineEnd(), s.lineStart(), h = l - 1; h >= f; --h) s.point(g[h], b[h]);
          s.lineEnd(), s.areaEnd();
        }
      v && ((g[l] = +t(d, l, c)), (b[l] = +n(d, l, c)), s.point(r ? +r(d, l, c) : g[l], e ? +e(d, l, c) : b[l]));
    }
    if (p) return (s = null), p + '' || null;
  }
  function l() {
    return ul().defined(i).curve(u).context(o);
  }
  return (
    (t = 'function' == typeof t ? t : void 0 === t ? il : Mc(+t)),
    (n = 'function' == typeof n ? n : Mc(void 0 === n ? 0 : +n)),
    (e = 'function' == typeof e ? e : void 0 === e ? ol : Mc(+e)),
    (c.x = function (n) {
      return arguments.length ? ((t = 'function' == typeof n ? n : Mc(+n)), (r = null), c) : t;
    }),
    (c.x0 = function (n) {
      return arguments.length ? ((t = 'function' == typeof n ? n : Mc(+n)), c) : t;
    }),
    (c.x1 = function (t) {
      return arguments.length ? ((r = null == t ? null : 'function' == typeof t ? t : Mc(+t)), c) : r;
    }),
    (c.y = function (t) {
      return arguments.length ? ((n = 'function' == typeof t ? t : Mc(+t)), (e = null), c) : n;
    }),
    (c.y0 = function (t) {
      return arguments.length ? ((n = 'function' == typeof t ? t : Mc(+t)), c) : n;
    }),
    (c.y1 = function (t) {
      return arguments.length ? ((e = null == t ? null : 'function' == typeof t ? t : Mc(+t)), c) : e;
    }),
    (c.lineX0 = c.lineY0 =
      function () {
        return l().x(t).y(n);
      }),
    (c.lineY1 = function () {
      return l().x(t).y(e);
    }),
    (c.lineX1 = function () {
      return l().x(r).y(n);
    }),
    (c.defined = function (t) {
      return arguments.length ? ((i = 'function' == typeof t ? t : Mc(!!t)), c) : i;
    }),
    (c.curve = function (t) {
      return arguments.length ? ((u = t), null != o && (s = u(o)), c) : u;
    }),
    (c.context = function (t) {
      return arguments.length ? (null == t ? (o = s = null) : (s = u((o = t))), c) : o;
    }),
    c
  );
}
(Gc.prototype = Hc.prototype),
  (el.prototype = {
    areaStart: function () {
      this._line = 0;
    },
    areaEnd: function () {
      this._line = NaN;
    },
    lineStart: function () {
      this._point = 0;
    },
    lineEnd: function () {
      (this._line || (0 !== this._line && 1 === this._point)) && this._context.closePath(),
        (this._line = 1 - this._line);
    },
    point: function (t, n) {
      switch (((t = +t), (n = +n), this._point)) {
        case 0:
          (this._point = 1), this._line ? this._context.lineTo(t, n) : this._context.moveTo(t, n);
          break;
        case 1:
          this._point = 2;
        default:
          this._context.lineTo(t, n);
      }
    },
  });
const al = {
  draw(t, n) {
    const e = Nc(n / _c);
    t.moveTo(e, 0), t.arc(0, 0, e, 0, Tc);
  },
};
function cl() {}
function ll(t, n, e) {
  t._context.bezierCurveTo(
    (2 * t._x0 + t._x1) / 3,
    (2 * t._y0 + t._y1) / 3,
    (t._x0 + 2 * t._x1) / 3,
    (t._y0 + 2 * t._y1) / 3,
    (t._x0 + 4 * t._x1 + n) / 6,
    (t._y0 + 4 * t._y1 + e) / 6,
  );
}
function fl(t) {
  this._context = t;
}
function hl(t) {
  this._context = t;
}
function dl(t) {
  this._context = t;
}
function pl(t, n) {
  (this._basis = new fl(t)), (this._beta = n);
}
(fl.prototype = {
  areaStart: function () {
    this._line = 0;
  },
  areaEnd: function () {
    this._line = NaN;
  },
  lineStart: function () {
    (this._x0 = this._x1 = this._y0 = this._y1 = NaN), (this._point = 0);
  },
  lineEnd: function () {
    switch (this._point) {
      case 3:
        ll(this, this._x1, this._y1);
      case 2:
        this._context.lineTo(this._x1, this._y1);
    }
    (this._line || (0 !== this._line && 1 === this._point)) && this._context.closePath(), (this._line = 1 - this._line);
  },
  point: function (t, n) {
    switch (((t = +t), (n = +n), this._point)) {
      case 0:
        (this._point = 1), this._line ? this._context.lineTo(t, n) : this._context.moveTo(t, n);
        break;
      case 1:
        this._point = 2;
        break;
      case 2:
        (this._point = 3), this._context.lineTo((5 * this._x0 + this._x1) / 6, (5 * this._y0 + this._y1) / 6);
      default:
        ll(this, t, n);
    }
    (this._x0 = this._x1), (this._x1 = t), (this._y0 = this._y1), (this._y1 = n);
  },
}),
  (hl.prototype = {
    areaStart: cl,
    areaEnd: cl,
    lineStart: function () {
      (this._x0 =
        this._x1 =
        this._x2 =
        this._x3 =
        this._x4 =
        this._y0 =
        this._y1 =
        this._y2 =
        this._y3 =
        this._y4 =
          NaN),
        (this._point = 0);
    },
    lineEnd: function () {
      switch (this._point) {
        case 1:
          this._context.moveTo(this._x2, this._y2), this._context.closePath();
          break;
        case 2:
          this._context.moveTo((this._x2 + 2 * this._x3) / 3, (this._y2 + 2 * this._y3) / 3),
            this._context.lineTo((this._x3 + 2 * this._x2) / 3, (this._y3 + 2 * this._y2) / 3),
            this._context.closePath();
          break;
        case 3:
          this.point(this._x2, this._y2), this.point(this._x3, this._y3), this.point(this._x4, this._y4);
      }
    },
    point: function (t, n) {
      switch (((t = +t), (n = +n), this._point)) {
        case 0:
          (this._point = 1), (this._x2 = t), (this._y2 = n);
          break;
        case 1:
          (this._point = 2), (this._x3 = t), (this._y3 = n);
          break;
        case 2:
          (this._point = 3),
            (this._x4 = t),
            (this._y4 = n),
            this._context.moveTo((this._x0 + 4 * this._x1 + t) / 6, (this._y0 + 4 * this._y1 + n) / 6);
          break;
        default:
          ll(this, t, n);
      }
      (this._x0 = this._x1), (this._x1 = t), (this._y0 = this._y1), (this._y1 = n);
    },
  }),
  (dl.prototype = {
    areaStart: function () {
      this._line = 0;
    },
    areaEnd: function () {
      this._line = NaN;
    },
    lineStart: function () {
      (this._x0 = this._x1 = this._y0 = this._y1 = NaN), (this._point = 0);
    },
    lineEnd: function () {
      (this._line || (0 !== this._line && 3 === this._point)) && this._context.closePath(),
        (this._line = 1 - this._line);
    },
    point: function (t, n) {
      switch (((t = +t), (n = +n), this._point)) {
        case 0:
          this._point = 1;
          break;
        case 1:
          this._point = 2;
          break;
        case 2:
          this._point = 3;
          var e = (this._x0 + 4 * this._x1 + t) / 6,
            r = (this._y0 + 4 * this._y1 + n) / 6;
          this._line ? this._context.lineTo(e, r) : this._context.moveTo(e, r);
          break;
        case 3:
          this._point = 4;
        default:
          ll(this, t, n);
      }
      (this._x0 = this._x1), (this._x1 = t), (this._y0 = this._y1), (this._y1 = n);
    },
  }),
  (pl.prototype = {
    lineStart: function () {
      (this._x = []), (this._y = []), this._basis.lineStart();
    },
    lineEnd: function () {
      var t = this._x,
        n = this._y,
        e = t.length - 1;
      if (e > 0)
        for (var r, i = t[0], o = n[0], u = t[e] - i, s = n[e] - o, a = -1; ++a <= e; )
          this._basis.point(
            this._beta * t[a] + (1 - this._beta) * (i + (r = a / e) * u),
            this._beta * n[a] + (1 - this._beta) * (o + r * s),
          );
      (this._x = this._y = null), this._basis.lineEnd();
    },
    point: function (t, n) {
      this._x.push(+t), this._y.push(+n);
    },
  });
const ml = (function t(n) {
  function e(t) {
    return 1 === n ? new fl(t) : new pl(t, n);
  }
  return (
    (e.beta = function (n) {
      return t(+n);
    }),
    e
  );
})(0.85);
function vl(t, n, e) {
  t._context.bezierCurveTo(
    t._x1 + t._k * (t._x2 - t._x0),
    t._y1 + t._k * (t._y2 - t._y0),
    t._x2 + t._k * (t._x1 - n),
    t._y2 + t._k * (t._y1 - e),
    t._x2,
    t._y2,
  );
}
function gl(t, n) {
  (this._context = t), (this._k = (1 - n) / 6);
}
gl.prototype = {
  areaStart: function () {
    this._line = 0;
  },
  areaEnd: function () {
    this._line = NaN;
  },
  lineStart: function () {
    (this._x0 = this._x1 = this._x2 = this._y0 = this._y1 = this._y2 = NaN), (this._point = 0);
  },
  lineEnd: function () {
    switch (this._point) {
      case 2:
        this._context.lineTo(this._x2, this._y2);
        break;
      case 3:
        vl(this, this._x1, this._y1);
    }
    (this._line || (0 !== this._line && 1 === this._point)) && this._context.closePath(), (this._line = 1 - this._line);
  },
  point: function (t, n) {
    switch (((t = +t), (n = +n), this._point)) {
      case 0:
        (this._point = 1), this._line ? this._context.lineTo(t, n) : this._context.moveTo(t, n);
        break;
      case 1:
        (this._point = 2), (this._x1 = t), (this._y1 = n);
        break;
      case 2:
        this._point = 3;
      default:
        vl(this, t, n);
    }
    (this._x0 = this._x1),
      (this._x1 = this._x2),
      (this._x2 = t),
      (this._y0 = this._y1),
      (this._y1 = this._y2),
      (this._y2 = n);
  },
};
const bl = (function t(n) {
  function e(t) {
    return new gl(t, n);
  }
  return (
    (e.tension = function (n) {
      return t(+n);
    }),
    e
  );
})(0);
function yl(t, n) {
  (this._context = t), (this._k = (1 - n) / 6);
}
yl.prototype = {
  areaStart: cl,
  areaEnd: cl,
  lineStart: function () {
    (this._x0 =
      this._x1 =
      this._x2 =
      this._x3 =
      this._x4 =
      this._x5 =
      this._y0 =
      this._y1 =
      this._y2 =
      this._y3 =
      this._y4 =
      this._y5 =
        NaN),
      (this._point = 0);
  },
  lineEnd: function () {
    switch (this._point) {
      case 1:
        this._context.moveTo(this._x3, this._y3), this._context.closePath();
        break;
      case 2:
        this._context.lineTo(this._x3, this._y3), this._context.closePath();
        break;
      case 3:
        this.point(this._x3, this._y3), this.point(this._x4, this._y4), this.point(this._x5, this._y5);
    }
  },
  point: function (t, n) {
    switch (((t = +t), (n = +n), this._point)) {
      case 0:
        (this._point = 1), (this._x3 = t), (this._y3 = n);
        break;
      case 1:
        (this._point = 2), this._context.moveTo((this._x4 = t), (this._y4 = n));
        break;
      case 2:
        (this._point = 3), (this._x5 = t), (this._y5 = n);
        break;
      default:
        vl(this, t, n);
    }
    (this._x0 = this._x1),
      (this._x1 = this._x2),
      (this._x2 = t),
      (this._y0 = this._y1),
      (this._y1 = this._y2),
      (this._y2 = n);
  },
};
const wl = (function t(n) {
  function e(t) {
    return new yl(t, n);
  }
  return (
    (e.tension = function (n) {
      return t(+n);
    }),
    e
  );
})(0);
function xl(t, n) {
  (this._context = t), (this._k = (1 - n) / 6);
}
xl.prototype = {
  areaStart: function () {
    this._line = 0;
  },
  areaEnd: function () {
    this._line = NaN;
  },
  lineStart: function () {
    (this._x0 = this._x1 = this._x2 = this._y0 = this._y1 = this._y2 = NaN), (this._point = 0);
  },
  lineEnd: function () {
    (this._line || (0 !== this._line && 3 === this._point)) && this._context.closePath(), (this._line = 1 - this._line);
  },
  point: function (t, n) {
    switch (((t = +t), (n = +n), this._point)) {
      case 0:
        this._point = 1;
        break;
      case 1:
        this._point = 2;
        break;
      case 2:
        (this._point = 3),
          this._line ? this._context.lineTo(this._x2, this._y2) : this._context.moveTo(this._x2, this._y2);
        break;
      case 3:
        this._point = 4;
      default:
        vl(this, t, n);
    }
    (this._x0 = this._x1),
      (this._x1 = this._x2),
      (this._x2 = t),
      (this._y0 = this._y1),
      (this._y1 = this._y2),
      (this._y2 = n);
  },
};
const Ol = (function t(n) {
  function e(t) {
    return new xl(t, n);
  }
  return (
    (e.tension = function (n) {
      return t(+n);
    }),
    e
  );
})(0);
function kl(t, n, e) {
  var r = t._x1,
    i = t._y1,
    o = t._x2,
    u = t._y2;
  if (t._l01_a > Bc) {
    var s = 2 * t._l01_2a + 3 * t._l01_a * t._l12_a + t._l12_2a,
      a = 3 * t._l01_a * (t._l01_a + t._l12_a);
    (r = (r * s - t._x0 * t._l12_2a + t._x2 * t._l01_2a) / a),
      (i = (i * s - t._y0 * t._l12_2a + t._y2 * t._l01_2a) / a);
  }
  if (t._l23_a > Bc) {
    var c = 2 * t._l23_2a + 3 * t._l23_a * t._l12_a + t._l12_2a,
      l = 3 * t._l23_a * (t._l23_a + t._l12_a);
    (o = (o * c + t._x1 * t._l23_2a - n * t._l12_2a) / l), (u = (u * c + t._y1 * t._l23_2a - e * t._l12_2a) / l);
  }
  t._context.bezierCurveTo(r, i, o, u, t._x2, t._y2);
}
function Al(t, n) {
  (this._context = t), (this._alpha = n);
}
Al.prototype = {
  areaStart: function () {
    this._line = 0;
  },
  areaEnd: function () {
    this._line = NaN;
  },
  lineStart: function () {
    (this._x0 = this._x1 = this._x2 = this._y0 = this._y1 = this._y2 = NaN),
      (this._l01_a = this._l12_a = this._l23_a = this._l01_2a = this._l12_2a = this._l23_2a = this._point = 0);
  },
  lineEnd: function () {
    switch (this._point) {
      case 2:
        this._context.lineTo(this._x2, this._y2);
        break;
      case 3:
        this.point(this._x2, this._y2);
    }
    (this._line || (0 !== this._line && 1 === this._point)) && this._context.closePath(), (this._line = 1 - this._line);
  },
  point: function (t, n) {
    if (((t = +t), (n = +n), this._point)) {
      var e = this._x2 - t,
        r = this._y2 - n;
      this._l23_a = Math.sqrt((this._l23_2a = Math.pow(e * e + r * r, this._alpha)));
    }
    switch (this._point) {
      case 0:
        (this._point = 1), this._line ? this._context.lineTo(t, n) : this._context.moveTo(t, n);
        break;
      case 1:
        this._point = 2;
        break;
      case 2:
        this._point = 3;
      default:
        kl(this, t, n);
    }
    (this._l01_a = this._l12_a),
      (this._l12_a = this._l23_a),
      (this._l01_2a = this._l12_2a),
      (this._l12_2a = this._l23_2a),
      (this._x0 = this._x1),
      (this._x1 = this._x2),
      (this._x2 = t),
      (this._y0 = this._y1),
      (this._y1 = this._y2),
      (this._y2 = n);
  },
};
const $l = (function t(n) {
  function e(t) {
    return n ? new Al(t, n) : new gl(t, 0);
  }
  return (
    (e.alpha = function (n) {
      return t(+n);
    }),
    e
  );
})(0.5);
function Ml(t, n) {
  (this._context = t), (this._alpha = n);
}
Ml.prototype = {
  areaStart: cl,
  areaEnd: cl,
  lineStart: function () {
    (this._x0 =
      this._x1 =
      this._x2 =
      this._x3 =
      this._x4 =
      this._x5 =
      this._y0 =
      this._y1 =
      this._y2 =
      this._y3 =
      this._y4 =
      this._y5 =
        NaN),
      (this._l01_a = this._l12_a = this._l23_a = this._l01_2a = this._l12_2a = this._l23_2a = this._point = 0);
  },
  lineEnd: function () {
    switch (this._point) {
      case 1:
        this._context.moveTo(this._x3, this._y3), this._context.closePath();
        break;
      case 2:
        this._context.lineTo(this._x3, this._y3), this._context.closePath();
        break;
      case 3:
        this.point(this._x3, this._y3), this.point(this._x4, this._y4), this.point(this._x5, this._y5);
    }
  },
  point: function (t, n) {
    if (((t = +t), (n = +n), this._point)) {
      var e = this._x2 - t,
        r = this._y2 - n;
      this._l23_a = Math.sqrt((this._l23_2a = Math.pow(e * e + r * r, this._alpha)));
    }
    switch (this._point) {
      case 0:
        (this._point = 1), (this._x3 = t), (this._y3 = n);
        break;
      case 1:
        (this._point = 2), this._context.moveTo((this._x4 = t), (this._y4 = n));
        break;
      case 2:
        (this._point = 3), (this._x5 = t), (this._y5 = n);
        break;
      default:
        kl(this, t, n);
    }
    (this._l01_a = this._l12_a),
      (this._l12_a = this._l23_a),
      (this._l01_2a = this._l12_2a),
      (this._l12_2a = this._l23_2a),
      (this._x0 = this._x1),
      (this._x1 = this._x2),
      (this._x2 = t),
      (this._y0 = this._y1),
      (this._y1 = this._y2),
      (this._y2 = n);
  },
};
const jl = (function t(n) {
  function e(t) {
    return n ? new Ml(t, n) : new yl(t, 0);
  }
  return (
    (e.alpha = function (n) {
      return t(+n);
    }),
    e
  );
})(0.5);
function Dl(t, n) {
  (this._context = t), (this._alpha = n);
}
Dl.prototype = {
  areaStart: function () {
    this._line = 0;
  },
  areaEnd: function () {
    this._line = NaN;
  },
  lineStart: function () {
    (this._x0 = this._x1 = this._x2 = this._y0 = this._y1 = this._y2 = NaN),
      (this._l01_a = this._l12_a = this._l23_a = this._l01_2a = this._l12_2a = this._l23_2a = this._point = 0);
  },
  lineEnd: function () {
    (this._line || (0 !== this._line && 3 === this._point)) && this._context.closePath(), (this._line = 1 - this._line);
  },
  point: function (t, n) {
    if (((t = +t), (n = +n), this._point)) {
      var e = this._x2 - t,
        r = this._y2 - n;
      this._l23_a = Math.sqrt((this._l23_2a = Math.pow(e * e + r * r, this._alpha)));
    }
    switch (this._point) {
      case 0:
        this._point = 1;
        break;
      case 1:
        this._point = 2;
        break;
      case 2:
        (this._point = 3),
          this._line ? this._context.lineTo(this._x2, this._y2) : this._context.moveTo(this._x2, this._y2);
        break;
      case 3:
        this._point = 4;
      default:
        kl(this, t, n);
    }
    (this._l01_a = this._l12_a),
      (this._l12_a = this._l23_a),
      (this._l01_2a = this._l12_2a),
      (this._l12_2a = this._l23_2a),
      (this._x0 = this._x1),
      (this._x1 = this._x2),
      (this._x2 = t),
      (this._y0 = this._y1),
      (this._y1 = this._y2),
      (this._y2 = n);
  },
};
const Fl = (function t(n) {
  function e(t) {
    return n ? new Dl(t, n) : new xl(t, 0);
  }
  return (
    (e.alpha = function (n) {
      return t(+n);
    }),
    e
  );
})(0.5);
function El(t) {
  this._context = t;
}
function Sl(t) {
  return t < 0 ? -1 : 1;
}
function Cl(t, n, e) {
  var r = t._x1 - t._x0,
    i = n - t._x1,
    o = (t._y1 - t._y0) / (r || (i < 0 && -0)),
    u = (e - t._y1) / (i || (r < 0 && -0)),
    s = (o * i + u * r) / (r + i);
  return (Sl(o) + Sl(u)) * Math.min(Math.abs(o), Math.abs(u), 0.5 * Math.abs(s)) || 0;
}
function Nl(t, n) {
  var e = t._x1 - t._x0;
  return e ? ((3 * (t._y1 - t._y0)) / e - n) / 2 : n;
}
function Bl(t, n, e) {
  var r = t._x0,
    i = t._x1,
    o = t._y1,
    u = (i - r) / 3;
  t._context.bezierCurveTo(r + u, t._y0 + u * n, i - u, o - u * e, i, o);
}
function _l(t) {
  this._context = t;
}
function zl(t) {
  this._context = new Tl(t);
}
function Tl(t) {
  this._context = t;
}
function Pl(t) {
  this._context = t;
}
function Rl(t) {
  var n,
    e,
    r = t.length - 1,
    i = new Array(r),
    o = new Array(r),
    u = new Array(r);
  for (i[0] = 0, o[0] = 2, u[0] = t[0] + 2 * t[1], n = 1; n < r - 1; ++n)
    (i[n] = 1), (o[n] = 4), (u[n] = 4 * t[n] + 2 * t[n + 1]);
  for (i[r - 1] = 2, o[r - 1] = 7, u[r - 1] = 8 * t[r - 1] + t[r], n = 1; n < r; ++n)
    (o[n] -= e = i[n] / o[n - 1]), (u[n] -= e * u[n - 1]);
  for (i[r - 1] = u[r - 1] / o[r - 1], n = r - 2; n >= 0; --n) i[n] = (u[n] - i[n + 1]) / o[n];
  for (o[r - 1] = (t[r] + i[r - 1]) / 2, n = 0; n < r - 1; ++n) o[n] = 2 * t[n + 1] - i[n + 1];
  return [i, o];
}
function Ll(t, n) {
  (this._context = t), (this._t = n);
}
function ql(t, n) {
  if ('undefined' != typeof document && document.createElement) {
    const e = document.createElement('canvas');
    if (e && e.getContext) return (e.width = t), (e.height = n), e;
  }
  return null;
}
(El.prototype = {
  areaStart: cl,
  areaEnd: cl,
  lineStart: function () {
    this._point = 0;
  },
  lineEnd: function () {
    this._point && this._context.closePath();
  },
  point: function (t, n) {
    (t = +t), (n = +n), this._point ? this._context.lineTo(t, n) : ((this._point = 1), this._context.moveTo(t, n));
  },
}),
  (_l.prototype = {
    areaStart: function () {
      this._line = 0;
    },
    areaEnd: function () {
      this._line = NaN;
    },
    lineStart: function () {
      (this._x0 = this._x1 = this._y0 = this._y1 = this._t0 = NaN), (this._point = 0);
    },
    lineEnd: function () {
      switch (this._point) {
        case 2:
          this._context.lineTo(this._x1, this._y1);
          break;
        case 3:
          Bl(this, this._t0, Nl(this, this._t0));
      }
      (this._line || (0 !== this._line && 1 === this._point)) && this._context.closePath(),
        (this._line = 1 - this._line);
    },
    point: function (t, n) {
      var e = NaN;
      if (((n = +n), (t = +t) !== this._x1 || n !== this._y1)) {
        switch (this._point) {
          case 0:
            (this._point = 1), this._line ? this._context.lineTo(t, n) : this._context.moveTo(t, n);
            break;
          case 1:
            this._point = 2;
            break;
          case 2:
            (this._point = 3), Bl(this, Nl(this, (e = Cl(this, t, n))), e);
            break;
          default:
            Bl(this, this._t0, (e = Cl(this, t, n)));
        }
        (this._x0 = this._x1), (this._x1 = t), (this._y0 = this._y1), (this._y1 = n), (this._t0 = e);
      }
    },
  }),
  ((zl.prototype = Object.create(_l.prototype)).point = function (t, n) {
    _l.prototype.point.call(this, n, t);
  }),
  (Tl.prototype = {
    moveTo: function (t, n) {
      this._context.moveTo(n, t);
    },
    closePath: function () {
      this._context.closePath();
    },
    lineTo: function (t, n) {
      this._context.lineTo(n, t);
    },
    bezierCurveTo: function (t, n, e, r, i, o) {
      this._context.bezierCurveTo(n, t, r, e, o, i);
    },
  }),
  (Pl.prototype = {
    areaStart: function () {
      this._line = 0;
    },
    areaEnd: function () {
      this._line = NaN;
    },
    lineStart: function () {
      (this._x = []), (this._y = []);
    },
    lineEnd: function () {
      var t = this._x,
        n = this._y,
        e = t.length;
      if (e)
        if ((this._line ? this._context.lineTo(t[0], n[0]) : this._context.moveTo(t[0], n[0]), 2 === e))
          this._context.lineTo(t[1], n[1]);
        else
          for (var r = Rl(t), i = Rl(n), o = 0, u = 1; u < e; ++o, ++u)
            this._context.bezierCurveTo(r[0][o], i[0][o], r[1][o], i[1][o], t[u], n[u]);
      (this._line || (0 !== this._line && 1 === e)) && this._context.closePath(),
        (this._line = 1 - this._line),
        (this._x = this._y = null);
    },
    point: function (t, n) {
      this._x.push(+t), this._y.push(+n);
    },
  }),
  (Ll.prototype = {
    areaStart: function () {
      this._line = 0;
    },
    areaEnd: function () {
      this._line = NaN;
    },
    lineStart: function () {
      (this._x = this._y = NaN), (this._point = 0);
    },
    lineEnd: function () {
      0 < this._t && this._t < 1 && 2 === this._point && this._context.lineTo(this._x, this._y),
        (this._line || (0 !== this._line && 1 === this._point)) && this._context.closePath(),
        this._line >= 0 && ((this._t = 1 - this._t), (this._line = 1 - this._line));
    },
    point: function (t, n) {
      switch (((t = +t), (n = +n), this._point)) {
        case 0:
          (this._point = 1), this._line ? this._context.lineTo(t, n) : this._context.moveTo(t, n);
          break;
        case 1:
          this._point = 2;
        default:
          if (this._t <= 0) this._context.lineTo(this._x, n), this._context.lineTo(t, n);
          else {
            var e = this._x * (1 - this._t) + t * this._t;
            this._context.lineTo(e, this._y), this._context.lineTo(e, n);
          }
      }
      (this._x = t), (this._y = n);
    },
  });
const Il = () => ('undefined' != typeof Image ? Image : null);
function Ul(t, n) {
  switch (arguments.length) {
    case 0:
      break;
    case 1:
      this.range(t);
      break;
    default:
      this.range(n).domain(t);
  }
  return this;
}
function Wl(t, n) {
  switch (arguments.length) {
    case 0:
      break;
    case 1:
      'function' == typeof t ? this.interpolator(t) : this.range(t);
      break;
    default:
      this.domain(t), 'function' == typeof n ? this.interpolator(n) : this.range(n);
  }
  return this;
}
const Hl = Symbol('implicit');
function Gl() {
  var t = new _n(),
    n = [],
    e = [],
    r = Hl;
  function i(i) {
    let o = t.get(i);
    if (void 0 === o) {
      if (r !== Hl) return r;
      t.set(i, (o = n.push(i) - 1));
    }
    return e[o % e.length];
  }
  return (
    (i.domain = function (e) {
      if (!arguments.length) return n.slice();
      (n = []), (t = new _n());
      for (const r of e) t.has(r) || t.set(r, n.push(r) - 1);
      return i;
    }),
    (i.range = function (t) {
      return arguments.length ? ((e = Array.from(t)), i) : e.slice();
    }),
    (i.unknown = function (t) {
      return arguments.length ? ((r = t), i) : r;
    }),
    (i.copy = function () {
      return Gl(n, e).unknown(r);
    }),
    Ul.apply(i, arguments),
    i
  );
}
function Vl(t, n, e) {
  (t.prototype = n.prototype = e), (e.constructor = t);
}
function Yl(t, n) {
  var e = Object.create(t.prototype);
  for (var r in n) e[r] = n[r];
  return e;
}
function Xl() {}
var Jl = 0.7,
  Ql = 1 / Jl,
  Zl = '\\s*([+-]?\\d+)\\s*',
  Kl = '\\s*([+-]?(?:\\d*\\.)?\\d+(?:[eE][+-]?\\d+)?)\\s*',
  tf = '\\s*([+-]?(?:\\d*\\.)?\\d+(?:[eE][+-]?\\d+)?)%\\s*',
  nf = /^#([0-9a-f]{3,8})$/,
  ef = new RegExp(`^rgb\\(${Zl},${Zl},${Zl}\\)$`),
  rf = new RegExp(`^rgb\\(${tf},${tf},${tf}\\)$`),
  of = new RegExp(`^rgba\\(${Zl},${Zl},${Zl},${Kl}\\)$`),
  uf = new RegExp(`^rgba\\(${tf},${tf},${tf},${Kl}\\)$`),
  sf = new RegExp(`^hsl\\(${Kl},${tf},${tf}\\)$`),
  af = new RegExp(`^hsla\\(${Kl},${tf},${tf},${Kl}\\)$`),
  cf = {
    aliceblue: 15792383,
    antiquewhite: 16444375,
    aqua: 65535,
    aquamarine: 8388564,
    azure: 15794175,
    beige: 16119260,
    bisque: 16770244,
    black: 0,
    blanchedalmond: 16772045,
    blue: 255,
    blueviolet: 9055202,
    brown: 10824234,
    burlywood: 14596231,
    cadetblue: 6266528,
    chartreuse: 8388352,
    chocolate: 13789470,
    coral: 16744272,
    cornflowerblue: 6591981,
    cornsilk: 16775388,
    crimson: 14423100,
    cyan: 65535,
    darkblue: 139,
    darkcyan: 35723,
    darkgoldenrod: 12092939,
    darkgray: 11119017,
    darkgreen: 25600,
    darkgrey: 11119017,
    darkkhaki: 12433259,
    darkmagenta: 9109643,
    darkolivegreen: 5597999,
    darkorange: 16747520,
    darkorchid: 10040012,
    darkred: 9109504,
    darksalmon: 15308410,
    darkseagreen: 9419919,
    darkslateblue: 4734347,
    darkslategray: 3100495,
    darkslategrey: 3100495,
    darkturquoise: 52945,
    darkviolet: 9699539,
    deeppink: 16716947,
    deepskyblue: 49151,
    dimgray: 6908265,
    dimgrey: 6908265,
    dodgerblue: 2003199,
    firebrick: 11674146,
    floralwhite: 16775920,
    forestgreen: 2263842,
    fuchsia: 16711935,
    gainsboro: 14474460,
    ghostwhite: 16316671,
    gold: 16766720,
    goldenrod: 14329120,
    gray: 8421504,
    green: 32768,
    greenyellow: 11403055,
    grey: 8421504,
    honeydew: 15794160,
    hotpink: 16738740,
    indianred: 13458524,
    indigo: 4915330,
    ivory: 16777200,
    khaki: 15787660,
    lavender: 15132410,
    lavenderblush: 16773365,
    lawngreen: 8190976,
    lemonchiffon: 16775885,
    lightblue: 11393254,
    lightcoral: 15761536,
    lightcyan: 14745599,
    lightgoldenrodyellow: 16448210,
    lightgray: 13882323,
    lightgreen: 9498256,
    lightgrey: 13882323,
    lightpink: 16758465,
    lightsalmon: 16752762,
    lightseagreen: 2142890,
    lightskyblue: 8900346,
    lightslategray: 7833753,
    lightslategrey: 7833753,
    lightsteelblue: 11584734,
    lightyellow: 16777184,
    lime: 65280,
    limegreen: 3329330,
    linen: 16445670,
    magenta: 16711935,
    maroon: 8388608,
    mediumaquamarine: 6737322,
    mediumblue: 205,
    mediumorchid: 12211667,
    mediumpurple: 9662683,
    mediumseagreen: 3978097,
    mediumslateblue: 8087790,
    mediumspringgreen: 64154,
    mediumturquoise: 4772300,
    mediumvioletred: 13047173,
    midnightblue: 1644912,
    mintcream: 16121850,
    mistyrose: 16770273,
    moccasin: 16770229,
    navajowhite: 16768685,
    navy: 128,
    oldlace: 16643558,
    olive: 8421376,
    olivedrab: 7048739,
    orange: 16753920,
    orangered: 16729344,
    orchid: 14315734,
    palegoldenrod: 15657130,
    palegreen: 10025880,
    paleturquoise: 11529966,
    palevioletred: 14381203,
    papayawhip: 16773077,
    peachpuff: 16767673,
    peru: 13468991,
    pink: 16761035,
    plum: 14524637,
    powderblue: 11591910,
    purple: 8388736,
    rebeccapurple: 6697881,
    red: 16711680,
    rosybrown: 12357519,
    royalblue: 4286945,
    saddlebrown: 9127187,
    salmon: 16416882,
    sandybrown: 16032864,
    seagreen: 3050327,
    seashell: 16774638,
    sienna: 10506797,
    silver: 12632256,
    skyblue: 8900331,
    slateblue: 6970061,
    slategray: 7372944,
    slategrey: 7372944,
    snow: 16775930,
    springgreen: 65407,
    steelblue: 4620980,
    tan: 13808780,
    teal: 32896,
    thistle: 14204888,
    tomato: 16737095,
    turquoise: 4251856,
    violet: 15631086,
    wheat: 16113331,
    white: 16777215,
    whitesmoke: 16119285,
    yellow: 16776960,
    yellowgreen: 10145074,
  };
function lf() {
  return this.rgb().formatHex();
}
function ff() {
  return this.rgb().formatRgb();
}
function hf(t) {
  var n, e;
  return (
    (t = (t + '').trim().toLowerCase()),
    (n = nf.exec(t))
      ? ((e = n[1].length),
        (n = parseInt(n[1], 16)),
        6 === e
          ? df(n)
          : 3 === e
          ? new gf(((n >> 8) & 15) | ((n >> 4) & 240), ((n >> 4) & 15) | (240 & n), ((15 & n) << 4) | (15 & n), 1)
          : 8 === e
          ? pf((n >> 24) & 255, (n >> 16) & 255, (n >> 8) & 255, (255 & n) / 255)
          : 4 === e
          ? pf(
              ((n >> 12) & 15) | ((n >> 8) & 240),
              ((n >> 8) & 15) | ((n >> 4) & 240),
              ((n >> 4) & 15) | (240 & n),
              (((15 & n) << 4) | (15 & n)) / 255,
            )
          : null)
      : (n = ef.exec(t))
      ? new gf(n[1], n[2], n[3], 1)
      : (n = rf.exec(t))
      ? new gf((255 * n[1]) / 100, (255 * n[2]) / 100, (255 * n[3]) / 100, 1)
      : (n = of.exec(t))
      ? pf(n[1], n[2], n[3], n[4])
      : (n = uf.exec(t))
      ? pf((255 * n[1]) / 100, (255 * n[2]) / 100, (255 * n[3]) / 100, n[4])
      : (n = sf.exec(t))
      ? kf(n[1], n[2] / 100, n[3] / 100, 1)
      : (n = af.exec(t))
      ? kf(n[1], n[2] / 100, n[3] / 100, n[4])
      : cf.hasOwnProperty(t)
      ? df(cf[t])
      : 'transparent' === t
      ? new gf(NaN, NaN, NaN, 0)
      : null
  );
}
function df(t) {
  return new gf((t >> 16) & 255, (t >> 8) & 255, 255 & t, 1);
}
function pf(t, n, e, r) {
  return r <= 0 && (t = n = e = NaN), new gf(t, n, e, r);
}
function mf(t) {
  return t instanceof Xl || (t = hf(t)), t ? new gf((t = t.rgb()).r, t.g, t.b, t.opacity) : new gf();
}
function vf(t, n, e, r) {
  return 1 === arguments.length ? mf(t) : new gf(t, n, e, null == r ? 1 : r);
}
function gf(t, n, e, r) {
  (this.r = +t), (this.g = +n), (this.b = +e), (this.opacity = +r);
}
function bf() {
  return `#${Of(this.r)}${Of(this.g)}${Of(this.b)}`;
}
function yf() {
  const t = wf(this.opacity);
  return `${1 === t ? 'rgb(' : 'rgba('}${xf(this.r)}, ${xf(this.g)}, ${xf(this.b)}${1 === t ? ')' : `, ${t})`}`;
}
function wf(t) {
  return isNaN(t) ? 1 : Math.max(0, Math.min(1, t));
}
function xf(t) {
  return Math.max(0, Math.min(255, Math.round(t) || 0));
}
function Of(t) {
  return ((t = xf(t)) < 16 ? '0' : '') + t.toString(16);
}
function kf(t, n, e, r) {
  return r <= 0 ? (t = n = e = NaN) : e <= 0 || e >= 1 ? (t = n = NaN) : n <= 0 && (t = NaN), new Mf(t, n, e, r);
}
function Af(t) {
  if (t instanceof Mf) return new Mf(t.h, t.s, t.l, t.opacity);
  if ((t instanceof Xl || (t = hf(t)), !t)) return new Mf();
  if (t instanceof Mf) return t;
  var n = (t = t.rgb()).r / 255,
    e = t.g / 255,
    r = t.b / 255,
    i = Math.min(n, e, r),
    o = Math.max(n, e, r),
    u = NaN,
    s = o - i,
    a = (o + i) / 2;
  return (
    s
      ? ((u = n === o ? (e - r) / s + 6 * (e < r) : e === o ? (r - n) / s + 2 : (n - e) / s + 4),
        (s /= a < 0.5 ? o + i : 2 - o - i),
        (u *= 60))
      : (s = a > 0 && a < 1 ? 0 : u),
    new Mf(u, s, a, t.opacity)
  );
}
function $f(t, n, e, r) {
  return 1 === arguments.length ? Af(t) : new Mf(t, n, e, null == r ? 1 : r);
}
function Mf(t, n, e, r) {
  (this.h = +t), (this.s = +n), (this.l = +e), (this.opacity = +r);
}
function jf(t) {
  return (t = (t || 0) % 360) < 0 ? t + 360 : t;
}
function Df(t) {
  return Math.max(0, Math.min(1, t || 0));
}
function Ff(t, n, e) {
  return 255 * (t < 60 ? n + ((e - n) * t) / 60 : t < 180 ? e : t < 240 ? n + ((e - n) * (240 - t)) / 60 : n);
}
Vl(Xl, hf, {
  copy(t) {
    return Object.assign(new this.constructor(), this, t);
  },
  displayable() {
    return this.rgb().displayable();
  },
  hex: lf,
  formatHex: lf,
  formatHex8: function () {
    return this.rgb().formatHex8();
  },
  formatHsl: function () {
    return Af(this).formatHsl();
  },
  formatRgb: ff,
  toString: ff,
}),
  Vl(
    gf,
    vf,
    Yl(Xl, {
      brighter(t) {
        return (t = null == t ? Ql : Math.pow(Ql, t)), new gf(this.r * t, this.g * t, this.b * t, this.opacity);
      },
      darker(t) {
        return (t = null == t ? Jl : Math.pow(Jl, t)), new gf(this.r * t, this.g * t, this.b * t, this.opacity);
      },
      rgb() {
        return this;
      },
      clamp() {
        return new gf(xf(this.r), xf(this.g), xf(this.b), wf(this.opacity));
      },
      displayable() {
        return (
          -0.5 <= this.r &&
          this.r < 255.5 &&
          -0.5 <= this.g &&
          this.g < 255.5 &&
          -0.5 <= this.b &&
          this.b < 255.5 &&
          0 <= this.opacity &&
          this.opacity <= 1
        );
      },
      hex: bf,
      formatHex: bf,
      formatHex8: function () {
        return `#${Of(this.r)}${Of(this.g)}${Of(this.b)}${Of(255 * (isNaN(this.opacity) ? 1 : this.opacity))}`;
      },
      formatRgb: yf,
      toString: yf,
    }),
  ),
  Vl(
    Mf,
    $f,
    Yl(Xl, {
      brighter(t) {
        return (t = null == t ? Ql : Math.pow(Ql, t)), new Mf(this.h, this.s, this.l * t, this.opacity);
      },
      darker(t) {
        return (t = null == t ? Jl : Math.pow(Jl, t)), new Mf(this.h, this.s, this.l * t, this.opacity);
      },
      rgb() {
        var t = (this.h % 360) + 360 * (this.h < 0),
          n = isNaN(t) || isNaN(this.s) ? 0 : this.s,
          e = this.l,
          r = e + (e < 0.5 ? e : 1 - e) * n,
          i = 2 * e - r;
        return new gf(
          Ff(t >= 240 ? t - 240 : t + 120, i, r),
          Ff(t, i, r),
          Ff(t < 120 ? t + 240 : t - 120, i, r),
          this.opacity,
        );
      },
      clamp() {
        return new Mf(jf(this.h), Df(this.s), Df(this.l), wf(this.opacity));
      },
      displayable() {
        return (
          ((0 <= this.s && this.s <= 1) || isNaN(this.s)) &&
          0 <= this.l &&
          this.l <= 1 &&
          0 <= this.opacity &&
          this.opacity <= 1
        );
      },
      formatHsl() {
        const t = wf(this.opacity);
        return `${1 === t ? 'hsl(' : 'hsla('}${jf(this.h)}, ${100 * Df(this.s)}%, ${100 * Df(this.l)}%${
          1 === t ? ')' : `, ${t})`
        }`;
      },
    }),
  );
const Ef = Math.PI / 180,
  Sf = 180 / Math.PI,
  Cf = 0.96422,
  Nf = 0.82521,
  Bf = 4 / 29,
  _f = 6 / 29,
  zf = 3 * _f * _f;
function Tf(t) {
  if (t instanceof Rf) return new Rf(t.l, t.a, t.b, t.opacity);
  if (t instanceof Gf) return Vf(t);
  t instanceof gf || (t = mf(t));
  var n,
    e,
    r = Uf(t.r),
    i = Uf(t.g),
    o = Uf(t.b),
    u = Lf((0.2225045 * r + 0.7168786 * i + 0.0606169 * o) / 1);
  return (
    r === i && i === o
      ? (n = e = u)
      : ((n = Lf((0.4360747 * r + 0.3850649 * i + 0.1430804 * o) / Cf)),
        (e = Lf((0.0139322 * r + 0.0971045 * i + 0.7141733 * o) / Nf))),
    new Rf(116 * u - 16, 500 * (n - u), 200 * (u - e), t.opacity)
  );
}
function Pf(t, n, e, r) {
  return 1 === arguments.length ? Tf(t) : new Rf(t, n, e, null == r ? 1 : r);
}
function Rf(t, n, e, r) {
  (this.l = +t), (this.a = +n), (this.b = +e), (this.opacity = +r);
}
function Lf(t) {
  return t > 0.008856451679035631 ? Math.pow(t, 1 / 3) : t / zf + Bf;
}
function qf(t) {
  return t > _f ? t * t * t : zf * (t - Bf);
}
function If(t) {
  return 255 * (t <= 0.0031308 ? 12.92 * t : 1.055 * Math.pow(t, 1 / 2.4) - 0.055);
}
function Uf(t) {
  return (t /= 255) <= 0.04045 ? t / 12.92 : Math.pow((t + 0.055) / 1.055, 2.4);
}
function Wf(t) {
  if (t instanceof Gf) return new Gf(t.h, t.c, t.l, t.opacity);
  if ((t instanceof Rf || (t = Tf(t)), 0 === t.a && 0 === t.b))
    return new Gf(NaN, 0 < t.l && t.l < 100 ? 0 : NaN, t.l, t.opacity);
  var n = Math.atan2(t.b, t.a) * Sf;
  return new Gf(n < 0 ? n + 360 : n, Math.sqrt(t.a * t.a + t.b * t.b), t.l, t.opacity);
}
function Hf(t, n, e, r) {
  return 1 === arguments.length ? Wf(t) : new Gf(t, n, e, null == r ? 1 : r);
}
function Gf(t, n, e, r) {
  (this.h = +t), (this.c = +n), (this.l = +e), (this.opacity = +r);
}
function Vf(t) {
  if (isNaN(t.h)) return new Rf(t.l, 0, 0, t.opacity);
  var n = t.h * Ef;
  return new Rf(t.l, Math.cos(n) * t.c, Math.sin(n) * t.c, t.opacity);
}
Vl(
  Rf,
  Pf,
  Yl(Xl, {
    brighter(t) {
      return new Rf(this.l + 18 * (null == t ? 1 : t), this.a, this.b, this.opacity);
    },
    darker(t) {
      return new Rf(this.l - 18 * (null == t ? 1 : t), this.a, this.b, this.opacity);
    },
    rgb() {
      var t = (this.l + 16) / 116,
        n = isNaN(this.a) ? t : t + this.a / 500,
        e = isNaN(this.b) ? t : t - this.b / 200;
      return new gf(
        If(3.1338561 * (n = Cf * qf(n)) - 1.6168667 * (t = 1 * qf(t)) - 0.4906146 * (e = Nf * qf(e))),
        If(-0.9787684 * n + 1.9161415 * t + 0.033454 * e),
        If(0.0719453 * n - 0.2289914 * t + 1.4052427 * e),
        this.opacity,
      );
    },
  }),
),
  Vl(
    Gf,
    Hf,
    Yl(Xl, {
      brighter(t) {
        return new Gf(this.h, this.c, this.l + 18 * (null == t ? 1 : t), this.opacity);
      },
      darker(t) {
        return new Gf(this.h, this.c, this.l - 18 * (null == t ? 1 : t), this.opacity);
      },
      rgb() {
        return Vf(this).rgb();
      },
    }),
  );
var Yf = -0.14861,
  Xf = 1.78277,
  Jf = -0.29227,
  Qf = -0.90649,
  Zf = 1.97294,
  Kf = Zf * Qf,
  th = Zf * Xf,
  nh = Xf * Jf - Qf * Yf;
function eh(t) {
  if (t instanceof ih) return new ih(t.h, t.s, t.l, t.opacity);
  t instanceof gf || (t = mf(t));
  var n = t.g / 255,
    e = t.b / 255,
    r = (nh * e + Kf * (t.r / 255) - th * n) / (nh + Kf - th),
    i = e - r,
    o = (Zf * (n - r) - Jf * i) / Qf,
    u = Math.sqrt(o * o + i * i) / (Zf * r * (1 - r)),
    s = u ? Math.atan2(o, i) * Sf - 120 : NaN;
  return new ih(s < 0 ? s + 360 : s, u, r, t.opacity);
}
function rh(t, n, e, r) {
  return 1 === arguments.length ? eh(t) : new ih(t, n, e, null == r ? 1 : r);
}
function ih(t, n, e, r) {
  (this.h = +t), (this.s = +n), (this.l = +e), (this.opacity = +r);
}
function oh(t, n, e, r, i) {
  var o = t * t,
    u = o * t;
  return ((1 - 3 * t + 3 * o - u) * n + (4 - 6 * o + 3 * u) * e + (1 + 3 * t + 3 * o - 3 * u) * r + u * i) / 6;
}
function uh(t) {
  var n = t.length - 1;
  return function (e) {
    var r = e <= 0 ? (e = 0) : e >= 1 ? ((e = 1), n - 1) : Math.floor(e * n),
      i = t[r],
      o = t[r + 1];
    return oh((e - r / n) * n, r > 0 ? t[r - 1] : 2 * i - o, i, o, r < n - 1 ? t[r + 2] : 2 * o - i);
  };
}
function sh(t) {
  var n = t.length;
  return function (e) {
    var r = Math.floor(((e %= 1) < 0 ? ++e : e) * n);
    return oh((e - r / n) * n, t[(r + n - 1) % n], t[r % n], t[(r + 1) % n], t[(r + 2) % n]);
  };
}
Vl(
  ih,
  rh,
  Yl(Xl, {
    brighter(t) {
      return (t = null == t ? Ql : Math.pow(Ql, t)), new ih(this.h, this.s, this.l * t, this.opacity);
    },
    darker(t) {
      return (t = null == t ? Jl : Math.pow(Jl, t)), new ih(this.h, this.s, this.l * t, this.opacity);
    },
    rgb() {
      var t = isNaN(this.h) ? 0 : (this.h + 120) * Ef,
        n = +this.l,
        e = isNaN(this.s) ? 0 : this.s * n * (1 - n),
        r = Math.cos(t),
        i = Math.sin(t);
      return new gf(
        255 * (n + e * (Yf * r + Xf * i)),
        255 * (n + e * (Jf * r + Qf * i)),
        255 * (n + e * (Zf * r)),
        this.opacity,
      );
    },
  }),
);
const ah = t => () => t;
function ch(t, n) {
  return function (e) {
    return t + e * n;
  };
}
function lh(t, n) {
  var e = n - t;
  return e ? ch(t, e > 180 || e < -180 ? e - 360 * Math.round(e / 360) : e) : ah(isNaN(t) ? n : t);
}
function fh(t, n) {
  var e = n - t;
  return e ? ch(t, e) : ah(isNaN(t) ? n : t);
}
const hh = (function t(n) {
  var e = (function (t) {
    return 1 == (t = +t)
      ? fh
      : function (n, e) {
          return e - n
            ? (function (t, n, e) {
                return (
                  (t = Math.pow(t, e)),
                  (n = Math.pow(n, e) - t),
                  (e = 1 / e),
                  function (r) {
                    return Math.pow(t + r * n, e);
                  }
                );
              })(n, e, t)
            : ah(isNaN(n) ? e : n);
        };
  })(n);
  function r(t, n) {
    var r = e((t = vf(t)).r, (n = vf(n)).r),
      i = e(t.g, n.g),
      o = e(t.b, n.b),
      u = fh(t.opacity, n.opacity);
    return function (n) {
      return (t.r = r(n)), (t.g = i(n)), (t.b = o(n)), (t.opacity = u(n)), t + '';
    };
  }
  return (r.gamma = t), r;
})(1);
function dh(t) {
  return function (n) {
    var e,
      r,
      i = n.length,
      o = new Array(i),
      u = new Array(i),
      s = new Array(i);
    for (e = 0; e < i; ++e) (r = vf(n[e])), (o[e] = r.r || 0), (u[e] = r.g || 0), (s[e] = r.b || 0);
    return (
      (o = t(o)),
      (u = t(u)),
      (s = t(s)),
      (r.opacity = 1),
      function (t) {
        return (r.r = o(t)), (r.g = u(t)), (r.b = s(t)), r + '';
      }
    );
  };
}
var ph = dh(uh),
  mh = dh(sh);
function vh(t, n) {
  n || (n = []);
  var e,
    r = t ? Math.min(n.length, t.length) : 0,
    i = n.slice();
  return function (o) {
    for (e = 0; e < r; ++e) i[e] = t[e] * (1 - o) + n[e] * o;
    return i;
  };
}
function gh(t) {
  return ArrayBuffer.isView(t) && !(t instanceof DataView);
}
function bh(t, n) {
  var e,
    r = n ? n.length : 0,
    i = t ? Math.min(r, t.length) : 0,
    o = new Array(i),
    u = new Array(r);
  for (e = 0; e < i; ++e) o[e] = $h(t[e], n[e]);
  for (; e < r; ++e) u[e] = n[e];
  return function (t) {
    for (e = 0; e < i; ++e) u[e] = o[e](t);
    return u;
  };
}
function yh(t, n) {
  var e = new Date();
  return (
    (t = +t),
    (n = +n),
    function (r) {
      return e.setTime(t * (1 - r) + n * r), e;
    }
  );
}
function wh(t, n) {
  return (
    (t = +t),
    (n = +n),
    function (e) {
      return t * (1 - e) + n * e;
    }
  );
}
function xh(t, n) {
  var e,
    r = {},
    i = {};
  for (e in ((null !== t && 'object' == typeof t) || (t = {}), (null !== n && 'object' == typeof n) || (n = {}), n))
    e in t ? (r[e] = $h(t[e], n[e])) : (i[e] = n[e]);
  return function (t) {
    for (e in r) i[e] = r[e](t);
    return i;
  };
}
var Oh = /[-+]?(?:\d+\.?\d*|\.?\d+)(?:[eE][-+]?\d+)?/g,
  kh = new RegExp(Oh.source, 'g');
function Ah(t, n) {
  var e,
    r,
    i,
    o = (Oh.lastIndex = kh.lastIndex = 0),
    u = -1,
    s = [],
    a = [];
  for (t += '', n += ''; (e = Oh.exec(t)) && (r = kh.exec(n)); )
    (i = r.index) > o && ((i = n.slice(o, i)), s[u] ? (s[u] += i) : (s[++u] = i)),
      (e = e[0]) === (r = r[0])
        ? s[u]
          ? (s[u] += r)
          : (s[++u] = r)
        : ((s[++u] = null), a.push({ i: u, x: wh(e, r) })),
      (o = kh.lastIndex);
  return (
    o < n.length && ((i = n.slice(o)), s[u] ? (s[u] += i) : (s[++u] = i)),
    s.length < 2
      ? a[0]
        ? (function (t) {
            return function (n) {
              return t(n) + '';
            };
          })(a[0].x)
        : (function (t) {
            return function () {
              return t;
            };
          })(n)
      : ((n = a.length),
        function (t) {
          for (var e, r = 0; r < n; ++r) s[(e = a[r]).i] = e.x(t);
          return s.join('');
        })
  );
}
function $h(t, n) {
  var e,
    r = typeof n;
  return null == n || 'boolean' === r
    ? ah(n)
    : ('number' === r
        ? wh
        : 'string' === r
        ? (e = hf(n))
          ? ((n = e), hh)
          : Ah
        : n instanceof hf
        ? hh
        : n instanceof Date
        ? yh
        : gh(n)
        ? vh
        : Array.isArray(n)
        ? bh
        : ('function' != typeof n.valueOf && 'function' != typeof n.toString) || isNaN(n)
        ? xh
        : wh)(t, n);
}
function Mh(t, n) {
  return (
    (t = +t),
    (n = +n),
    function (e) {
      return Math.round(t * (1 - e) + n * e);
    }
  );
}
var jh,
  Dh = 180 / Math.PI,
  Fh = { translateX: 0, translateY: 0, rotate: 0, skewX: 0, scaleX: 1, scaleY: 1 };
function Eh(t, n, e, r, i, o) {
  var u, s, a;
  return (
    (u = Math.sqrt(t * t + n * n)) && ((t /= u), (n /= u)),
    (a = t * e + n * r) && ((e -= t * a), (r -= n * a)),
    (s = Math.sqrt(e * e + r * r)) && ((e /= s), (r /= s), (a /= s)),
    t * r < n * e && ((t = -t), (n = -n), (a = -a), (u = -u)),
    { translateX: i, translateY: o, rotate: Math.atan2(n, t) * Dh, skewX: Math.atan(a) * Dh, scaleX: u, scaleY: s }
  );
}
function Sh(t, n, e, r) {
  function i(t) {
    return t.length ? t.pop() + ' ' : '';
  }
  return function (o, u) {
    var s = [],
      a = [];
    return (
      (o = t(o)),
      (u = t(u)),
      (function (t, r, i, o, u, s) {
        if (t !== i || r !== o) {
          var a = u.push('translate(', null, n, null, e);
          s.push({ i: a - 4, x: wh(t, i) }, { i: a - 2, x: wh(r, o) });
        } else (i || o) && u.push('translate(' + i + n + o + e);
      })(o.translateX, o.translateY, u.translateX, u.translateY, s, a),
      (function (t, n, e, o) {
        t !== n
          ? (t - n > 180 ? (n += 360) : n - t > 180 && (t += 360),
            o.push({ i: e.push(i(e) + 'rotate(', null, r) - 2, x: wh(t, n) }))
          : n && e.push(i(e) + 'rotate(' + n + r);
      })(o.rotate, u.rotate, s, a),
      (function (t, n, e, o) {
        t !== n
          ? o.push({ i: e.push(i(e) + 'skewX(', null, r) - 2, x: wh(t, n) })
          : n && e.push(i(e) + 'skewX(' + n + r);
      })(o.skewX, u.skewX, s, a),
      (function (t, n, e, r, o, u) {
        if (t !== e || n !== r) {
          var s = o.push(i(o) + 'scale(', null, ',', null, ')');
          u.push({ i: s - 4, x: wh(t, e) }, { i: s - 2, x: wh(n, r) });
        } else (1 === e && 1 === r) || o.push(i(o) + 'scale(' + e + ',' + r + ')');
      })(o.scaleX, o.scaleY, u.scaleX, u.scaleY, s, a),
      (o = u = null),
      function (t) {
        for (var n, e = -1, r = a.length; ++e < r; ) s[(n = a[e]).i] = n.x(t);
        return s.join('');
      }
    );
  };
}
var Ch = Sh(
    function (t) {
      const n = new ('function' == typeof DOMMatrix ? DOMMatrix : WebKitCSSMatrix)(t + '');
      return n.isIdentity ? Fh : Eh(n.a, n.b, n.c, n.d, n.e, n.f);
    },
    'px, ',
    'px)',
    'deg)',
  ),
  Nh = Sh(
    function (t) {
      return null == t
        ? Fh
        : (jh || (jh = document.createElementNS('http://www.w3.org/2000/svg', 'g')),
          jh.setAttribute('transform', t),
          (t = jh.transform.baseVal.consolidate()) ? Eh((t = t.matrix).a, t.b, t.c, t.d, t.e, t.f) : Fh);
    },
    ', ',
    ')',
    ')',
  );
function Bh(t) {
  return ((t = Math.exp(t)) + 1 / t) / 2;
}
const _h = (function t(n, e, r) {
  function i(t, i) {
    var o,
      u,
      s = t[0],
      a = t[1],
      c = t[2],
      l = i[2],
      f = i[0] - s,
      h = i[1] - a,
      d = f * f + h * h;
    if (d < 1e-12)
      (u = Math.log(l / c) / n),
        (o = function (t) {
          return [s + t * f, a + t * h, c * Math.exp(n * t * u)];
        });
    else {
      var p = Math.sqrt(d),
        m = (l * l - c * c + r * d) / (2 * c * e * p),
        v = (l * l - c * c - r * d) / (2 * l * e * p),
        g = Math.log(Math.sqrt(m * m + 1) - m),
        b = Math.log(Math.sqrt(v * v + 1) - v);
      (u = (b - g) / n),
        (o = function (t) {
          var r = t * u,
            i = Bh(g),
            o =
              (c / (e * p)) *
              (i *
                (function (t) {
                  return ((t = Math.exp(2 * t)) - 1) / (t + 1);
                })(n * r + g) -
                (function (t) {
                  return ((t = Math.exp(t)) - 1 / t) / 2;
                })(g));
          return [s + o * f, a + o * h, (c * i) / Bh(n * r + g)];
        });
    }
    return (o.duration = (1e3 * u * n) / Math.SQRT2), o;
  }
  return (
    (i.rho = function (n) {
      var e = Math.max(0.001, +n),
        r = e * e;
      return t(e, r, r * r);
    }),
    i
  );
})(Math.SQRT2, 2, 4);
function zh(t) {
  return function (n, e) {
    var r = t((n = $f(n)).h, (e = $f(e)).h),
      i = fh(n.s, e.s),
      o = fh(n.l, e.l),
      u = fh(n.opacity, e.opacity);
    return function (t) {
      return (n.h = r(t)), (n.s = i(t)), (n.l = o(t)), (n.opacity = u(t)), n + '';
    };
  };
}
const Th = zh(lh);
var Ph = zh(fh);
function Rh(t) {
  return function (n, e) {
    var r = t((n = Hf(n)).h, (e = Hf(e)).h),
      i = fh(n.c, e.c),
      o = fh(n.l, e.l),
      u = fh(n.opacity, e.opacity);
    return function (t) {
      return (n.h = r(t)), (n.c = i(t)), (n.l = o(t)), (n.opacity = u(t)), n + '';
    };
  };
}
const Lh = Rh(lh);
var qh = Rh(fh);
function Ih(t) {
  return (function n(e) {
    function r(n, r) {
      var i = t((n = rh(n)).h, (r = rh(r)).h),
        o = fh(n.s, r.s),
        u = fh(n.l, r.l),
        s = fh(n.opacity, r.opacity);
      return function (t) {
        return (n.h = i(t)), (n.s = o(t)), (n.l = u(Math.pow(t, e))), (n.opacity = s(t)), n + '';
      };
    }
    return (e = +e), (r.gamma = n), r;
  })(1);
}
const Uh = Ih(lh);
var Wh = Ih(fh);
function Hh(t, n) {
  void 0 === n && ((n = t), (t = $h));
  for (var e = 0, r = n.length - 1, i = n[0], o = new Array(r < 0 ? 0 : r); e < r; ) o[e] = t(i, (i = n[++e]));
  return function (t) {
    var n = Math.max(0, Math.min(r - 1, Math.floor((t *= r))));
    return o[n](t - n);
  };
}
const Gh = Object.freeze({
  __proto__: null,
  interpolate: $h,
  interpolateArray: function (t, n) {
    return (gh(n) ? vh : bh)(t, n);
  },
  interpolateBasis: uh,
  interpolateBasisClosed: sh,
  interpolateDate: yh,
  interpolateDiscrete: function (t) {
    var n = t.length;
    return function (e) {
      return t[Math.max(0, Math.min(n - 1, Math.floor(e * n)))];
    };
  },
  interpolateHue: function (t, n) {
    var e = lh(+t, +n);
    return function (t) {
      var n = e(t);
      return n - 360 * Math.floor(n / 360);
    };
  },
  interpolateNumber: wh,
  interpolateNumberArray: vh,
  interpolateObject: xh,
  interpolateRound: Mh,
  interpolateString: Ah,
  interpolateTransformCss: Ch,
  interpolateTransformSvg: Nh,
  interpolateZoom: _h,
  interpolateRgb: hh,
  interpolateRgbBasis: ph,
  interpolateRgbBasisClosed: mh,
  interpolateHsl: Th,
  interpolateHslLong: Ph,
  interpolateLab: function (t, n) {
    var e = fh((t = Pf(t)).l, (n = Pf(n)).l),
      r = fh(t.a, n.a),
      i = fh(t.b, n.b),
      o = fh(t.opacity, n.opacity);
    return function (n) {
      return (t.l = e(n)), (t.a = r(n)), (t.b = i(n)), (t.opacity = o(n)), t + '';
    };
  },
  interpolateHcl: Lh,
  interpolateHclLong: qh,
  interpolateCubehelix: Uh,
  interpolateCubehelixLong: Wh,
  piecewise: Hh,
  quantize: function (t, n) {
    for (var e = new Array(n), r = 0; r < n; ++r) e[r] = t(r / (n - 1));
    return e;
  },
});
function Vh(t) {
  return +t;
}
var Yh = [0, 1];
function Xh(t) {
  return t;
}
function Jh(t, n) {
  return (n -= t = +t)
    ? function (e) {
        return (e - t) / n;
      }
    : (function (t) {
        return function () {
          return t;
        };
      })(isNaN(n) ? NaN : 0.5);
}
function Qh(t, n, e) {
  var r = t[0],
    i = t[1],
    o = n[0],
    u = n[1];
  return (
    i < r ? ((r = Jh(i, r)), (o = e(u, o))) : ((r = Jh(r, i)), (o = e(o, u))),
    function (t) {
      return o(r(t));
    }
  );
}
function Zh(t, n, e) {
  var r = Math.min(t.length, n.length) - 1,
    i = new Array(r),
    o = new Array(r),
    u = -1;
  for (t[r] < t[0] && ((t = t.slice().reverse()), (n = n.slice().reverse())); ++u < r; )
    (i[u] = Jh(t[u], t[u + 1])), (o[u] = e(n[u], n[u + 1]));
  return function (n) {
    var e = Cn(t, n, 1, r) - 1;
    return o[e](i[e](n));
  };
}
function Kh(t, n) {
  return n.domain(t.domain()).range(t.range()).interpolate(t.interpolate()).clamp(t.clamp()).unknown(t.unknown());
}
function td() {
  var t,
    n,
    e,
    r,
    i,
    o,
    u = Yh,
    s = Yh,
    a = $h,
    c = Xh;
  function l() {
    var t = Math.min(u.length, s.length);
    return (
      c !== Xh &&
        (c = (function (t, n) {
          var e;
          return (
            t > n && ((e = t), (t = n), (n = e)),
            function (e) {
              return Math.max(t, Math.min(n, e));
            }
          );
        })(u[0], u[t - 1])),
      (r = t > 2 ? Zh : Qh),
      (i = o = null),
      f
    );
  }
  function f(n) {
    return null == n || isNaN((n = +n)) ? e : (i || (i = r(u.map(t), s, a)))(t(c(n)));
  }
  return (
    (f.invert = function (e) {
      return c(n((o || (o = r(s, u.map(t), wh)))(e)));
    }),
    (f.domain = function (t) {
      return arguments.length ? ((u = Array.from(t, Vh)), l()) : u.slice();
    }),
    (f.range = function (t) {
      return arguments.length ? ((s = Array.from(t)), l()) : s.slice();
    }),
    (f.rangeRound = function (t) {
      return (s = Array.from(t)), (a = Mh), l();
    }),
    (f.clamp = function (t) {
      return arguments.length ? ((c = !!t || Xh), l()) : c !== Xh;
    }),
    (f.interpolate = function (t) {
      return arguments.length ? ((a = t), l()) : a;
    }),
    (f.unknown = function (t) {
      return arguments.length ? ((e = t), f) : e;
    }),
    function (e, r) {
      return (t = e), (n = r), l();
    }
  );
}
function nd() {
  return td()(Xh, Xh);
}
function ed(t, n, e, r) {
  var i,
    o = Yn(t, n, e);
  switch ((r = ce(null == r ? ',f' : r)).type) {
    case 's':
      var u = Math.max(Math.abs(t), Math.abs(n));
      return null != r.precision || isNaN((i = xe(o, u))) || (r.precision = i), ve(r, u);
    case '':
    case 'e':
    case 'g':
    case 'p':
    case 'r':
      null != r.precision ||
        isNaN((i = Oe(o, Math.max(Math.abs(t), Math.abs(n))))) ||
        (r.precision = i - ('e' === r.type));
      break;
    case 'f':
    case '%':
      null != r.precision || isNaN((i = we(o))) || (r.precision = i - 2 * ('%' === r.type));
  }
  return me(r);
}
function rd(t) {
  var n = t.domain;
  return (
    (t.ticks = function (t) {
      var e = n();
      return Gn(e[0], e[e.length - 1], null == t ? 10 : t);
    }),
    (t.tickFormat = function (t, e) {
      var r = n();
      return ed(r[0], r[r.length - 1], null == t ? 10 : t, e);
    }),
    (t.nice = function (e) {
      null == e && (e = 10);
      var r,
        i,
        o = n(),
        u = 0,
        s = o.length - 1,
        a = o[u],
        c = o[s],
        l = 10;
      for (c < a && ((i = a), (a = c), (c = i), (i = u), (u = s), (s = i)); l-- > 0; ) {
        if ((i = Vn(a, c, e)) === r) return (o[u] = a), (o[s] = c), n(o);
        if (i > 0) (a = Math.floor(a / i) * i), (c = Math.ceil(c / i) * i);
        else {
          if (!(i < 0)) break;
          (a = Math.ceil(a * i) / i), (c = Math.floor(c * i) / i);
        }
        r = i;
      }
      return t;
    }),
    t
  );
}
function id(t, n) {
  var e,
    r = 0,
    i = (t = t.slice()).length - 1,
    o = t[r],
    u = t[i];
  return u < o && ((e = r), (r = i), (i = e), (e = o), (o = u), (u = e)), (t[r] = n.floor(o)), (t[i] = n.ceil(u)), t;
}
function od(t) {
  return Math.log(t);
}
function ud(t) {
  return Math.exp(t);
}
function sd(t) {
  return -Math.log(-t);
}
function ad(t) {
  return -Math.exp(-t);
}
function cd(t) {
  return isFinite(t) ? +('1e' + t) : t < 0 ? 0 : t;
}
function ld(t) {
  return (n, e) => -t(-n, e);
}
function fd(t) {
  const n = t(od, ud),
    e = n.domain;
  let r,
    i,
    o = 10;
  function u() {
    return (
      (r = (function (t) {
        return t === Math.E
          ? Math.log
          : (10 === t && Math.log10) || (2 === t && Math.log2) || ((t = Math.log(t)), n => Math.log(n) / t);
      })(o)),
      (i = (function (t) {
        return 10 === t ? cd : t === Math.E ? Math.exp : n => Math.pow(t, n);
      })(o)),
      e()[0] < 0 ? ((r = ld(r)), (i = ld(i)), t(sd, ad)) : t(od, ud),
      n
    );
  }
  return (
    (n.base = function (t) {
      return arguments.length ? ((o = +t), u()) : o;
    }),
    (n.domain = function (t) {
      return arguments.length ? (e(t), u()) : e();
    }),
    (n.ticks = t => {
      const n = e();
      let u = n[0],
        s = n[n.length - 1];
      const a = s < u;
      a && ([u, s] = [s, u]);
      let c,
        l,
        f = r(u),
        h = r(s);
      const d = null == t ? 10 : +t;
      let p = [];
      if (!(o % 1) && h - f < d) {
        if (((f = Math.floor(f)), (h = Math.ceil(h)), u > 0)) {
          for (; f <= h; ++f)
            for (c = 1; c < o; ++c)
              if (((l = f < 0 ? c / i(-f) : c * i(f)), !(l < u))) {
                if (l > s) break;
                p.push(l);
              }
        } else
          for (; f <= h; ++f)
            for (c = o - 1; c >= 1; --c)
              if (((l = f > 0 ? c / i(-f) : c * i(f)), !(l < u))) {
                if (l > s) break;
                p.push(l);
              }
        2 * p.length < d && (p = Gn(u, s, d));
      } else p = Gn(f, h, Math.min(h - f, d)).map(i);
      return a ? p.reverse() : p;
    }),
    (n.tickFormat = (t, e) => {
      if (
        (null == t && (t = 10),
        null == e && (e = 10 === o ? 's' : ','),
        'function' != typeof e && (o % 1 || null != (e = ce(e)).precision || (e.trim = !0), (e = me(e))),
        t === 1 / 0)
      )
        return e;
      const u = Math.max(1, (o * t) / n.ticks().length);
      return t => {
        let n = t / i(Math.round(r(t)));
        return n * o < o - 0.5 && (n *= o), n <= u ? e(t) : '';
      };
    }),
    (n.nice = () => e(id(e(), { floor: t => i(Math.floor(r(t))), ceil: t => i(Math.ceil(r(t))) }))),
    n
  );
}
function hd(t) {
  return function (n) {
    return Math.sign(n) * Math.log1p(Math.abs(n / t));
  };
}
function dd(t) {
  return function (n) {
    return Math.sign(n) * Math.expm1(Math.abs(n)) * t;
  };
}
function pd(t) {
  var n = 1,
    e = t(hd(n), dd(n));
  return (
    (e.constant = function (e) {
      return arguments.length ? t(hd((n = +e)), dd(n)) : n;
    }),
    rd(e)
  );
}
function md(t) {
  return function (n) {
    return n < 0 ? -Math.pow(-n, t) : Math.pow(n, t);
  };
}
function vd(t) {
  return t < 0 ? -Math.sqrt(-t) : Math.sqrt(t);
}
function gd(t) {
  return t < 0 ? -t * t : t * t;
}
function bd(t) {
  var n = t(Xh, Xh),
    e = 1;
  function r() {
    return 1 === e ? t(Xh, Xh) : 0.5 === e ? t(vd, gd) : t(md(e), md(1 / e));
  }
  return (
    (n.exponent = function (t) {
      return arguments.length ? ((e = +t), r()) : e;
    }),
    rd(n)
  );
}
function yd() {
  var t = bd(td());
  return (
    (t.copy = function () {
      return Kh(t, yd()).exponent(t.exponent());
    }),
    Ul.apply(t, arguments),
    t
  );
}
function wd(t) {
  return new Date(t);
}
function xd(t) {
  return t instanceof Date ? +t : +new Date(+t);
}
function Od(t, n, e, r, i, o, u, s, a, c) {
  var l = nd(),
    f = l.invert,
    h = l.domain,
    d = c('.%L'),
    p = c(':%S'),
    m = c('%I:%M'),
    v = c('%I %p'),
    g = c('%a %d'),
    b = c('%b %d'),
    y = c('%B'),
    w = c('%Y');
  function x(t) {
    return (
      a(t) < t ? d : s(t) < t ? p : u(t) < t ? m : o(t) < t ? v : r(t) < t ? (i(t) < t ? g : b) : e(t) < t ? y : w
    )(t);
  }
  return (
    (l.invert = function (t) {
      return new Date(f(t));
    }),
    (l.domain = function (t) {
      return arguments.length ? h(Array.from(t, xd)) : h().map(wd);
    }),
    (l.ticks = function (n) {
      var e = h();
      return t(e[0], e[e.length - 1], null == n ? 10 : n);
    }),
    (l.tickFormat = function (t, n) {
      return null == n ? x : c(n);
    }),
    (l.nice = function (t) {
      var e = h();
      return (
        (t && 'function' == typeof t.range) || (t = n(e[0], e[e.length - 1], null == t ? 10 : t)), t ? h(id(e, t)) : l
      );
    }),
    (l.copy = function () {
      return Kh(l, Od(t, n, e, r, i, o, u, s, a, c));
    }),
    l
  );
}
function kd() {
  var t,
    n,
    e,
    r,
    i,
    o = 0,
    u = 1,
    s = Xh,
    a = !1;
  function c(n) {
    return null == n || isNaN((n = +n))
      ? i
      : s(0 === e ? 0.5 : ((n = (r(n) - t) * e), a ? Math.max(0, Math.min(1, n)) : n));
  }
  function l(t) {
    return function (n) {
      var e, r;
      return arguments.length ? (([e, r] = n), (s = t(e, r)), c) : [s(0), s(1)];
    };
  }
  return (
    (c.domain = function (i) {
      return arguments.length
        ? (([o, u] = i), (t = r((o = +o))), (n = r((u = +u))), (e = t === n ? 0 : 1 / (n - t)), c)
        : [o, u];
    }),
    (c.clamp = function (t) {
      return arguments.length ? ((a = !!t), c) : a;
    }),
    (c.interpolator = function (t) {
      return arguments.length ? ((s = t), c) : s;
    }),
    (c.range = l($h)),
    (c.rangeRound = l(Mh)),
    (c.unknown = function (t) {
      return arguments.length ? ((i = t), c) : i;
    }),
    function (i) {
      return (r = i), (t = i(o)), (n = i(u)), (e = t === n ? 0 : 1 / (n - t)), c;
    }
  );
}
function Ad(t, n) {
  return n.domain(t.domain()).interpolator(t.interpolator()).clamp(t.clamp()).unknown(t.unknown());
}
function $d() {
  var t = rd(kd()(Xh));
  return (
    (t.copy = function () {
      return Ad(t, $d());
    }),
    Wl.apply(t, arguments)
  );
}
function Md() {
  var t = bd(kd());
  return (
    (t.copy = function () {
      return Ad(t, Md()).exponent(t.exponent());
    }),
    Wl.apply(t, arguments)
  );
}
function jd() {
  var t,
    n,
    e,
    r,
    i,
    o,
    u,
    s = 0,
    a = 0.5,
    c = 1,
    l = 1,
    f = Xh,
    h = !1;
  function d(t) {
    return isNaN((t = +t))
      ? u
      : ((t = 0.5 + ((t = +o(t)) - n) * (l * t < l * n ? r : i)), f(h ? Math.max(0, Math.min(1, t)) : t));
  }
  function p(t) {
    return function (n) {
      var e, r, i;
      return arguments.length ? (([e, r, i] = n), (f = Hh(t, [e, r, i])), d) : [f(0), f(0.5), f(1)];
    };
  }
  return (
    (d.domain = function (u) {
      return arguments.length
        ? (([s, a, c] = u),
          (t = o((s = +s))),
          (n = o((a = +a))),
          (e = o((c = +c))),
          (r = t === n ? 0 : 0.5 / (n - t)),
          (i = n === e ? 0 : 0.5 / (e - n)),
          (l = n < t ? -1 : 1),
          d)
        : [s, a, c];
    }),
    (d.clamp = function (t) {
      return arguments.length ? ((h = !!t), d) : h;
    }),
    (d.interpolator = function (t) {
      return arguments.length ? ((f = t), d) : f;
    }),
    (d.range = p($h)),
    (d.rangeRound = p(Mh)),
    (d.unknown = function (t) {
      return arguments.length ? ((u = t), d) : u;
    }),
    function (u) {
      return (
        (o = u),
        (t = u(s)),
        (n = u(a)),
        (e = u(c)),
        (r = t === n ? 0 : 0.5 / (n - t)),
        (i = n === e ? 0 : 0.5 / (e - n)),
        (l = n < t ? -1 : 1),
        d
      );
    }
  );
}
function Dd() {
  var t = bd(jd());
  return (
    (t.copy = function () {
      return Ad(t, Dd()).exponent(t.exponent());
    }),
    Wl.apply(t, arguments)
  );
}
function Fd(t, n, e) {
  const r = t - n + 2 * e;
  return t ? (r > 0 ? r : 1) : 0;
}
const Ed = 'linear',
  Sd = 'log',
  Cd = 'pow',
  Nd = 'sqrt',
  Bd = 'symlog',
  _d = 'time',
  zd = 'utc',
  Td = 'sequential',
  Pd = 'diverging',
  Rd = 'quantile',
  Ld = 'quantize',
  qd = 'threshold',
  Id = 'ordinal',
  Ud = 'point',
  Wd = 'band',
  Hd = 'bin-ordinal',
  Gd = 'continuous',
  Vd = 'discrete',
  Yd = 'discretizing',
  Xd = 'interpolating',
  Jd = 'temporal';
function Qd() {
  const t = Gl().unknown(void 0),
    n = t.domain,
    e = t.range;
  let r,
    i,
    o = [0, 1],
    u = !1,
    s = 0,
    a = 0,
    c = 0.5;
  function l() {
    const t = n().length,
      l = o[1] < o[0],
      f = o[1 - l],
      h = Fd(t, s, a);
    let d = o[l - 0];
    (r = (f - d) / (h || 1)),
      u && (r = Math.floor(r)),
      (d += (f - d - r * (t - s)) * c),
      (i = r * (1 - s)),
      u && ((d = Math.round(d)), (i = Math.round(i)));
    const p = re(t).map(t => d + r * t);
    return e(l ? p.reverse() : p);
  }
  return (
    delete t.unknown,
    (t.domain = function (t) {
      return arguments.length ? (n(t), l()) : n();
    }),
    (t.range = function (t) {
      return arguments.length ? ((o = [+t[0], +t[1]]), l()) : o.slice();
    }),
    (t.rangeRound = function (t) {
      return (o = [+t[0], +t[1]]), (u = !0), l();
    }),
    (t.bandwidth = function () {
      return i;
    }),
    (t.step = function () {
      return r;
    }),
    (t.round = function (t) {
      return arguments.length ? ((u = !!t), l()) : u;
    }),
    (t.padding = function (t) {
      return arguments.length ? ((a = Math.max(0, Math.min(1, t))), (s = a), l()) : s;
    }),
    (t.paddingInner = function (t) {
      return arguments.length ? ((s = Math.max(0, Math.min(1, t))), l()) : s;
    }),
    (t.paddingOuter = function (t) {
      return arguments.length ? ((a = Math.max(0, Math.min(1, t))), l()) : a;
    }),
    (t.align = function (t) {
      return arguments.length ? ((c = Math.max(0, Math.min(1, t))), l()) : c;
    }),
    (t.invertRange = function (t) {
      if (null == t[0] || null == t[1]) return;
      const r = o[1] < o[0],
        u = r ? e().reverse() : e(),
        s = u.length - 1;
      let a,
        c,
        l,
        f = +t[0],
        h = +t[1];
      return f != f || h != h || (h < f && ((l = f), (f = h), (h = l)), h < u[0] || f > o[1 - r])
        ? void 0
        : ((a = Math.max(0, Cn(u, f) - 1)),
          (c = f === h ? a : Cn(u, h) - 1),
          f - u[a] > i + 1e-10 && ++a,
          r && ((l = a), (a = s - c), (c = s - l)),
          a > c ? void 0 : n().slice(a, c + 1));
    }),
    (t.invert = function (n) {
      const e = t.invertRange([n, n]);
      return e ? e[0] : e;
    }),
    (t.copy = function () {
      return Qd().domain(n()).range(o).round(u).paddingInner(s).paddingOuter(a).align(c);
    }),
    l()
  );
}
function Zd(t) {
  const n = t.copy;
  return (
    (t.padding = t.paddingOuter),
    delete t.paddingInner,
    (t.copy = function () {
      return Zd(n());
    }),
    t
  );
}
var Kd = Array.prototype.map;
function tp(t) {
  return Kd.call(t, ut);
}
const np = Array.prototype.slice,
  ep = {};
function rp(t, n, e) {
  const r = function () {
    const e = n();
    return (
      e.invertRange ||
        (e.invertRange = e.invert
          ? ((r = e),
            function (t) {
              let n,
                e = t[0],
                i = t[1];
              return i < e && ((n = e), (e = i), (i = n)), [r.invert(e), r.invert(i)];
            })
          : e.invertExtent
          ? (function (t) {
              return function (n) {
                const e = t.range();
                let r,
                  i,
                  o,
                  u,
                  s = n[0],
                  a = n[1],
                  c = -1;
                for (a < s && ((i = s), (s = a), (a = i)), o = 0, u = e.length; o < u; ++o)
                  e[o] >= s && e[o] <= a && (c < 0 && (c = o), (r = o));
                if (!(c < 0))
                  return (
                    (s = t.invertExtent(e[c])),
                    (a = t.invertExtent(e[r])),
                    [void 0 === s[0] ? s[1] : s[0], void 0 === a[1] ? a[0] : a[1]]
                  );
              };
            })(e)
          : void 0),
      (e.type = t),
      e
    );
    var r;
  };
  return (r.metadata = cn(At(e))), r;
}
function ip(t, n, e) {
  return arguments.length > 1 ? ((ep[t] = rp(t, n, e)), this) : op(t) ? ep[t] : void 0;
}
function op(t) {
  return Pt(ep, t);
}
function up(t, n) {
  const e = ep[t];
  return e && e.metadata[n];
}
function sp(t) {
  return up(t, Gd);
}
function ap(t) {
  return up(t, Vd);
}
function cp(t) {
  return up(t, Yd);
}
function lp(t) {
  return up(t, Sd);
}
function fp(t) {
  return up(t, Xd);
}
function hp(t) {
  return up(t, Rd);
}
ip('identity', function t(n) {
  var e;
  function r(t) {
    return null == t || isNaN((t = +t)) ? e : t;
  }
  return (
    (r.invert = r),
    (r.domain = r.range =
      function (t) {
        return arguments.length ? ((n = Array.from(t, Vh)), r) : n.slice();
      }),
    (r.unknown = function (t) {
      return arguments.length ? ((e = t), r) : e;
    }),
    (r.copy = function () {
      return t(n).unknown(e);
    }),
    (n = arguments.length ? Array.from(n, Vh) : [0, 1]),
    rd(r)
  );
}),
  ip(
    Ed,
    function t() {
      var n = nd();
      return (
        (n.copy = function () {
          return Kh(n, t());
        }),
        Ul.apply(n, arguments),
        rd(n)
      );
    },
    Gd,
  ),
  ip(
    Sd,
    function t() {
      const n = fd(td()).domain([1, 10]);
      return (n.copy = () => Kh(n, t()).base(n.base())), Ul.apply(n, arguments), n;
    },
    [Gd, Sd],
  ),
  ip(Cd, yd, Gd),
  ip(
    Nd,
    function () {
      return yd.apply(null, arguments).exponent(0.5);
    },
    Gd,
  ),
  ip(
    Bd,
    function t() {
      var n = pd(td());
      return (
        (n.copy = function () {
          return Kh(n, t()).constant(n.constant());
        }),
        Ul.apply(n, arguments)
      );
    },
    Gd,
  ),
  ip(
    _d,
    function () {
      return Ul.apply(
        Od(er, rr, Qe, Xe, Ie, Pe, ze, Be, Ne, di).domain([new Date(2e3, 0, 1), new Date(2e3, 0, 2)]),
        arguments,
      );
    },
    [Gd, Jd],
  ),
  ip(
    zd,
    function () {
      return Ul.apply(
        Od(tr, nr, Ze, Je, Ge, Re, Te, _e, Ne, mi).domain([Date.UTC(2e3, 0, 1), Date.UTC(2e3, 0, 2)]),
        arguments,
      );
    },
    [Gd, Jd],
  ),
  ip(Td, $d, [Gd, Xd]),
  ip(''.concat(Td, '-').concat(Ed), $d, [Gd, Xd]),
  ip(
    ''.concat(Td, '-').concat(Sd),
    function t() {
      var n = fd(kd()).domain([1, 10]);
      return (
        (n.copy = function () {
          return Ad(n, t()).base(n.base());
        }),
        Wl.apply(n, arguments)
      );
    },
    [Gd, Xd, Sd],
  ),
  ip(''.concat(Td, '-').concat(Cd), Md, [Gd, Xd]),
  ip(
    ''.concat(Td, '-').concat(Nd),
    function () {
      return Md.apply(null, arguments).exponent(0.5);
    },
    [Gd, Xd],
  ),
  ip(
    ''.concat(Td, '-').concat(Bd),
    function t() {
      var n = pd(kd());
      return (
        (n.copy = function () {
          return Ad(n, t()).constant(n.constant());
        }),
        Wl.apply(n, arguments)
      );
    },
    [Gd, Xd],
  ),
  ip(
    ''.concat(Pd, '-').concat(Ed),
    function t() {
      var n = rd(jd()(Xh));
      return (
        (n.copy = function () {
          return Ad(n, t());
        }),
        Wl.apply(n, arguments)
      );
    },
    [Gd, Xd],
  ),
  ip(
    ''.concat(Pd, '-').concat(Sd),
    function t() {
      var n = fd(jd()).domain([0.1, 1, 10]);
      return (
        (n.copy = function () {
          return Ad(n, t()).base(n.base());
        }),
        Wl.apply(n, arguments)
      );
    },
    [Gd, Xd, Sd],
  ),
  ip(''.concat(Pd, '-').concat(Cd), Dd, [Gd, Xd]),
  ip(
    ''.concat(Pd, '-').concat(Nd),
    function () {
      return Dd.apply(null, arguments).exponent(0.5);
    },
    [Gd, Xd],
  ),
  ip(
    ''.concat(Pd, '-').concat(Bd),
    function t() {
      var n = pd(jd());
      return (
        (n.copy = function () {
          return Ad(n, t()).constant(n.constant());
        }),
        Wl.apply(n, arguments)
      );
    },
    [Gd, Xd],
  ),
  ip(
    Rd,
    function t() {
      var n,
        e = [],
        r = [],
        i = [];
      function o() {
        var t = 0,
          n = Math.max(1, r.length);
        for (i = new Array(n - 1); ++t < n; ) i[t - 1] = te(e, t / n);
        return u;
      }
      function u(t) {
        return null == t || isNaN((t = +t)) ? n : r[Cn(i, t)];
      }
      return (
        (u.invertExtent = function (t) {
          var n = r.indexOf(t);
          return n < 0 ? [NaN, NaN] : [n > 0 ? i[n - 1] : e[0], n < i.length ? i[n] : e[e.length - 1]];
        }),
        (u.domain = function (t) {
          if (!arguments.length) return e.slice();
          e = [];
          for (let n of t) null == n || isNaN((n = +n)) || e.push(n);
          return e.sort(Mn), o();
        }),
        (u.range = function (t) {
          return arguments.length ? ((r = Array.from(t)), o()) : r.slice();
        }),
        (u.unknown = function (t) {
          return arguments.length ? ((n = t), u) : n;
        }),
        (u.quantiles = function () {
          return i.slice();
        }),
        (u.copy = function () {
          return t().domain(e).range(r).unknown(n);
        }),
        Ul.apply(u, arguments)
      );
    },
    [Yd, Rd],
  ),
  ip(
    Ld,
    function t() {
      var n,
        e = 0,
        r = 1,
        i = 1,
        o = [0.5],
        u = [0, 1];
      function s(t) {
        return null != t && t <= t ? u[Cn(o, t, 0, i)] : n;
      }
      function a() {
        var t = -1;
        for (o = new Array(i); ++t < i; ) o[t] = ((t + 1) * r - (t - i) * e) / (i + 1);
        return s;
      }
      return (
        (s.domain = function (t) {
          return arguments.length ? (([e, r] = t), (e = +e), (r = +r), a()) : [e, r];
        }),
        (s.range = function (t) {
          return arguments.length ? ((i = (u = Array.from(t)).length - 1), a()) : u.slice();
        }),
        (s.invertExtent = function (t) {
          var n = u.indexOf(t);
          return n < 0 ? [NaN, NaN] : n < 1 ? [e, o[0]] : n >= i ? [o[i - 1], r] : [o[n - 1], o[n]];
        }),
        (s.unknown = function (t) {
          return arguments.length ? ((n = t), s) : s;
        }),
        (s.thresholds = function () {
          return o.slice();
        }),
        (s.copy = function () {
          return t().domain([e, r]).range(u).unknown(n);
        }),
        Ul.apply(rd(s), arguments)
      );
    },
    Yd,
  ),
  ip(
    qd,
    function t() {
      var n,
        e = [0.5],
        r = [0, 1],
        i = 1;
      function o(t) {
        return null != t && t <= t ? r[Cn(e, t, 0, i)] : n;
      }
      return (
        (o.domain = function (t) {
          return arguments.length ? ((e = Array.from(t)), (i = Math.min(e.length, r.length - 1)), o) : e.slice();
        }),
        (o.range = function (t) {
          return arguments.length ? ((r = Array.from(t)), (i = Math.min(e.length, r.length - 1)), o) : r.slice();
        }),
        (o.invertExtent = function (t) {
          var n = r.indexOf(t);
          return [e[n - 1], e[n]];
        }),
        (o.unknown = function (t) {
          return arguments.length ? ((n = t), o) : n;
        }),
        (o.copy = function () {
          return t().domain(e).range(r).unknown(n);
        }),
        Ul.apply(o, arguments)
      );
    },
    Yd,
  ),
  ip(
    Hd,
    function t() {
      let n = [],
        e = [];
      function r(t) {
        return null == t || t != t ? void 0 : e[(Cn(n, t) - 1) % e.length];
      }
      return (
        (r.domain = function (t) {
          return arguments.length ? ((n = tp(t)), r) : n.slice();
        }),
        (r.range = function (t) {
          return arguments.length ? ((e = np.call(t)), r) : e.slice();
        }),
        (r.tickFormat = function (t, e) {
          return ed(n[0], ot(n), null == t ? 10 : t, e);
        }),
        (r.copy = function () {
          return t().domain(r.domain()).range(r.range());
        }),
        r
      );
    },
    [Vd, Yd],
  ),
  ip(Id, Gl, Vd),
  ip(Wd, Qd, Vd),
  ip(
    Ud,
    function () {
      return Zd(Qd().paddingInner(1));
    },
    Vd,
  );
const dp = ['clamp', 'base', 'constant', 'exponent'];
function pp(t, n) {
  const e = n[0],
    r = ot(n) - e;
  return function (n) {
    return t(e + n * r);
  };
}
function mp(t, n, e) {
  return Hh(bp(n || 'rgb', e), t);
}
function vp(t, n) {
  const e = new Array(n),
    r = n + 1;
  for (let i = 0; i < n; ) e[i] = t(++i / r);
  return e;
}
function gp(t, n, e) {
  const r = e - n;
  let i, o, u;
  return r && Number.isFinite(r)
    ? ((i = (o = t.type).indexOf('-')),
      (o = i < 0 ? o : o.slice(i + 1)),
      (u = ip(o)().domain([n, e]).range([0, 1])),
      dp.forEach(n => (t[n] ? u[n](t[n]()) : 0)),
      u)
    : Ct(0.5);
}
function bp(t, n) {
  const e =
    Gh[
      (function (t) {
        return (
          'interpolate' +
          t
            .toLowerCase()
            .split('-')
            .map(t => t[0].toUpperCase() + t.slice(1))
            .join('')
        );
      })(t)
    ];
  return null != n && e && e.gamma ? e.gamma(n) : e;
}
function yp(t) {
  const n = (t.length / 6) | 0,
    e = new Array(n);
  for (let r = 0; r < n; ) e[r] = '#' + t.slice(6 * r, 6 * ++r);
  return e;
}
function wp(t, n) {
  for (const e in t) Op(e, n(t[e]));
}
const xp = {};
function Op(t, n) {
  return (t = t && t.toLowerCase()), arguments.length > 1 ? ((xp[t] = n), this) : xp[t];
}
wp(
  {
    category10: '1f77b4ff7f0e2ca02cd627289467bd8c564be377c27f7f7fbcbd2217becf',
    category20:
      '1f77b4aec7e8ff7f0effbb782ca02c98df8ad62728ff98969467bdc5b0d58c564bc49c94e377c2f7b6d27f7f7fc7c7c7bcbd22dbdb8d17becf9edae5',
    category20b:
      '393b795254a36b6ecf9c9ede6379398ca252b5cf6bcedb9c8c6d31bd9e39e7ba52e7cb94843c39ad494ad6616be7969c7b4173a55194ce6dbdde9ed6',
    category20c:
      '3182bd6baed69ecae1c6dbefe6550dfd8d3cfdae6bfdd0a231a35474c476a1d99bc7e9c0756bb19e9ac8bcbddcdadaeb636363969696bdbdbdd9d9d9',
    tableau10: '4c78a8f58518e4575672b7b254a24beeca3bb279a2ff9da69d755dbab0ac',
    tableau20:
      '4c78a89ecae9f58518ffbf7954a24b88d27ab79a20f2cf5b43989483bcb6e45756ff9d9879706ebab0acd67195fcbfd2b279a2d6a5c99e765fd8b5a5',
    accent: '7fc97fbeaed4fdc086ffff99386cb0f0027fbf5b17666666',
    dark2: '1b9e77d95f027570b3e7298a66a61ee6ab02a6761d666666',
    paired: 'a6cee31f78b4b2df8a33a02cfb9a99e31a1cfdbf6fff7f00cab2d66a3d9affff99b15928',
    pastel1: 'fbb4aeb3cde3ccebc5decbe4fed9a6ffffcce5d8bdfddaecf2f2f2',
    pastel2: 'b3e2cdfdcdaccbd5e8f4cae4e6f5c9fff2aef1e2cccccccc',
    set1: 'e41a1c377eb84daf4a984ea3ff7f00ffff33a65628f781bf999999',
    set2: '66c2a5fc8d628da0cbe78ac3a6d854ffd92fe5c494b3b3b3',
    set3: '8dd3c7ffffb3bebadafb807280b1d3fdb462b3de69fccde5d9d9d9bc80bdccebc5ffed6f',
  },
  yp,
),
  wp(
    {
      blues: 'cfe1f2bed8eca8cee58fc1de74b2d75ba3cf4592c63181bd206fb2125ca40a4a90',
      greens: 'd3eecdc0e6baabdda594d3917bc77d60ba6c46ab5e329a512089430e7735036429',
      greys: 'e2e2e2d4d4d4c4c4c4b1b1b19d9d9d8888887575756262624d4d4d3535351e1e1e',
      oranges: 'fdd8b3fdc998fdb87bfda55efc9244f87f2cf06b18e4580bd14904b93d029f3303',
      purples: 'e2e1efd4d4e8c4c5e0b4b3d6a3a0cc928ec3827cb97566ae684ea25c3696501f8c',
      reds: 'fdc9b4fcb49afc9e80fc8767fa7051f6573fec3f2fdc2a25c81b1db21218970b13',
      blueGreen: 'd5efedc1e8e0a7ddd18bd2be70c6a958ba9144ad77319c5d2089460e7736036429',
      bluePurple: 'ccddecbad0e4a8c2dd9ab0d4919cc98d85be8b6db28a55a6873c99822287730f71',
      greenBlue: 'd3eecec5e8c3b1e1bb9bd8bb82cec269c2ca51b2cd3c9fc7288abd1675b10b60a1',
      orangeRed: 'fddcaffdcf9bfdc18afdad77fb9562f67d53ee6545e24932d32d1ebf130da70403',
      purpleBlue: 'dbdaebc8cee4b1c3de97b7d87bacd15b9fc93a90c01e7fb70b70ab056199045281',
      purpleBlueGreen: 'dbd8eac8cee4b0c3de93b7d872acd1549fc83892bb1c88a3097f8702736b016353',
      purpleRed: 'dcc9e2d3b3d7ce9eccd186c0da6bb2e14da0e23189d91e6fc61159ab07498f023a',
      redPurple: 'fccfccfcbec0faa9b8f98faff571a5ec539ddb3695c41b8aa908808d0179700174',
      yellowGreen: 'e4f4acd1eca0b9e2949ed68880c97c62bb6e47aa5e3297502083440e723b036034',
      yellowOrangeBrown: 'feeaa1fedd84fecc63feb746fca031f68921eb7215db5e0bc54c05ab3d038f3204',
      yellowOrangeRed: 'fee087fed16ffebd59fea849fd903efc7335f9522bee3423de1b20ca0b22af0225',
      blueOrange: '134b852f78b35da2cb9dcae1d2e5eff2f0ebfce0bafbbf74e8932fc5690d994a07',
      brownBlueGreen: '704108a0651ac79548e3c78af3e6c6eef1eac9e9e48ed1c74da79e187a72025147',
      purpleGreen: '5b1667834792a67fb6c9aed3e6d6e8eff0efd9efd5aedda971bb75368e490e5e29',
      purpleOrange: '4114696647968f83b7b9b4d6dadbebf3eeeafce0bafbbf74e8932fc5690d994a07',
      redBlue: '8c0d25bf363adf745ef4ae91fbdbc9f2efeed2e5ef9dcae15da2cb2f78b3134b85',
      redGrey: '8c0d25bf363adf745ef4ae91fcdccbfaf4f1e2e2e2c0c0c0969696646464343434',
      yellowGreenBlue: 'eff9bddbf1b4bde5b594d5b969c5be45b4c22c9ec02182b82163aa23479c1c3185',
      redYellowBlue: 'a50026d4322cf16e43fcac64fedd90faf8c1dcf1ecabd6e875abd04a74b4313695',
      redYellowGreen: 'a50026d4322cf16e43fcac63fedd8df9f7aed7ee8ea4d86e64bc6122964f006837',
      pinkYellowGreen: '8e0152c0267edd72adf0b3d6faddedf5f3efe1f2cab6de8780bb474f9125276419',
      spectral: '9e0142d13c4bf0704afcac63fedd8dfbf8b0e0f3a1a9dda269bda94288b55e4fa2',
      viridis:
        '440154470e61481a6c482575472f7d443a834144873d4e8a39568c35608d31688e2d708e2a788e27818e23888e21918d1f988b1fa08822a8842ab07f35b77943bf7154c56866cc5d7ad1518fd744a5db36bcdf27d2e21be9e51afde725',
      magma:
        '0000040404130b0924150e3720114b2c11603b0f704a107957157e651a80721f817f24828c29819a2e80a8327db6377ac43c75d1426fde4968e95462f1605df76f5cfa7f5efc8f65fe9f6dfeaf78febf84fece91fddea0fcedaffcfdbf',
      inferno:
        '0000040403130c0826170c3b240c4f330a5f420a68500d6c5d126e6b176e781c6d86216b932667a12b62ae305cbb3755c73e4cd24644dd513ae65c30ed6925f3771af8850ffb9506fca50afcb519fac62df6d645f2e661f3f484fcffa4',
      plasma:
        '0d088723069033059742039d5002a25d01a66a00a87801a88405a7900da49c179ea72198b12a90ba3488c33d80cb4779d35171da5a69e16462e76e5bed7953f2834cf68f44fa9a3dfca636fdb32ffec029fcce25f9dc24f5ea27f0f921',
      cividis:
        '00205100235800265d002961012b65042e670831690d346b11366c16396d1c3c6e213f6e26426e2c456e31476e374a6e3c4d6e42506e47536d4c566d51586e555b6e5a5e6e5e616e62646f66676f6a6a706e6d717270717573727976737c79747f7c75827f758682768985778c8877908b78938e789691789a94789e9778a19b78a59e77a9a177aea575b2a874b6ab73bbaf71c0b26fc5b66dc9b96acebd68d3c065d8c462ddc85fe2cb5ce7cf58ebd355f0d652f3da4ff7de4cfae249fce647',
      rainbow:
        '6e40aa883eb1a43db3bf3cafd83fa4ee4395fe4b83ff576eff6659ff7847ff8c38f3a130e2b72fcfcc36bee044aff05b8ff4576ff65b52f6673af27828ea8d1ddfa319d0b81cbecb23abd82f96e03d82e14c6edb5a5dd0664dbf6e40aa',
      sinebow:
        'ff4040fc582af47218e78d0bd5a703bfbf00a7d5038de70b72f41858fc2a40ff402afc5818f4720be78d03d5a700bfbf03a7d50b8de71872f42a58fc4040ff582afc7218f48d0be7a703d5bf00bfd503a7e70b8df41872fc2a58ff4040',
      turbo:
        '23171b32204a3e2a71453493493eae4b49c54a53d7485ee44569ee4074f53c7ff8378af93295f72e9ff42ba9ef28b3e926bce125c5d925cdcf27d5c629dcbc2de3b232e9a738ee9d3ff39347f68950f9805afc7765fd6e70fe667cfd5e88fc5795fb51a1f84badf545b9f140c5ec3cd0e637dae034e4d931ecd12ef4c92bfac029ffb626ffad24ffa223ff9821ff8d1fff821dff771cfd6c1af76118f05616e84b14df4111d5380fcb2f0dc0260ab61f07ac1805a313029b0f00950c00910b00',
      browns: 'eedbbdecca96e9b97ae4a865dc9856d18954c7784cc0673fb85536ad44339f3632',
      tealBlues: 'bce4d89dd3d181c3cb65b3c245a2b9368fae347da0306a932c5985',
      teals: 'bbdfdfa2d4d58ac9c975bcbb61b0af4da5a43799982b8b8c1e7f7f127273006667',
      warmGreys: 'dcd4d0cec5c1c0b8b4b3aaa7a59c9998908c8b827f7e7673726866665c5a59504e',
      goldGreen: 'f4d166d5ca60b6c35c98bb597cb25760a6564b9c533f8f4f33834a257740146c36',
      goldOrange: 'f4d166f8be5cf8aa4cf5983bf3852aef701be2621fd65322c54923b142239e3a26',
      goldRed: 'f4d166f6be59f9aa51fc964ef6834bee734ae56249db5247cf4244c43141b71d3e',
      lightGreyRed: 'efe9e6e1dad7d5cbc8c8bdb9bbaea9cd967ddc7b43e15f19df4011dc000b',
      lightGreyTeal: 'e4eaead6dcddc8ced2b7c2c7a6b4bc64b0bf22a6c32295c11f85be1876bc',
      lightMulti: 'e0f1f2c4e9d0b0de9fd0e181f6e072f6c053f3993ef77440ef4a3c',
      lightOrange: 'f2e7daf7d5baf9c499fab184fa9c73f68967ef7860e8645bde515bd43d5b',
      lightTealBlue: 'e3e9e0c0dccf9aceca7abfc859afc0389fb9328dad2f7ca0276b95255988',
      darkBlue: '3232322d46681a5c930074af008cbf05a7ce25c0dd38daed50f3faffffff',
      darkGold: '3c3c3c584b37725e348c7631ae8b2bcfa424ecc31ef9de30fff184ffffff',
      darkGreen: '3a3a3a215748006f4d048942489e4276b340a6c63dd2d836ffeb2cffffaa',
      darkMulti: '3737371f5287197d8c29a86995ce3fffe800ffffff',
      darkRed: '3434347036339e3c38cc4037e75d1eec8620eeab29f0ce32ffeb2c',
    },
    t => mp(yp(t)),
  );
const kp = 'symbol',
  Ap = t => (K(t) ? t.map(t => String(t)) : String(t)),
  $p = (t, n) => t[1] - n[1],
  Mp = (t, n) => n[1] - t[1];
function jp(t, n, e) {
  let r;
  return (
    Vt(n) &&
      (t.bins && (n = Math.max(n, t.bins.length)), null != e && (n = Math.min(n, Math.floor(en(t.domain()) / e || 1)))),
    tt(n) && ((r = n.step), (n = n.interval)),
    Xt(n) &&
      ((n = t.type === _d ? Wr(n) : t.type == zd ? Hr(n) : I('Only time and utc scales accept interval strings.')),
      r && (n = n.every(r))),
    n
  );
}
function Dp(t, n, e) {
  let r = t.range(),
    i = r[0],
    o = ot(r),
    u = $p;
  if (
    (i > o && ((r = o), (o = i), (i = r), (u = Mp)),
    (i = Math.floor(i)),
    (o = Math.ceil(o)),
    (n = n
      .map(n => [n, t(n)])
      .filter(t => i <= t[1] && t[1] <= o)
      .sort(u)
      .map(t => t[0])),
    e > 0 && n.length > 1)
  ) {
    const t = [n[0], ot(n)];
    for (; n.length > e && n.length >= 3; ) n = n.filter((t, n) => !(n % 2));
    n.length < 3 && (n = t);
  }
  return n;
}
function Fp(t, n) {
  return t.bins ? Dp(t, t.bins) : t.ticks ? t.ticks(n) : t.domain();
}
function Ep(t, n, e, r, i, o) {
  const u = n.type;
  let s = Ap;
  if (u === _d || i === _d) s = t.timeFormat(r);
  else if (u === zd || i === zd) s = t.utcFormat(r);
  else if (lp(u)) {
    const i = t.formatFloat(r);
    if (o || n.bins) s = i;
    else {
      const t = Sp(n, e, !1);
      s = n => (t(n) ? i(n) : '');
    }
  } else if (n.tickFormat) {
    const i = n.domain();
    s = t.formatSpan(i[0], i[i.length - 1], e, r);
  } else r && (s = t.format(r));
  return s;
}
function Sp(t, n, e) {
  const r = Fp(t, n),
    i = t.base(),
    o = Math.log(i),
    u = Math.max(1, (i * n) / r.length),
    s = t => {
      let n = t / Math.pow(i, Math.round(Math.log(t) / o));
      return n * i < i - 0.5 && (n *= i), n <= u;
    };
  return e ? r.filter(s) : s;
}
const Cp = { [Rd]: 'quantiles', [Ld]: 'thresholds', [qd]: 'domain' },
  Np = { [Rd]: 'quantiles', [Ld]: 'domain' };
function Bp(t, n) {
  return t.bins
    ? (function (t) {
        const n = t.slice(0, -1);
        return (n.max = ot(t)), n;
      })(t.bins)
    : t.type === Sd
    ? Sp(t, n, !0)
    : Cp[t.type]
    ? (function (t) {
        const n = [-1 / 0].concat(t);
        return (n.max = 1 / 0), n;
      })(t[Cp[t.type]]())
    : Fp(t, n);
}
function _p(t, n, e, r, i, o, u) {
  const s =
    Np[n.type] && o !== _d && o !== zd
      ? (function (t, n, e) {
          const r = n[Np[n.type]](),
            i = r.length;
          let o,
            u = i > 1 ? r[1] - r[0] : r[0];
          for (o = 1; o < i; ++o) u = Math.min(u, r[o] - r[o - 1]);
          return t.formatSpan(0, u, 30, e);
        })(t, n, i)
      : Ep(t, n, e, i, o, u);
  return r === kp && (t => Cp[t.type] || t.bins)(n) ? zp(s) : 'discrete' === r ? Pp(s) : Rp(s);
}
const zp = t => (n, e, r) => {
    const i = Tp(r[e + 1], Tp(r.max, 1 / 0)),
      o = Lp(n, t),
      u = Lp(i, t);
    return o && u ? o + ' – ' + u : u ? '< ' + u : '≥ ' + o;
  },
  Tp = (t, n) => (null != t ? t : n),
  Pp = t => (n, e) => (e ? t(n) : null),
  Rp = t => n => t(n),
  Lp = (t, n) => (Number.isFinite(t) ? n(t) : null);
function qp(t, n, e) {
  e = e || {};
  const r = Math.max(3, e.maxlen || 7),
    i = (function (t, n, e, r) {
      const i = r || n.type;
      return (
        Xt(e) &&
          (function (t) {
            return up(t, Jd);
          })(i) &&
          (e = e.replace(/%a/g, '%A').replace(/%b/g, '%B')),
        e || i !== _d
          ? e || i !== zd
            ? _p(t, n, 5, null, e, r, !0)
            : t.utcFormat('%A, %d %B %Y, %X UTC')
          : t.timeFormat('%A, %d %B %Y, %X')
      );
    })(t, n, e.format, e.formatType);
  if (cp(n.type)) {
    const t = Bp(n).slice(1).map(i),
      e = t.length;
    return ''
      .concat(e, ' boundar')
      .concat(1 === e ? 'y' : 'ies', ': ')
      .concat(t.join(', '));
  }
  if (ap(n.type)) {
    const t = n.domain(),
      e = t.length,
      o =
        e > r
          ? t
              .slice(0, r - 2)
              .map(i)
              .join(', ') +
            ', ending with ' +
            t.slice(-1).map(i)
          : t.map(i).join(', ');
    return ''
      .concat(e, ' value')
      .concat(1 === e ? '' : 's', ': ')
      .concat(o);
  }
  {
    const t = n.domain();
    return 'values from '.concat(i(t[0]), ' to ').concat(i(ot(t)));
  }
}
let Ip = 0;
const Up = 'p_';
function Wp(t) {
  return t && t.gradient;
}
function Hp(t, n, e) {
  const r = t.gradient;
  let i = t.id,
    o = 'radial' === r ? Up : '';
  return (
    i ||
      ((i = t.id = 'gradient_' + Ip++),
      'radial' === r
        ? ((t.x1 = Gp(t.x1, 0.5)),
          (t.y1 = Gp(t.y1, 0.5)),
          (t.r1 = Gp(t.r1, 0)),
          (t.x2 = Gp(t.x2, 0.5)),
          (t.y2 = Gp(t.y2, 0.5)),
          (t.r2 = Gp(t.r2, 0.5)),
          (o = Up))
        : ((t.x1 = Gp(t.x1, 0)), (t.y1 = Gp(t.y1, 0)), (t.x2 = Gp(t.x2, 1)), (t.y2 = Gp(t.y2, 0)))),
    (n[i] = t),
    'url(' + (e || '') + '#' + o + i + ')'
  );
}
function Gp(t, n) {
  return null != t ? t : n;
}
function Vp(t, n) {
  var e,
    r = [];
  return (e = {
    gradient: 'linear',
    x1: t ? t[0] : 0,
    y1: t ? t[1] : 0,
    x2: n ? n[0] : 1,
    y2: n ? n[1] : 0,
    stops: r,
    stop: function (t, n) {
      return r.push({ offset: t, color: n }), e;
    },
  });
}
const Yp = {
  basis: {
    curve: function (t) {
      return new fl(t);
    },
  },
  'basis-closed': {
    curve: function (t) {
      return new hl(t);
    },
  },
  'basis-open': {
    curve: function (t) {
      return new dl(t);
    },
  },
  bundle: { curve: ml, tension: 'beta', value: 0.85 },
  cardinal: { curve: bl, tension: 'tension', value: 0 },
  'cardinal-open': { curve: Ol, tension: 'tension', value: 0 },
  'cardinal-closed': { curve: wl, tension: 'tension', value: 0 },
  'catmull-rom': { curve: $l, tension: 'alpha', value: 0.5 },
  'catmull-rom-closed': { curve: jl, tension: 'alpha', value: 0.5 },
  'catmull-rom-open': { curve: Fl, tension: 'alpha', value: 0.5 },
  linear: { curve: rl },
  'linear-closed': {
    curve: function (t) {
      return new El(t);
    },
  },
  monotone: {
    horizontal: function (t) {
      return new zl(t);
    },
    vertical: function (t) {
      return new _l(t);
    },
  },
  natural: {
    curve: function (t) {
      return new Pl(t);
    },
  },
  step: {
    curve: function (t) {
      return new Ll(t, 0.5);
    },
  },
  'step-after': {
    curve: function (t) {
      return new Ll(t, 1);
    },
  },
  'step-before': {
    curve: function (t) {
      return new Ll(t, 0);
    },
  },
};
function Xp(t, n, e) {
  var r = Pt(Yp, t) && Yp[t],
    i = null;
  return r && ((i = r.curve || r[n || 'vertical']), r.tension && null != e && (i = i[r.tension](e))), i;
}
const Jp = { m: 2, l: 2, h: 1, v: 1, z: 0, c: 6, s: 4, q: 4, t: 2, a: 7 },
  Qp = /[mlhvzcsqta]([^mlhvzcsqta]+|$)/gi,
  Zp = /^[+-]?(([0-9]*\.[0-9]+)|([0-9]+\.)|([0-9]+))([eE][+-]?[0-9]+)?/,
  Kp = /^((\s+,?\s*)|(,\s*))/,
  tm = /^[01]/;
function nm(t) {
  const n = [];
  return (
    (t.match(Qp) || []).forEach(t => {
      let e = t[0];
      const r = e.toLowerCase(),
        i = Jp[r],
        o = (function (t, n, e) {
          const r = [];
          for (let i = 0; n && i < e.length; )
            for (let o = 0; o < n; ++o) {
              const n = 'a' !== t || (3 !== o && 4 !== o) ? Zp : tm,
                u = e.slice(i).match(n);
              if (null === u) throw Error('Invalid SVG path, incorrect parameter type');
              (i += u[0].length), r.push(+u[0]);
              const s = e.slice(i).match(Kp);
              null !== s && (i += s[0].length);
            }
          return r;
        })(r, i, t.slice(1).trim()),
        u = o.length;
      if (u < i || (u && u % i != 0)) throw Error('Invalid SVG path, incorrect parameter count');
      if ((n.push([e, ...o.slice(0, i)]), u !== i)) {
        'm' === r && (e = 'M' === e ? 'L' : 'l');
        for (let t = i; t < u; t += i) n.push([e, ...o.slice(t, t + i)]);
      }
    }),
    n
  );
}
const em = Math.PI / 180,
  rm = Math.PI / 2,
  im = 2 * Math.PI,
  om = Math.sqrt(3) / 2;
var um = {},
  sm = {},
  am = [].join;
function cm(t) {
  const n = am.call(t);
  if (sm[n]) return sm[n];
  var e = t[0],
    r = t[1],
    i = t[2],
    o = t[3],
    u = t[4],
    s = t[5],
    a = t[6],
    c = t[7];
  const l = c * u,
    f = -a * s,
    h = a * u,
    d = c * s,
    p = Math.cos(i),
    m = Math.sin(i),
    v = Math.cos(o),
    g = Math.sin(o),
    b = 0.5 * (o - i),
    y = Math.sin(0.5 * b),
    w = ((8 / 3) * y * y) / Math.sin(b),
    x = e + p - w * m,
    O = r + m + w * p,
    k = e + v,
    A = r + g,
    $ = k + w * g,
    M = A - w * v;
  return (sm[n] = [l * x + f * O, h * x + d * O, l * $ + f * M, h * $ + d * M, l * k + f * A, h * k + d * A]);
}
const lm = ['l', 0, 0, 0, 0, 0, 0, 0];
function fm(t, n, e) {
  const r = (lm[0] = t[0]);
  if ('a' === r || 'A' === r)
    (lm[1] = n * t[1]),
      (lm[2] = e * t[2]),
      (lm[3] = t[3]),
      (lm[4] = t[4]),
      (lm[5] = t[5]),
      (lm[6] = n * t[6]),
      (lm[7] = e * t[7]);
  else if ('h' === r || 'H' === r) lm[1] = n * t[1];
  else if ('v' === r || 'V' === r) lm[1] = e * t[1];
  else for (var i = 1, o = t.length; i < o; ++i) lm[i] = (i % 2 == 1 ? n : e) * t[i];
  return lm;
}
function hm(t, n, e, r, i, o) {
  var u,
    s,
    a,
    c,
    l,
    f = null,
    h = 0,
    d = 0,
    p = 0,
    m = 0,
    v = 0,
    g = 0;
  null == e && (e = 0), null == r && (r = 0), null == i && (i = 1), null == o && (o = i), t.beginPath && t.beginPath();
  for (var b = 0, y = n.length; b < y; ++b) {
    switch (((u = n[b]), (1 === i && 1 === o) || (u = fm(u, i, o)), u[0])) {
      case 'l':
        t.lineTo((h += u[1]) + e, (d += u[2]) + r);
        break;
      case 'L':
        t.lineTo((h = u[1]) + e, (d = u[2]) + r);
        break;
      case 'h':
        t.lineTo((h += u[1]) + e, d + r);
        break;
      case 'H':
        t.lineTo((h = u[1]) + e, d + r);
        break;
      case 'v':
        t.lineTo(h + e, (d += u[1]) + r);
        break;
      case 'V':
        t.lineTo(h + e, (d = u[1]) + r);
        break;
      case 'm':
        (v = h += u[1]), (g = d += u[2]), t.moveTo(h + e, d + r);
        break;
      case 'M':
        (v = h = u[1]), (g = d = u[2]), t.moveTo(h + e, d + r);
        break;
      case 'c':
        t.bezierCurveTo(
          h + u[1] + e,
          d + u[2] + r,
          (p = h + u[3]) + e,
          (m = d + u[4]) + r,
          (s = h + u[5]) + e,
          (a = d + u[6]) + r,
        ),
          (h = s),
          (d = a);
        break;
      case 'C':
        t.bezierCurveTo(u[1] + e, u[2] + r, (p = u[3]) + e, (m = u[4]) + r, (h = u[5]) + e, (d = u[6]) + r);
        break;
      case 's':
        t.bezierCurveTo(
          (p = 2 * h - p) + e,
          (m = 2 * d - m) + r,
          h + u[1] + e,
          d + u[2] + r,
          (s = h + u[3]) + e,
          (a = d + u[4]) + r,
        ),
          (p = h + u[1]),
          (m = d + u[2]),
          (h = s),
          (d = a);
        break;
      case 'S':
        t.bezierCurveTo((p = 2 * h - p) + e, (m = 2 * d - m) + r, u[1] + e, u[2] + r, (s = u[3]) + e, (a = u[4]) + r),
          (h = s),
          (d = a),
          (p = u[1]),
          (m = u[2]);
        break;
      case 'q':
        t.quadraticCurveTo((p = h + u[1]) + e, (m = d + u[2]) + r, (s = h + u[3]) + e, (a = d + u[4]) + r),
          (h = s),
          (d = a);
        break;
      case 'Q':
        t.quadraticCurveTo(u[1] + e, u[2] + r, (s = u[3]) + e, (a = u[4]) + r),
          (h = s),
          (d = a),
          (p = u[1]),
          (m = u[2]);
        break;
      case 't':
        (s = h + u[1]),
          (a = d + u[2]),
          null === f[0].match(/[QqTt]/)
            ? ((p = h), (m = d))
            : 't' === f[0]
            ? ((p = 2 * h - c), (m = 2 * d - l))
            : 'q' === f[0] && ((p = 2 * h - p), (m = 2 * d - m)),
          (c = p),
          (l = m),
          t.quadraticCurveTo(p + e, m + r, s + e, a + r),
          (p = (h = s) + u[1]),
          (m = (d = a) + u[2]);
        break;
      case 'T':
        t.quadraticCurveTo((p = 2 * h - p) + e, (m = 2 * d - m) + r, (s = u[1]) + e, (a = u[2]) + r), (h = s), (d = a);
        break;
      case 'a':
        dm(t, h + e, d + r, [u[1], u[2], u[3], u[4], u[5], u[6] + h + e, u[7] + d + r]), (h += u[6]), (d += u[7]);
        break;
      case 'A':
        dm(t, h + e, d + r, [u[1], u[2], u[3], u[4], u[5], u[6] + e, u[7] + r]), (h = u[6]), (d = u[7]);
        break;
      case 'z':
      case 'Z':
        (h = v), (d = g), t.closePath();
    }
    f = u;
  }
}
function dm(t, n, e, r) {
  const i = (function (t, n, e, r, i, o, u, s, a) {
    const c = am.call(arguments);
    if (um[c]) return um[c];
    const l = u * em,
      f = Math.sin(l),
      h = Math.cos(l),
      d = h * (s - t) * 0.5 + f * (a - n) * 0.5,
      p = h * (a - n) * 0.5 - f * (s - t) * 0.5;
    let m = (d * d) / ((e = Math.abs(e)) * e) + (p * p) / ((r = Math.abs(r)) * r);
    m > 1 && ((m = Math.sqrt(m)), (e *= m), (r *= m));
    const v = h / e,
      g = f / e,
      b = -f / r,
      y = h / r,
      w = v * s + g * a,
      x = b * s + y * a,
      O = v * t + g * n,
      k = b * t + y * n,
      A = (O - w) * (O - w) + (k - x) * (k - x);
    let $ = 1 / A - 0.25;
    $ < 0 && ($ = 0);
    let M = Math.sqrt($);
    o == i && (M = -M);
    const j = 0.5 * (w + O) - M * (k - x),
      D = 0.5 * (x + k) + M * (O - w),
      F = Math.atan2(x - D, w - j),
      E = Math.atan2(k - D, O - j);
    let S = E - F;
    S < 0 && 1 === o ? (S += im) : S > 0 && 0 === o && (S -= im);
    const C = Math.ceil(Math.abs(S / (rm + 0.001))),
      N = [];
    for (let t = 0; t < C; ++t) N[t] = [j, D, F + (t * S) / C, F + ((t + 1) * S) / C, e, r, f, h];
    return (um[c] = N);
  })(r[5], r[6], r[0], r[1], r[3], r[4], r[2], n, e);
  for (let n = 0; n < i.length; ++n) {
    const e = cm(i[n]);
    t.bezierCurveTo(e[0], e[1], e[2], e[3], e[4], e[5]);
  }
}
const pm = 0.5773502691896257,
  mm = {
    circle: {
      draw: function (t, n) {
        const e = Math.sqrt(n) / 2;
        t.moveTo(e, 0), t.arc(0, 0, e, 0, im);
      },
    },
    cross: {
      draw: function (t, n) {
        var e = Math.sqrt(n) / 2,
          r = e / 2.5;
        t.moveTo(-e, -r),
          t.lineTo(-e, r),
          t.lineTo(-r, r),
          t.lineTo(-r, e),
          t.lineTo(r, e),
          t.lineTo(r, r),
          t.lineTo(e, r),
          t.lineTo(e, -r),
          t.lineTo(r, -r),
          t.lineTo(r, -e),
          t.lineTo(-r, -e),
          t.lineTo(-r, -r),
          t.closePath();
      },
    },
    diamond: {
      draw: function (t, n) {
        const e = Math.sqrt(n) / 2;
        t.moveTo(-e, 0), t.lineTo(0, -e), t.lineTo(e, 0), t.lineTo(0, e), t.closePath();
      },
    },
    square: {
      draw: function (t, n) {
        var e = Math.sqrt(n),
          r = -e / 2;
        t.rect(r, r, e, e);
      },
    },
    arrow: {
      draw: function (t, n) {
        var e = Math.sqrt(n) / 2,
          r = e / 7,
          i = e / 2.5,
          o = e / 8;
        t.moveTo(-r, e),
          t.lineTo(r, e),
          t.lineTo(r, -o),
          t.lineTo(i, -o),
          t.lineTo(0, -e),
          t.lineTo(-i, -o),
          t.lineTo(-r, -o),
          t.closePath();
      },
    },
    wedge: {
      draw: function (t, n) {
        var e = Math.sqrt(n) / 2,
          r = om * e,
          i = r - e * pm,
          o = e / 4;
        t.moveTo(0, -r - i), t.lineTo(-o, r - i), t.lineTo(o, r - i), t.closePath();
      },
    },
    triangle: {
      draw: function (t, n) {
        var e = Math.sqrt(n) / 2,
          r = om * e,
          i = r - e * pm;
        t.moveTo(0, -r - i), t.lineTo(-e, r - i), t.lineTo(e, r - i), t.closePath();
      },
    },
    'triangle-up': {
      draw: function (t, n) {
        var e = Math.sqrt(n) / 2,
          r = om * e;
        t.moveTo(0, -r), t.lineTo(-e, r), t.lineTo(e, r), t.closePath();
      },
    },
    'triangle-down': {
      draw: function (t, n) {
        var e = Math.sqrt(n) / 2,
          r = om * e;
        t.moveTo(0, r), t.lineTo(-e, -r), t.lineTo(e, -r), t.closePath();
      },
    },
    'triangle-right': {
      draw: function (t, n) {
        var e = Math.sqrt(n) / 2,
          r = om * e;
        t.moveTo(r, 0), t.lineTo(-r, -e), t.lineTo(-r, e), t.closePath();
      },
    },
    'triangle-left': {
      draw: function (t, n) {
        var e = Math.sqrt(n) / 2,
          r = om * e;
        t.moveTo(-r, 0), t.lineTo(r, -e), t.lineTo(r, e), t.closePath();
      },
    },
    stroke: {
      draw: function (t, n) {
        const e = Math.sqrt(n) / 2;
        t.moveTo(-e, 0), t.lineTo(e, 0);
      },
    },
  };
function vm(t) {
  return Pt(mm, t)
    ? mm[t]
    : (function (t) {
        if (!Pt(gm, t)) {
          const n = nm(t);
          gm[t] = {
            draw: function (t, e) {
              hm(t, n, 0, 0, Math.sqrt(e) / 2);
            },
          };
        }
        return gm[t];
      })(t);
}
var gm = {};
const bm = 0.448084975506;
function ym(t) {
  return t.x;
}
function wm(t) {
  return t.y;
}
function xm(t) {
  return t.width;
}
function Om(t) {
  return t.height;
}
function km(t) {
  return 'function' == typeof t ? t : () => +t;
}
function Am(t, n, e) {
  return Math.max(n, Math.min(t, e));
}
function $m() {
  var t = ym,
    n = wm,
    e = xm,
    r = Om,
    i = km(0),
    o = i,
    u = i,
    s = i,
    a = null;
  function c(c, l, f) {
    var h,
      d = null != l ? l : +t.call(this, c),
      p = null != f ? f : +n.call(this, c),
      m = +e.call(this, c),
      v = +r.call(this, c),
      g = Math.min(m, v) / 2,
      b = Am(+i.call(this, c), 0, g),
      y = Am(+o.call(this, c), 0, g),
      w = Am(+u.call(this, c), 0, g),
      x = Am(+s.call(this, c), 0, g);
    if ((a || (a = h = Gc()), b <= 0 && y <= 0 && w <= 0 && x <= 0)) a.rect(d, p, m, v);
    else {
      var O = d + m,
        k = p + v;
      a.moveTo(d + b, p),
        a.lineTo(O - y, p),
        a.bezierCurveTo(O - bm * y, p, O, p + bm * y, O, p + y),
        a.lineTo(O, k - x),
        a.bezierCurveTo(O, k - bm * x, O - bm * x, k, O - x, k),
        a.lineTo(d + w, k),
        a.bezierCurveTo(d + bm * w, k, d, k - bm * w, d, k - w),
        a.lineTo(d, p + b),
        a.bezierCurveTo(d, p + bm * b, d + bm * b, p, d + b, p),
        a.closePath();
    }
    if (h) return (a = null), h + '' || null;
  }
  return (
    (c.x = function (n) {
      return arguments.length ? ((t = km(n)), c) : t;
    }),
    (c.y = function (t) {
      return arguments.length ? ((n = km(t)), c) : n;
    }),
    (c.width = function (t) {
      return arguments.length ? ((e = km(t)), c) : e;
    }),
    (c.height = function (t) {
      return arguments.length ? ((r = km(t)), c) : r;
    }),
    (c.cornerRadius = function (t, n, e, r) {
      return arguments.length
        ? ((i = km(t)), (o = null != n ? km(n) : i), (s = null != e ? km(e) : i), (u = null != r ? km(r) : o), c)
        : i;
    }),
    (c.context = function (t) {
      return arguments.length ? ((a = null == t ? null : t), c) : a;
    }),
    c
  );
}
function Mm() {
  var t,
    n,
    e,
    r,
    i,
    o,
    u,
    s,
    a = null;
  function c(t, n, e) {
    const r = e / 2;
    if (i) {
      var c = u - n,
        l = t - o;
      if (c || l) {
        var f = Math.sqrt(c * c + l * l),
          h = (c /= f) * s,
          d = (l /= f) * s,
          p = Math.atan2(l, c);
        a.moveTo(o - h, u - d),
          a.lineTo(t - c * r, n - l * r),
          a.arc(t, n, r, p - Math.PI, p),
          a.lineTo(o + h, u + d),
          a.arc(o, u, s, p, p + Math.PI);
      } else a.arc(t, n, r, 0, im);
      a.closePath();
    } else i = 1;
    (o = t), (u = n), (s = r);
  }
  function l(o) {
    var u,
      s,
      l,
      f = o.length,
      h = !1;
    for (null == a && (a = l = Gc()), u = 0; u <= f; ++u)
      !(u < f && r((s = o[u]), u, o)) === h && (h = !h) && (i = 0), h && c(+t(s, u, o), +n(s, u, o), +e(s, u, o));
    if (l) return (a = null), l + '' || null;
  }
  return (
    (l.x = function (n) {
      return arguments.length ? ((t = n), l) : t;
    }),
    (l.y = function (t) {
      return arguments.length ? ((n = t), l) : n;
    }),
    (l.size = function (t) {
      return arguments.length ? ((e = t), l) : e;
    }),
    (l.defined = function (t) {
      return arguments.length ? ((r = t), l) : r;
    }),
    (l.context = function (t) {
      return arguments.length ? ((a = null == t ? null : t), l) : a;
    }),
    l
  );
}
function jm(t, n) {
  return null != t ? t : n;
}
const Dm = t => t.x || 0,
  Fm = t => t.y || 0,
  Em = t => !(!1 === t.defined),
  Sm = (function () {
    var t = Yc,
      n = Xc,
      e = Mc(0),
      r = null,
      i = Jc,
      o = Qc,
      u = Zc,
      s = null,
      a = Vc(c);
    function c() {
      var c,
        l,
        f = +t.apply(this, arguments),
        h = +n.apply(this, arguments),
        d = i.apply(this, arguments) - zc,
        p = o.apply(this, arguments) - zc,
        m = jc(p - d),
        v = p > d;
      if ((s || (s = c = a()), h < f && ((l = h), (h = f), (f = l)), h > Bc))
        if (m > Tc - Bc)
          s.moveTo(h * Fc(d), h * Cc(d)),
            s.arc(0, 0, h, d, p, !v),
            f > Bc && (s.moveTo(f * Fc(p), f * Cc(p)), s.arc(0, 0, f, p, d, v));
        else {
          var g,
            b,
            y = d,
            w = p,
            x = d,
            O = p,
            k = m,
            A = m,
            $ = u.apply(this, arguments) / 2,
            M = $ > Bc && (r ? +r.apply(this, arguments) : Nc(f * f + h * h)),
            j = Sc(jc(h - f) / 2, +e.apply(this, arguments)),
            D = j,
            F = j;
          if (M > Bc) {
            var E = Rc((M / f) * Cc($)),
              S = Rc((M / h) * Cc($));
            (k -= 2 * E) > Bc ? ((x += E *= v ? 1 : -1), (O -= E)) : ((k = 0), (x = O = (d + p) / 2)),
              (A -= 2 * S) > Bc ? ((y += S *= v ? 1 : -1), (w -= S)) : ((A = 0), (y = w = (d + p) / 2));
          }
          var C = h * Fc(y),
            N = h * Cc(y),
            B = f * Fc(O),
            _ = f * Cc(O);
          if (j > Bc) {
            var z,
              T = h * Fc(w),
              P = h * Cc(w),
              R = f * Fc(x),
              L = f * Cc(x);
            if (m < _c)
              if ((z = Kc(C, N, R, L, T, P, B, _))) {
                var q = C - z[0],
                  I = N - z[1],
                  U = T - z[0],
                  W = P - z[1],
                  H = 1 / Cc(Pc((q * U + I * W) / (Nc(q * q + I * I) * Nc(U * U + W * W))) / 2),
                  G = Nc(z[0] * z[0] + z[1] * z[1]);
                (D = Sc(j, (f - G) / (H - 1))), (F = Sc(j, (h - G) / (H + 1)));
              } else D = F = 0;
          }
          A > Bc
            ? F > Bc
              ? ((g = tl(R, L, C, N, h, F, v)),
                (b = tl(T, P, B, _, h, F, v)),
                s.moveTo(g.cx + g.x01, g.cy + g.y01),
                F < j
                  ? s.arc(g.cx, g.cy, F, Dc(g.y01, g.x01), Dc(b.y01, b.x01), !v)
                  : (s.arc(g.cx, g.cy, F, Dc(g.y01, g.x01), Dc(g.y11, g.x11), !v),
                    s.arc(0, 0, h, Dc(g.cy + g.y11, g.cx + g.x11), Dc(b.cy + b.y11, b.cx + b.x11), !v),
                    s.arc(b.cx, b.cy, F, Dc(b.y11, b.x11), Dc(b.y01, b.x01), !v)))
              : (s.moveTo(C, N), s.arc(0, 0, h, y, w, !v))
            : s.moveTo(C, N),
            f > Bc && k > Bc
              ? D > Bc
                ? ((g = tl(B, _, T, P, f, -D, v)),
                  (b = tl(C, N, R, L, f, -D, v)),
                  s.lineTo(g.cx + g.x01, g.cy + g.y01),
                  D < j
                    ? s.arc(g.cx, g.cy, D, Dc(g.y01, g.x01), Dc(b.y01, b.x01), !v)
                    : (s.arc(g.cx, g.cy, D, Dc(g.y01, g.x01), Dc(g.y11, g.x11), !v),
                      s.arc(0, 0, f, Dc(g.cy + g.y11, g.cx + g.x11), Dc(b.cy + b.y11, b.cx + b.x11), v),
                      s.arc(b.cx, b.cy, D, Dc(b.y11, b.x11), Dc(b.y01, b.x01), !v)))
                : s.arc(0, 0, f, O, x, v)
              : s.lineTo(B, _);
        }
      else s.moveTo(0, 0);
      if ((s.closePath(), c)) return (s = null), c + '' || null;
    }
    return (
      (c.centroid = function () {
        var e = (+t.apply(this, arguments) + +n.apply(this, arguments)) / 2,
          r = (+i.apply(this, arguments) + +o.apply(this, arguments)) / 2 - _c / 2;
        return [Fc(r) * e, Cc(r) * e];
      }),
      (c.innerRadius = function (n) {
        return arguments.length ? ((t = 'function' == typeof n ? n : Mc(+n)), c) : t;
      }),
      (c.outerRadius = function (t) {
        return arguments.length ? ((n = 'function' == typeof t ? t : Mc(+t)), c) : n;
      }),
      (c.cornerRadius = function (t) {
        return arguments.length ? ((e = 'function' == typeof t ? t : Mc(+t)), c) : e;
      }),
      (c.padRadius = function (t) {
        return arguments.length ? ((r = null == t ? null : 'function' == typeof t ? t : Mc(+t)), c) : r;
      }),
      (c.startAngle = function (t) {
        return arguments.length ? ((i = 'function' == typeof t ? t : Mc(+t)), c) : i;
      }),
      (c.endAngle = function (t) {
        return arguments.length ? ((o = 'function' == typeof t ? t : Mc(+t)), c) : o;
      }),
      (c.padAngle = function (t) {
        return arguments.length ? ((u = 'function' == typeof t ? t : Mc(+t)), c) : u;
      }),
      (c.context = function (t) {
        return arguments.length ? ((s = null == t ? null : t), c) : s;
      }),
      c
    );
  })()
    .startAngle(t => t.startAngle || 0)
    .endAngle(t => t.endAngle || 0)
    .padAngle(t => t.padAngle || 0)
    .innerRadius(t => t.innerRadius || 0)
    .outerRadius(t => t.outerRadius || 0)
    .cornerRadius(t => t.cornerRadius || 0),
  Cm = sl()
    .x(Dm)
    .y1(Fm)
    .y0(t => (t.y || 0) + (t.height || 0))
    .defined(Em),
  Nm = sl()
    .y(Fm)
    .x1(Dm)
    .x0(t => (t.x || 0) + (t.width || 0))
    .defined(Em),
  Bm = ul().x(Dm).y(Fm).defined(Em),
  _m = $m()
    .x(Dm)
    .y(Fm)
    .width(t => t.width || 0)
    .height(t => t.height || 0)
    .cornerRadius(
      t => jm(t.cornerRadiusTopLeft, t.cornerRadius) || 0,
      t => jm(t.cornerRadiusTopRight, t.cornerRadius) || 0,
      t => jm(t.cornerRadiusBottomRight, t.cornerRadius) || 0,
      t => jm(t.cornerRadiusBottomLeft, t.cornerRadius) || 0,
    ),
  zm = (function (t, n) {
    let e = null,
      r = Vc(i);
    function i() {
      let i;
      if ((e || (e = i = r()), t.apply(this, arguments).draw(e, +n.apply(this, arguments)), i))
        return (e = null), i + '' || null;
    }
    return (
      (t = 'function' == typeof t ? t : Mc(t || al)),
      (n = 'function' == typeof n ? n : Mc(void 0 === n ? 64 : +n)),
      (i.type = function (n) {
        return arguments.length ? ((t = 'function' == typeof n ? n : Mc(n)), i) : t;
      }),
      (i.size = function (t) {
        return arguments.length ? ((n = 'function' == typeof t ? t : Mc(+t)), i) : n;
      }),
      (i.context = function (t) {
        return arguments.length ? ((e = null == t ? null : t), i) : e;
      }),
      i
    );
  })()
    .type(t => vm(t.shape || 'circle'))
    .size(t => jm(t.size, 64)),
  Tm = Mm()
    .x(Dm)
    .y(Fm)
    .defined(Em)
    .size(t => t.size || 1);
function Pm(t) {
  return (
    t.cornerRadius ||
    t.cornerRadiusTopLeft ||
    t.cornerRadiusTopRight ||
    t.cornerRadiusBottomRight ||
    t.cornerRadiusBottomLeft
  );
}
function Rm(t, n, e, r) {
  return _m.context(t)(n, e, r);
}
var Lm = 1;
function qm() {
  Lm = 1;
}
function Im(t, n, e) {
  var r = n.clip,
    i = t._defs,
    o = n.clip_id || (n.clip_id = 'clip' + Lm++),
    u = i.clipping[o] || (i.clipping[o] = { id: o });
  return (
    Mt(r)
      ? (u.path = r(null))
      : Pm(e)
      ? (u.path = Rm(null, e, 0, 0))
      : ((u.width = e.width || 0), (u.height = e.height || 0)),
    'url(#' + o + ')'
  );
}
function Um(t) {
  this.clear(), t && this.union(t);
}
function Wm(t) {
  (this.mark = t), (this.bounds = this.bounds || new Um());
}
function Hm(t) {
  Wm.call(this, t), (this.items = this.items || []);
}
function Gm(t) {
  (this._pending = 0), (this._loader = t || xu());
}
function Vm(t) {
  t._pending += 1;
}
function Ym(t) {
  t._pending -= 1;
}
function Xm(t, n, e) {
  if (n.stroke && 0 !== n.opacity && 0 !== n.strokeOpacity) {
    const r = null != n.strokeWidth ? +n.strokeWidth : 1;
    t.expand(
      r +
        (e
          ? (function (t, n) {
              return t.strokeJoin && 'miter' !== t.strokeJoin ? 0 : n;
            })(n, r)
          : 0),
    );
  }
  return t;
}
(Um.prototype = {
  clone() {
    return new Um(this);
  },
  clear() {
    return (
      (this.x1 = +Number.MAX_VALUE),
      (this.y1 = +Number.MAX_VALUE),
      (this.x2 = -Number.MAX_VALUE),
      (this.y2 = -Number.MAX_VALUE),
      this
    );
  },
  empty() {
    return (
      this.x1 === +Number.MAX_VALUE &&
      this.y1 === +Number.MAX_VALUE &&
      this.x2 === -Number.MAX_VALUE &&
      this.y2 === -Number.MAX_VALUE
    );
  },
  equals(t) {
    return this.x1 === t.x1 && this.y1 === t.y1 && this.x2 === t.x2 && this.y2 === t.y2;
  },
  set(t, n, e, r) {
    return (
      e < t ? ((this.x2 = t), (this.x1 = e)) : ((this.x1 = t), (this.x2 = e)),
      r < n ? ((this.y2 = n), (this.y1 = r)) : ((this.y1 = n), (this.y2 = r)),
      this
    );
  },
  add(t, n) {
    return (
      t < this.x1 && (this.x1 = t),
      n < this.y1 && (this.y1 = n),
      t > this.x2 && (this.x2 = t),
      n > this.y2 && (this.y2 = n),
      this
    );
  },
  expand(t) {
    return (this.x1 -= t), (this.y1 -= t), (this.x2 += t), (this.y2 += t), this;
  },
  round() {
    return (
      (this.x1 = Math.floor(this.x1)),
      (this.y1 = Math.floor(this.y1)),
      (this.x2 = Math.ceil(this.x2)),
      (this.y2 = Math.ceil(this.y2)),
      this
    );
  },
  scale(t) {
    return (this.x1 *= t), (this.y1 *= t), (this.x2 *= t), (this.y2 *= t), this;
  },
  translate(t, n) {
    return (this.x1 += t), (this.x2 += t), (this.y1 += n), (this.y2 += n), this;
  },
  rotate(t, n, e) {
    const r = this.rotatedPoints(t, n, e);
    return this.clear().add(r[0], r[1]).add(r[2], r[3]).add(r[4], r[5]).add(r[6], r[7]);
  },
  rotatedPoints(t, n, e) {
    var { x1: r, y1: i, x2: o, y2: u } = this,
      s = Math.cos(t),
      a = Math.sin(t),
      c = n - n * s + e * a,
      l = e - n * a - e * s;
    return [
      s * r - a * i + c,
      a * r + s * i + l,
      s * r - a * u + c,
      a * r + s * u + l,
      s * o - a * i + c,
      a * o + s * i + l,
      s * o - a * u + c,
      a * o + s * u + l,
    ];
  },
  union(t) {
    return (
      t.x1 < this.x1 && (this.x1 = t.x1),
      t.y1 < this.y1 && (this.y1 = t.y1),
      t.x2 > this.x2 && (this.x2 = t.x2),
      t.y2 > this.y2 && (this.y2 = t.y2),
      this
    );
  },
  intersect(t) {
    return (
      t.x1 > this.x1 && (this.x1 = t.x1),
      t.y1 > this.y1 && (this.y1 = t.y1),
      t.x2 < this.x2 && (this.x2 = t.x2),
      t.y2 < this.y2 && (this.y2 = t.y2),
      this
    );
  },
  encloses(t) {
    return t && this.x1 <= t.x1 && this.x2 >= t.x2 && this.y1 <= t.y1 && this.y2 >= t.y2;
  },
  alignsWith(t) {
    return t && (this.x1 == t.x1 || this.x2 == t.x2 || this.y1 == t.y1 || this.y2 == t.y2);
  },
  intersects(t) {
    return t && !(this.x2 < t.x1 || this.x1 > t.x2 || this.y2 < t.y1 || this.y1 > t.y2);
  },
  contains(t, n) {
    return !(t < this.x1 || t > this.x2 || n < this.y1 || n > this.y2);
  },
  width() {
    return this.x2 - this.x1;
  },
  height() {
    return this.y2 - this.y1;
  },
}),
  It(Hm, Wm),
  (Gm.prototype = {
    pending() {
      return this._pending;
    },
    sanitizeURL(t) {
      const n = this;
      return (
        Vm(n),
        n._loader
          .sanitize(t, { context: 'href' })
          .then(t => (Ym(n), t))
          .catch(() => (Ym(n), null))
      );
    },
    loadImage(t) {
      const n = this,
        e = Il();
      return (
        Vm(n),
        n._loader
          .sanitize(t, { context: 'image' })
          .then(t => {
            const r = t.href;
            if (!r || !e) throw { url: r };
            const i = new e(),
              o = Pt(t, 'crossOrigin') ? t.crossOrigin : 'anonymous';
            return (
              null != o && (i.crossOrigin = o), (i.onload = () => Ym(n)), (i.onerror = () => Ym(n)), (i.src = r), i
            );
          })
          .catch(t => (Ym(n), { complete: !1, width: 0, height: 0, src: (t && t.url) || '' }))
      );
    },
    ready() {
      const t = this;
      return new Promise(n => {
        !(function e(r) {
          t.pending()
            ? setTimeout(() => {
                e(!0);
              }, 10)
            : n(r);
        })(!1);
      });
    },
  });
const Jm = im - 1e-8;
let Qm, Zm, Km, tv, nv, ev, rv, iv;
const ov = (t, n) => Qm.add(t, n),
  uv = (t, n) => ov((Zm = t), (Km = n)),
  sv = t => ov(t, Qm.y1),
  av = t => ov(Qm.x1, t),
  cv = (t, n) => nv * t + rv * n,
  lv = (t, n) => ev * t + iv * n,
  fv = (t, n) => ov(cv(t, n), lv(t, n)),
  hv = (t, n) => uv(cv(t, n), lv(t, n));
function dv(t, n) {
  return (
    (Qm = t),
    n
      ? ((tv = n * em), (nv = iv = Math.cos(tv)), (ev = Math.sin(tv)), (rv = -ev))
      : ((nv = iv = 1), (tv = ev = rv = 0)),
    pv
  );
}
const pv = {
  beginPath() {},
  closePath() {},
  moveTo: hv,
  lineTo: hv,
  rect(t, n, e, r) {
    tv ? (fv(t + e, n), fv(t + e, n + r), fv(t, n + r), hv(t, n)) : (ov(t + e, n + r), uv(t, n));
  },
  quadraticCurveTo(t, n, e, r) {
    const i = cv(t, n),
      o = lv(t, n),
      u = cv(e, r),
      s = lv(e, r);
    mv(Zm, i, u, sv), mv(Km, o, s, av), uv(u, s);
  },
  bezierCurveTo(t, n, e, r, i, o) {
    const u = cv(t, n),
      s = lv(t, n),
      a = cv(e, r),
      c = lv(e, r),
      l = cv(i, o),
      f = lv(i, o);
    vv(Zm, u, a, l, sv), vv(Km, s, c, f, av), uv(l, f);
  },
  arc(t, n, e, r, i, o) {
    if (((r += tv), (i += tv), (Zm = e * Math.cos(i) + t), (Km = e * Math.sin(i) + n), Math.abs(i - r) > Jm))
      ov(t - e, n - e), ov(t + e, n + e);
    else {
      const u = r => ov(e * Math.cos(r) + t, e * Math.sin(r) + n);
      let s, a;
      if ((u(r), u(i), i !== r))
        if (((r %= im) < 0 && (r += im), (i %= im) < 0 && (i += im), i < r && ((o = !o), (s = r), (r = i), (i = s)), o))
          for (i -= im, s = r - (r % rm), a = 0; a < 4 && s > i; ++a, s -= rm) u(s);
        else for (s = r - (r % rm) + rm, a = 0; a < 4 && s < i; ++a, s += rm) u(s);
    }
  },
};
function mv(t, n, e, r) {
  const i = (t - n) / (t + e - 2 * n);
  0 < i && i < 1 && r(t + (n - t) * i);
}
function vv(t, n, e, r, i) {
  const o = r - t + 3 * n - 3 * e,
    u = t + e - 2 * n,
    s = t - n;
  let a,
    c = 0,
    l = 0;
  Math.abs(o) > 1e-14
    ? ((a = u * u + s * o), a >= 0 && ((a = Math.sqrt(a)), (c = (-u + a) / o), (l = (-u - a) / o)))
    : (c = (0.5 * s) / u),
    0 < c && c < 1 && i(gv(c, t, n, e, r)),
    0 < l && l < 1 && i(gv(l, t, n, e, r));
}
function gv(t, n, e, r, i) {
  const o = 1 - t,
    u = o * o,
    s = t * t;
  return u * o * n + 3 * u * t * e + 3 * o * s * r + s * t * i;
}
var bv = (bv = ql(1, 1)) ? bv.getContext('2d') : null;
const yv = new Um();
function wv(t) {
  return function (n, e) {
    if (!bv) return !0;
    t(bv, n), yv.clear().union(n.bounds).intersect(e).round();
    const { x1: r, y1: i, x2: o, y2: u } = yv;
    for (let t = i; t <= u; ++t) for (let n = r; n <= o; ++n) if (bv.isPointInPath(n, t)) return !0;
    return !1;
  };
}
function xv(t, n) {
  return n.contains(t.x || 0, t.y || 0);
}
function Ov(t, n) {
  const e = t.x || 0,
    r = t.y || 0;
  return n.intersects(yv.set(e, r, e + (t.width || 0), r + (t.height || 0)));
}
function kv(t, n) {
  const e = t.x || 0,
    r = t.y || 0;
  return Av(n, e, r, null != t.x2 ? t.x2 : e, null != t.y2 ? t.y2 : r);
}
function Av(t, n, e, r, i) {
  const { x1: o, y1: u, x2: s, y2: a } = t,
    c = r - n,
    l = i - e;
  let f,
    h,
    d,
    p,
    m = 0,
    v = 1;
  for (p = 0; p < 4; ++p) {
    if (
      (0 === p && ((f = -c), (h = -(o - n))),
      1 === p && ((f = c), (h = s - n)),
      2 === p && ((f = -l), (h = -(u - e))),
      3 === p && ((f = l), (h = a - e)),
      Math.abs(f) < 1e-10 && h < 0)
    )
      return !1;
    if (((d = h / f), f < 0)) {
      if (d > v) return !1;
      d > m && (m = d);
    } else if (f > 0) {
      if (d < m) return !1;
      d < v && (v = d);
    }
  }
  return !0;
}
function $v(t, n) {
  t.globalCompositeOperation = n.blend || 'source-over';
}
function Mv(t, n) {
  return null == t ? n : t;
}
function jv(t, n) {
  const e = n.length;
  for (let r = 0; r < e; ++r) t.addColorStop(n[r].offset, n[r].color);
  return t;
}
function Dv(t, n, e) {
  return Wp(e)
    ? (function (t, n, e) {
        const r = e.width(),
          i = e.height();
        let o;
        if ('radial' === n.gradient)
          o = t.createRadialGradient(
            e.x1 + Mv(n.x1, 0.5) * r,
            e.y1 + Mv(n.y1, 0.5) * i,
            Math.max(r, i) * Mv(n.r1, 0),
            e.x1 + Mv(n.x2, 0.5) * r,
            e.y1 + Mv(n.y2, 0.5) * i,
            Math.max(r, i) * Mv(n.r2, 0.5),
          );
        else {
          const u = Mv(n.x1, 0),
            s = Mv(n.y1, 0),
            a = Mv(n.x2, 1),
            c = Mv(n.y2, 0);
          if (u !== a && s !== c && r !== i) {
            const e = ql(Math.ceil(r), Math.ceil(i)),
              o = e.getContext('2d');
            return (
              o.scale(r, i),
              (o.fillStyle = jv(o.createLinearGradient(u, s, a, c), n.stops)),
              o.fillRect(0, 0, r, i),
              t.createPattern(e, 'no-repeat')
            );
          }
          o = t.createLinearGradient(e.x1 + u * r, e.y1 + s * i, e.x1 + a * r, e.y1 + c * i);
        }
        return jv(o, n.stops);
      })(t, e, n.bounds)
    : e;
}
function Fv(t, n, e) {
  return (
    (e *= null == n.fillOpacity ? 1 : n.fillOpacity) > 0 && ((t.globalAlpha = e), (t.fillStyle = Dv(t, n, n.fill)), !0)
  );
}
var Ev = [];
function Sv(t, n, e) {
  var r = null != (r = n.strokeWidth) ? r : 1;
  return (
    !(r <= 0) &&
    (e *= null == n.strokeOpacity ? 1 : n.strokeOpacity) > 0 &&
    ((t.globalAlpha = e),
    (t.strokeStyle = Dv(t, n, n.stroke)),
    (t.lineWidth = r),
    (t.lineCap = n.strokeCap || 'butt'),
    (t.lineJoin = n.strokeJoin || 'miter'),
    (t.miterLimit = n.strokeMiterLimit || 10),
    t.setLineDash && (t.setLineDash(n.strokeDash || Ev), (t.lineDashOffset = n.strokeDashOffset || 0)),
    !0)
  );
}
function Cv(t, n) {
  return t.zindex - n.zindex || t.index - n.index;
}
function Nv(t) {
  if (!t.zdirty) return t.zitems;
  var n,
    e,
    r,
    i = t.items,
    o = [];
  for (e = 0, r = i.length; e < r; ++e) ((n = i[e]).index = e), n.zindex && o.push(n);
  return (t.zdirty = !1), (t.zitems = o.sort(Cv));
}
function Bv(t, n) {
  var e,
    r,
    i = t.items;
  if (!i || !i.length) return;
  const o = Nv(t);
  if (o && o.length) {
    for (e = 0, r = i.length; e < r; ++e) i[e].zindex || n(i[e]);
    i = o;
  }
  for (e = 0, r = i.length; e < r; ++e) n(i[e]);
}
function _v(t, n) {
  var e,
    r,
    i = t.items;
  if (!i || !i.length) return null;
  const o = Nv(t);
  for (o && o.length && (i = o), r = i.length; --r >= 0; ) if ((e = n(i[r]))) return e;
  if (i === o) for (r = (i = t.items).length; --r >= 0; ) if (!i[r].zindex && (e = n(i[r]))) return e;
  return null;
}
function zv(t) {
  return function (n, e, r) {
    Bv(e, e => {
      (r && !r.intersects(e.bounds)) || Pv(t, n, e, e);
    });
  };
}
function Tv(t) {
  return function (n, e, r) {
    !e.items.length || (r && !r.intersects(e.bounds)) || Pv(t, n, e.items[0], e.items);
  };
}
function Pv(t, n, e, r) {
  var i = null == e.opacity ? 1 : e.opacity;
  0 !== i && (t(n, r) || ($v(n, e), e.fill && Fv(n, e, i) && n.fill(), e.stroke && Sv(n, e, i) && n.stroke()));
}
function Rv(t) {
  return (
    (t = t || X),
    function (n, e, r, i, o, u) {
      return (
        (r *= n.pixelRatio),
        (i *= n.pixelRatio),
        _v(e, e => {
          const s = e.bounds;
          if ((!s || s.contains(o, u)) && s) return t(n, e, r, i, o, u) ? e : void 0;
        })
      );
    }
  );
}
function Lv(t, n) {
  return function (e, r, i, o) {
    var u,
      s,
      a = Array.isArray(r) ? r[0] : r,
      c = null == n ? a.fill : n,
      l = a.stroke && e.isPointInStroke;
    return (
      l &&
        ((s = a.strokeCap), (e.lineWidth = null != (u = a.strokeWidth) ? u : 1), (e.lineCap = null != s ? s : 'butt')),
      !t(e, r) && ((c && e.isPointInPath(i, o)) || (l && e.isPointInStroke(i, o)))
    );
  };
}
function qv(t) {
  return Rv(Lv(t));
}
function Iv(t, n) {
  return 'translate(' + t + ',' + n + ')';
}
function Uv(t) {
  return 'rotate(' + t + ')';
}
function Wv(t) {
  return Iv(t.x || 0, t.y || 0);
}
function Hv(t, n, e) {
  function r(t, e) {
    var r = e.x || 0,
      i = e.y || 0,
      o = e.angle || 0;
    t.translate(r, i), o && t.rotate((o *= em)), t.beginPath(), n(t, e), o && t.rotate(-o), t.translate(-r, -i);
  }
  return {
    type: t,
    tag: 'path',
    nested: !1,
    attr: function (t, e) {
      t(
        'transform',
        (function (t) {
          return Iv(t.x || 0, t.y || 0) + (t.angle ? ' ' + Uv(t.angle) : '');
        })(e),
      ),
        t('d', n(null, e));
    },
    bound: function (t, e) {
      return n(dv(t, e.angle), e), Xm(t, e).translate(e.x || 0, e.y || 0);
    },
    draw: zv(r),
    pick: qv(r),
    isect: e || wv(r),
  };
}
var Gv = Hv('arc', function (t, n) {
  return Sm.context(t)(n);
});
function Vv(t, n, e) {
  function r(t, e) {
    t.beginPath(), n(t, e);
  }
  const i = Lv(r);
  return {
    type: t,
    tag: 'path',
    nested: !0,
    attr: function (t, e) {
      var r = e.mark.items;
      r.length && t('d', n(null, r));
    },
    bound: function (t, e) {
      var r = e.items;
      return 0 === r.length ? t : (n(dv(t), r), Xm(t, r[0]));
    },
    draw: Tv(r),
    pick: function (t, n, e, r, o, u) {
      var s = n.items,
        a = n.bounds;
      return !s || !s.length || (a && !a.contains(o, u))
        ? null
        : i(t, s, (e *= t.pixelRatio), (r *= t.pixelRatio))
        ? s[0]
        : null;
    },
    isect: xv,
    tip: e,
  };
}
var Yv = Vv(
  'area',
  function (t, n) {
    const e = n[0];
    return ('horizontal' === e.orient ? Nm : Cm).curve(Xp(e.interpolate || 'linear', e.orient, e.tension)).context(t)(
      n,
    );
  },
  function (t, n) {
    for (
      var e,
        r,
        i = 'horizontal' === t[0].orient ? n[1] : n[0],
        o = 'horizontal' === t[0].orient ? 'y' : 'x',
        u = t.length,
        s = 1 / 0;
      --u >= 0;

    )
      !1 !== t[u].defined && (r = Math.abs(t[u][o] - i)) < s && ((s = r), (e = t[u]));
    return e;
  },
);
function Xv(t, n) {
  t.beginPath(), Pm(n) ? Rm(t, n, 0, 0) : t.rect(0, 0, n.width || 0, n.height || 0), t.clip();
}
function Jv(t) {
  const n = Mv(t.strokeWidth, 1);
  return null != t.strokeOffset ? t.strokeOffset : t.stroke && n > 0.5 && n < 1.5 ? 0.5 - Math.abs(n - 1) : 0;
}
function Qv(t, n) {
  const e = Jv(n);
  t('d', Rm(null, n, e, e));
}
function Zv(t, n, e, r) {
  const i = Jv(n);
  t.beginPath(), Rm(t, n, (e || 0) + i, (r || 0) + i);
}
const Kv = Lv(Zv),
  tg = Lv(Zv, !1),
  ng = Lv(Zv, !0);
var eg = {
    type: 'group',
    tag: 'g',
    nested: !1,
    attr: function (t, n) {
      t('transform', Wv(n));
    },
    bound: function (t, n) {
      if (!n.clip && n.items) {
        const e = n.items,
          r = e.length;
        for (let n = 0; n < r; ++n) t.union(e[n].bounds);
      }
      return (
        (n.clip || n.width || n.height) && !n.noBound && t.add(0, 0).add(n.width || 0, n.height || 0),
        Xm(t, n),
        t.translate(n.x || 0, n.y || 0)
      );
    },
    draw: function (t, n, e) {
      Bv(n, n => {
        const r = n.x || 0,
          i = n.y || 0,
          o = n.strokeForeground,
          u = null == n.opacity ? 1 : n.opacity;
        (n.stroke || n.fill) &&
          u &&
          (Zv(t, n, r, i), $v(t, n), n.fill && Fv(t, n, u) && t.fill(), n.stroke && !o && Sv(t, n, u) && t.stroke()),
          t.save(),
          t.translate(r, i),
          n.clip && Xv(t, n),
          e && e.translate(-r, -i),
          Bv(n, n => {
            this.draw(t, n, e);
          }),
          e && e.translate(r, i),
          t.restore(),
          o && n.stroke && u && (Zv(t, n, r, i), $v(t, n), Sv(t, n, u) && t.stroke());
      });
    },
    pick: function (t, n, e, r, i, o) {
      if ((n.bounds && !n.bounds.contains(i, o)) || !n.items) return null;
      const u = e * t.pixelRatio,
        s = r * t.pixelRatio;
      return _v(n, a => {
        let c, l, f;
        const h = a.bounds;
        if (h && !h.contains(i, o)) return;
        (l = a.x || 0), (f = a.y || 0);
        const d = a.clip;
        if (d && (i < l || i > l + (a.width || 0) || o < f || o > f + (a.height || 0))) return;
        if ((t.save(), t.translate(l, f), (l = i - l), (f = o - f), d && Pm(a) && !ng(t, a, u, s)))
          return t.restore(), null;
        const p = a.strokeForeground,
          m = !1 !== n.interactive;
        return m && p && a.stroke && tg(t, a, u, s)
          ? (t.restore(), a)
          : ((c = _v(a, t =>
              (function (t, n, e) {
                return (!1 !== t.interactive || 'group' === t.marktype) && t.bounds && t.bounds.contains(n, e);
              })(t, l, f)
                ? this.pick(t, e, r, l, f)
                : null,
            )),
            !c && m && (a.fill || (!p && a.stroke)) && Kv(t, a, u, s) && (c = a),
            t.restore(),
            c || null);
      });
    },
    isect: Ov,
    content: function (t, n, e) {
      t('clip-path', n.clip ? Im(e, n, n) : null);
    },
    background: function (t, n) {
      t('class', 'background'), t('aria-hidden', !0), Qv(t, n);
    },
    foreground: function (t, n) {
      t('class', 'foreground'), t('aria-hidden', !0), n.strokeForeground ? Qv(t, n) : t('d', '');
    },
  },
  rg = { xmlns: 'http://www.w3.org/2000/svg', 'xmlns:xlink': 'http://www.w3.org/1999/xlink', version: '1.1' };
function ig(t, n) {
  var e = t.image;
  return (
    (!e || (t.url && t.url !== e.url)) &&
      ((e = { complete: !1, width: 0, height: 0 }),
      n.loadImage(t.url).then(n => {
        (t.image = n), (t.image.url = t.url);
      })),
    e
  );
}
function og(t, n) {
  return null != t.width
    ? t.width
    : n && n.width
    ? !1 !== t.aspect && t.height
      ? (t.height * n.width) / n.height
      : n.width
    : 0;
}
function ug(t, n) {
  return null != t.height
    ? t.height
    : n && n.height
    ? !1 !== t.aspect && t.width
      ? (t.width * n.height) / n.width
      : n.height
    : 0;
}
function sg(t, n) {
  return 'center' === t ? n / 2 : 'right' === t ? n : 0;
}
function ag(t, n) {
  return 'middle' === t ? n / 2 : 'bottom' === t ? n : 0;
}
var cg = {
    type: 'image',
    tag: 'image',
    nested: !1,
    attr: function (t, n, e) {
      const r = ig(n, e),
        i = og(n, r),
        o = ug(n, r),
        u = (n.x || 0) - sg(n.align, i),
        s = (n.y || 0) - ag(n.baseline, o);
      t('href', !r.src && r.toDataURL ? r.toDataURL() : r.src || '', rg['xmlns:xlink'], 'xlink:href'),
        t('transform', Iv(u, s)),
        t('width', i),
        t('height', o),
        t('preserveAspectRatio', !1 === n.aspect ? 'none' : 'xMidYMid');
    },
    bound: function (t, n) {
      const e = n.image,
        r = og(n, e),
        i = ug(n, e),
        o = (n.x || 0) - sg(n.align, r),
        u = (n.y || 0) - ag(n.baseline, i);
      return t.set(o, u, o + r, u + i);
    },
    draw: function (t, n, e) {
      Bv(n, n => {
        if (e && !e.intersects(n.bounds)) return;
        const r = ig(n, this);
        let i = og(n, r),
          o = ug(n, r);
        if (0 === i || 0 === o) return;
        let u,
          s,
          a,
          c,
          l = (n.x || 0) - sg(n.align, i),
          f = (n.y || 0) - ag(n.baseline, o);
        !1 !== n.aspect &&
          ((s = r.width / r.height),
          (a = n.width / n.height),
          s == s &&
            a == a &&
            s !== a &&
            (a < s ? ((c = i / s), (f += (o - c) / 2), (o = c)) : ((c = o * s), (l += (i - c) / 2), (i = c)))),
          (r.complete || r.toDataURL) &&
            ($v(t, n),
            (t.globalAlpha = null != (u = n.opacity) ? u : 1),
            (t.imageSmoothingEnabled = !1 !== n.smooth),
            t.drawImage(r, l, f, i, o));
      });
    },
    pick: Rv(),
    isect: X,
    get: ig,
    xOffset: sg,
    yOffset: ag,
  },
  lg = Vv(
    'line',
    function (t, n) {
      const e = n[0];
      return Bm.curve(Xp(e.interpolate || 'linear', e.orient, e.tension)).context(t)(n);
    },
    function (t, n) {
      for (var e, r, i = Math.pow(t[0].strokeWidth || 1, 2), o = t.length; --o >= 0; )
        if (!1 !== t[o].defined && (e = t[o].x - n[0]) * e + (r = t[o].y - n[1]) * r < i) return t[o];
      return null;
    },
  );
function fg(t, n) {
  var e = n.path;
  if (null == e) return !0;
  var r = n.x || 0,
    i = n.y || 0,
    o = n.scaleX || 1,
    u = n.scaleY || 1,
    s = (n.angle || 0) * em,
    a = n.pathCache;
  (a && a.path === e) || ((n.pathCache = a = nm(e)).path = e),
    s && t.rotate && t.translate
      ? (t.translate(r, i), t.rotate(s), hm(t, a, 0, 0, o, u), t.rotate(-s), t.translate(-r, -i))
      : hm(t, a, r, i, o, u);
}
var hg = {
  type: 'path',
  tag: 'path',
  nested: !1,
  attr: function (t, n) {
    (1 === (n.scaleX || 1) && 1 === (n.scaleY || 1)) || t('vector-effect', 'non-scaling-stroke'),
      t(
        'transform',
        (function (t) {
          return (
            Iv(t.x || 0, t.y || 0) +
            (t.angle ? ' ' + Uv(t.angle) : '') +
            (t.scaleX || t.scaleY ? ' ' + ('scale(' + (t.scaleX || 1) + ',' + (t.scaleY || 1) + ')') : '')
          );
        })(n),
      ),
      t('d', n.path);
  },
  bound: function (t, n) {
    return fg(dv(t, n.angle), n) ? t.set(0, 0, 0, 0) : Xm(t, n, !0);
  },
  draw: zv(fg),
  pick: qv(fg),
  isect: wv(fg),
};
function dg(t, n) {
  t.beginPath(), Rm(t, n);
}
var pg = {
  type: 'rect',
  tag: 'path',
  nested: !1,
  attr: function (t, n) {
    t('d', Rm(null, n));
  },
  bound: function (t, n) {
    var e, r;
    return Xm(t.set((e = n.x || 0), (r = n.y || 0), e + n.width || 0, r + n.height || 0), n);
  },
  draw: zv(dg),
  pick: qv(dg),
  isect: Ov,
};
function mg(t, n, e) {
  var r, i, o, u;
  return !(
    !n.stroke ||
    !Sv(t, n, e) ||
    ((r = n.x || 0),
    (i = n.y || 0),
    (o = null != n.x2 ? n.x2 : r),
    (u = null != n.y2 ? n.y2 : i),
    t.beginPath(),
    t.moveTo(r, i),
    t.lineTo(o, u),
    0)
  );
}
var vg = {
    type: 'rule',
    tag: 'line',
    nested: !1,
    attr: function (t, n) {
      t('transform', Wv(n)),
        t('x2', null != n.x2 ? n.x2 - (n.x || 0) : 0),
        t('y2', null != n.y2 ? n.y2 - (n.y || 0) : 0);
    },
    bound: function (t, n) {
      var e, r;
      return Xm(t.set((e = n.x || 0), (r = n.y || 0), null != n.x2 ? n.x2 : e, null != n.y2 ? n.y2 : r), n);
    },
    draw: function (t, n, e) {
      Bv(n, n => {
        if (!e || e.intersects(n.bounds)) {
          var r = null == n.opacity ? 1 : n.opacity;
          r && mg(t, n, r) && ($v(t, n), t.stroke());
        }
      });
    },
    pick: Rv(function (t, n, e, r) {
      return !!t.isPointInStroke && mg(t, n, 1) && t.isPointInStroke(e, r);
    }),
    isect: kv,
  },
  gg = Hv('shape', function (t, n) {
    return (n.mark.shape || n.shape).context(t)(n);
  }),
  bg = Hv(
    'symbol',
    function (t, n) {
      return zm.context(t)(n);
    },
    xv,
  );
const yg = Zt();
var wg = { height: Mg, measureWidth: Ag, estimateWidth: Og, width: Og, canvas: xg };
function xg(t) {
  wg.width = t && bv ? Ag : Og;
}
function Og(t, n) {
  return kg(Eg(t, n), Mg(t));
}
function kg(t, n) {
  return ~~(0.8 * t.length * n);
}
function Ag(t, n) {
  return Mg(t) <= 0 || !(n = Eg(t, n)) ? 0 : $g(n, Cg(t));
}
function $g(t, n) {
  const e = '('.concat(n, ') ').concat(t);
  let r = yg.get(e);
  return void 0 === r && ((bv.font = n), (r = bv.measureText(t).width), yg.set(e, r)), r;
}
function Mg(t) {
  return null != t.fontSize ? +t.fontSize || 0 : 11;
}
function jg(t) {
  return null != t.lineHeight ? t.lineHeight : Mg(t) + 2;
}
function Dg(t) {
  return (
    (n = t.lineBreak && t.text && !K(t.text) ? t.text.split(t.lineBreak) : t.text), K(n) ? (n.length > 1 ? n : n[0]) : n
  );
  var n;
}
function Fg(t) {
  const n = Dg(t);
  return (K(n) ? n.length - 1 : 0) * jg(t);
}
function Eg(t, n) {
  const e = null == n ? '' : (n + '').trim();
  return t.limit > 0 && e.length
    ? (function (t, n) {
        var e = +t.limit,
          r = (function (t) {
            if (wg.width === Ag) {
              const n = Cg(t);
              return t => $g(t, n);
            }
            {
              const n = Mg(t);
              return t => kg(t, n);
            }
          })(t);
        if (r(n) < e) return n;
        var i,
          o = t.ellipsis || '…',
          u = 'rtl' === t.dir,
          s = 0,
          a = n.length;
        if (((e -= r(o)), u)) {
          for (; s < a; ) r(n.slice((i = (s + a) >>> 1))) > e ? (s = i + 1) : (a = i);
          return o + n.slice(s);
        }
        for (; s < a; ) r(n.slice(0, (i = 1 + ((s + a) >>> 1)))) < e ? (s = i) : (a = i - 1);
        return n.slice(0, s) + o;
      })(t, e)
    : e;
}
function Sg(t, n) {
  var e = t.font;
  return (n && e ? String(e).replace(/"/g, "'") : e) || 'sans-serif';
}
function Cg(t, n) {
  return (
    (t.fontStyle ? t.fontStyle + ' ' : '') +
    (t.fontVariant ? t.fontVariant + ' ' : '') +
    (t.fontWeight ? t.fontWeight + ' ' : '') +
    Mg(t) +
    'px ' +
    Sg(t, n)
  );
}
function Ng(t) {
  var n = t.baseline,
    e = Mg(t);
  return Math.round(
    'top' === n
      ? 0.79 * e
      : 'middle' === n
      ? 0.3 * e
      : 'bottom' === n
      ? -0.21 * e
      : 'line-top' === n
      ? 0.29 * e + 0.5 * jg(t)
      : 'line-bottom' === n
      ? 0.29 * e - 0.5 * jg(t)
      : 0,
  );
}
xg(!0);
const Bg = { left: 'start', center: 'middle', right: 'end' },
  _g = new Um();
function zg(t) {
  var n,
    e = t.x || 0,
    r = t.y || 0,
    i = t.radius || 0;
  return i && ((n = (t.theta || 0) - rm), (e += i * Math.cos(n)), (r += i * Math.sin(n))), (_g.x1 = e), (_g.y1 = r), _g;
}
function Tg(t, n, e) {
  var r,
    i = wg.height(n),
    o = n.align,
    u = zg(n),
    s = u.x1,
    a = u.y1,
    c = n.dx || 0,
    l = (n.dy || 0) + Ng(n) - Math.round(0.8 * i),
    f = Dg(n);
  if (
    (K(f)
      ? ((i += jg(n) * (f.length - 1)), (r = f.reduce((t, e) => Math.max(t, wg.width(n, e)), 0)))
      : (r = wg.width(n, f)),
    'center' === o ? (c -= r / 2) : 'right' === o && (c -= r),
    t.set((c += s), (l += a), c + r, l + i),
    n.angle && !e)
  )
    t.rotate(n.angle * em, s, a);
  else if (2 === e) return t.rotatedPoints(n.angle * em, s, a);
  return t;
}
var Pg = {
    type: 'text',
    tag: 'text',
    nested: !1,
    attr: function (t, n) {
      var e,
        r = n.dx || 0,
        i = (n.dy || 0) + Ng(n),
        o = zg(n),
        u = o.x1,
        s = o.y1,
        a = n.angle || 0;
      t('text-anchor', Bg[n.align] || 'start'),
        a ? ((e = Iv(u, s) + ' ' + Uv(a)), (r || i) && (e += ' ' + Iv(r, i))) : (e = Iv(u + r, s + i)),
        t('transform', e);
    },
    bound: Tg,
    draw: function (t, n, e) {
      Bv(n, n => {
        var r,
          i,
          o,
          u,
          s,
          a,
          c,
          l = null == n.opacity ? 1 : n.opacity;
        if (!((e && !e.intersects(n.bounds)) || 0 === l || n.fontSize <= 0 || null == n.text || 0 === n.text.length)) {
          if (
            ((t.font = Cg(n)),
            (t.textAlign = n.align || 'left'),
            (i = (r = zg(n)).x1),
            (o = r.y1),
            n.angle && (t.save(), t.translate(i, o), t.rotate(n.angle * em), (i = o = 0)),
            (i += n.dx || 0),
            (o += (n.dy || 0) + Ng(n)),
            (a = Dg(n)),
            $v(t, n),
            K(a))
          )
            for (s = jg(n), u = 0; u < a.length; ++u)
              (c = Eg(n, a[u])),
                n.fill && Fv(t, n, l) && t.fillText(c, i, o),
                n.stroke && Sv(t, n, l) && t.strokeText(c, i, o),
                (o += s);
          else
            (c = Eg(n, a)),
              n.fill && Fv(t, n, l) && t.fillText(c, i, o),
              n.stroke && Sv(t, n, l) && t.strokeText(c, i, o);
          n.angle && t.restore();
        }
      });
    },
    pick: Rv(function (t, n, e, r, i, o) {
      if (n.fontSize <= 0) return !1;
      if (!n.angle) return !0;
      var u = zg(n),
        s = u.x1,
        a = u.y1,
        c = Tg(_g, n, 1),
        l = -n.angle * em,
        f = Math.cos(l),
        h = Math.sin(l);
      return c.contains(f * i - h * o + (s - f * s + h * a), h * i + f * o + (a - h * s - f * a));
    }),
    isect: function (t, n) {
      const e = Tg(_g, t, 2);
      return (
        Av(n, e[0], e[1], e[2], e[3]) ||
        Av(n, e[0], e[1], e[4], e[5]) ||
        Av(n, e[4], e[5], e[6], e[7]) ||
        Av(n, e[2], e[3], e[6], e[7])
      );
    },
  },
  Rg = Vv(
    'trail',
    function (t, n) {
      return Tm.context(t)(n);
    },
    function (t, n) {
      for (var e, r, i = t.length; --i >= 0; )
        if (!1 !== t[i].defined && (e = t[i].x - n[0]) * e + (r = t[i].y - n[1]) * r < (e = t[i].size || 1) * e)
          return t[i];
      return null;
    },
  ),
  Lg = {
    arc: Gv,
    area: Yv,
    group: eg,
    image: cg,
    line: lg,
    path: hg,
    rect: pg,
    rule: vg,
    shape: gg,
    symbol: bg,
    text: Pg,
    trail: Rg,
  };
function qg(t, n, e) {
  var r = Lg[t.mark.marktype];
  return r.nested && (t = t.mark), (n || r.bound)(t.bounds || (t.bounds = new Um()), t, e);
}
var Ig = { mark: null };
function Ug(t, n, e) {
  var r,
    i,
    o,
    u,
    s = Lg[t.marktype],
    a = s.bound,
    c = t.items,
    l = c && c.length;
  if (s.nested) return l ? (o = c[0]) : ((Ig.mark = t), (o = Ig)), (u = qg(o, a, e)), (n && n.union(u)) || u;
  if (((n = n || (t.bounds && t.bounds.clear()) || new Um()), l))
    for (r = 0, i = c.length; r < i; ++r) n.union(qg(c[r], a, e));
  return (t.bounds = n);
}
const Wg = [
  'marktype',
  'name',
  'role',
  'interactive',
  'clip',
  'items',
  'zindex',
  'x',
  'y',
  'width',
  'height',
  'align',
  'baseline',
  'fill',
  'fillOpacity',
  'opacity',
  'blend',
  'stroke',
  'strokeOpacity',
  'strokeWidth',
  'strokeCap',
  'strokeDash',
  'strokeDashOffset',
  'strokeForeground',
  'strokeOffset',
  'startAngle',
  'endAngle',
  'innerRadius',
  'outerRadius',
  'cornerRadius',
  'padAngle',
  'cornerRadiusTopLeft',
  'cornerRadiusTopRight',
  'cornerRadiusBottomLeft',
  'cornerRadiusBottomRight',
  'interpolate',
  'tension',
  'orient',
  'defined',
  'url',
  'aspect',
  'smooth',
  'path',
  'scaleX',
  'scaleY',
  'x2',
  'y2',
  'size',
  'shape',
  'text',
  'angle',
  'theta',
  'radius',
  'dir',
  'dx',
  'dy',
  'ellipsis',
  'limit',
  'lineBreak',
  'lineHeight',
  'font',
  'fontSize',
  'fontWeight',
  'fontStyle',
  'fontVariant',
  'description',
  'aria',
  'ariaRole',
  'ariaRoleDescription',
];
function Hg(t, n) {
  return JSON.stringify(t, Wg, n);
}
function Gg(t) {
  return Vg('string' == typeof t ? JSON.parse(t) : t);
}
function Vg(t) {
  var n,
    e,
    r,
    i = t.marktype,
    o = t.items;
  if (o)
    for (e = 0, r = o.length; e < r; ++e)
      (o[e][(n = i ? 'mark' : 'group')] = t), o[e].zindex && (o[e][n].zdirty = !0), 'group' === (i || n) && Vg(o[e]);
  return i && Ug(t), t;
}
function Yg(t) {
  arguments.length
    ? (this.root = Gg(t))
    : ((this.root = Xg({ marktype: 'group', name: 'root', role: 'frame' })), (this.root.items = [new Hm(this.root)]));
}
function Xg(t, n) {
  const e = {
    bounds: new Um(),
    clip: !!t.clip,
    group: n,
    interactive: !1 !== t.interactive,
    items: [],
    marktype: t.marktype,
    name: t.name || void 0,
    role: t.role || void 0,
    zindex: t.zindex || 0,
  };
  return null != t.aria && (e.aria = t.aria), t.description && (e.description = t.description), e;
}
function Jg(t, n, e) {
  return (
    !t && 'undefined' != typeof document && document.createElement && (t = document),
    t ? (e ? t.createElementNS(e, n) : t.createElement(n)) : null
  );
}
function Qg(t, n) {
  n = n.toLowerCase();
  for (var e = t.childNodes, r = 0, i = e.length; r < i; ++r) if (e[r].tagName.toLowerCase() === n) return e[r];
}
function Zg(t, n, e, r) {
  var i,
    o = t.childNodes[n];
  return (
    (o && o.tagName.toLowerCase() === e.toLowerCase()) ||
      ((i = o || null), (o = Jg(t.ownerDocument, e, r)), t.insertBefore(o, i)),
    o
  );
}
function Kg(t, n) {
  for (var e = t.childNodes, r = e.length; r > n; ) t.removeChild(e[--r]);
  return t;
}
function tb(t) {
  return 'mark-' + t.marktype + (t.role ? ' role-' + t.role : '') + (t.name ? ' ' + t.name : '');
}
function nb(t, n) {
  const e = n.getBoundingClientRect();
  return [t.clientX - e.left - (n.clientLeft || 0), t.clientY - e.top - (n.clientTop || 0)];
}
function eb(t, n) {
  (this._active = null), (this._handlers = {}), (this._loader = t || xu()), (this._tooltip = n || rb);
}
function rb(t, n, e, r) {
  t.element().setAttribute('title', r || '');
}
function ib(t) {
  (this._el = null), (this._bgcolor = null), (this._loader = new Gm(t));
}
(Yg.prototype = {
  toJSON(t) {
    return Hg(this.root, t || 0);
  },
  mark(t, n, e) {
    const r = Xg(t, (n = n || this.root.items[0]));
    return (n.items[e] = r), r.zindex && (r.group.zdirty = !0), r;
  },
}),
  (eb.prototype = {
    initialize(t, n, e) {
      return (this._el = t), (this._obj = e || null), this.origin(n);
    },
    element() {
      return this._el;
    },
    canvas() {
      return this._el && this._el.firstChild;
    },
    origin(t) {
      return arguments.length ? ((this._origin = t || [0, 0]), this) : this._origin.slice();
    },
    scene(t) {
      return arguments.length ? ((this._scene = t), this) : this._scene;
    },
    on() {},
    off() {},
    _handlerIndex(t, n, e) {
      for (let r = t ? t.length : 0; --r >= 0; ) if (t[r].type === n && (!e || t[r].handler === e)) return r;
      return -1;
    },
    handlers(t) {
      const n = this._handlers,
        e = [];
      if (t) e.push(...n[this.eventName(t)]);
      else for (const t in n) e.push(...n[t]);
      return e;
    },
    eventName(t) {
      const n = t.indexOf('.');
      return n < 0 ? t : t.slice(0, n);
    },
    handleHref(t, n, e) {
      this._loader
        .sanitize(e, { context: 'href' })
        .then(n => {
          const e = new MouseEvent(t.type, t),
            r = Jg(null, 'a');
          for (const t in n) r.setAttribute(t, n[t]);
          r.dispatchEvent(e);
        })
        .catch(() => {});
    },
    handleTooltip(t, n, e) {
      n &&
        null != n.tooltip &&
        ((n = (function (t, n, e, r) {
          var i,
            o,
            u = t && t.mark;
          if (u && (i = Lg[u.marktype]).tip) {
            for ((o = nb(n, e))[0] -= r[0], o[1] -= r[1]; (t = t.mark.group); ) (o[0] -= t.x || 0), (o[1] -= t.y || 0);
            t = i.tip(u.items, o);
          }
          return t;
        })(n, t, this.canvas(), this._origin)),
        this._tooltip.call(this._obj, this, t, n, (e && n && n.tooltip) || null));
    },
    getItemBoundingClientRect(t) {
      const n = this.canvas();
      if (!n) return;
      const e = n.getBoundingClientRect(),
        r = this._origin,
        i = t.bounds,
        o = i.width(),
        u = i.height();
      let s = i.x1 + r[0] + e.left,
        a = i.y1 + r[1] + e.top;
      for (; t.mark && (t = t.mark.group); ) (s += t.x || 0), (a += t.y || 0);
      return { x: s, y: a, width: o, height: u, left: s, top: a, right: s + o, bottom: a + u };
    },
  }),
  (ib.prototype = {
    initialize(t, n, e, r, i) {
      return (this._el = t), this.resize(n, e, r, i);
    },
    element() {
      return this._el;
    },
    canvas() {
      return this._el && this._el.firstChild;
    },
    background(t) {
      return 0 === arguments.length ? this._bgcolor : ((this._bgcolor = t), this);
    },
    resize(t, n, e, r) {
      return (this._width = t), (this._height = n), (this._origin = e || [0, 0]), (this._scale = r || 1), this;
    },
    dirty() {},
    render(t) {
      const n = this;
      return (
        (n._call = function () {
          n._render(t);
        }),
        n._call(),
        (n._call = null),
        n
      );
    },
    _render() {},
    renderAsync(t) {
      const n = this.render(t);
      return this._ready ? this._ready.then(() => n) : Promise.resolve(n);
    },
    _load(t, n) {
      var e = this,
        r = e._loader[t](n);
      if (!e._ready) {
        const t = e._call;
        e._ready = e._loader.ready().then(n => {
          n && t(), (e._ready = null);
        });
      }
      return r;
    },
    sanitizeURL(t) {
      return this._load('sanitizeURL', t);
    },
    loadImage(t) {
      return this._load('loadImage', t);
    },
  });
const ob = 'dragenter',
  ub = 'dragleave',
  sb = 'dragover',
  ab = 'mousedown',
  cb = 'mousemove',
  lb = 'mouseout',
  fb = 'mouseover',
  hb = 'click',
  db = 'mousewheel',
  pb = 'touchstart',
  mb = 'touchmove',
  vb = 'touchend',
  gb = cb,
  bb = lb,
  yb = hb;
function wb(t, n) {
  eb.call(this, t, n), (this._down = null), (this._touch = null), (this._first = !0), (this._events = {});
}
function xb(t, n) {
  (t => (t === pb || t === mb || t === vb ? [pb, mb, vb] : [t]))(n).forEach(n =>
    (function (t, n) {
      const e = t.canvas();
      e && !t._events[n] && ((t._events[n] = 1), e.addEventListener(n, t[n] ? e => t[n](e) : e => t.fire(n, e)));
    })(t, n),
  );
}
function Ob(t, n, e) {
  return function (r) {
    const i = this._active,
      o = this.pickEvent(r);
    o === i || ((i && i.exit) || this.fire(e, r), (this._active = o), this.fire(n, r)), this.fire(t, r);
  };
}
function kb(t) {
  return function (n) {
    this.fire(t, n), (this._active = null);
  };
}
It(wb, eb, {
  initialize(t, n, e) {
    return (
      (this._canvas = t && Qg(t, 'canvas')),
      [hb, ab, cb, lb, ub].forEach(t => xb(this, t)),
      eb.prototype.initialize.call(this, t, n, e)
    );
  },
  canvas() {
    return this._canvas;
  },
  context() {
    return this._canvas.getContext('2d');
  },
  events: [
    'keydown',
    'keypress',
    'keyup',
    ob,
    ub,
    sb,
    ab,
    'mouseup',
    cb,
    lb,
    fb,
    hb,
    'dblclick',
    'wheel',
    db,
    pb,
    mb,
    vb,
  ],
  DOMMouseScroll(t) {
    this.fire(db, t);
  },
  mousemove: Ob(cb, fb, lb),
  dragover: Ob(sb, ob, ub),
  mouseout: kb(lb),
  dragleave: kb(ub),
  mousedown(t) {
    (this._down = this._active), this.fire(ab, t);
  },
  click(t) {
    this._down === this._active && (this.fire(hb, t), (this._down = null));
  },
  touchstart(t) {
    (this._touch = this.pickEvent(t.changedTouches[0])),
      this._first && ((this._active = this._touch), (this._first = !1)),
      this.fire(pb, t, !0);
  },
  touchmove(t) {
    this.fire(mb, t, !0);
  },
  touchend(t) {
    this.fire(vb, t, !0), (this._touch = null);
  },
  fire(t, n, e) {
    const r = e ? this._touch : this._active,
      i = this._handlers[t];
    if (
      ((n.vegaType = t),
      t === yb && r && r.href
        ? this.handleHref(n, r, r.href)
        : (t !== gb && t !== bb) || this.handleTooltip(n, r, t !== bb),
      i)
    )
      for (let t = 0, e = i.length; t < e; ++t) i[t].handler.call(this._obj, n, r);
  },
  on(t, n) {
    const e = this.eventName(t),
      r = this._handlers;
    return (
      this._handlerIndex(r[e], t, n) < 0 && (xb(this, t), (r[e] || (r[e] = [])).push({ type: t, handler: n })), this
    );
  },
  off(t, n) {
    const e = this.eventName(t),
      r = this._handlers[e],
      i = this._handlerIndex(r, t, n);
    return i >= 0 && r.splice(i, 1), this;
  },
  pickEvent(t) {
    const n = nb(t, this._canvas),
      e = this._origin;
    return this.pick(this._scene, n[0], n[1], n[0] - e[0], n[1] - e[1]);
  },
  pick(t, n, e, r, i) {
    const o = this.context();
    return Lg[t.marktype].pick.call(this, o, t, n, e, r, i);
  },
});
var Ab = ('undefined' != typeof window && window.devicePixelRatio) || 1;
function $b(t) {
  ib.call(this, t), (this._options = {}), (this._redraw = !1), (this._dirty = new Um()), (this._tempb = new Um());
}
const Mb = ib.prototype;
function jb(t, n) {
  eb.call(this, t, n);
  const e = this;
  (e._hrefHandler = Db(e, (t, n) => {
    n && n.href && e.handleHref(t, n, n.href);
  })),
    (e._tooltipHandler = Db(e, (t, n) => {
      e.handleTooltip(t, n, t.type !== bb);
    }));
}
It($b, ib, {
  initialize(t, n, e, r, i, o) {
    return (
      (this._options = o || {}),
      (this._canvas = this._options.externalContext ? null : ql(1, 1)),
      t && this._canvas && (Kg(t, 0).appendChild(this._canvas), this._canvas.setAttribute('class', 'marks')),
      Mb.initialize.call(this, t, n, e, r, i)
    );
  },
  resize(t, n, e, r) {
    if ((Mb.resize.call(this, t, n, e, r), this._canvas))
      !(function (t, n, e, r, i, o) {
        const u = 'undefined' != typeof HTMLElement && t instanceof HTMLElement && null != t.parentNode,
          s = t.getContext('2d'),
          a = u ? Ab : i;
        (t.width = n * a), (t.height = e * a);
        for (const t in o) s[t] = o[t];
        u && 1 !== a && ((t.style.width = n + 'px'), (t.style.height = e + 'px')),
          (s.pixelRatio = a),
          s.setTransform(a, 0, 0, a, a * r[0], a * r[1]);
      })(this._canvas, this._width, this._height, this._origin, this._scale, this._options.context);
    else {
      const t = this._options.externalContext;
      t || I('CanvasRenderer is missing a valid canvas or context'),
        t.scale(this._scale, this._scale),
        t.translate(this._origin[0], this._origin[1]);
    }
    return (this._redraw = !0), this;
  },
  canvas() {
    return this._canvas;
  },
  context() {
    return this._options.externalContext || (this._canvas ? this._canvas.getContext('2d') : null);
  },
  dirty(t) {
    const n = this._tempb.clear().union(t.bounds);
    let e = t.mark.group;
    for (; e; ) n.translate(e.x || 0, e.y || 0), (e = e.mark.group);
    this._dirty.union(n);
  },
  _render(t) {
    const n = this.context(),
      e = this._origin,
      r = this._width,
      i = this._height,
      o = this._dirty,
      u = ((t, n, e) => new Um().set(0, 0, n, e).translate(-t[0], -t[1]))(e, r, i);
    n.save();
    const s =
      this._redraw || o.empty()
        ? ((this._redraw = !1), u.expand(1))
        : (function (t, n, e) {
            return (
              n.expand(1).round(),
              t.pixelRatio % 1 &&
                n
                  .scale(t.pixelRatio)
                  .round()
                  .scale(1 / t.pixelRatio),
              n.translate(-e[0] % 1, -e[1] % 1),
              t.beginPath(),
              t.rect(n.x1, n.y1, n.width(), n.height()),
              t.clip(),
              n
            );
          })(n, u.intersect(o), e);
    return this.clear(-e[0], -e[1], r, i), this.draw(n, t, s), n.restore(), o.clear(), this;
  },
  draw(t, n, e) {
    const r = Lg[n.marktype];
    n.clip &&
      (function (t, n) {
        var e = n.clip;
        t.save(), Mt(e) ? (t.beginPath(), e(t), t.clip()) : Xv(t, n.group);
      })(t, n),
      r.draw.call(this, t, n, e),
      n.clip && t.restore();
  },
  clear(t, n, e, r) {
    const i = this._options,
      o = this.context();
    'pdf' === i.type || i.externalContext || o.clearRect(t, n, e, r),
      null != this._bgcolor && ((o.fillStyle = this._bgcolor), o.fillRect(t, n, e, r));
  },
});
const Db = (t, n) => e => {
  let r = e.target.__data__;
  (r = Array.isArray(r) ? r[0] : r), (e.vegaType = e.type), n.call(t._obj, e, r);
};
It(jb, eb, {
  initialize(t, n, e) {
    let r = this._svg;
    return (
      r &&
        (r.removeEventListener(yb, this._hrefHandler),
        r.removeEventListener(gb, this._tooltipHandler),
        r.removeEventListener(bb, this._tooltipHandler)),
      (this._svg = r = t && Qg(t, 'svg')),
      r &&
        (r.addEventListener(yb, this._hrefHandler),
        r.addEventListener(gb, this._tooltipHandler),
        r.addEventListener(bb, this._tooltipHandler)),
      eb.prototype.initialize.call(this, t, n, e)
    );
  },
  canvas() {
    return this._svg;
  },
  on(t, n) {
    const e = this.eventName(t),
      r = this._handlers;
    if (this._handlerIndex(r[e], t, n) < 0) {
      const i = { type: t, handler: n, listener: Db(this, n) };
      (r[e] || (r[e] = [])).push(i), this._svg && this._svg.addEventListener(e, i.listener);
    }
    return this;
  },
  off(t, n) {
    const e = this.eventName(t),
      r = this._handlers[e],
      i = this._handlerIndex(r, t, n);
    return i >= 0 && (this._svg && this._svg.removeEventListener(e, r[i].listener), r.splice(i, 1)), this;
  },
});
const Fb = 'aria-hidden',
  Eb = 'aria-label',
  Sb = 'role',
  Cb = 'aria-roledescription',
  Nb = 'graphics-object',
  Bb = 'graphics-symbol',
  _b = (t, n, e) => ({ [Sb]: t, [Cb]: n, [Eb]: e || void 0 }),
  zb = cn([
    'axis-domain',
    'axis-grid',
    'axis-label',
    'axis-tick',
    'axis-title',
    'legend-band',
    'legend-entry',
    'legend-gradient',
    'legend-label',
    'legend-title',
    'legend-symbol',
    'title',
  ]),
  Tb = {
    axis: {
      desc: 'axis',
      caption: function (t) {
        const n = t.datum,
          e = t.orient,
          r = n.title ? Ib(t) : null,
          i = t.context,
          o = i.scales[n.scale].value,
          u = i.dataflow.locale(),
          s = o.type;
        return (
          ''.concat('left' === e || 'right' === e ? 'Y' : 'X', '-axis') +
          (r ? " titled '".concat(r, "'") : '') +
          ' for a '.concat(ap(s) ? 'discrete' : s, ' scale') +
          ' with '.concat(qp(u, o, t))
        );
      },
    },
    legend: {
      desc: 'legend',
      caption: function (t) {
        const n = t.datum,
          e = n.title ? Ib(t) : null,
          r = ''.concat(n.type || '', ' legend').trim(),
          i = n.scales,
          o = Object.keys(i),
          u = t.context,
          s = u.scales[i[o[0]]].value,
          a = u.dataflow.locale();
        return (
          ((c = r).length ? c[0].toUpperCase() + c.slice(1) : c) +
          (e ? " titled '".concat(e, "'") : '') +
          ' for '.concat(
            (function (t) {
              return (t = t.map(t => t + ('fill' === t || 'stroke' === t ? ' color' : ''))).length < 2
                ? t[0]
                : t.slice(0, -1).join(', ') + ' and ' + ot(t);
            })(o),
          ) +
          ' with '.concat(qp(a, s, t))
        );
        var c;
      },
    },
    'title-text': { desc: 'title', caption: t => "Title text '".concat(qb(t), "'") },
    'title-subtitle': { desc: 'subtitle', caption: t => "Subtitle text '".concat(qb(t), "'") },
  },
  Pb = { ariaRole: Sb, ariaRoleDescription: Cb, description: Eb };
function Rb(t, n) {
  const e = !1 === n.aria;
  if ((t(Fb, e || void 0), e || null == n.description)) for (const n in Pb) t(Pb[n], void 0);
  else {
    const e = n.mark.marktype;
    t(Eb, n.description),
      t(Sb, n.ariaRole || ('group' === e ? Nb : Bb)),
      t(Cb, n.ariaRoleDescription || ''.concat(e, ' mark'));
  }
}
function Lb(t) {
  return !1 === t.aria
    ? { [Fb]: !0 }
    : zb[t.role]
    ? null
    : Tb[t.role]
    ? (function (t, n) {
        try {
          const e = t.items[0];
          return _b(n.role || Bb, n.desc, e.description || (n.caption || (() => ''))(e));
        } catch (t) {
          return null;
        }
      })(t, Tb[t.role])
    : (function (t) {
        const n = t.marktype,
          e = 'group' === n || 'text' === n || t.items.some(t => null != t.description && !1 !== t.aria);
        return _b(e ? Nb : Bb, ''.concat(n, ' mark container'), t.description);
      })(t);
}
function qb(t) {
  return At(t.text).join(' ');
}
function Ib(t) {
  try {
    return At(ot(t.items).items[0].text).join(' ');
  } catch (t) {
    return null;
  }
}
const Ub = t => (t + '').replace(/&/g, '&amp;').replace(/</g, '&lt;').replace(/>/g, '&gt;');
function Wb() {
  let t = '',
    n = '',
    e = '';
  const r = [],
    i = () => (n = e = ''),
    o = (t, e) => (
      null != e &&
        (n += ' '
          .concat(t, '="')
          .concat(
            Ub(e).replace(/"/g, '&quot;').replace(/\t/g, '&#x9;').replace(/\n/g, '&#xA;').replace(/\r/g, '&#xD;'),
            '"',
          )),
      u
    ),
    u = {
      open(s) {
        (o => {
          n && ((t += ''.concat(n, '>').concat(e)), i()), r.push(o);
        })(s),
          (n = '<' + s);
        for (var a = arguments.length, c = new Array(a > 1 ? a - 1 : 0), l = 1; l < a; l++) c[l - 1] = arguments[l];
        for (const t of c) for (const n in t) o(n, t[n]);
        return u;
      },
      close() {
        const o = r.pop();
        return (t += n ? n + (e ? '>'.concat(e, '</').concat(o, '>') : '/>') : '</'.concat(o, '>')), i(), u;
      },
      attr: o,
      text: t => ((e += Ub(t)), u),
      toString: () => t,
    };
  return u;
}
const Hb = t => Gb(Wb(), t) + '';
function Gb(t, n) {
  if ((t.open(n.tagName), n.hasAttributes())) {
    const e = n.attributes,
      r = e.length;
    for (let n = 0; n < r; ++n) t.attr(e[n].name, e[n].value);
  }
  if (n.hasChildNodes()) {
    const e = n.childNodes;
    for (const n of e) 3 === n.nodeType ? t.text(n.nodeValue) : Gb(t, n);
  }
  return t.close();
}
const Vb = {
    fill: 'fill',
    fillOpacity: 'fill-opacity',
    stroke: 'stroke',
    strokeOpacity: 'stroke-opacity',
    strokeWidth: 'stroke-width',
    strokeCap: 'stroke-linecap',
    strokeJoin: 'stroke-linejoin',
    strokeDash: 'stroke-dasharray',
    strokeDashOffset: 'stroke-dashoffset',
    strokeMiterLimit: 'stroke-miterlimit',
    opacity: 'opacity',
  },
  Yb = { blend: 'mix-blend-mode' },
  Xb = { fill: 'none', 'stroke-miterlimit': 10 },
  Jb = 'http://www.w3.org/2000/xmlns/',
  Qb = rg.xmlns;
function Zb(t) {
  ib.call(this, t),
    (this._dirtyID = 0),
    (this._dirty = []),
    (this._svg = null),
    (this._root = null),
    (this._defs = null);
}
const Kb = ib.prototype;
function ty(t, n) {
  for (; t && t.dirty !== n; t = t.mark.group) {
    if (((t.dirty = n), !t.mark || t.mark.dirty === n)) return;
    t.mark.dirty = n;
  }
}
function ny(t, n, e) {
  let r, i, o;
  if ('radial' === n.gradient) {
    let r = Zg(t, e++, 'pattern', Qb);
    cy(r, { id: Up + n.id, viewBox: '0,0,1,1', width: '100%', height: '100%', preserveAspectRatio: 'xMidYMid slice' }),
      (r = Zg(r, 0, 'rect', Qb)),
      cy(r, { width: 1, height: 1, fill: 'url('.concat(fy(), '#').concat(n.id, ')') }),
      cy((t = Zg(t, e++, 'radialGradient', Qb)), {
        id: n.id,
        fx: n.x1,
        fy: n.y1,
        fr: n.r1,
        cx: n.x2,
        cy: n.y2,
        r: n.r2,
      });
  } else cy((t = Zg(t, e++, 'linearGradient', Qb)), { id: n.id, x1: n.x1, x2: n.x2, y1: n.y1, y2: n.y2 });
  for (r = 0, i = n.stops.length; r < i; ++r)
    (o = Zg(t, r, 'stop', Qb)),
      o.setAttribute('offset', n.stops[r].offset),
      o.setAttribute('stop-color', n.stops[r].color);
  return Kg(t, r), e;
}
function ey(t, n, e) {
  let r;
  return (
    (t = Zg(t, e, 'clipPath', Qb)).setAttribute('id', n.id),
    n.path
      ? ((r = Zg(t, 0, 'path', Qb)), r.setAttribute('d', n.path))
      : ((r = Zg(t, 0, 'rect', Qb)), cy(r, { x: 0, y: 0, width: n.width, height: n.height })),
    Kg(t, 1),
    e + 1
  );
}
function ry(t, n, e, r, i) {
  let o,
    u = t._svg;
  if (
    !u &&
    ((o = n.ownerDocument),
    (u = Jg(o, r, Qb)),
    (t._svg = u),
    t.mark && ((u.__data__ = t), (u.__values__ = { fill: 'default' }), 'g' === r))
  ) {
    const n = Jg(o, 'path', Qb);
    u.appendChild(n), (n.__data__ = t);
    const e = Jg(o, 'g', Qb);
    u.appendChild(e), (e.__data__ = t);
    const r = Jg(o, 'path', Qb);
    u.appendChild(r), (r.__data__ = t), (r.__values__ = { fill: 'default' });
  }
  return (
    (u.ownerSVGElement !== i ||
      (function (t, n) {
        return t.parentNode && t.parentNode.childNodes.length > 1 && t.previousSibling != n;
      })(u, e)) &&
      n.insertBefore(u, e ? e.nextSibling : n.firstChild),
    u
  );
}
It(Zb, ib, {
  initialize(t, n, e, r, i) {
    return (
      (this._defs = {}),
      this._clearDefs(),
      t &&
        ((this._svg = Zg(t, 0, 'svg', Qb)),
        this._svg.setAttributeNS(Jb, 'xmlns', Qb),
        this._svg.setAttributeNS(Jb, 'xmlns:xlink', rg['xmlns:xlink']),
        this._svg.setAttribute('version', rg.version),
        this._svg.setAttribute('class', 'marks'),
        Kg(t, 1),
        (this._root = Zg(this._svg, 0, 'g', Qb)),
        cy(this._root, Xb),
        Kg(this._svg, 1)),
      this.background(this._bgcolor),
      Kb.initialize.call(this, t, n, e, r, i)
    );
  },
  background(t) {
    return (
      arguments.length && this._svg && this._svg.style.setProperty('background-color', t),
      Kb.background.apply(this, arguments)
    );
  },
  resize(t, n, e, r) {
    return (
      Kb.resize.call(this, t, n, e, r),
      this._svg &&
        (cy(this._svg, {
          width: this._width * this._scale,
          height: this._height * this._scale,
          viewBox: '0 0 '.concat(this._width, ' ').concat(this._height),
        }),
        this._root.setAttribute('transform', 'translate('.concat(this._origin, ')'))),
      (this._dirty = []),
      this
    );
  },
  canvas() {
    return this._svg;
  },
  svg() {
    const t = this._svg,
      n = this._bgcolor;
    if (!t) return null;
    let e;
    n &&
      (t.removeAttribute('style'),
      (e = Zg(t, 0, 'rect', Qb)),
      cy(e, { width: this._width, height: this._height, fill: n }));
    const r = Hb(t);
    return n && (t.removeChild(e), this._svg.style.setProperty('background-color', n)), r;
  },
  _render(t) {
    return (
      this._dirtyCheck() && (this._dirtyAll && this._clearDefs(), this.mark(this._root, t), Kg(this._root, 1)),
      this.defs(),
      (this._dirty = []),
      ++this._dirtyID,
      this
    );
  },
  dirty(t) {
    t.dirty !== this._dirtyID && ((t.dirty = this._dirtyID), this._dirty.push(t));
  },
  isDirty(t) {
    return this._dirtyAll || !t._svg || !t._svg.ownerSVGElement || t.dirty === this._dirtyID;
  },
  _dirtyCheck() {
    this._dirtyAll = !0;
    const t = this._dirty;
    if (!t.length || !this._dirtyID) return !0;
    const n = ++this._dirtyID;
    let e, r, i, o, u, s, a;
    for (u = 0, s = t.length; u < s; ++u)
      (e = t[u]),
        (r = e.mark),
        r.marktype !== i && ((i = r.marktype), (o = Lg[i])),
        r.zdirty &&
          r.dirty !== n &&
          ((this._dirtyAll = !1),
          ty(e, n),
          r.items.forEach(t => {
            t.dirty = n;
          })),
        r.zdirty ||
          (e.exit
            ? (o.nested && r.items.length
                ? ((a = r.items[0]), a._svg && this._update(o, a._svg, a))
                : e._svg && ((a = e._svg.parentNode), a && a.removeChild(e._svg)),
              (e._svg = null))
            : ((e = o.nested ? r.items[0] : e),
              e._update !== n &&
                (e._svg && e._svg.ownerSVGElement ? this._update(o, e._svg, e) : ((this._dirtyAll = !1), ty(e, n)),
                (e._update = n))));
    return !this._dirtyAll;
  },
  mark(t, n, e) {
    if (!this.isDirty(n)) return n._svg;
    const r = this._svg,
      i = Lg[n.marktype],
      o = !1 === n.interactive ? 'none' : null,
      u = 'g' === i.tag,
      s = ry(n, t, e, 'g', r);
    s.setAttribute('class', tb(n));
    const a = Lb(n);
    for (const t in a) ly(s, t, a[t]);
    u || ly(s, 'pointer-events', o), ly(s, 'clip-path', n.clip ? Im(this, n, n.group) : null);
    let c = null,
      l = 0;
    const f = t => {
      const n = this.isDirty(t),
        e = ry(t, s, c, i.tag, r);
      n &&
        (this._update(i, e, t),
        u &&
          (function (t, n, e) {
            n = n.lastChild.previousSibling;
            let r,
              i = 0;
            Bv(e, e => {
              (r = t.mark(n, e, r)), ++i;
            }),
              Kg(n, 1 + i);
          })(this, e, t)),
        (c = e),
        ++l;
    };
    return i.nested ? n.items.length && f(n.items[0]) : Bv(n, f), Kg(s, l), s;
  },
  _update(t, n, e) {
    (iy = n), (oy = n.__values__), Rb(sy, e), t.attr(sy, e, this);
    const r = uy[t.type];
    r && r.call(this, t, n, e), iy && this.style(iy, e);
  },
  style(t, n) {
    if (null != n) {
      for (const e in Vb) {
        let r = 'font' === e ? Sg(n) : n[e];
        if (r === oy[e]) continue;
        const i = Vb[e];
        null == r ? t.removeAttribute(i) : (Wp(r) && (r = Hp(r, this._defs.gradient, fy())), t.setAttribute(i, r + '')),
          (oy[e] = r);
      }
      for (const e in Yb) ay(t, Yb[e], n[e]);
    }
  },
  defs() {
    const t = this._svg,
      n = this._defs;
    let e = n.el,
      r = 0;
    for (const i in n.gradient) e || (n.el = e = Zg(t, 1, 'defs', Qb)), (r = ny(e, n.gradient[i], r));
    for (const i in n.clipping) e || (n.el = e = Zg(t, 1, 'defs', Qb)), (r = ey(e, n.clipping[i], r));
    e && (0 === r ? (t.removeChild(e), (n.el = null)) : Kg(e, r));
  },
  _clearDefs() {
    const t = this._defs;
    (t.gradient = {}), (t.clipping = {});
  },
});
let iy = null,
  oy = null;
const uy = {
  group(t, n, e) {
    const r = (iy = n.childNodes[2]);
    (oy = r.__values__), t.foreground(sy, e, this), (oy = n.__values__), (iy = n.childNodes[1]), t.content(sy, e, this);
    const i = (iy = n.childNodes[0]);
    t.background(sy, e, this);
    const o = !1 === e.mark.interactive ? 'none' : null;
    if (
      (o !== oy.events && (ly(r, 'pointer-events', o), ly(i, 'pointer-events', o), (oy.events = o)),
      e.strokeForeground && e.stroke)
    ) {
      const t = e.fill;
      ly(r, 'display', null),
        this.style(i, e),
        ly(i, 'stroke', null),
        t && (e.fill = null),
        (oy = r.__values__),
        this.style(r, e),
        t && (e.fill = t),
        (iy = null);
    } else ly(r, 'display', 'none');
  },
  image(t, n, e) {
    !1 === e.smooth
      ? (ay(n, 'image-rendering', 'optimizeSpeed'), ay(n, 'image-rendering', 'pixelated'))
      : ay(n, 'image-rendering', null);
  },
  text(t, n, e) {
    const r = Dg(e);
    let i, o, u, s;
    K(r)
      ? ((o = r.map(t => Eg(e, t))),
        (i = o.join('\n')),
        i !== oy.text &&
          (Kg(n, 0),
          (u = n.ownerDocument),
          (s = jg(e)),
          o.forEach((t, r) => {
            const i = Jg(u, 'tspan', Qb);
            (i.__data__ = e),
              (i.textContent = t),
              r && (i.setAttribute('x', 0), i.setAttribute('dy', s)),
              n.appendChild(i);
          }),
          (oy.text = i)))
      : ((o = Eg(e, r)), o !== oy.text && ((n.textContent = o), (oy.text = o))),
      ly(n, 'font-family', Sg(e)),
      ly(n, 'font-size', Mg(e) + 'px'),
      ly(n, 'font-style', e.fontStyle),
      ly(n, 'font-variant', e.fontVariant),
      ly(n, 'font-weight', e.fontWeight);
  },
};
function sy(t, n, e) {
  n !== oy[t] &&
    (e
      ? (function (t, n, e, r) {
          null != e ? t.setAttributeNS(r, n, e) : t.removeAttributeNS(r, n);
        })(iy, t, n, e)
      : ly(iy, t, n),
    (oy[t] = n));
}
function ay(t, n, e) {
  e !== oy[n] && (null == e ? t.style.removeProperty(n) : t.style.setProperty(n, e + ''), (oy[n] = e));
}
function cy(t, n) {
  for (const e in n) ly(t, e, n[e]);
}
function ly(t, n, e) {
  null != e ? t.setAttribute(n, e) : t.removeAttribute(n);
}
function fy() {
  let t;
  return 'undefined' == typeof window ? '' : (t = window.location).hash ? t.href.slice(0, -t.hash.length) : t.href;
}
function hy(t) {
  ib.call(this, t), (this._text = null), (this._defs = { gradient: {}, clipping: {} });
}
It(hy, ib, {
  svg() {
    return this._text;
  },
  _render(t) {
    const n = Wb();
    n.open(
      'svg',
      Bt({}, rg, {
        class: 'marks',
        width: this._width * this._scale,
        height: this._height * this._scale,
        viewBox: '0 0 '.concat(this._width, ' ').concat(this._height),
      }),
    );
    const e = this._bgcolor;
    return (
      e &&
        'transparent' !== e &&
        'none' !== e &&
        n.open('rect', { width: this._width, height: this._height, fill: e }).close(),
      n.open('g', Xb, { transform: 'translate(' + this._origin + ')' }),
      this.mark(n, t),
      n.close(),
      this.defs(n),
      (this._text = n.close() + ''),
      this
    );
  },
  mark(t, n) {
    const e = Lg[n.marktype],
      r = e.tag,
      i = [Rb, e.attr];
    t.open('g', { class: tb(n), 'clip-path': n.clip ? Im(this, n, n.group) : null }, Lb(n), {
      'pointer-events': 'g' !== r && !1 === n.interactive ? 'none' : null,
    });
    const o = o => {
      const u = this.href(o);
      if ((u && t.open('a', u), t.open(r, this.attr(n, o, i, 'g' !== r ? r : null)), 'text' === r)) {
        const n = Dg(o);
        if (K(n)) {
          const e = { x: 0, dy: jg(o) };
          for (let r = 0; r < n.length; ++r)
            t.open('tspan', r ? e : null)
              .text(Eg(o, n[r]))
              .close();
        } else t.text(Eg(o, n));
      } else if ('g' === r) {
        const r = o.strokeForeground,
          i = o.fill,
          u = o.stroke;
        r && u && (o.stroke = null),
          t.open('path', this.attr(n, o, e.background, 'bgrect')).close(),
          t.open('g', this.attr(n, o, e.content)),
          Bv(o, n => this.mark(t, n)),
          t.close(),
          r && u
            ? (i && (o.fill = null),
              (o.stroke = u),
              t.open('path', this.attr(n, o, e.foreground, 'bgrect')).close(),
              i && (o.fill = i))
            : t.open('path', this.attr(n, o, e.foreground, 'bgfore')).close();
      }
      t.close(), u && t.close();
    };
    return e.nested ? n.items && n.items.length && o(n.items[0]) : Bv(n, o), t.close();
  },
  href(t) {
    const n = t.href;
    let e;
    if (n) {
      if ((e = this._hrefs && this._hrefs[n])) return e;
      this.sanitizeURL(n).then(t => {
        (t['xlink:href'] = t.href), (t.href = null), ((this._hrefs || (this._hrefs = {}))[n] = t);
      });
    }
    return null;
  },
  attr(t, n, e, r) {
    const i = {},
      o = (t, n, e, r) => {
        i[r || t] = n;
      };
    return (
      Array.isArray(e) ? e.forEach(t => t(o, n, this)) : e(o, n, this),
      r &&
        (function (t, n, e, r, i) {
          let o;
          if (null == n) return t;
          if (
            ('bgrect' === r && !1 === e.interactive && (t['pointer-events'] = 'none'),
            'bgfore' === r &&
              (!1 === e.interactive && (t['pointer-events'] = 'none'), (t.display = 'none'), null !== n.fill))
          )
            return t;
          'image' === r && !1 === n.smooth && (o = ['image-rendering: optimizeSpeed;', 'image-rendering: pixelated;']),
            'text' === r &&
              ((t['font-family'] = Sg(n)),
              (t['font-size'] = Mg(n) + 'px'),
              (t['font-style'] = n.fontStyle),
              (t['font-variant'] = n.fontVariant),
              (t['font-weight'] = n.fontWeight));
          for (const e in Vb) {
            let r = n[e];
            const o = Vb[e];
            ('transparent' !== r || ('fill' !== o && 'stroke' !== o)) &&
              null != r &&
              (Wp(r) && (r = Hp(r, i.gradient, '')), (t[o] = r));
          }
          for (const t in Yb) {
            const e = n[t];
            null != e && ((o = o || []), o.push(''.concat(Yb[t], ': ').concat(e, ';')));
          }
          o && (t.style = o.join(' '));
        })(i, n, t, r, this._defs),
      i
    );
  },
  defs(t) {
    const n = this._defs.gradient,
      e = this._defs.clipping;
    if (0 !== Object.keys(n).length + Object.keys(e).length) {
      t.open('defs');
      for (const e in n) {
        const r = n[e],
          i = r.stops;
        'radial' === r.gradient
          ? (t.open('pattern', {
              id: Up + e,
              viewBox: '0,0,1,1',
              width: '100%',
              height: '100%',
              preserveAspectRatio: 'xMidYMid slice',
            }),
            t.open('rect', { width: '1', height: '1', fill: 'url(#' + e + ')' }).close(),
            t.close(),
            t.open('radialGradient', { id: e, fx: r.x1, fy: r.y1, fr: r.r1, cx: r.x2, cy: r.y2, r: r.r2 }))
          : t.open('linearGradient', { id: e, x1: r.x1, x2: r.x2, y1: r.y1, y2: r.y2 });
        for (let n = 0; n < i.length; ++n) t.open('stop', { offset: i[n].offset, 'stop-color': i[n].color }).close();
        t.close();
      }
      for (const n in e) {
        const r = e[n];
        t.open('clipPath', { id: n }),
          r.path
            ? t.open('path', { d: r.path }).close()
            : t.open('rect', { x: 0, y: 0, width: r.width, height: r.height }).close(),
          t.close();
      }
      t.close();
    }
  },
});
const dy = 'canvas',
  py = 'none',
  my = { Canvas: dy, PNG: 'png', SVG: 'svg', None: py },
  vy = {};
function gy(t, n) {
  return (t = String(t || '').toLowerCase()), arguments.length > 1 ? ((vy[t] = n), this) : vy[t];
}
function by(t, n, e) {
  const r = [],
    i = new Um().union(n),
    o = t.marktype;
  return o ? yy(t, i, e, r) : 'group' === o ? wy(t, i, e, r) : I('Intersect scene must be mark node or group item.');
}
function yy(t, n, e, r) {
  if (
    (function (t, n, e) {
      return t.bounds && n.intersects(t.bounds) && ('group' === t.marktype || (!1 !== t.interactive && (!e || e(t))));
    })(t, n, e)
  ) {
    const i = t.items,
      o = t.marktype,
      u = i.length;
    let s = 0;
    if ('group' === o) for (; s < u; ++s) wy(i[s], n, e, r);
    else
      for (const t = Lg[o].isect; s < u; ++s) {
        const e = i[s];
        xy(e, n, t) && r.push(e);
      }
  }
  return r;
}
function wy(t, n, e, r) {
  e && e(t.mark) && xy(t, n, Lg.group.isect) && r.push(t);
  const i = t.items,
    o = i && i.length;
  if (o) {
    const u = t.x || 0,
      s = t.y || 0;
    n.translate(-u, -s);
    for (let t = 0; t < o; ++t) yy(i[t], n, e, r);
    n.translate(u, s);
  }
  return r;
}
function xy(t, n, e) {
  const r = t.bounds;
  return n.encloses(r) || (n.intersects(r) && e(t, n));
}
(vy[dy] = vy.png = { renderer: $b, headless: $b, handler: wb }),
  (vy.svg = { renderer: Zb, headless: hy, handler: jb }),
  (vy[py] = {});
const Oy = new Um();
function ky(t) {
  const n = t.clip;
  if (Mt(n)) n(dv(Oy.clear()));
  else {
    if (!n) return;
    Oy.set(0, 0, t.group.width, t.group.height);
  }
  t.bounds.intersect(Oy);
}
function Ay(t, n, e) {
  return (
    t === n ||
    ('path' === e
      ? $y(t, n)
      : t instanceof Date && n instanceof Date
      ? +t == +n
      : Vt(t) && Vt(n)
      ? Math.abs(t - n) <= 1e-9
      : t && n && (tt(t) || tt(n))
      ? (function (t, n) {
          var e,
            r,
            i = Object.keys(t),
            o = Object.keys(n);
          if (i.length !== o.length) return !1;
          for (i.sort(), o.sort(), r = i.length - 1; r >= 0; r--) if (i[r] != o[r]) return !1;
          for (r = i.length - 1; r >= 0; r--) if (!Ay(t[(e = i[r])], n[e], e)) return !1;
          return typeof t == typeof n;
        })(t, n)
      : t == n)
  );
}
function $y(t, n) {
  return Ay(nm(t), nm(n));
}
const My = 'top',
  jy = 'left',
  Dy = 'right',
  Fy = 'bottom',
  Ey = 'start',
  Sy = 'middle',
  Cy = 'end',
  Ny = 'group',
  By = 'axis',
  _y = 'title',
  zy = 'legend',
  Ty = 'row-header',
  Py = 'row-footer',
  Ry = 'row-title',
  Ly = 'column-header',
  qy = 'column-footer',
  Iy = 'column-title',
  Uy = 'none',
  Wy = 'all',
  Hy = 'each',
  Gy = 'flush',
  Vy = 'column',
  Yy = 'row';
function Xy(t) {
  os.call(this, null, t);
}
function Jy(t, n, e) {
  return n(t.bounds.clear(), t, e);
}
It(Xy, os, {
  transform(t, n) {
    const e = n.dataflow,
      r = t.mark,
      i = r.marktype,
      o = Lg[i],
      u = o.bound;
    let s,
      a = r.bounds;
    if (o.nested)
      r.items.length && e.dirty(r.items[0]),
        (a = Jy(r, u)),
        r.items.forEach(t => {
          t.bounds.clear().union(a);
        });
    else if (i === Ny || t.modified())
      switch ((n.visit(n.MOD, t => e.dirty(t)), a.clear(), r.items.forEach(t => a.union(Jy(t, u))), r.role)) {
        case By:
        case zy:
        case _y:
          n.reflow();
      }
    else
      (s = n.changed(n.REM)),
        n.visit(n.ADD, t => {
          a.union(Jy(t, u));
        }),
        n.visit(n.MOD, t => {
          (s = s || a.alignsWith(t.bounds)), e.dirty(t), a.union(Jy(t, u));
        }),
        s && (a.clear(), r.items.forEach(t => a.union(t.bounds)));
    return ky(r), n.modifies('bounds');
  },
});
const Qy = ':vega_identifier:';
function Zy(t) {
  os.call(this, 0, t);
}
function Ky(t) {
  os.call(this, null, t);
}
function tw(t) {
  os.call(this, null, t);
}
(Zy.Definition = {
  type: 'Identifier',
  metadata: { modifies: !0 },
  params: [{ name: 'as', type: 'string', required: !0 }],
}),
  It(Zy, os, {
    transform(t, n) {
      const e = (i = n.dataflow)._signals[Qy] || (i._signals[Qy] = i.add(0)),
        r = t.as;
      var i;
      let o = e.value;
      return n.visit(n.ADD, t => (t[r] = t[r] || ++o)), e.set((this.value = o)), n;
    },
  }),
  It(Ky, os, {
    transform(t, n) {
      let e = this.value;
      e ||
        ((e = n.dataflow.scenegraph().mark(
          t.markdef,
          (function (t) {
            const n = t.groups,
              e = t.parent;
            return n && 1 === n.size ? n.get(Object.keys(n.object)[0]) : n && e ? n.lookup(e) : null;
          })(t),
          t.index,
        )),
        (e.group.context = t.context),
        t.context.group || (t.context.group = e.group),
        (e.source = this.source),
        (e.clip = t.clip),
        (e.interactive = t.interactive),
        (this.value = e));
      const r = e.marktype === Ny ? Hm : Wm;
      return (
        n.visit(n.ADD, t => r.call(t, e)),
        (t.modified('clip') || t.modified('interactive')) &&
          ((e.clip = t.clip), (e.interactive = !!t.interactive), (e.zdirty = !0), n.reflow()),
        (e.items = n.source),
        n
      );
    },
  });
const nw = {
    parity: t => t.filter((t, n) => (n % 2 ? (t.opacity = 0) : 1)),
    greedy: (t, n) => {
      let e;
      return t.filter((t, r) => (r && ew(e.bounds, t.bounds, n) ? (t.opacity = 0) : ((e = t), 1)));
    },
  },
  ew = (t, n, e) => e > Math.max(n.x1 - t.x2, t.x1 - n.x2, n.y1 - t.y2, t.y1 - n.y2),
  rw = (t, n) => {
    for (var e, r = 1, i = t.length, o = t[0].bounds; r < i; o = e, ++r) if (ew(o, (e = t[r].bounds), n)) return !0;
  },
  iw = t => {
    const n = t.bounds;
    return n.width() > 1 && n.height() > 1;
  },
  ow = t => (t.forEach(t => (t.opacity = 1)), t),
  uw = (t, n) => t.reflow(n.modified()).modifies('opacity');
function sw(t) {
  os.call(this, null, t);
}
It(tw, os, {
  transform(t, n) {
    const e = nw[t.method] || nw.parity,
      r = t.separation || 0;
    let i,
      o,
      u = n.materialize(n.SOURCE).source;
    if (!u || !u.length) return;
    if (!t.method) return t.modified('method') && (ow(u), (n = uw(n, t))), n;
    if (((u = u.filter(iw)), !u.length)) return;
    if ((t.sort && (u = u.slice().sort(t.sort)), (i = ow(u)), (n = uw(n, t)), i.length >= 3 && rw(i, r))) {
      do {
        i = e(i, r);
      } while (i.length >= 3 && rw(i, r));
      i.length < 3 && !ot(u).opacity && (i.length > 1 && (ot(i).opacity = 0), (ot(u).opacity = 1));
    }
    t.boundScale &&
      t.boundTolerance >= 0 &&
      ((o = ((t, n, e) => {
        var r = t.range(),
          i = new Um();
        return (
          n === My || n === Fy ? i.set(r[0], -1 / 0, r[1], 1 / 0) : i.set(-1 / 0, r[0], 1 / 0, r[1]),
          i.expand(e || 1),
          t => i.encloses(t.bounds)
        );
      })(t.boundScale, t.boundOrient, +t.boundTolerance)),
      u.forEach(t => {
        o(t) || (t.opacity = 0);
      }));
    const s = i[0].mark.bounds.clear();
    return (
      u.forEach(t => {
        t.opacity && s.union(t.bounds);
      }),
      n
    );
  },
}),
  It(sw, os, {
    transform(t, n) {
      const e = n.dataflow;
      if ((n.visit(n.ALL, t => e.dirty(t)), n.fields && n.fields.zindex)) {
        const t = n.source && n.source[0];
        t && (t.mark.zdirty = !0);
      }
    },
  });
const aw = new Um();
function cw(t, n, e) {
  return t[n] === e ? 0 : ((t[n] = e), 1);
}
function lw(t) {
  var n = t.items[0].orient;
  return n === jy || n === Dy;
}
function fw(t, n, e, r) {
  var i,
    o,
    u = n.items[0],
    s = u.datum,
    a = null != u.translate ? u.translate : 0.5,
    c = u.orient,
    l = (function (t) {
      let n = +t.grid;
      return [t.ticks ? n++ : -1, t.labels ? n++ : -1, n + +t.domain];
    })(s),
    f = u.range,
    h = u.offset,
    d = u.position,
    p = u.minExtent,
    m = u.maxExtent,
    v = s.title && u.items[l[2]].items[0],
    g = u.titlePadding,
    b = u.bounds,
    y = v && Fg(v),
    w = 0,
    x = 0;
  switch (
    (aw.clear().union(b),
    b.clear(),
    (i = l[0]) > -1 && b.union(u.items[i].bounds),
    (i = l[1]) > -1 && b.union(u.items[i].bounds),
    c)
  ) {
    case My:
      (w = d || 0),
        (x = -h),
        (o = Math.max(p, Math.min(m, -b.y1))),
        b.add(0, -o).add(f, 0),
        v && hw(t, v, o, g, y, 0, -1, b);
      break;
    case jy:
      (w = -h),
        (x = d || 0),
        (o = Math.max(p, Math.min(m, -b.x1))),
        b.add(-o, 0).add(0, f),
        v && hw(t, v, o, g, y, 1, -1, b);
      break;
    case Dy:
      (w = e + h),
        (x = d || 0),
        (o = Math.max(p, Math.min(m, b.x2))),
        b.add(0, 0).add(o, f),
        v && hw(t, v, o, g, y, 1, 1, b);
      break;
    case Fy:
      (w = d || 0),
        (x = r + h),
        (o = Math.max(p, Math.min(m, b.y2))),
        b.add(0, 0).add(f, o),
        v && hw(t, v, o, g, 0, 0, 1, b);
      break;
    default:
      (w = u.x), (x = u.y);
  }
  return (
    Xm(b.translate(w, x), u),
    cw(u, 'x', w + a) | cw(u, 'y', x + a) && ((u.bounds = aw), t.dirty(u), (u.bounds = b), t.dirty(u)),
    u.mark.bounds.clear().union(b)
  );
}
function hw(t, n, e, r, i, o, u, s) {
  const a = n.bounds;
  if (n.auto) {
    const s = u * (e + i + r);
    let c = 0,
      l = 0;
    t.dirty(n),
      o ? (c = (n.x || 0) - (n.x = s)) : (l = (n.y || 0) - (n.y = s)),
      n.mark.bounds.clear().union(a.translate(-c, -l)),
      t.dirty(n);
  }
  s.union(a);
}
const dw = (t, n) => Math.floor(Math.min(t, n)),
  pw = (t, n) => Math.ceil(Math.max(t, n));
function mw(t) {
  return new Um().set(0, 0, t.width || 0, t.height || 0);
}
function vw(t) {
  const n = t.bounds.clone();
  return n.empty() ? n.set(0, 0, 0, 0) : n.translate(-(t.x || 0), -(t.y || 0));
}
function gw(t, n, e) {
  const r = tt(t) ? t[n] : t;
  return null != r ? r : void 0 !== e ? e : 0;
}
function bw(t) {
  return t < 0 ? Math.ceil(-t) : 0;
}
function yw(t, n, e) {
  var r,
    i,
    o,
    u,
    s,
    a,
    c,
    l,
    f,
    h,
    d,
    p = !e.nodirty,
    m = e.bounds === Gy ? mw : vw,
    v = aw.set(0, 0, 0, 0),
    g = gw(e.align, Vy),
    b = gw(e.align, Yy),
    y = gw(e.padding, Vy),
    w = gw(e.padding, Yy),
    x = e.columns || n.length,
    O = x <= 0 ? 1 : Math.ceil(n.length / x),
    k = n.length,
    A = Array(k),
    $ = Array(x),
    M = 0,
    j = Array(k),
    D = Array(O),
    F = 0,
    E = Array(k),
    S = Array(k),
    C = Array(k);
  for (i = 0; i < x; ++i) $[i] = 0;
  for (i = 0; i < O; ++i) D[i] = 0;
  for (i = 0; i < k; ++i)
    (s = C[i] = m((a = n[i]))),
      (a.x = a.x || 0),
      (E[i] = 0),
      (a.y = a.y || 0),
      (S[i] = 0),
      (o = i % x),
      (u = ~~(i / x)),
      (M = Math.max(M, (c = Math.ceil(s.x2)))),
      (F = Math.max(F, (l = Math.ceil(s.y2)))),
      ($[o] = Math.max($[o], c)),
      (D[u] = Math.max(D[u], l)),
      (A[i] = y + bw(s.x1)),
      (j[i] = w + bw(s.y1)),
      p && t.dirty(n[i]);
  for (i = 0; i < k; ++i) i % x == 0 && (A[i] = 0), i < x && (j[i] = 0);
  if (g === Hy)
    for (o = 1; o < x; ++o) {
      for (d = 0, i = o; i < k; i += x) d < A[i] && (d = A[i]);
      for (i = o; i < k; i += x) A[i] = d + $[o - 1];
    }
  else if (g === Wy) {
    for (d = 0, i = 0; i < k; ++i) i % x && d < A[i] && (d = A[i]);
    for (i = 0; i < k; ++i) i % x && (A[i] = d + M);
  } else for (g = !1, o = 1; o < x; ++o) for (i = o; i < k; i += x) A[i] += $[o - 1];
  if (b === Hy)
    for (u = 1; u < O; ++u) {
      for (d = 0, r = (i = u * x) + x; i < r; ++i) d < j[i] && (d = j[i]);
      for (i = u * x; i < r; ++i) j[i] = d + D[u - 1];
    }
  else if (b === Wy) {
    for (d = 0, i = x; i < k; ++i) d < j[i] && (d = j[i]);
    for (i = x; i < k; ++i) j[i] = d + F;
  } else for (b = !1, u = 1; u < O; ++u) for (r = (i = u * x) + x; i < r; ++i) j[i] += D[u - 1];
  for (f = 0, i = 0; i < k; ++i) E[i] += (f = A[i] + (i % x ? f : 0)) - n[i].x;
  for (o = 0; o < x; ++o) for (h = 0, i = o; i < k; i += x) S[i] += (h += j[i]) - n[i].y;
  if (g && gw(e.center, Vy) && O > 1)
    for (i = 0; i < k; ++i) (f = (s = g === Wy ? M : $[i % x]) - C[i].x2 - n[i].x - E[i]) > 0 && (E[i] += f / 2);
  if (b && gw(e.center, Yy) && 1 !== x)
    for (i = 0; i < k; ++i) (h = (s = b === Wy ? F : D[~~(i / x)]) - C[i].y2 - n[i].y - S[i]) > 0 && (S[i] += h / 2);
  for (i = 0; i < k; ++i) v.union(C[i].translate(E[i], S[i]));
  switch (((f = gw(e.anchor, 'x')), (h = gw(e.anchor, 'y')), gw(e.anchor, Vy))) {
    case Cy:
      f -= v.width();
      break;
    case Sy:
      f -= v.width() / 2;
  }
  switch (gw(e.anchor, Yy)) {
    case Cy:
      h -= v.height();
      break;
    case Sy:
      h -= v.height() / 2;
  }
  for (f = Math.round(f), h = Math.round(h), v.clear(), i = 0; i < k; ++i) n[i].mark.bounds.clear();
  for (i = 0; i < k; ++i)
    ((a = n[i]).x += E[i] += f),
      (a.y += S[i] += h),
      v.union(a.mark.bounds.union(a.bounds.translate(E[i], S[i]))),
      p && t.dirty(a);
  return v;
}
function ww(t, n) {
  return 'x1' === n
    ? t.x || 0
    : 'y1' === n
    ? t.y || 0
    : 'x2' === n
    ? (t.x || 0) + (t.width || 0)
    : 'y2' === n
    ? (t.y || 0) + (t.height || 0)
    : void 0;
}
function xw(t, n) {
  return t.bounds[n];
}
function Ow(t, n, e, r, i, o, u, s, a, c, l, f, h, d) {
  var p,
    m,
    v,
    g,
    b,
    y,
    w,
    x,
    O,
    k = e.length,
    A = 0,
    $ = 0;
  if (!k) return A;
  for (p = l; p < k; p += f) e[p] && (A = u(A, a(e[p], c)));
  if (!n.length) return A;
  for (
    n.length > i && (t.warn('Grid headers exceed limit: ' + i), (n = n.slice(0, i))), A += o, m = 0, g = n.length;
    m < g;
    ++m
  )
    t.dirty(n[m]), n[m].mark.bounds.clear();
  for (p = l, m = 0, g = n.length; m < g; ++m, p += f) {
    for (b = (y = n[m]).mark.bounds, v = p; v >= 0 && null == (w = e[v]); v -= h);
    s
      ? ((x = null == d ? w.x : Math.round(w.bounds.x1 + d * w.bounds.width())), (O = A))
      : ((x = A), (O = null == d ? w.y : Math.round(w.bounds.y1 + d * w.bounds.height()))),
      b.union(y.bounds.translate(x - (y.x || 0), O - (y.y || 0))),
      (y.x = x),
      (y.y = O),
      t.dirty(y),
      ($ = u($, b[c]));
  }
  return $;
}
function kw(t, n, e, r, i, o) {
  if (n) {
    t.dirty(n);
    var u = e,
      s = e;
    r ? (u = Math.round(i.x1 + o * i.width())) : (s = Math.round(i.y1 + o * i.height())),
      n.bounds.translate(u - (n.x || 0), s - (n.y || 0)),
      n.mark.bounds.clear().union(n.bounds),
      (n.x = u),
      (n.y = s),
      t.dirty(n);
  }
}
function Aw(t, n, e, r, i, o, u) {
  const s = (function (t, n) {
      const e = t[n] || {};
      return (n, r) => (null != e[n] ? e[n] : null != t[n] ? t[n] : r);
    })(e, n),
    a = (function (t, n) {
      let e = -1 / 0;
      return (
        t.forEach(t => {
          null != t.offset && (e = Math.max(e, t.offset));
        }),
        e > -1 / 0 ? e : n
      );
    })(t, s('offset', 0)),
    c = s('anchor', Ey),
    l = c === Cy ? 1 : c === Sy ? 0.5 : 0,
    f = {
      align: Hy,
      bounds: s('bounds', Gy),
      columns: 'vertical' === s('direction') ? 1 : t.length,
      padding: s('margin', 8),
      center: s('center'),
      nodirty: !0,
    };
  switch (n) {
    case jy:
      f.anchor = { x: Math.floor(r.x1) - a, column: Cy, y: l * (u || r.height() + 2 * r.y1), row: c };
      break;
    case Dy:
      f.anchor = { x: Math.ceil(r.x2) + a, y: l * (u || r.height() + 2 * r.y1), row: c };
      break;
    case My:
      f.anchor = { y: Math.floor(i.y1) - a, row: Cy, x: l * (o || i.width() + 2 * i.x1), column: c };
      break;
    case Fy:
      f.anchor = { y: Math.ceil(i.y2) + a, x: l * (o || i.width() + 2 * i.x1), column: c };
      break;
    case 'top-left':
      f.anchor = { x: a, y: a };
      break;
    case 'top-right':
      f.anchor = { x: o - a, y: a, column: Cy };
      break;
    case 'bottom-left':
      f.anchor = { x: a, y: u - a, row: Cy };
      break;
    case 'bottom-right':
      f.anchor = { x: o - a, y: u - a, column: Cy, row: Cy };
  }
  return f;
}
function $w(t, n) {
  var e,
    r,
    i = n.items[0],
    o = i.datum,
    u = i.orient,
    s = i.bounds,
    a = i.x,
    c = i.y;
  return (
    i._bounds ? i._bounds.clear().union(s) : (i._bounds = s.clone()),
    s.clear(),
    (function (t, n, e) {
      var r = n.padding,
        i = r - e.x,
        o = r - e.y;
      if (n.datum.title) {
        var u = n.items[1].items[0],
          s = u.anchor,
          a = n.titlePadding || 0,
          c = r - u.x,
          l = r - u.y;
        switch (u.orient) {
          case jy:
            i += Math.ceil(u.bounds.width()) + a;
            break;
          case Dy:
          case Fy:
            break;
          default:
            o += u.bounds.height() + a;
        }
        switch (((i || o) && jw(t, e, i, o), u.orient)) {
          case jy:
            l += Mw(n, e, u, s, 1, 1);
            break;
          case Dy:
            (c += Mw(n, e, u, Cy, 0, 0) + a), (l += Mw(n, e, u, s, 1, 1));
            break;
          case Fy:
            (c += Mw(n, e, u, s, 0, 0)), (l += Mw(n, e, u, Cy, -1, 0, 1) + a);
            break;
          default:
            c += Mw(n, e, u, s, 0, 0);
        }
        (c || l) && jw(t, u, c, l), (c = Math.round(u.bounds.x1 - r)) < 0 && (jw(t, e, -c, 0), jw(t, u, -c, 0));
      } else (i || o) && jw(t, e, i, o);
    })(t, i, i.items[0].items[0]),
    (s = (function (t, n) {
      return t.items.forEach(t => n.union(t.bounds)), (n.x1 = t.padding), (n.y1 = t.padding), n;
    })(i, s)),
    (e = 2 * i.padding),
    (r = 2 * i.padding),
    s.empty() || ((e = Math.ceil(s.width() + e)), (r = Math.ceil(s.height() + r))),
    'symbol' === o.type &&
      (function (t) {
        const n = t.reduce((t, n) => ((t[n.column] = Math.max(n.bounds.x2 - n.x, t[n.column] || 0)), t), {});
        t.forEach(t => {
          (t.width = n[t.column]), (t.height = t.bounds.y2 - t.y);
        });
      })(i.items[0].items[0].items[0].items),
    u !== Uy && ((i.x = a = 0), (i.y = c = 0)),
    (i.width = e),
    (i.height = r),
    Xm(s.set(a, c, a + e, c + r), i),
    i.mark.bounds.clear().union(s),
    i
  );
}
function Mw(t, n, e, r, i, o, u) {
  const s = e.datum.vgrad,
    a = ('symbol' === t.datum.type || (!o && s) || u ? n : n.items[0]).bounds[i ? 'y2' : 'x2'] - t.padding,
    c = s && o ? a : 0,
    l = s && o ? 0 : a,
    f = i <= 0 ? 0 : Fg(e);
  return Math.round(r === Ey ? c : r === Cy ? l - f : 0.5 * (a - f));
}
function jw(t, n, e, r) {
  (n.x += e), (n.y += r), n.bounds.translate(e, r), n.mark.bounds.translate(e, r), t.dirty(n);
}
function Dw(t) {
  os.call(this, null, t);
}
It(Dw, os, {
  transform(t, n) {
    const e = n.dataflow;
    return (
      t.mark.items.forEach(n => {
        t.layout &&
          (function (t, n, e) {
            var r,
              i,
              o,
              u,
              s,
              a,
              c,
              l = (function (t) {
                var n,
                  e,
                  r = t.items,
                  i = r.length,
                  o = 0;
                const u = {
                  marks: [],
                  rowheaders: [],
                  rowfooters: [],
                  colheaders: [],
                  colfooters: [],
                  rowtitle: null,
                  coltitle: null,
                };
                for (; o < i; ++o)
                  if (((e = (n = r[o]).items), n.marktype === Ny))
                    switch (n.role) {
                      case By:
                      case zy:
                      case _y:
                        break;
                      case Ty:
                        u.rowheaders.push(...e);
                        break;
                      case Py:
                        u.rowfooters.push(...e);
                        break;
                      case Ly:
                        u.colheaders.push(...e);
                        break;
                      case qy:
                        u.colfooters.push(...e);
                        break;
                      case Ry:
                        u.rowtitle = e[0];
                        break;
                      case Iy:
                        u.coltitle = e[0];
                        break;
                      default:
                        u.marks.push(...e);
                    }
                return u;
              })(n),
              f = l.marks,
              h = e.bounds === Gy ? ww : xw,
              d = e.offset,
              p = e.columns || f.length,
              m = p <= 0 ? 1 : Math.ceil(f.length / p),
              v = m * p;
            const g = yw(t, f, e);
            g.empty() && g.set(0, 0, 0, 0),
              l.rowheaders &&
                ((a = gw(e.headerBand, Yy, null)),
                (r = Ow(t, l.rowheaders, f, 0, m, -gw(d, 'rowHeader'), dw, 0, h, 'x1', 0, p, 1, a))),
              l.colheaders &&
                ((a = gw(e.headerBand, Vy, null)),
                (i = Ow(t, l.colheaders, f, 0, p, -gw(d, 'columnHeader'), dw, 1, h, 'y1', 0, 1, p, a))),
              l.rowfooters &&
                ((a = gw(e.footerBand, Yy, null)),
                (o = Ow(t, l.rowfooters, f, 0, m, gw(d, 'rowFooter'), pw, 0, h, 'x2', p - 1, p, 1, a))),
              l.colfooters &&
                ((a = gw(e.footerBand, Vy, null)),
                (u = Ow(t, l.colfooters, f, 0, p, gw(d, 'columnFooter'), pw, 1, h, 'y2', v - p, 1, p, a))),
              l.rowtitle &&
                ((s = gw(e.titleAnchor, Yy)),
                (c = gw(d, 'rowTitle')),
                (c = s === Cy ? o + c : r - c),
                (a = gw(e.titleBand, Yy, 0.5)),
                kw(t, l.rowtitle, c, 0, g, a)),
              l.coltitle &&
                ((s = gw(e.titleAnchor, Vy)),
                (c = gw(d, 'columnTitle')),
                (c = s === Cy ? u + c : i - c),
                (a = gw(e.titleBand, Vy, 0.5)),
                kw(t, l.coltitle, c, 1, g, a));
          })(e, n, t.layout),
          (function (t, n, e) {
            var r,
              i,
              o,
              u,
              s,
              a = n.items,
              c = Math.max(0, n.width || 0),
              l = Math.max(0, n.height || 0),
              f = new Um().set(0, 0, c, l),
              h = f.clone(),
              d = f.clone(),
              p = [];
            for (u = 0, s = a.length; u < s; ++u)
              switch ((i = a[u]).role) {
                case By:
                  (lw(i) ? h : d).union(fw(t, i, c, l));
                  break;
                case _y:
                  r = i;
                  break;
                case zy:
                  p.push($w(t, i));
                  break;
                case 'frame':
                case 'scope':
                case Ty:
                case Py:
                case Ry:
                case Ly:
                case qy:
                case Iy:
                  h.union(i.bounds), d.union(i.bounds);
                  break;
                default:
                  f.union(i.bounds);
              }
            if (p.length) {
              const n = {};
              p.forEach(t => {
                (o = t.orient || Dy) !== Uy && (n[o] || (n[o] = [])).push(t);
              });
              for (const r in n) {
                const i = n[r];
                yw(t, i, Aw(i, r, e.legends, h, d, c, l));
              }
              p.forEach(n => {
                const r = n.bounds;
                if (
                  (r.equals(n._bounds) || ((n.bounds = n._bounds), t.dirty(n), (n.bounds = r), t.dirty(n)),
                  e.autosize && 'fit' === e.autosize.type)
                )
                  switch (n.orient) {
                    case jy:
                    case Dy:
                      f.add(r.x1, 0).add(r.x2, 0);
                      break;
                    case My:
                    case Fy:
                      f.add(0, r.y1).add(0, r.y2);
                  }
                else f.union(r);
              });
            }
            f.union(h).union(d),
              r &&
                f.union(
                  (function (t, n, e, r, i) {
                    var o,
                      u = n.items[0],
                      s = u.orient,
                      a = u.anchor,
                      c = u.offset,
                      l = u.padding,
                      f = u.items[0].items[0],
                      h = u.items[1] && u.items[1].items[0],
                      d = s === jy || s === Dy ? r : e,
                      p = 0,
                      m = 0,
                      v = 0,
                      g = 0,
                      b = 0;
                    if (
                      (u.frame !== Ny
                        ? s === jy
                          ? ((p = i.y2), (d = i.y1))
                          : s === Dy
                          ? ((p = i.y1), (d = i.y2))
                          : ((p = i.x1), (d = i.x2))
                        : s === jy && ((p = r), (d = 0)),
                      (o = a === Ey ? p : a === Cy ? d : (p + d) / 2),
                      h && h.text)
                    ) {
                      switch (s) {
                        case My:
                        case Fy:
                          b = f.bounds.height() + l;
                          break;
                        case jy:
                          g = f.bounds.width() + l;
                          break;
                        case Dy:
                          g = -f.bounds.width() - l;
                      }
                      aw.clear().union(h.bounds),
                        aw.translate(g - (h.x || 0), b - (h.y || 0)),
                        cw(h, 'x', g) | cw(h, 'y', b) &&
                          (t.dirty(h), h.bounds.clear().union(aw), h.mark.bounds.clear().union(aw), t.dirty(h)),
                        aw.clear().union(h.bounds);
                    } else aw.clear();
                    switch ((aw.union(f.bounds), s)) {
                      case My:
                        (m = o), (v = i.y1 - aw.height() - c);
                        break;
                      case jy:
                        (m = i.x1 - aw.width() - c), (v = o);
                        break;
                      case Dy:
                        (m = i.x2 + aw.width() + c), (v = o);
                        break;
                      case Fy:
                        (m = o), (v = i.y2 + c);
                        break;
                      default:
                        (m = u.x), (v = u.y);
                    }
                    return (
                      cw(u, 'x', m) | cw(u, 'y', v) &&
                        (aw.translate(m, v),
                        t.dirty(u),
                        u.bounds.clear().union(aw),
                        n.bounds.clear().union(aw),
                        t.dirty(u)),
                      u.bounds
                    );
                  })(t, r, c, l, f),
                ),
              n.clip && f.set(0, 0, n.width || 0, n.height || 0),
              (function (t, n, e, r) {
                const i = r.autosize || {},
                  o = i.type;
                if (t._autosize < 1 || !o) return;
                let u = t._width,
                  s = t._height,
                  a = Math.max(0, n.width || 0),
                  c = Math.max(0, Math.ceil(-e.x1)),
                  l = Math.max(0, n.height || 0),
                  f = Math.max(0, Math.ceil(-e.y1));
                const h = Math.max(0, Math.ceil(e.x2 - a)),
                  d = Math.max(0, Math.ceil(e.y2 - l));
                if ('padding' === i.contains) {
                  const n = t.padding();
                  (u -= n.left + n.right), (s -= n.top + n.bottom);
                }
                o === Uy
                  ? ((c = 0), (f = 0), (a = u), (l = s))
                  : 'fit' === o
                  ? ((a = Math.max(0, u - c - h)), (l = Math.max(0, s - f - d)))
                  : 'fit-x' === o
                  ? ((a = Math.max(0, u - c - h)), (s = l + f + d))
                  : 'fit-y' === o
                  ? ((u = a + c + h), (l = Math.max(0, s - f - d)))
                  : 'pad' === o && ((u = a + c + h), (s = l + f + d)),
                  t._resizeView(u, s, a, l, [c, f], i.resize);
              })(t, n, f, e);
          })(e, n, t);
      }),
      (function (t) {
        return t && 'legend-entry' !== t.mark.role;
      })(t.mark.group)
        ? n.reflow()
        : n
    );
  },
});
const Fw = Object.freeze({
  __proto__: null,
  bound: Xy,
  identifier: Zy,
  mark: Ky,
  overlap: tw,
  render: sw,
  viewlayout: Dw,
});
function Ew(t) {
  os.call(this, null, t);
}
function Sw(t) {
  os.call(this, null, t);
}
function Cw() {
  return Fu({});
}
function Nw(t) {
  os.call(this, null, t);
}
function Bw(t) {
  os.call(this, [], t);
}
It(Ew, os, {
  transform(t, n) {
    if (this.value && !t.modified()) return n.StopPropagation;
    var e = n.dataflow.locale(),
      r = n.fork(n.NO_SOURCE | n.NO_FIELDS),
      i = this.value,
      o = t.scale,
      u = jp(o, null == t.count ? (t.values ? t.values.length : 10) : t.count, t.minstep),
      s = t.format || Ep(e, o, u, t.formatSpecifier, t.formatType, !!t.values),
      a = t.values ? Dp(o, t.values, u) : Fp(o, u);
    return (
      i && (r.rem = i),
      (i = a.map((t, n) => Fu({ index: n / (a.length - 1 || 1), value: t, label: s(t) }))),
      t.extra && i.length && i.push(Fu({ index: -1, extra: { value: i[0].value }, label: '' })),
      (r.source = i),
      (r.add = i),
      (this.value = i),
      r
    );
  },
}),
  It(Sw, os, {
    transform(t, n) {
      var e = n.dataflow,
        r = n.fork(n.NO_SOURCE | n.NO_FIELDS),
        i = t.item || Cw,
        o = t.key || ju,
        u = this.value;
      return (
        K(r.encode) && (r.encode = null),
        u && (t.modified('key') || n.modified(o)) && I('DataJoin does not support modified key function or fields.'),
        u ||
          ((n = n.addAll()),
          (this.value = u =
            (function (t) {
              const n = Lt().test(t => t.exit);
              return (n.lookup = e => n.get(t(e))), n;
            })(o))),
        n.visit(n.ADD, t => {
          const n = o(t);
          let e = u.get(n);
          e ? (e.exit ? (u.empty--, r.add.push(e)) : r.mod.push(e)) : ((e = i(t)), u.set(n, e), r.add.push(e)),
            (e.datum = t),
            (e.exit = !1);
        }),
        n.visit(n.MOD, t => {
          const n = o(t),
            e = u.get(n);
          e && ((e.datum = t), r.mod.push(e));
        }),
        n.visit(n.REM, t => {
          const n = o(t),
            e = u.get(n);
          t !== e.datum || e.exit || (r.rem.push(e), (e.exit = !0), ++u.empty);
        }),
        n.changed(n.ADD_MOD) && r.modifies('datum'),
        (n.clean() || (t.clean && u.empty > e.cleanThreshold)) && e.runAfter(u.clean),
        r
      );
    },
  }),
  It(Nw, os, {
    transform(t, n) {
      var e = n.fork(n.ADD_REM),
        r = t.mod || !1,
        i = t.encoders,
        o = n.encode;
      if (K(o)) {
        if (!e.changed() && !o.every(t => i[t])) return n.StopPropagation;
        (o = o[0]), (e.encode = null);
      }
      var u = 'enter' === o,
        s = i.update || J,
        a = i.enter || J,
        c = i.exit || J,
        l = (o && !u ? i[o] : s) || J;
      if (
        (n.changed(n.ADD) &&
          (n.visit(n.ADD, n => {
            a(n, t), s(n, t);
          }),
          e.modifies(a.output),
          e.modifies(s.output),
          l !== J &&
            l !== s &&
            (n.visit(n.ADD, n => {
              l(n, t);
            }),
            e.modifies(l.output))),
        n.changed(n.REM) &&
          c !== J &&
          (n.visit(n.REM, n => {
            c(n, t);
          }),
          e.modifies(c.output)),
        u || l !== J)
      ) {
        const i = n.MOD | (t.modified() ? n.REFLOW : 0);
        u
          ? (n.visit(i, n => {
              const i = a(n, t) || r;
              (l(n, t) || i) && e.mod.push(n);
            }),
            e.mod.length && e.modifies(a.output))
          : n.visit(i, n => {
              (l(n, t) || r) && e.mod.push(n);
            }),
          e.mod.length && e.modifies(l.output);
      }
      return e.changed() ? e : n.StopPropagation;
    },
  }),
  It(Bw, os, {
    transform(t, n) {
      if (null != this.value && !t.modified()) return n.StopPropagation;
      var e,
        r,
        i,
        o,
        u,
        s = n.dataflow.locale(),
        a = n.fork(n.NO_SOURCE | n.NO_FIELDS),
        c = this.value,
        l = t.type || kp,
        f = t.scale,
        h = +t.limit,
        d = jp(f, null == t.count ? 5 : t.count, t.minstep),
        p = t.format || _p(s, f, d, l, t.formatSpecifier, t.formatType, !!t.values || l === kp),
        m = t.values || Bp(f, d);
      return (
        c && (a.rem = c),
        l === kp
          ? (h && m.length > h
              ? (n.dataflow.warn('Symbol legend count exceeds limit, filtering items.'),
                (c = m.slice(0, h - 1)),
                (u = !0))
              : (c = m),
            Mt((i = t.size))
              ? (t.values || 0 !== f(c[0]) || (c = c.slice(1)), (o = c.reduce((n, e) => Math.max(n, i(e, t)), 0)))
              : (i = Ct((o = i || 8))),
            (c = c.map((n, e) => Fu({ index: e, label: p(n, e, c), value: n, offset: o, size: i(n, t) }))),
            u &&
              ((u = m[c.length]),
              c.push(
                Fu({
                  index: c.length,
                  label: '…'.concat(m.length - c.length, ' entries'),
                  value: u,
                  offset: o,
                  size: i(u, t),
                }),
              )))
          : 'gradient' === l
          ? ((e = f.domain()),
            (r = gp(f, e[0], ot(e))),
            m.length < 3 && !t.values && e[0] !== ot(e) && (m = [e[0], ot(e)]),
            (c = m.map((t, n) => Fu({ index: n, label: p(t, n, m), value: t, perc: r(t) }))))
          : ((i = m.length - 1),
            (r = (function (t) {
              const n = t.domain(),
                e = n.length - 1;
              let r = +n[0],
                i = +ot(n),
                o = i - r;
              if (t.type === qd) {
                const t = e ? o / e : 0.1;
                (r -= t), (i += t), (o = i - r);
              }
              return t => (t - r) / o;
            })(f)),
            (c = m.map((t, n) =>
              Fu({ index: n, label: p(t, n, m), value: t, perc: n ? r(t) : 0, perc2: n === i ? 1 : r(m[n + 1]) }),
            ))),
        (a.source = c),
        (a.add = c),
        (this.value = c),
        a
      );
    },
  });
const _w = t => t.source.x,
  zw = t => t.source.y,
  Tw = t => t.target.x,
  Pw = t => t.target.y;
function Rw(t) {
  os.call(this, {}, t);
}
(Rw.Definition = {
  type: 'LinkPath',
  metadata: { modifies: !0 },
  params: [
    { name: 'sourceX', type: 'field', default: 'source.x' },
    { name: 'sourceY', type: 'field', default: 'source.y' },
    { name: 'targetX', type: 'field', default: 'target.x' },
    { name: 'targetY', type: 'field', default: 'target.y' },
    { name: 'orient', type: 'enum', default: 'vertical', values: ['horizontal', 'vertical', 'radial'] },
    { name: 'shape', type: 'enum', default: 'line', values: ['line', 'arc', 'curve', 'diagonal', 'orthogonal'] },
    { name: 'require', type: 'signal' },
    { name: 'as', type: 'string', default: 'path' },
  ],
}),
  It(Rw, os, {
    transform(t, n) {
      var e = t.sourceX || _w,
        r = t.sourceY || zw,
        i = t.targetX || Tw,
        o = t.targetY || Pw,
        u = t.as || 'path',
        s = t.shape || 'line',
        a = Uw.get(s + '-' + (t.orient || 'vertical')) || Uw.get(s);
      return (
        a || I('LinkPath unsupported type: ' + t.shape + (t.orient ? '-' + t.orient : '')),
        n.visit(n.SOURCE, t => {
          t[u] = a(e(t), r(t), i(t), o(t));
        }),
        n.reflow(t.modified()).modifies(u)
      );
    },
  });
const Lw = (t, n, e, r) => 'M' + t + ',' + n + 'L' + e + ',' + r,
  qw = (t, n, e, r) => {
    var i = e - t,
      o = r - n,
      u = Math.sqrt(i * i + o * o) / 2;
    return 'M' + t + ',' + n + 'A' + u + ',' + u + ' ' + (180 * Math.atan2(o, i)) / Math.PI + ' 0 1 ' + e + ',' + r;
  },
  Iw = (t, n, e, r) => {
    const i = e - t,
      o = r - n,
      u = 0.2 * (i + o),
      s = 0.2 * (o - i);
    return 'M' + t + ',' + n + 'C' + (t + u) + ',' + (n + s) + ' ' + (e + s) + ',' + (r - u) + ' ' + e + ',' + r;
  },
  Uw = Lt({
    line: Lw,
    'line-radial': (t, n, e, r) => Lw(n * Math.cos(t), n * Math.sin(t), r * Math.cos(e), r * Math.sin(e)),
    arc: qw,
    'arc-radial': (t, n, e, r) => qw(n * Math.cos(t), n * Math.sin(t), r * Math.cos(e), r * Math.sin(e)),
    curve: Iw,
    'curve-radial': (t, n, e, r) => Iw(n * Math.cos(t), n * Math.sin(t), r * Math.cos(e), r * Math.sin(e)),
    'orthogonal-horizontal': (t, n, e, r) => 'M' + t + ',' + n + 'V' + r + 'H' + e,
    'orthogonal-vertical': (t, n, e, r) => 'M' + t + ',' + n + 'H' + e + 'V' + r,
    'orthogonal-radial': (t, n, e, r) => {
      const i = Math.cos(t),
        o = Math.sin(t),
        u = Math.cos(e),
        s = Math.sin(e);
      return (
        'M' +
        n * i +
        ',' +
        n * o +
        'A' +
        n +
        ',' +
        n +
        ' 0 0,' +
        ((Math.abs(e - t) > Math.PI ? e <= t : e > t) ? 1 : 0) +
        ' ' +
        n * u +
        ',' +
        n * s +
        'L' +
        r * u +
        ',' +
        r * s
      );
    },
    'diagonal-horizontal': (t, n, e, r) => {
      const i = (t + e) / 2;
      return 'M' + t + ',' + n + 'C' + i + ',' + n + ' ' + i + ',' + r + ' ' + e + ',' + r;
    },
    'diagonal-vertical': (t, n, e, r) => {
      const i = (n + r) / 2;
      return 'M' + t + ',' + n + 'C' + t + ',' + i + ' ' + e + ',' + i + ' ' + e + ',' + r;
    },
    'diagonal-radial': (t, n, e, r) => {
      const i = Math.cos(t),
        o = Math.sin(t),
        u = Math.cos(e),
        s = Math.sin(e),
        a = (n + r) / 2;
      return (
        'M' + n * i + ',' + n * o + 'C' + a * i + ',' + a * o + ' ' + a * u + ',' + a * s + ' ' + r * u + ',' + r * s
      );
    },
  });
function Ww(t) {
  os.call(this, null, t);
}
function Hw(t) {
  return sp(t) && t !== Td;
}
(Ww.Definition = {
  type: 'Pie',
  metadata: { modifies: !0 },
  params: [
    { name: 'field', type: 'field' },
    { name: 'startAngle', type: 'number', default: 0 },
    { name: 'endAngle', type: 'number', default: 6.283185307179586 },
    { name: 'sort', type: 'boolean', default: !1 },
    { name: 'as', type: 'string', array: !0, length: 2, default: ['startAngle', 'endAngle'] },
  ],
}),
  It(Ww, os, {
    transform(t, n) {
      var e,
        r,
        i,
        o = t.as || ['startAngle', 'endAngle'],
        u = o[0],
        s = o[1],
        a = t.startAngle || 0,
        c = null != t.endAngle ? t.endAngle : 2 * Math.PI,
        l = n.source,
        f = l.map(t.field || Y),
        h = f.length,
        d = a,
        p = (c - a) / ie(f),
        m = re(h);
      for (t.sort && m.sort((t, n) => f[t] - f[n]), e = 0; e < h; ++e)
        (i = f[m[e]]), ((r = l[m[e]])[u] = d), (r[s] = d += i * p);
      return (this.value = f), n.reflow(t.modified()).modifies(o);
    },
  });
const Gw = cn([
  'set',
  'modified',
  'clear',
  'type',
  'scheme',
  'schemeExtent',
  'schemeCount',
  'domain',
  'domainMin',
  'domainMid',
  'domainMax',
  'domainRaw',
  'domainImplicit',
  'nice',
  'zero',
  'bins',
  'range',
  'rangeStep',
  'round',
  'reverse',
  'interpolate',
  'interpolateGamma',
]);
function Vw(t) {
  os.call(this, null, t), this.modified(!0);
}
function Yw(t, n, e) {
  return (
    lp(t) &&
      Math.abs(n.reduce((t, n) => t + (n < 0 ? -1 : n > 0 ? 1 : 0), 0)) !== n.length &&
      e.warn('Log scale domain includes zero: ' + rn(n)),
    n
  );
}
function Xw(t, n, e) {
  return Mt(t) && (n || e) ? pp(t, Jw(n || [0, 1], e)) : t;
}
function Jw(t, n) {
  return n ? t.slice().reverse() : t;
}
function Qw(t) {
  os.call(this, null, t);
}
It(Vw, os, {
  transform(t, n) {
    var e = n.dataflow,
      r = this.value,
      i = (function (t) {
        var n,
          e = t.type,
          r = '';
        return e === Td
          ? Td + '-' + Ed
          : ((function (t) {
              const n = t.type;
              return sp(n) && n !== _d && n !== zd && (t.scheme || (t.range && t.range.length && t.range.every(Xt)));
            })(t) &&
              (r =
                2 === (n = t.rawDomain ? t.rawDomain.length : t.domain ? t.domain.length + +(null != t.domainMid) : 0)
                  ? Td + '-'
                  : 3 === n
                  ? Pd + '-'
                  : ''),
            (r + e || Ed).toLowerCase());
      })(t);
    for (i in ((r && i === r.type) || (this.value = r = ip(i)()), t))
      if (!Gw[i]) {
        if ('padding' === i && Hw(r.type)) continue;
        Mt(r[i]) ? r[i](t[i]) : e.warn('Unsupported scale property: ' + i);
      }
    return (
      (function (t, n, e) {
        var r = t.type,
          i = n.round || !1,
          o = n.range;
        if (null != n.rangeStep)
          o = (function (t, n, e) {
            return (
              t !== Wd && t !== Ud && I('Only band and point scales support rangeStep.'),
              [
                0,
                n.rangeStep *
                  Fd(
                    e,
                    t === Ud ? 1 : (null != n.paddingInner ? n.paddingInner : n.padding) || 0,
                    (null != n.paddingOuter ? n.paddingOuter : n.padding) || 0,
                  ),
              ]
            );
          })(r, n, e);
        else if (
          n.scheme &&
          ((o = (function (t, n, e) {
            var r,
              i = n.schemeExtent;
            return (
              K(n.scheme)
                ? (r = mp(n.scheme, n.interpolate, n.interpolateGamma))
                : (r = Op(n.scheme.toLowerCase())) || I('Unrecognized scheme name: '.concat(n.scheme)),
              (e = t === qd ? e + 1 : t === Hd ? e - 1 : t === Rd || t === Ld ? +n.schemeCount || 5 : e),
              fp(t) ? Xw(r, i, n.reverse) : Mt(r) ? vp(Xw(r, i), e) : t === Id ? r : r.slice(0, e)
            );
          })(r, n, e)),
          Mt(o))
        ) {
          if (t.interpolator) return t.interpolator(o);
          I('Scale type '.concat(r, ' does not support interpolating color schemes.'));
        }
        if (o && fp(r)) return t.interpolator(mp(Jw(o, n.reverse), n.interpolate, n.interpolateGamma));
        o && n.interpolate && t.interpolate
          ? t.interpolate(bp(n.interpolate, n.interpolateGamma))
          : Mt(t.round)
          ? t.round(i)
          : Mt(t.rangeRound) && t.interpolate(i ? Mh : $h),
          o && t.range(Jw(o, n.reverse));
      })(
        r,
        t,
        (function (t, n, e) {
          let r = n.bins;
          if (r && !K(r)) {
            const n = t.domain(),
              e = n[0],
              i = ot(n),
              o = r.step;
            let u = null == r.start ? e : r.start,
              s = null == r.stop ? i : r.stop;
            o || I('Scale bins parameter missing step property.'),
              u < e && (u = o * Math.ceil(e / o)),
              s > i && (s = o * Math.floor(i / o)),
              (r = re(u, s + o / 2, o));
          }
          return (
            r ? (t.bins = r) : t.bins && delete t.bins,
            t.type === Hd && (r ? n.domain || n.domainRaw || (t.domain(r), (e = r.length)) : (t.bins = t.domain())),
            e
          );
        })(
          r,
          t,
          (function (t, n, e) {
            const r = (function (t, n, e) {
              return n ? (t.domain(Yw(t.type, n, e)), n.length) : -1;
            })(t, n.domainRaw, e);
            if (r > -1) return r;
            var i,
              o,
              u = n.domain,
              s = t.type,
              a =
                n.zero ||
                (void 0 === n.zero &&
                  (function (t) {
                    const n = t.type;
                    return !t.bins && (n === Ed || n === Cd || n === Nd);
                  })(t));
            if (!u) return 0;
            if (
              (Hw(s) &&
                n.padding &&
                u[0] !== ot(u) &&
                (u = (function (t, n, e, r, i, o) {
                  var u = Math.abs(ot(e) - e[0]),
                    s = u / (u - 2 * r),
                    a =
                      t === Sd
                        ? yt(n, null, s)
                        : t === Nd
                        ? wt(n, null, s, 0.5)
                        : t === Cd
                        ? wt(n, null, s, i || 1)
                        : t === Bd
                        ? xt(n, null, s, o || 1)
                        : bt(n, null, s);
                  return ((n = n.slice())[0] = a[0]), (n[n.length - 1] = a[1]), n;
                })(s, u, n.range, n.padding, n.exponent, n.constant)),
              (a || null != n.domainMin || null != n.domainMax || null != n.domainMid) &&
                ((i = (u = u.slice()).length - 1 || 1),
                a && (u[0] > 0 && (u[0] = 0), u[i] < 0 && (u[i] = 0)),
                null != n.domainMin && (u[0] = n.domainMin),
                null != n.domainMax && (u[i] = n.domainMax),
                null != n.domainMid))
            ) {
              const t = (o = n.domainMid) > u[i] ? i + 1 : o < u[0] ? 0 : i;
              t !== i && e.warn('Scale domainMid exceeds domain min or max.', o), u.splice(t, 0, o);
            }
            return (
              t.domain(Yw(s, u, e)),
              s === Id && t.unknown(n.domainImplicit ? Hl : void 0),
              n.nice && t.nice && t.nice((!0 !== n.nice && jp(t, n.nice)) || null),
              u.length
            );
          })(r, t, e),
        ),
      ),
      n.fork(n.NO_SOURCE | n.NO_FIELDS)
    );
  },
}),
  It(Qw, os, {
    transform(t, n) {
      const e = t.modified('sort') || n.changed(n.ADD) || n.modified(t.sort.fields) || n.modified('datum');
      return e && n.source.sort(Nu(t.sort)), this.modified(e), n;
    },
  });
const Zw = 'zero',
  Kw = 'center',
  tx = 'normalize',
  nx = ['y0', 'y1'];
function ex(t) {
  os.call(this, null, t);
}
function rx(t, n, e, r, i) {
  for (var o, u = (n - t.sum) / 2, s = t.length, a = 0; a < s; ++a) ((o = t[a])[r] = u), (o[i] = u += Math.abs(e(o)));
}
function ix(t, n, e, r, i) {
  for (var o, u = 1 / t.sum, s = 0, a = t.length, c = 0, l = 0; c < a; ++c)
    ((o = t[c])[r] = s), (o[i] = s = u * (l += Math.abs(e(o))));
}
function ox(t, n, e, r, i) {
  for (var o, u, s = 0, a = 0, c = t.length, l = 0; l < c; ++l)
    (o = +e((u = t[l]))) < 0 ? ((u[r] = a), (u[i] = a += o)) : ((u[r] = s), (u[i] = s += o));
}
(ex.Definition = {
  type: 'Stack',
  metadata: { modifies: !0 },
  params: [
    { name: 'field', type: 'field' },
    { name: 'groupby', type: 'field', array: !0 },
    { name: 'sort', type: 'compare' },
    { name: 'offset', type: 'enum', default: Zw, values: [Zw, Kw, tx] },
    { name: 'as', type: 'string', array: !0, length: 2, default: nx },
  ],
}),
  It(ex, os, {
    transform(t, n) {
      var e,
        r,
        i,
        o,
        u = t.as || nx,
        s = u[0],
        a = u[1],
        c = Nu(t.sort),
        l = t.field || Y,
        f = t.offset === Kw ? rx : t.offset === tx ? ix : ox;
      for (
        e = (function (t, n, e, r) {
          var i,
            o,
            u,
            s,
            a,
            c,
            l,
            f,
            h,
            d = [],
            p = t => t(a);
          if (null == n) d.push(t.slice());
          else
            for (i = {}, o = 0, u = t.length; o < u; ++o)
              (a = t[o]), (l = i[(c = n.map(p))]) || ((i[c] = l = []), d.push(l)), l.push(a);
          for (c = 0, h = 0, s = d.length; c < s; ++c) {
            for (o = 0, f = 0, u = (l = d[c]).length; o < u; ++o) f += Math.abs(r(l[o]));
            (l.sum = f), f > h && (h = f), e && l.sort(e);
          }
          return (d.max = h), d;
        })(n.source, t.groupby, c, l),
          r = 0,
          i = e.length,
          o = e.max;
        r < i;
        ++r
      )
        f(e[r], o, l, s, a);
      return n.reflow(t.modified()).modifies(u);
    },
  });
const ux = Object.freeze({
  __proto__: null,
  axisticks: Ew,
  datajoin: Sw,
  encode: Nw,
  legendentries: Bw,
  linkpath: Rw,
  pie: Ww,
  scale: Vw,
  sortitems: Qw,
  stack: ex,
});
var sx = 1e-6,
  ax = 1e-12,
  cx = Math.PI,
  lx = cx / 2,
  fx = cx / 4,
  hx = 2 * cx,
  dx = 180 / cx,
  px = cx / 180,
  mx = Math.abs,
  vx = Math.atan,
  gx = Math.atan2,
  bx = Math.cos,
  yx = Math.ceil,
  wx = Math.exp,
  xx = Math.hypot,
  Ox = Math.log,
  kx = Math.pow,
  Ax = Math.sin,
  $x =
    Math.sign ||
    function (t) {
      return t > 0 ? 1 : t < 0 ? -1 : 0;
    },
  Mx = Math.sqrt,
  jx = Math.tan;
function Dx(t) {
  return t > 1 ? 0 : t < -1 ? cx : Math.acos(t);
}
function Fx(t) {
  return t > 1 ? lx : t < -1 ? -lx : Math.asin(t);
}
function Ex() {}
function Sx(t, n) {
  t && Nx.hasOwnProperty(t.type) && Nx[t.type](t, n);
}
var Cx = {
    Feature: function (t, n) {
      Sx(t.geometry, n);
    },
    FeatureCollection: function (t, n) {
      for (var e = t.features, r = -1, i = e.length; ++r < i; ) Sx(e[r].geometry, n);
    },
  },
  Nx = {
    Sphere: function (t, n) {
      n.sphere();
    },
    Point: function (t, n) {
      n.point((t = t.coordinates)[0], t[1], t[2]);
    },
    MultiPoint: function (t, n) {
      for (var e = t.coordinates, r = -1, i = e.length; ++r < i; ) n.point((t = e[r])[0], t[1], t[2]);
    },
    LineString: function (t, n) {
      Bx(t.coordinates, n, 0);
    },
    MultiLineString: function (t, n) {
      for (var e = t.coordinates, r = -1, i = e.length; ++r < i; ) Bx(e[r], n, 0);
    },
    Polygon: function (t, n) {
      _x(t.coordinates, n);
    },
    MultiPolygon: function (t, n) {
      for (var e = t.coordinates, r = -1, i = e.length; ++r < i; ) _x(e[r], n);
    },
    GeometryCollection: function (t, n) {
      for (var e = t.geometries, r = -1, i = e.length; ++r < i; ) Sx(e[r], n);
    },
  };
function Bx(t, n, e) {
  var r,
    i = -1,
    o = t.length - e;
  for (n.lineStart(); ++i < o; ) n.point((r = t[i])[0], r[1], r[2]);
  n.lineEnd();
}
function _x(t, n) {
  var e = -1,
    r = t.length;
  for (n.polygonStart(); ++e < r; ) Bx(t[e], n, 1);
  n.polygonEnd();
}
function zx(t, n) {
  t && Cx.hasOwnProperty(t.type) ? Cx[t.type](t, n) : Sx(t, n);
}
var Tx,
  Px,
  Rx,
  Lx,
  qx,
  Ix,
  Ux,
  Wx,
  Hx,
  Gx,
  Vx,
  Yx,
  Xx,
  Jx,
  Qx,
  Zx,
  Kx = new Bn(),
  tO = new Bn(),
  nO = {
    point: Ex,
    lineStart: Ex,
    lineEnd: Ex,
    polygonStart: function () {
      (Kx = new Bn()), (nO.lineStart = eO), (nO.lineEnd = rO);
    },
    polygonEnd: function () {
      var t = +Kx;
      tO.add(t < 0 ? hx + t : t), (this.lineStart = this.lineEnd = this.point = Ex);
    },
    sphere: function () {
      tO.add(hx);
    },
  };
function eO() {
  nO.point = iO;
}
function rO() {
  oO(Tx, Px);
}
function iO(t, n) {
  (nO.point = oO), (Tx = t), (Px = n), (Rx = t *= px), (Lx = bx((n = (n *= px) / 2 + fx))), (qx = Ax(n));
}
function oO(t, n) {
  var e = (t *= px) - Rx,
    r = e >= 0 ? 1 : -1,
    i = r * e,
    o = bx((n = (n *= px) / 2 + fx)),
    u = Ax(n),
    s = qx * u,
    a = Lx * o + s * bx(i),
    c = s * r * Ax(i);
  Kx.add(gx(c, a)), (Rx = t), (Lx = o), (qx = u);
}
function uO(t) {
  return [gx(t[1], t[0]), Fx(t[2])];
}
function sO(t) {
  var n = t[0],
    e = t[1],
    r = bx(e);
  return [r * bx(n), r * Ax(n), Ax(e)];
}
function aO(t, n) {
  return t[0] * n[0] + t[1] * n[1] + t[2] * n[2];
}
function cO(t, n) {
  return [t[1] * n[2] - t[2] * n[1], t[2] * n[0] - t[0] * n[2], t[0] * n[1] - t[1] * n[0]];
}
function lO(t, n) {
  (t[0] += n[0]), (t[1] += n[1]), (t[2] += n[2]);
}
function fO(t, n) {
  return [t[0] * n, t[1] * n, t[2] * n];
}
function hO(t) {
  var n = Mx(t[0] * t[0] + t[1] * t[1] + t[2] * t[2]);
  (t[0] /= n), (t[1] /= n), (t[2] /= n);
}
var dO,
  pO,
  mO,
  vO,
  gO,
  bO,
  yO,
  wO,
  xO,
  OO,
  kO,
  AO,
  $O,
  MO,
  jO,
  DO,
  FO = {
    point: EO,
    lineStart: CO,
    lineEnd: NO,
    polygonStart: function () {
      (FO.point = BO), (FO.lineStart = _O), (FO.lineEnd = zO), (Jx = new Bn()), nO.polygonStart();
    },
    polygonEnd: function () {
      nO.polygonEnd(),
        (FO.point = EO),
        (FO.lineStart = CO),
        (FO.lineEnd = NO),
        Kx < 0 ? ((Ix = -(Wx = 180)), (Ux = -(Hx = 90))) : Jx > sx ? (Hx = 90) : Jx < -1e-6 && (Ux = -90),
        (Zx[0] = Ix),
        (Zx[1] = Wx);
    },
    sphere: function () {
      (Ix = -(Wx = 180)), (Ux = -(Hx = 90));
    },
  };
function EO(t, n) {
  Qx.push((Zx = [(Ix = t), (Wx = t)])), n < Ux && (Ux = n), n > Hx && (Hx = n);
}
function SO(t, n) {
  var e = sO([t * px, n * px]);
  if (Xx) {
    var r = cO(Xx, e),
      i = cO([r[1], -r[0], 0], r);
    hO(i), (i = uO(i));
    var o,
      u = t - Gx,
      s = u > 0 ? 1 : -1,
      a = i[0] * dx * s,
      c = mx(u) > 180;
    c ^ (s * Gx < a && a < s * t)
      ? (o = i[1] * dx) > Hx && (Hx = o)
      : c ^ (s * Gx < (a = ((a + 360) % 360) - 180) && a < s * t)
      ? (o = -i[1] * dx) < Ux && (Ux = o)
      : (n < Ux && (Ux = n), n > Hx && (Hx = n)),
      c
        ? t < Gx
          ? TO(Ix, t) > TO(Ix, Wx) && (Wx = t)
          : TO(t, Wx) > TO(Ix, Wx) && (Ix = t)
        : Wx >= Ix
        ? (t < Ix && (Ix = t), t > Wx && (Wx = t))
        : t > Gx
        ? TO(Ix, t) > TO(Ix, Wx) && (Wx = t)
        : TO(t, Wx) > TO(Ix, Wx) && (Ix = t);
  } else Qx.push((Zx = [(Ix = t), (Wx = t)]));
  n < Ux && (Ux = n), n > Hx && (Hx = n), (Xx = e), (Gx = t);
}
function CO() {
  FO.point = SO;
}
function NO() {
  (Zx[0] = Ix), (Zx[1] = Wx), (FO.point = EO), (Xx = null);
}
function BO(t, n) {
  if (Xx) {
    var e = t - Gx;
    Jx.add(mx(e) > 180 ? e + (e > 0 ? 360 : -360) : e);
  } else (Vx = t), (Yx = n);
  nO.point(t, n), SO(t, n);
}
function _O() {
  nO.lineStart();
}
function zO() {
  BO(Vx, Yx), nO.lineEnd(), mx(Jx) > sx && (Ix = -(Wx = 180)), (Zx[0] = Ix), (Zx[1] = Wx), (Xx = null);
}
function TO(t, n) {
  return (n -= t) < 0 ? n + 360 : n;
}
function PO(t, n) {
  return t[0] - n[0];
}
function RO(t, n) {
  return t[0] <= t[1] ? t[0] <= n && n <= t[1] : n < t[0] || t[1] < n;
}
var LO = {
  sphere: Ex,
  point: qO,
  lineStart: UO,
  lineEnd: GO,
  polygonStart: function () {
    (LO.lineStart = VO), (LO.lineEnd = YO);
  },
  polygonEnd: function () {
    (LO.lineStart = UO), (LO.lineEnd = GO);
  },
};
function qO(t, n) {
  t *= px;
  var e = bx((n *= px));
  IO(e * bx(t), e * Ax(t), Ax(n));
}
function IO(t, n, e) {
  ++dO, (mO += (t - mO) / dO), (vO += (n - vO) / dO), (gO += (e - gO) / dO);
}
function UO() {
  LO.point = WO;
}
function WO(t, n) {
  t *= px;
  var e = bx((n *= px));
  (MO = e * bx(t)), (jO = e * Ax(t)), (DO = Ax(n)), (LO.point = HO), IO(MO, jO, DO);
}
function HO(t, n) {
  t *= px;
  var e = bx((n *= px)),
    r = e * bx(t),
    i = e * Ax(t),
    o = Ax(n),
    u = gx(
      Mx((u = jO * o - DO * i) * u + (u = DO * r - MO * o) * u + (u = MO * i - jO * r) * u),
      MO * r + jO * i + DO * o,
    );
  (pO += u), (bO += u * (MO + (MO = r))), (yO += u * (jO + (jO = i))), (wO += u * (DO + (DO = o))), IO(MO, jO, DO);
}
function GO() {
  LO.point = qO;
}
function VO() {
  LO.point = XO;
}
function YO() {
  JO(AO, $O), (LO.point = qO);
}
function XO(t, n) {
  (AO = t), ($O = n), (t *= px), (n *= px), (LO.point = JO);
  var e = bx(n);
  (MO = e * bx(t)), (jO = e * Ax(t)), (DO = Ax(n)), IO(MO, jO, DO);
}
function JO(t, n) {
  t *= px;
  var e = bx((n *= px)),
    r = e * bx(t),
    i = e * Ax(t),
    o = Ax(n),
    u = jO * o - DO * i,
    s = DO * r - MO * o,
    a = MO * i - jO * r,
    c = xx(u, s, a),
    l = Fx(c),
    f = c && -l / c;
  xO.add(f * u),
    OO.add(f * s),
    kO.add(f * a),
    (pO += l),
    (bO += l * (MO + (MO = r))),
    (yO += l * (jO + (jO = i))),
    (wO += l * (DO + (DO = o))),
    IO(MO, jO, DO);
}
function QO(t, n) {
  function e(e, r) {
    return (e = t(e, r)), n(e[0], e[1]);
  }
  return (
    t.invert &&
      n.invert &&
      (e.invert = function (e, r) {
        return (e = n.invert(e, r)) && t.invert(e[0], e[1]);
      }),
    e
  );
}
function ZO(t, n) {
  return mx(t) > cx && (t -= Math.round(t / hx) * hx), [t, n];
}
function KO(t, n, e) {
  return (t %= hx) ? (n || e ? QO(nk(t), ek(n, e)) : nk(t)) : n || e ? ek(n, e) : ZO;
}
function tk(t) {
  return function (n, e) {
    return mx((n += t)) > cx && (n -= Math.round(n / hx) * hx), [n, e];
  };
}
function nk(t) {
  var n = tk(t);
  return (n.invert = tk(-t)), n;
}
function ek(t, n) {
  var e = bx(t),
    r = Ax(t),
    i = bx(n),
    o = Ax(n);
  function u(t, n) {
    var u = bx(n),
      s = bx(t) * u,
      a = Ax(t) * u,
      c = Ax(n),
      l = c * e + s * r;
    return [gx(a * i - l * o, s * e - c * r), Fx(l * i + a * o)];
  }
  return (
    (u.invert = function (t, n) {
      var u = bx(n),
        s = bx(t) * u,
        a = Ax(t) * u,
        c = Ax(n),
        l = c * i - a * o;
      return [gx(a * i + c * o, s * e + l * r), Fx(l * e - s * r)];
    }),
    u
  );
}
function rk(t, n) {
  ((n = sO(n))[0] -= t), hO(n);
  var e = Dx(-n[1]);
  return ((-n[2] < 0 ? -e : e) + hx - sx) % hx;
}
function ik() {
  var t,
    n = [];
  return {
    point: function (n, e, r) {
      t.push([n, e, r]);
    },
    lineStart: function () {
      n.push((t = []));
    },
    lineEnd: Ex,
    rejoin: function () {
      n.length > 1 && n.push(n.pop().concat(n.shift()));
    },
    result: function () {
      var e = n;
      return (n = []), (t = null), e;
    },
  };
}
function ok(t, n) {
  return mx(t[0] - n[0]) < sx && mx(t[1] - n[1]) < sx;
}
function uk(t, n, e, r) {
  (this.x = t), (this.z = n), (this.o = e), (this.e = r), (this.v = !1), (this.n = this.p = null);
}
function sk(t, n, e, r, i) {
  var o,
    u,
    s = [],
    a = [];
  if (
    (t.forEach(function (t) {
      if (!((n = t.length - 1) <= 0)) {
        var n,
          e,
          r = t[0],
          u = t[n];
        if (ok(r, u)) {
          if (!r[2] && !u[2]) {
            for (i.lineStart(), o = 0; o < n; ++o) i.point((r = t[o])[0], r[1]);
            return void i.lineEnd();
          }
          u[0] += 2e-6;
        }
        s.push((e = new uk(r, t, null, !0))),
          a.push((e.o = new uk(r, null, e, !1))),
          s.push((e = new uk(u, t, null, !1))),
          a.push((e.o = new uk(u, null, e, !0)));
      }
    }),
    s.length)
  ) {
    for (a.sort(n), ak(s), ak(a), o = 0, u = a.length; o < u; ++o) a[o].e = e = !e;
    for (var c, l, f = s[0]; ; ) {
      for (var h = f, d = !0; h.v; ) if ((h = h.n) === f) return;
      (c = h.z), i.lineStart();
      do {
        if (((h.v = h.o.v = !0), h.e)) {
          if (d) for (o = 0, u = c.length; o < u; ++o) i.point((l = c[o])[0], l[1]);
          else r(h.x, h.n.x, 1, i);
          h = h.n;
        } else {
          if (d) for (o = (c = h.p.z).length - 1; o >= 0; --o) i.point((l = c[o])[0], l[1]);
          else r(h.x, h.p.x, -1, i);
          h = h.p;
        }
        (c = (h = h.o).z), (d = !d);
      } while (!h.v);
      i.lineEnd();
    }
  }
}
function ak(t) {
  if ((n = t.length)) {
    for (var n, e, r = 0, i = t[0]; ++r < n; ) (i.n = e = t[r]), (e.p = i), (i = e);
    (i.n = e = t[0]), (e.p = i);
  }
}
function ck(t) {
  return mx(t[0]) <= cx ? t[0] : $x(t[0]) * (((mx(t[0]) + cx) % hx) - cx);
}
function lk(t, n, e, r) {
  return function (i) {
    var o,
      u,
      s,
      a = n(i),
      c = ik(),
      l = n(c),
      f = !1,
      h = {
        point: d,
        lineStart: m,
        lineEnd: v,
        polygonStart: function () {
          (h.point = g), (h.lineStart = b), (h.lineEnd = y), (u = []), (o = []);
        },
        polygonEnd: function () {
          (h.point = d), (h.lineStart = m), (h.lineEnd = v), (u = ee(u));
          var t = (function (t, n) {
            var e = ck(n),
              r = n[1],
              i = Ax(r),
              o = [Ax(e), -bx(e), 0],
              u = 0,
              s = 0,
              a = new Bn();
            1 === i ? (r = lx + sx) : -1 === i && (r = -lx - sx);
            for (var c = 0, l = t.length; c < l; ++c)
              if ((h = (f = t[c]).length))
                for (
                  var f, h, d = f[h - 1], p = ck(d), m = d[1] / 2 + fx, v = Ax(m), g = bx(m), b = 0;
                  b < h;
                  ++b, p = w, v = O, g = k, d = y
                ) {
                  var y = f[b],
                    w = ck(y),
                    x = y[1] / 2 + fx,
                    O = Ax(x),
                    k = bx(x),
                    A = w - p,
                    $ = A >= 0 ? 1 : -1,
                    M = $ * A,
                    j = M > cx,
                    D = v * O;
                  if (
                    (a.add(gx(D * $ * Ax(M), g * k + D * bx(M))), (u += j ? A + $ * hx : A), j ^ (p >= e) ^ (w >= e))
                  ) {
                    var F = cO(sO(d), sO(y));
                    hO(F);
                    var E = cO(o, F);
                    hO(E);
                    var S = (j ^ (A >= 0) ? -1 : 1) * Fx(E[2]);
                    (r > S || (r === S && (F[0] || F[1]))) && (s += j ^ (A >= 0) ? 1 : -1);
                  }
                }
            return (u < -1e-6 || (u < sx && a < -1e-12)) ^ (1 & s);
          })(o, r);
          u.length
            ? (f || (i.polygonStart(), (f = !0)), sk(u, hk, t, e, i))
            : t && (f || (i.polygonStart(), (f = !0)), i.lineStart(), e(null, null, 1, i), i.lineEnd()),
            f && (i.polygonEnd(), (f = !1)),
            (u = o = null);
        },
        sphere: function () {
          i.polygonStart(), i.lineStart(), e(null, null, 1, i), i.lineEnd(), i.polygonEnd();
        },
      };
    function d(n, e) {
      t(n, e) && i.point(n, e);
    }
    function p(t, n) {
      a.point(t, n);
    }
    function m() {
      (h.point = p), a.lineStart();
    }
    function v() {
      (h.point = d), a.lineEnd();
    }
    function g(t, n) {
      s.push([t, n]), l.point(t, n);
    }
    function b() {
      l.lineStart(), (s = []);
    }
    function y() {
      g(s[0][0], s[0][1]), l.lineEnd();
      var t,
        n,
        e,
        r,
        a = l.clean(),
        h = c.result(),
        d = h.length;
      if ((s.pop(), o.push(s), (s = null), d))
        if (1 & a) {
          if ((n = (e = h[0]).length - 1) > 0) {
            for (f || (i.polygonStart(), (f = !0)), i.lineStart(), t = 0; t < n; ++t) i.point((r = e[t])[0], r[1]);
            i.lineEnd();
          }
        } else d > 1 && 2 & a && h.push(h.pop().concat(h.shift())), u.push(h.filter(fk));
    }
    return h;
  };
}
function fk(t) {
  return t.length > 1;
}
function hk(t, n) {
  return ((t = t.x)[0] < 0 ? t[1] - lx - sx : lx - t[1]) - ((n = n.x)[0] < 0 ? n[1] - lx - sx : lx - n[1]);
}
ZO.invert = ZO;
const dk = lk(
  function () {
    return !0;
  },
  function (t) {
    var n,
      e = NaN,
      r = NaN,
      i = NaN;
    return {
      lineStart: function () {
        t.lineStart(), (n = 1);
      },
      point: function (o, u) {
        var s = o > 0 ? cx : -cx,
          a = mx(o - e);
        mx(a - cx) < sx
          ? (t.point(e, (r = (r + u) / 2 > 0 ? lx : -lx)),
            t.point(i, r),
            t.lineEnd(),
            t.lineStart(),
            t.point(s, r),
            t.point(o, r),
            (n = 0))
          : i !== s &&
            a >= cx &&
            (mx(e - i) < sx && (e -= i * sx),
            mx(o - s) < sx && (o -= s * sx),
            (r = (function (t, n, e, r) {
              var i,
                o,
                u = Ax(t - e);
              return mx(u) > sx
                ? vx((Ax(n) * (o = bx(r)) * Ax(e) - Ax(r) * (i = bx(n)) * Ax(t)) / (i * o * u))
                : (n + r) / 2;
            })(e, r, o, u)),
            t.point(i, r),
            t.lineEnd(),
            t.lineStart(),
            t.point(s, r),
            (n = 0)),
          t.point((e = o), (r = u)),
          (i = s);
      },
      lineEnd: function () {
        t.lineEnd(), (e = r = NaN);
      },
      clean: function () {
        return 2 - n;
      },
    };
  },
  function (t, n, e, r) {
    var i;
    if (null == t)
      r.point(-cx, (i = e * lx)),
        r.point(0, i),
        r.point(cx, i),
        r.point(cx, 0),
        r.point(cx, -i),
        r.point(0, -i),
        r.point(-cx, -i),
        r.point(-cx, 0),
        r.point(-cx, i);
    else if (mx(t[0] - n[0]) > sx) {
      var o = t[0] < n[0] ? cx : -cx;
      r.point(-o, (i = (e * o) / 2)), r.point(0, i), r.point(o, i);
    } else r.point(n[0], n[1]);
  },
  [-cx, -lx],
);
function pk(t) {
  var n = bx(t),
    e = 6 * px,
    r = n > 0,
    i = mx(n) > sx;
  function o(t, e) {
    return bx(t) * bx(e) > n;
  }
  function u(t, e, r) {
    var i = [1, 0, 0],
      o = cO(sO(t), sO(e)),
      u = aO(o, o),
      s = o[0],
      a = u - s * s;
    if (!a) return !r && t;
    var c = (n * u) / a,
      l = (-n * s) / a,
      f = cO(i, o),
      h = fO(i, c);
    lO(h, fO(o, l));
    var d = f,
      p = aO(h, d),
      m = aO(d, d),
      v = p * p - m * (aO(h, h) - 1);
    if (!(v < 0)) {
      var g = Mx(v),
        b = fO(d, (-p - g) / m);
      if ((lO(b, h), (b = uO(b)), !r)) return b;
      var y,
        w = t[0],
        x = e[0],
        O = t[1],
        k = e[1];
      x < w && ((y = w), (w = x), (x = y));
      var A = x - w,
        $ = mx(A - cx) < sx;
      if (
        (!$ && k < O && ((y = O), (O = k), (k = y)),
        $ || A < sx
          ? $
            ? (O + k > 0) ^ (b[1] < (mx(b[0] - w) < sx ? O : k))
            : O <= b[1] && b[1] <= k
          : (A > cx) ^ (w <= b[0] && b[0] <= x))
      ) {
        var M = fO(d, (-p + g) / m);
        return lO(M, h), [b, uO(M)];
      }
    }
  }
  function s(n, e) {
    var i = r ? t : cx - t,
      o = 0;
    return n < -i ? (o |= 1) : n > i && (o |= 2), e < -i ? (o |= 4) : e > i && (o |= 8), o;
  }
  return lk(
    o,
    function (t) {
      var n, e, a, c, l;
      return {
        lineStart: function () {
          (c = a = !1), (l = 1);
        },
        point: function (f, h) {
          var d,
            p = [f, h],
            m = o(f, h),
            v = r ? (m ? 0 : s(f, h)) : m ? s(f + (f < 0 ? cx : -cx), h) : 0;
          if (
            (!n && (c = a = m) && t.lineStart(),
            m !== a && (!(d = u(n, p)) || ok(n, d) || ok(p, d)) && (p[2] = 1),
            m !== a)
          )
            (l = 0),
              m
                ? (t.lineStart(), (d = u(p, n)), t.point(d[0], d[1]))
                : ((d = u(n, p)), t.point(d[0], d[1], 2), t.lineEnd()),
              (n = d);
          else if (i && n && r ^ m) {
            var g;
            v & e ||
              !(g = u(p, n, !0)) ||
              ((l = 0),
              r
                ? (t.lineStart(), t.point(g[0][0], g[0][1]), t.point(g[1][0], g[1][1]), t.lineEnd())
                : (t.point(g[1][0], g[1][1]), t.lineEnd(), t.lineStart(), t.point(g[0][0], g[0][1], 3)));
          }
          !m || (n && ok(n, p)) || t.point(p[0], p[1]), (n = p), (a = m), (e = v);
        },
        lineEnd: function () {
          a && t.lineEnd(), (n = null);
        },
        clean: function () {
          return l | ((c && a) << 1);
        },
      };
    },
    function (n, r, i, o) {
      !(function (t, n, e, r, i, o) {
        if (e) {
          var u = bx(n),
            s = Ax(n),
            a = r * e;
          null == i
            ? ((i = n + r * hx), (o = n - a / 2))
            : ((i = rk(u, i)), (o = rk(u, o)), (r > 0 ? i < o : i > o) && (i += r * hx));
          for (var c, l = i; r > 0 ? l > o : l < o; l -= a) (c = uO([u, -s * bx(l), -s * Ax(l)])), t.point(c[0], c[1]);
        }
      })(o, t, e, i, n, r);
    },
    r ? [0, -t] : [-cx, t - cx],
  );
}
var mk = 1e9,
  vk = -mk;
function gk(t, n, e, r) {
  function i(i, o) {
    return t <= i && i <= e && n <= o && o <= r;
  }
  function o(i, o, s, c) {
    var l = 0,
      f = 0;
    if (null == i || (l = u(i, s)) !== (f = u(o, s)) || (a(i, o) < 0) ^ (s > 0))
      do {
        c.point(0 === l || 3 === l ? t : e, l > 1 ? r : n);
      } while ((l = (l + s + 4) % 4) !== f);
    else c.point(o[0], o[1]);
  }
  function u(r, i) {
    return mx(r[0] - t) < sx
      ? i > 0
        ? 0
        : 3
      : mx(r[0] - e) < sx
      ? i > 0
        ? 2
        : 1
      : mx(r[1] - n) < sx
      ? i > 0
        ? 1
        : 0
      : i > 0
      ? 3
      : 2;
  }
  function s(t, n) {
    return a(t.x, n.x);
  }
  function a(t, n) {
    var e = u(t, 1),
      r = u(n, 1);
    return e !== r ? e - r : 0 === e ? n[1] - t[1] : 1 === e ? t[0] - n[0] : 2 === e ? t[1] - n[1] : n[0] - t[0];
  }
  return function (u) {
    var a,
      c,
      l,
      f,
      h,
      d,
      p,
      m,
      v,
      g,
      b,
      y = u,
      w = ik(),
      x = {
        point: O,
        lineStart: function () {
          (x.point = k), c && c.push((l = [])), (g = !0), (v = !1), (p = m = NaN);
        },
        lineEnd: function () {
          a && (k(f, h), d && v && w.rejoin(), a.push(w.result())), (x.point = O), v && y.lineEnd();
        },
        polygonStart: function () {
          (y = w), (a = []), (c = []), (b = !0);
        },
        polygonEnd: function () {
          var n = (function () {
              for (var n = 0, e = 0, i = c.length; e < i; ++e)
                for (var o, u, s = c[e], a = 1, l = s.length, f = s[0], h = f[0], d = f[1]; a < l; ++a)
                  (o = h),
                    (u = d),
                    (h = (f = s[a])[0]),
                    (d = f[1]),
                    u <= r
                      ? d > r && (h - o) * (r - u) > (d - u) * (t - o) && ++n
                      : d <= r && (h - o) * (r - u) < (d - u) * (t - o) && --n;
              return n;
            })(),
            e = b && n,
            i = (a = ee(a)).length;
          (e || i) &&
            (u.polygonStart(),
            e && (u.lineStart(), o(null, null, 1, u), u.lineEnd()),
            i && sk(a, s, n, o, u),
            u.polygonEnd()),
            (y = u),
            (a = c = l = null);
        },
      };
    function O(t, n) {
      i(t, n) && y.point(t, n);
    }
    function k(o, u) {
      var s = i(o, u);
      if ((c && l.push([o, u]), g)) (f = o), (h = u), (d = s), (g = !1), s && (y.lineStart(), y.point(o, u));
      else if (s && v) y.point(o, u);
      else {
        var a = [(p = Math.max(vk, Math.min(mk, p))), (m = Math.max(vk, Math.min(mk, m)))],
          w = [(o = Math.max(vk, Math.min(mk, o))), (u = Math.max(vk, Math.min(mk, u)))];
        !(function (t, n, e, r, i, o) {
          var u,
            s = t[0],
            a = t[1],
            c = 0,
            l = 1,
            f = n[0] - s,
            h = n[1] - a;
          if (((u = e - s), f || !(u > 0))) {
            if (((u /= f), f < 0)) {
              if (u < c) return;
              u < l && (l = u);
            } else if (f > 0) {
              if (u > l) return;
              u > c && (c = u);
            }
            if (((u = i - s), f || !(u < 0))) {
              if (((u /= f), f < 0)) {
                if (u > l) return;
                u > c && (c = u);
              } else if (f > 0) {
                if (u < c) return;
                u < l && (l = u);
              }
              if (((u = r - a), h || !(u > 0))) {
                if (((u /= h), h < 0)) {
                  if (u < c) return;
                  u < l && (l = u);
                } else if (h > 0) {
                  if (u > l) return;
                  u > c && (c = u);
                }
                if (((u = o - a), h || !(u < 0))) {
                  if (((u /= h), h < 0)) {
                    if (u > l) return;
                    u > c && (c = u);
                  } else if (h > 0) {
                    if (u < c) return;
                    u < l && (l = u);
                  }
                  return (
                    c > 0 && ((t[0] = s + c * f), (t[1] = a + c * h)),
                    l < 1 && ((n[0] = s + l * f), (n[1] = a + l * h)),
                    !0
                  );
                }
              }
            }
          }
        })(a, w, t, n, e, r)
          ? s && (y.lineStart(), y.point(o, u), (b = !1))
          : (v || (y.lineStart(), y.point(a[0], a[1])), y.point(w[0], w[1]), s || y.lineEnd(), (b = !1));
      }
      (p = o), (m = u), (v = s);
    }
    return x;
  };
}
function bk(t, n, e) {
  var r = re(t, n - sx, e).concat(n);
  return function (t) {
    return r.map(function (n) {
      return [t, n];
    });
  };
}
function yk(t, n, e) {
  var r = re(t, n - sx, e).concat(n);
  return function (t) {
    return r.map(function (n) {
      return [n, t];
    });
  };
}
const wk = t => t;
var xk,
  Ok,
  kk,
  Ak,
  $k = new Bn(),
  Mk = new Bn(),
  jk = {
    point: Ex,
    lineStart: Ex,
    lineEnd: Ex,
    polygonStart: function () {
      (jk.lineStart = Dk), (jk.lineEnd = Sk);
    },
    polygonEnd: function () {
      (jk.lineStart = jk.lineEnd = jk.point = Ex), $k.add(mx(Mk)), (Mk = new Bn());
    },
    result: function () {
      var t = $k / 2;
      return ($k = new Bn()), t;
    },
  };
function Dk() {
  jk.point = Fk;
}
function Fk(t, n) {
  (jk.point = Ek), (xk = kk = t), (Ok = Ak = n);
}
function Ek(t, n) {
  Mk.add(Ak * t - kk * n), (kk = t), (Ak = n);
}
function Sk() {
  Ek(xk, Ok);
}
var Ck,
  Nk,
  Bk,
  _k,
  zk = 1 / 0,
  Tk = zk,
  Pk = -zk,
  Rk = Pk,
  Lk = {
    point: function (t, n) {
      t < zk && (zk = t), t > Pk && (Pk = t), n < Tk && (Tk = n), n > Rk && (Rk = n);
    },
    lineStart: Ex,
    lineEnd: Ex,
    polygonStart: Ex,
    polygonEnd: Ex,
    result: function () {
      var t = [
        [zk, Tk],
        [Pk, Rk],
      ];
      return (Pk = Rk = -(Tk = zk = 1 / 0)), t;
    },
  },
  qk = 0,
  Ik = 0,
  Uk = 0,
  Wk = 0,
  Hk = 0,
  Gk = 0,
  Vk = 0,
  Yk = 0,
  Xk = 0,
  Jk = {
    point: Qk,
    lineStart: Zk,
    lineEnd: nA,
    polygonStart: function () {
      (Jk.lineStart = eA), (Jk.lineEnd = rA);
    },
    polygonEnd: function () {
      (Jk.point = Qk), (Jk.lineStart = Zk), (Jk.lineEnd = nA);
    },
    result: function () {
      var t = Xk ? [Vk / Xk, Yk / Xk] : Gk ? [Wk / Gk, Hk / Gk] : Uk ? [qk / Uk, Ik / Uk] : [NaN, NaN];
      return (qk = Ik = Uk = Wk = Hk = Gk = Vk = Yk = Xk = 0), t;
    },
  };
function Qk(t, n) {
  (qk += t), (Ik += n), ++Uk;
}
function Zk() {
  Jk.point = Kk;
}
function Kk(t, n) {
  (Jk.point = tA), Qk((Bk = t), (_k = n));
}
function tA(t, n) {
  var e = t - Bk,
    r = n - _k,
    i = Mx(e * e + r * r);
  (Wk += (i * (Bk + t)) / 2), (Hk += (i * (_k + n)) / 2), (Gk += i), Qk((Bk = t), (_k = n));
}
function nA() {
  Jk.point = Qk;
}
function eA() {
  Jk.point = iA;
}
function rA() {
  oA(Ck, Nk);
}
function iA(t, n) {
  (Jk.point = oA), Qk((Ck = Bk = t), (Nk = _k = n));
}
function oA(t, n) {
  var e = t - Bk,
    r = n - _k,
    i = Mx(e * e + r * r);
  (Wk += (i * (Bk + t)) / 2),
    (Hk += (i * (_k + n)) / 2),
    (Gk += i),
    (Vk += (i = _k * t - Bk * n) * (Bk + t)),
    (Yk += i * (_k + n)),
    (Xk += 3 * i),
    Qk((Bk = t), (_k = n));
}
function uA(t) {
  this._context = t;
}
uA.prototype = {
  _radius: 4.5,
  pointRadius: function (t) {
    return (this._radius = t), this;
  },
  polygonStart: function () {
    this._line = 0;
  },
  polygonEnd: function () {
    this._line = NaN;
  },
  lineStart: function () {
    this._point = 0;
  },
  lineEnd: function () {
    0 === this._line && this._context.closePath(), (this._point = NaN);
  },
  point: function (t, n) {
    switch (this._point) {
      case 0:
        this._context.moveTo(t, n), (this._point = 1);
        break;
      case 1:
        this._context.lineTo(t, n);
        break;
      default:
        this._context.moveTo(t + this._radius, n), this._context.arc(t, n, this._radius, 0, hx);
    }
  },
  result: Ex,
};
var sA,
  aA,
  cA,
  lA,
  fA,
  hA = new Bn(),
  dA = {
    point: Ex,
    lineStart: function () {
      dA.point = pA;
    },
    lineEnd: function () {
      sA && mA(aA, cA), (dA.point = Ex);
    },
    polygonStart: function () {
      sA = !0;
    },
    polygonEnd: function () {
      sA = null;
    },
    result: function () {
      var t = +hA;
      return (hA = new Bn()), t;
    },
  };
function pA(t, n) {
  (dA.point = mA), (aA = lA = t), (cA = fA = n);
}
function mA(t, n) {
  hA.add(Mx((lA -= t) * lA + (fA -= n) * fA)), (lA = t), (fA = n);
}
let vA, gA, bA, yA;
class wA {
  constructor(t) {
    (this._append =
      null == t
        ? xA
        : (function (t) {
            const n = Math.floor(t);
            if (!(n >= 0)) throw new RangeError(`invalid digits: ${t}`);
            if (n > 15) return xA;
            if (n !== vA) {
              const t = 10 ** n;
              (vA = n),
                (gA = function (n) {
                  let e = 1;
                  this._ += n[0];
                  for (const r = n.length; e < r; ++e) this._ += Math.round(arguments[e] * t) / t + n[e];
                });
            }
            return gA;
          })(t)),
      (this._radius = 4.5),
      (this._ = '');
  }
  pointRadius(t) {
    return (this._radius = +t), this;
  }
  polygonStart() {
    this._line = 0;
  }
  polygonEnd() {
    this._line = NaN;
  }
  lineStart() {
    this._point = 0;
  }
  lineEnd() {
    0 === this._line && (this._ += 'Z'), (this._point = NaN);
  }
  point(t, n) {
    switch (this._point) {
      case 0:
        this._append`M${t},${n}`, (this._point = 1);
        break;
      case 1:
        this._append`L${t},${n}`;
        break;
      default:
        if ((this._append`M${t},${n}`, this._radius !== bA || this._append !== gA)) {
          const t = this._radius,
            n = this._;
          (this._ = ''),
            this._append`m0,${t}a${t},${t} 0 1,1 0,${-2 * t}a${t},${t} 0 1,1 0,${2 * t}z`,
            (bA = t),
            (gA = this._append),
            (yA = this._),
            (this._ = n);
        }
        this._ += yA;
    }
  }
  result() {
    const t = this._;
    return (this._ = ''), t.length ? t : null;
  }
}
function xA(t) {
  let n = 1;
  this._ += t[0];
  for (const e = t.length; n < e; ++n) this._ += arguments[n] + t[n];
}
function OA(t, n) {
  let e,
    r,
    i = 3,
    o = 4.5;
  function u(t) {
    return t && ('function' == typeof o && r.pointRadius(+o.apply(this, arguments)), zx(t, e(r))), r.result();
  }
  return (
    (u.area = function (t) {
      return zx(t, e(jk)), jk.result();
    }),
    (u.measure = function (t) {
      return zx(t, e(dA)), dA.result();
    }),
    (u.bounds = function (t) {
      return zx(t, e(Lk)), Lk.result();
    }),
    (u.centroid = function (t) {
      return zx(t, e(Jk)), Jk.result();
    }),
    (u.projection = function (n) {
      return arguments.length ? ((e = null == n ? ((t = null), wk) : (t = n).stream), u) : t;
    }),
    (u.context = function (t) {
      return arguments.length
        ? ((r = null == t ? ((n = null), new wA(i)) : new uA((n = t))), 'function' != typeof o && r.pointRadius(o), u)
        : n;
    }),
    (u.pointRadius = function (t) {
      return arguments.length ? ((o = 'function' == typeof t ? t : (r.pointRadius(+t), +t)), u) : o;
    }),
    (u.digits = function (t) {
      if (!arguments.length) return i;
      if (null == t) i = null;
      else {
        const n = Math.floor(t);
        if (!(n >= 0)) throw new RangeError(`invalid digits: ${t}`);
        i = n;
      }
      return null === n && (r = new wA(i)), u;
    }),
    u.projection(t).digits(i).context(n)
  );
}
function kA(t) {
  return function (n) {
    var e = new AA();
    for (var r in t) e[r] = t[r];
    return (e.stream = n), e;
  };
}
function AA() {}
function $A(t, n, e) {
  var r = t.clipExtent && t.clipExtent();
  return (
    t.scale(150).translate([0, 0]),
    null != r && t.clipExtent(null),
    zx(e, t.stream(Lk)),
    n(Lk.result()),
    null != r && t.clipExtent(r),
    t
  );
}
function MA(t, n, e) {
  return $A(
    t,
    function (e) {
      var r = n[1][0] - n[0][0],
        i = n[1][1] - n[0][1],
        o = Math.min(r / (e[1][0] - e[0][0]), i / (e[1][1] - e[0][1])),
        u = +n[0][0] + (r - o * (e[1][0] + e[0][0])) / 2,
        s = +n[0][1] + (i - o * (e[1][1] + e[0][1])) / 2;
      t.scale(150 * o).translate([u, s]);
    },
    e,
  );
}
function jA(t, n, e) {
  return MA(t, [[0, 0], n], e);
}
function DA(t, n, e) {
  return $A(
    t,
    function (e) {
      var r = +n,
        i = r / (e[1][0] - e[0][0]),
        o = (r - i * (e[1][0] + e[0][0])) / 2,
        u = -i * e[0][1];
      t.scale(150 * i).translate([o, u]);
    },
    e,
  );
}
function FA(t, n, e) {
  return $A(
    t,
    function (e) {
      var r = +n,
        i = r / (e[1][1] - e[0][1]),
        o = -i * e[0][0],
        u = (r - i * (e[1][1] + e[0][1])) / 2;
      t.scale(150 * i).translate([o, u]);
    },
    e,
  );
}
AA.prototype = {
  constructor: AA,
  point: function (t, n) {
    this.stream.point(t, n);
  },
  sphere: function () {
    this.stream.sphere();
  },
  lineStart: function () {
    this.stream.lineStart();
  },
  lineEnd: function () {
    this.stream.lineEnd();
  },
  polygonStart: function () {
    this.stream.polygonStart();
  },
  polygonEnd: function () {
    this.stream.polygonEnd();
  },
};
var EA = bx(30 * px);
function SA(t, n) {
  return +n
    ? (function (t, n) {
        function e(r, i, o, u, s, a, c, l, f, h, d, p, m, v) {
          var g = c - r,
            b = l - i,
            y = g * g + b * b;
          if (y > 4 * n && m--) {
            var w = u + h,
              x = s + d,
              O = a + p,
              k = Mx(w * w + x * x + O * O),
              A = Fx((O /= k)),
              $ = mx(mx(O) - 1) < sx || mx(o - f) < sx ? (o + f) / 2 : gx(x, w),
              M = t($, A),
              j = M[0],
              D = M[1],
              F = j - r,
              E = D - i,
              S = b * F - g * E;
            ((S * S) / y > n || mx((g * F + b * E) / y - 0.5) > 0.3 || u * h + s * d + a * p < EA) &&
              (e(r, i, o, u, s, a, j, D, $, (w /= k), (x /= k), O, m, v),
              v.point(j, D),
              e(j, D, $, w, x, O, c, l, f, h, d, p, m, v));
          }
        }
        return function (n) {
          var r,
            i,
            o,
            u,
            s,
            a,
            c,
            l,
            f,
            h,
            d,
            p,
            m = {
              point: v,
              lineStart: g,
              lineEnd: y,
              polygonStart: function () {
                n.polygonStart(), (m.lineStart = w);
              },
              polygonEnd: function () {
                n.polygonEnd(), (m.lineStart = g);
              },
            };
          function v(e, r) {
            (e = t(e, r)), n.point(e[0], e[1]);
          }
          function g() {
            (l = NaN), (m.point = b), n.lineStart();
          }
          function b(r, i) {
            var o = sO([r, i]),
              u = t(r, i);
            e(l, f, c, h, d, p, (l = u[0]), (f = u[1]), (c = r), (h = o[0]), (d = o[1]), (p = o[2]), 16, n),
              n.point(l, f);
          }
          function y() {
            (m.point = v), n.lineEnd();
          }
          function w() {
            g(), (m.point = x), (m.lineEnd = O);
          }
          function x(t, n) {
            b((r = t), n), (i = l), (o = f), (u = h), (s = d), (a = p), (m.point = b);
          }
          function O() {
            e(l, f, c, h, d, p, i, o, r, u, s, a, 16, n), (m.lineEnd = y), y();
          }
          return m;
        };
      })(t, n)
    : (function (t) {
        return kA({
          point: function (n, e) {
            (n = t(n, e)), this.stream.point(n[0], n[1]);
          },
        });
      })(t);
}
var CA = kA({
  point: function (t, n) {
    this.stream.point(t * px, n * px);
  },
});
function NA(t, n, e, r, i, o) {
  if (!o)
    return (function (t, n, e, r, i) {
      function o(o, u) {
        return [n + t * (o *= r), e - t * (u *= i)];
      }
      return (
        (o.invert = function (o, u) {
          return [((o - n) / t) * r, ((e - u) / t) * i];
        }),
        o
      );
    })(t, n, e, r, i);
  var u = bx(o),
    s = Ax(o),
    a = u * t,
    c = s * t,
    l = u / t,
    f = s / t,
    h = (s * e - u * n) / t,
    d = (s * n + u * e) / t;
  function p(t, o) {
    return [a * (t *= r) - c * (o *= i) + n, e - c * t - a * o];
  }
  return (
    (p.invert = function (t, n) {
      return [r * (l * t - f * n + h), i * (d - f * t - l * n)];
    }),
    p
  );
}
function BA(t) {
  return _A(function () {
    return t;
  })();
}
function _A(t) {
  var n,
    e,
    r,
    i,
    o,
    u,
    s,
    a,
    c,
    l,
    f = 150,
    h = 480,
    d = 250,
    p = 0,
    m = 0,
    v = 0,
    g = 0,
    b = 0,
    y = 0,
    w = 1,
    x = 1,
    O = null,
    k = dk,
    A = null,
    $ = wk,
    M = 0.5;
  function j(t) {
    return a(t[0] * px, t[1] * px);
  }
  function D(t) {
    return (t = a.invert(t[0], t[1])) && [t[0] * dx, t[1] * dx];
  }
  function F() {
    var t = NA(f, 0, 0, w, x, y).apply(null, n(p, m)),
      r = NA(f, h - t[0], d - t[1], w, x, y);
    return (e = KO(v, g, b)), (s = QO(n, r)), (a = QO(e, s)), (u = SA(s, M)), E();
  }
  function E() {
    return (c = l = null), j;
  }
  return (
    (j.stream = function (t) {
      return c && l === t
        ? c
        : (c = CA(
            (function (t) {
              return kA({
                point: function (n, e) {
                  var r = t(n, e);
                  return this.stream.point(r[0], r[1]);
                },
              });
            })(e)(k(u($((l = t))))),
          ));
    }),
    (j.preclip = function (t) {
      return arguments.length ? ((k = t), (O = void 0), E()) : k;
    }),
    (j.postclip = function (t) {
      return arguments.length ? (($ = t), (A = r = i = o = null), E()) : $;
    }),
    (j.clipAngle = function (t) {
      return arguments.length ? ((k = +t ? pk((O = t * px)) : ((O = null), dk)), E()) : O * dx;
    }),
    (j.clipExtent = function (t) {
      return arguments.length
        ? (($ =
            null == t
              ? ((A = r = i = o = null), wk)
              : gk((A = +t[0][0]), (r = +t[0][1]), (i = +t[1][0]), (o = +t[1][1]))),
          E())
        : null == A
        ? null
        : [
            [A, r],
            [i, o],
          ];
    }),
    (j.scale = function (t) {
      return arguments.length ? ((f = +t), F()) : f;
    }),
    (j.translate = function (t) {
      return arguments.length ? ((h = +t[0]), (d = +t[1]), F()) : [h, d];
    }),
    (j.center = function (t) {
      return arguments.length ? ((p = (t[0] % 360) * px), (m = (t[1] % 360) * px), F()) : [p * dx, m * dx];
    }),
    (j.rotate = function (t) {
      return arguments.length
        ? ((v = (t[0] % 360) * px), (g = (t[1] % 360) * px), (b = t.length > 2 ? (t[2] % 360) * px : 0), F())
        : [v * dx, g * dx, b * dx];
    }),
    (j.angle = function (t) {
      return arguments.length ? ((y = (t % 360) * px), F()) : y * dx;
    }),
    (j.reflectX = function (t) {
      return arguments.length ? ((w = t ? -1 : 1), F()) : w < 0;
    }),
    (j.reflectY = function (t) {
      return arguments.length ? ((x = t ? -1 : 1), F()) : x < 0;
    }),
    (j.precision = function (t) {
      return arguments.length ? ((u = SA(s, (M = t * t))), E()) : Mx(M);
    }),
    (j.fitExtent = function (t, n) {
      return MA(j, t, n);
    }),
    (j.fitSize = function (t, n) {
      return jA(j, t, n);
    }),
    (j.fitWidth = function (t, n) {
      return DA(j, t, n);
    }),
    (j.fitHeight = function (t, n) {
      return FA(j, t, n);
    }),
    function () {
      return (n = t.apply(this, arguments)), (j.invert = n.invert && D), F();
    }
  );
}
function zA(t) {
  var n = 0,
    e = cx / 3,
    r = _A(t),
    i = r(n, e);
  return (
    (i.parallels = function (t) {
      return arguments.length ? r((n = t[0] * px), (e = t[1] * px)) : [n * dx, e * dx];
    }),
    i
  );
}
function TA(t, n) {
  var e = Ax(t),
    r = (e + Ax(n)) / 2;
  if (mx(r) < sx)
    return (function (t) {
      var n = bx(t);
      function e(t, e) {
        return [t * n, Ax(e) / n];
      }
      return (
        (e.invert = function (t, e) {
          return [t / n, Fx(e * n)];
        }),
        e
      );
    })(t);
  var i = 1 + e * (2 * r - e),
    o = Mx(i) / r;
  function u(t, n) {
    var e = Mx(i - 2 * r * Ax(n)) / r;
    return [e * Ax((t *= r)), o - e * bx(t)];
  }
  return (
    (u.invert = function (t, n) {
      var e = o - n,
        u = gx(t, mx(e)) * $x(e);
      return e * r < 0 && (u -= cx * $x(t) * $x(e)), [u / r, Fx((i - (t * t + e * e) * r * r) / (2 * r))];
    }),
    u
  );
}
function PA() {
  return zA(TA).scale(155.424).center([0, 33.6442]);
}
function RA() {
  return PA().parallels([29.5, 45.5]).scale(1070).translate([480, 250]).rotate([96, 0]).center([-0.6, 38.7]);
}
function LA(t) {
  return function (n, e) {
    var r = bx(n),
      i = bx(e),
      o = t(r * i);
    return o === 1 / 0 ? [2, 0] : [o * i * Ax(n), o * Ax(e)];
  };
}
function qA(t) {
  return function (n, e) {
    var r = Mx(n * n + e * e),
      i = t(r),
      o = Ax(i),
      u = bx(i);
    return [gx(n * o, r * u), Fx(r && (e * o) / r)];
  };
}
var IA = LA(function (t) {
  return Mx(2 / (1 + t));
});
IA.invert = qA(function (t) {
  return 2 * Fx(t / 2);
});
var UA = LA(function (t) {
  return (t = Dx(t)) && t / Ax(t);
});
function WA(t, n) {
  return [t, Ox(jx((lx + n) / 2))];
}
function HA(t) {
  var n,
    e,
    r,
    i = BA(t),
    o = i.center,
    u = i.scale,
    s = i.translate,
    a = i.clipExtent,
    c = null;
  function l() {
    var o = cx * u(),
      s = i(
        (function (t) {
          function n(n) {
            return ((n = t(n[0] * px, n[1] * px))[0] *= dx), (n[1] *= dx), n;
          }
          return (
            (t = KO(t[0] * px, t[1] * px, t.length > 2 ? t[2] * px : 0)),
            (n.invert = function (n) {
              return ((n = t.invert(n[0] * px, n[1] * px))[0] *= dx), (n[1] *= dx), n;
            }),
            n
          );
        })(i.rotate()).invert([0, 0]),
      );
    return a(
      null == c
        ? [
            [s[0] - o, s[1] - o],
            [s[0] + o, s[1] + o],
          ]
        : t === WA
        ? [
            [Math.max(s[0] - o, c), n],
            [Math.min(s[0] + o, e), r],
          ]
        : [
            [c, Math.max(s[1] - o, n)],
            [e, Math.min(s[1] + o, r)],
          ],
    );
  }
  return (
    (i.scale = function (t) {
      return arguments.length ? (u(t), l()) : u();
    }),
    (i.translate = function (t) {
      return arguments.length ? (s(t), l()) : s();
    }),
    (i.center = function (t) {
      return arguments.length ? (o(t), l()) : o();
    }),
    (i.clipExtent = function (t) {
      return arguments.length
        ? (null == t ? (c = n = e = r = null) : ((c = +t[0][0]), (n = +t[0][1]), (e = +t[1][0]), (r = +t[1][1])), l())
        : null == c
        ? null
        : [
            [c, n],
            [e, r],
          ];
    }),
    l()
  );
}
function GA(t) {
  return jx((lx + t) / 2);
}
function VA(t, n) {
  var e = bx(t),
    r = t === n ? Ax(t) : Ox(e / bx(n)) / Ox(GA(n) / GA(t)),
    i = (e * kx(GA(t), r)) / r;
  if (!r) return WA;
  function o(t, n) {
    i > 0 ? n < -lx + sx && (n = -lx + sx) : n > lx - sx && (n = lx - sx);
    var e = i / kx(GA(n), r);
    return [e * Ax(r * t), i - e * bx(r * t)];
  }
  return (
    (o.invert = function (t, n) {
      var e = i - n,
        o = $x(r) * Mx(t * t + e * e),
        u = gx(t, mx(e)) * $x(e);
      return e * r < 0 && (u -= cx * $x(t) * $x(e)), [u / r, 2 * vx(kx(i / o, 1 / r)) - lx];
    }),
    o
  );
}
function YA(t, n) {
  return [t, n];
}
function XA(t, n) {
  var e = bx(t),
    r = t === n ? Ax(t) : (e - bx(n)) / (n - t),
    i = e / r + t;
  if (mx(r) < sx) return YA;
  function o(t, n) {
    var e = i - n,
      o = r * t;
    return [e * Ax(o), i - e * bx(o)];
  }
  return (
    (o.invert = function (t, n) {
      var e = i - n,
        o = gx(t, mx(e)) * $x(e);
      return e * r < 0 && (o -= cx * $x(t) * $x(e)), [o / r, i - $x(r) * Mx(t * t + e * e)];
    }),
    o
  );
}
(UA.invert = qA(function (t) {
  return t;
})),
  (WA.invert = function (t, n) {
    return [t, 2 * vx(wx(n)) - lx];
  }),
  (YA.invert = YA);
var JA = 1.340264,
  QA = -0.081106,
  ZA = 893e-6,
  KA = 0.003796,
  t$ = Mx(3) / 2;
function n$(t, n) {
  var e = Fx(t$ * Ax(n)),
    r = e * e,
    i = r * r * r;
  return [(t * bx(e)) / (t$ * (JA + 3 * QA * r + i * (7 * ZA + 9 * KA * r))), e * (JA + QA * r + i * (ZA + KA * r))];
}
function e$(t, n) {
  var e = bx(n),
    r = bx(t) * e;
  return [(e * Ax(t)) / r, Ax(n) / r];
}
function r$(t, n) {
  var e = n * n,
    r = e * e;
  return [
    t * (0.8707 - 0.131979 * e + r * (r * (0.003971 * e - 0.001529 * r) - 0.013791)),
    n * (1.007226 + e * (0.015085 + r * (0.028874 * e - 0.044475 - 0.005916 * r))),
  ];
}
function i$(t, n) {
  return [bx(n) * Ax(t), Ax(n)];
}
function o$(t, n) {
  var e = bx(n),
    r = 1 + bx(t) * e;
  return [(e * Ax(t)) / r, Ax(n) / r];
}
function u$(t, n) {
  return [Ox(jx((lx + n) / 2)), -t];
}
(n$.invert = function (t, n) {
  for (
    var e, r = n, i = r * r, o = i * i * i, u = 0;
    u < 12 &&
    ((o =
      (i = (r -= e = (r * (JA + QA * i + o * (ZA + KA * i)) - n) / (JA + 3 * QA * i + o * (7 * ZA + 9 * KA * i))) * r) *
      i *
      i),
    !(mx(e) < ax));
    ++u
  );
  return [(t$ * t * (JA + 3 * QA * i + o * (7 * ZA + 9 * KA * i))) / bx(r), Fx(Ax(r) / t$)];
}),
  (e$.invert = qA(vx)),
  (r$.invert = function (t, n) {
    var e,
      r = n,
      i = 25;
    do {
      var o = r * r,
        u = o * o;
      r -= e =
        (r * (1.007226 + o * (0.015085 + u * (0.028874 * o - 0.044475 - 0.005916 * u))) - n) /
        (1.007226 + o * (0.045255 + u * (0.259866 * o - 0.311325 - 0.005916 * 11 * u)));
    } while (mx(e) > sx && --i > 0);
    return [t / (0.8707 + (o = r * r) * (o * (o * o * o * (0.003971 - 0.001529 * o) - 0.013791) - 0.131979)), r];
  }),
  (i$.invert = qA(Fx)),
  (o$.invert = qA(function (t) {
    return 2 * vx(t);
  })),
  (u$.invert = function (t, n) {
    return [-n, 2 * vx(wx(t)) - lx];
  });
var s$ = Math.abs,
  a$ = Math.cos,
  c$ = Math.sin,
  l$ = Math.PI,
  f$ = l$ / 2,
  h$ = Math.sqrt(2);
function d$(t) {
  return t > 1 ? f$ : t < -1 ? -f$ : Math.asin(t);
}
function p$(t, n) {
  var e,
    r = t * c$(n),
    i = 30;
  do {
    n -= e = (n + c$(n) - r) / (1 + a$(n));
  } while (s$(e) > 1e-6 && --i > 0);
  return n / 2;
}
var m$ = (function (t, n, e) {
  function r(r, i) {
    return [t * r * a$((i = p$(e, i))), n * c$(i)];
  }
  return (
    (r.invert = function (r, i) {
      return (i = d$(i / n)), [r / (t * a$(i)), d$((2 * i + c$(2 * i)) / e)];
    }),
    r
  );
})(h$ / f$, h$, l$);
const v$ = OA(),
  g$ = [
    'clipAngle',
    'clipExtent',
    'scale',
    'translate',
    'center',
    'rotate',
    'parallels',
    'precision',
    'reflectX',
    'reflectY',
    'coefficient',
    'distance',
    'fraction',
    'lobes',
    'parallel',
    'radius',
    'ratio',
    'spacing',
    'tilt',
  ];
function b$(t, n) {
  return function e() {
    const r = n();
    return (
      (r.type = t),
      (r.path = OA().projection(r)),
      (r.copy =
        r.copy ||
        function () {
          const t = e();
          return (
            g$.forEach(n => {
              r[n] && t[n](r[n]());
            }),
            t.path.pointRadius(r.path.pointRadius()),
            t
          );
        }),
      r
    );
  };
}
function y$(t, n) {
  if (!t || 'string' != typeof t) throw new Error('Projection type must be a name string.');
  return (t = t.toLowerCase()), arguments.length > 1 ? ((x$[t] = b$(t, n)), this) : x$[t] || null;
}
function w$(t) {
  return (t && t.path) || v$;
}
const x$ = {
  albers: RA,
  albersusa: function () {
    var t,
      n,
      e,
      r,
      i,
      o,
      u = RA(),
      s = PA().rotate([154, 0]).center([-2, 58.5]).parallels([55, 65]),
      a = PA().rotate([157, 0]).center([-3, 19.9]).parallels([8, 18]),
      c = {
        point: function (t, n) {
          o = [t, n];
        },
      };
    function l(t) {
      var n = t[0],
        u = t[1];
      return (o = null), e.point(n, u), o || (r.point(n, u), o) || (i.point(n, u), o);
    }
    function f() {
      return (t = n = null), l;
    }
    return (
      (l.invert = function (t) {
        var n = u.scale(),
          e = u.translate(),
          r = (t[0] - e[0]) / n,
          i = (t[1] - e[1]) / n;
        return (
          i >= 0.12 && i < 0.234 && r >= -0.425 && r < -0.214
            ? s
            : i >= 0.166 && i < 0.234 && r >= -0.214 && r < -0.115
            ? a
            : u
        ).invert(t);
      }),
      (l.stream = function (e) {
        return t && n === e
          ? t
          : ((r = [u.stream((n = e)), s.stream(e), a.stream(e)]),
            (i = r.length),
            (t = {
              point: function (t, n) {
                for (var e = -1; ++e < i; ) r[e].point(t, n);
              },
              sphere: function () {
                for (var t = -1; ++t < i; ) r[t].sphere();
              },
              lineStart: function () {
                for (var t = -1; ++t < i; ) r[t].lineStart();
              },
              lineEnd: function () {
                for (var t = -1; ++t < i; ) r[t].lineEnd();
              },
              polygonStart: function () {
                for (var t = -1; ++t < i; ) r[t].polygonStart();
              },
              polygonEnd: function () {
                for (var t = -1; ++t < i; ) r[t].polygonEnd();
              },
            }));
        var r, i;
      }),
      (l.precision = function (t) {
        return arguments.length ? (u.precision(t), s.precision(t), a.precision(t), f()) : u.precision();
      }),
      (l.scale = function (t) {
        return arguments.length ? (u.scale(t), s.scale(0.35 * t), a.scale(t), l.translate(u.translate())) : u.scale();
      }),
      (l.translate = function (t) {
        if (!arguments.length) return u.translate();
        var n = u.scale(),
          o = +t[0],
          l = +t[1];
        return (
          (e = u
            .translate(t)
            .clipExtent([
              [o - 0.455 * n, l - 0.238 * n],
              [o + 0.455 * n, l + 0.238 * n],
            ])
            .stream(c)),
          (r = s
            .translate([o - 0.307 * n, l + 0.201 * n])
            .clipExtent([
              [o - 0.425 * n + sx, l + 0.12 * n + sx],
              [o - 0.214 * n - sx, l + 0.234 * n - sx],
            ])
            .stream(c)),
          (i = a
            .translate([o - 0.205 * n, l + 0.212 * n])
            .clipExtent([
              [o - 0.214 * n + sx, l + 0.166 * n + sx],
              [o - 0.115 * n - sx, l + 0.234 * n - sx],
            ])
            .stream(c)),
          f()
        );
      }),
      (l.fitExtent = function (t, n) {
        return MA(l, t, n);
      }),
      (l.fitSize = function (t, n) {
        return jA(l, t, n);
      }),
      (l.fitWidth = function (t, n) {
        return DA(l, t, n);
      }),
      (l.fitHeight = function (t, n) {
        return FA(l, t, n);
      }),
      l.scale(1070)
    );
  },
  azimuthalequalarea: function () {
    return BA(IA).scale(124.75).clipAngle(179.999);
  },
  azimuthalequidistant: function () {
    return BA(UA).scale(79.4188).clipAngle(179.999);
  },
  conicconformal: function () {
    return zA(VA).scale(109.5).parallels([30, 30]);
  },
  conicequalarea: PA,
  conicequidistant: function () {
    return zA(XA).scale(131.154).center([0, 13.9389]);
  },
  equalEarth: function () {
    return BA(n$).scale(177.158);
  },
  equirectangular: function () {
    return BA(YA).scale(152.63);
  },
  gnomonic: function () {
    return BA(e$).scale(144.049).clipAngle(60);
  },
  identity: function () {
    var t,
      n,
      e,
      r,
      i,
      o,
      u,
      s = 1,
      a = 0,
      c = 0,
      l = 1,
      f = 1,
      h = 0,
      d = null,
      p = 1,
      m = 1,
      v = kA({
        point: function (t, n) {
          var e = y([t, n]);
          this.stream.point(e[0], e[1]);
        },
      }),
      g = wk;
    function b() {
      return (p = s * l), (m = s * f), (o = u = null), y;
    }
    function y(e) {
      var r = e[0] * p,
        i = e[1] * m;
      if (h) {
        var o = i * t - r * n;
        (r = r * t + i * n), (i = o);
      }
      return [r + a, i + c];
    }
    return (
      (y.invert = function (e) {
        var r = e[0] - a,
          i = e[1] - c;
        if (h) {
          var o = i * t + r * n;
          (r = r * t - i * n), (i = o);
        }
        return [r / p, i / m];
      }),
      (y.stream = function (t) {
        return o && u === t ? o : (o = v(g((u = t))));
      }),
      (y.postclip = function (t) {
        return arguments.length ? ((g = t), (d = e = r = i = null), b()) : g;
      }),
      (y.clipExtent = function (t) {
        return arguments.length
          ? ((g =
              null == t
                ? ((d = e = r = i = null), wk)
                : gk((d = +t[0][0]), (e = +t[0][1]), (r = +t[1][0]), (i = +t[1][1]))),
            b())
          : null == d
          ? null
          : [
              [d, e],
              [r, i],
            ];
      }),
      (y.scale = function (t) {
        return arguments.length ? ((s = +t), b()) : s;
      }),
      (y.translate = function (t) {
        return arguments.length ? ((a = +t[0]), (c = +t[1]), b()) : [a, c];
      }),
      (y.angle = function (e) {
        return arguments.length ? ((n = Ax((h = (e % 360) * px))), (t = bx(h)), b()) : h * dx;
      }),
      (y.reflectX = function (t) {
        return arguments.length ? ((l = t ? -1 : 1), b()) : l < 0;
      }),
      (y.reflectY = function (t) {
        return arguments.length ? ((f = t ? -1 : 1), b()) : f < 0;
      }),
      (y.fitExtent = function (t, n) {
        return MA(y, t, n);
      }),
      (y.fitSize = function (t, n) {
        return jA(y, t, n);
      }),
      (y.fitWidth = function (t, n) {
        return DA(y, t, n);
      }),
      (y.fitHeight = function (t, n) {
        return FA(y, t, n);
      }),
      y
    );
  },
  mercator: function () {
    return HA(WA).scale(961 / hx);
  },
  mollweide: function () {
    return BA(m$).scale(169.529);
  },
  naturalEarth1: function () {
    return BA(r$).scale(175.295);
  },
  orthographic: function () {
    return BA(i$).scale(249.5).clipAngle(90.000001);
  },
  stereographic: function () {
    return BA(o$).scale(250).clipAngle(142);
  },
  transversemercator: function () {
    var t = HA(u$),
      n = t.center,
      e = t.rotate;
    return (
      (t.center = function (t) {
        return arguments.length ? n([-t[1], t[0]]) : [(t = n())[1], -t[0]];
      }),
      (t.rotate = function (t) {
        return arguments.length ? e([t[0], t[1], t.length > 2 ? t[2] + 90 : 90]) : [(t = e())[0], t[1], t[2] - 90];
      }),
      e([0, 0, 90]).scale(159.155)
    );
  },
};
for (const t in x$) y$(t, x$[t]);
function O$() {}
const k$ = [
  [],
  [
    [
      [1, 1.5],
      [0.5, 1],
    ],
  ],
  [
    [
      [1.5, 1],
      [1, 1.5],
    ],
  ],
  [
    [
      [1.5, 1],
      [0.5, 1],
    ],
  ],
  [
    [
      [1, 0.5],
      [1.5, 1],
    ],
  ],
  [
    [
      [1, 1.5],
      [0.5, 1],
    ],
    [
      [1, 0.5],
      [1.5, 1],
    ],
  ],
  [
    [
      [1, 0.5],
      [1, 1.5],
    ],
  ],
  [
    [
      [1, 0.5],
      [0.5, 1],
    ],
  ],
  [
    [
      [0.5, 1],
      [1, 0.5],
    ],
  ],
  [
    [
      [1, 1.5],
      [1, 0.5],
    ],
  ],
  [
    [
      [0.5, 1],
      [1, 0.5],
    ],
    [
      [1.5, 1],
      [1, 1.5],
    ],
  ],
  [
    [
      [1.5, 1],
      [1, 0.5],
    ],
  ],
  [
    [
      [0.5, 1],
      [1.5, 1],
    ],
  ],
  [
    [
      [1, 1.5],
      [1.5, 1],
    ],
  ],
  [
    [
      [0.5, 1],
      [1, 1.5],
    ],
  ],
  [],
];
function A$() {
  var t = 1,
    n = 1,
    e = u;
  function r(t, n) {
    return n.map(n => i(t, n));
  }
  function i(r, i) {
    var u = [],
      s = [];
    return (
      (function (e, r, i) {
        var u,
          s,
          a,
          c,
          l,
          f = new Array(),
          h = new Array();
        for (u = s = -1, k$[(a = e[0] >= r) << 1].forEach(d); ++u < t - 1; )
          k$[a | ((a = e[u + 1] >= r) << 1)].forEach(d);
        for (k$[a << 0].forEach(d); ++s < n - 1; ) {
          for (u = -1, k$[((a = e[s * t + t] >= r) << 1) | ((c = e[s * t] >= r) << 2)].forEach(d); ++u < t - 1; )
            (l = c),
              k$[a | ((a = e[s * t + t + u + 1] >= r) << 1) | ((c = e[s * t + u + 1] >= r) << 2) | (l << 3)].forEach(d);
          k$[a | (c << 3)].forEach(d);
        }
        for (u = -1, k$[(c = e[s * t] >= r) << 2].forEach(d); ++u < t - 1; )
          (l = c), k$[((c = e[s * t + u + 1] >= r) << 2) | (l << 3)].forEach(d);
        function d(t) {
          var n,
            e,
            r = [t[0][0] + u, t[0][1] + s],
            a = [t[1][0] + u, t[1][1] + s],
            c = o(r),
            l = o(a);
          (n = h[c])
            ? (e = f[l])
              ? (delete h[n.end],
                delete f[e.start],
                n === e
                  ? (n.ring.push(a), i(n.ring))
                  : (f[n.start] = h[e.end] = { start: n.start, end: e.end, ring: n.ring.concat(e.ring) }))
              : (delete h[n.end], n.ring.push(a), (h[(n.end = l)] = n))
            : (n = f[l])
            ? (e = h[c])
              ? (delete f[n.start],
                delete h[e.end],
                n === e
                  ? (n.ring.push(a), i(n.ring))
                  : (f[e.start] = h[n.end] = { start: e.start, end: n.end, ring: e.ring.concat(n.ring) }))
              : (delete f[n.start], n.ring.unshift(r), (f[(n.start = c)] = n))
            : (f[c] = h[l] = { start: c, end: l, ring: [r, a] });
        }
        k$[c << 3].forEach(d);
      })(r, i, t => {
        e(t, r, i),
          (function (t) {
            for (var n = 0, e = t.length, r = t[e - 1][1] * t[0][0] - t[e - 1][0] * t[0][1]; ++n < e; )
              r += t[n - 1][1] * t[n][0] - t[n - 1][0] * t[n][1];
            return r;
          })(t) > 0
            ? u.push([t])
            : s.push(t);
      }),
      s.forEach(t => {
        for (var n, e = 0, r = u.length; e < r; ++e) if (-1 !== $$((n = u[e])[0], t)) return void n.push(t);
      }),
      { type: 'MultiPolygon', value: i, coordinates: u }
    );
  }
  function o(n) {
    return 2 * n[0] + n[1] * (t + 1) * 4;
  }
  function u(e, r, i) {
    e.forEach(e => {
      var o,
        u = e[0],
        s = e[1],
        a = 0 | u,
        c = 0 | s,
        l = r[c * t + a];
      u > 0 && u < t && a === u && (e[0] = u + (i - (o = r[c * t + a - 1])) / (l - o) - 0.5),
        s > 0 && s < n && c === s && (e[1] = s + (i - (o = r[(c - 1) * t + a])) / (l - o) - 0.5);
    });
  }
  return (
    (r.contour = i),
    (r.size = function (e) {
      if (!arguments.length) return [t, n];
      var i = Math.floor(e[0]),
        o = Math.floor(e[1]);
      return (i >= 0 && o >= 0) || I('invalid size'), (t = i), (n = o), r;
    }),
    (r.smooth = function (t) {
      return arguments.length ? ((e = t ? u : O$), r) : e === u;
    }),
    r
  );
}
function $$(t, n) {
  for (var e, r = -1, i = n.length; ++r < i; ) if ((e = M$(t, n[r]))) return e;
  return 0;
}
function M$(t, n) {
  for (var e = n[0], r = n[1], i = -1, o = 0, u = t.length, s = u - 1; o < u; s = o++) {
    var a = t[o],
      c = a[0],
      l = a[1],
      f = t[s],
      h = f[0],
      d = f[1];
    if (j$(a, f, n)) return 0;
    l > r != d > r && e < ((h - c) * (r - l)) / (d - l) + c && (i = -i);
  }
  return i;
}
function j$(t, n, e) {
  var r, i, o, u;
  return (
    (function (t, n, e) {
      return (n[0] - t[0]) * (e[1] - t[1]) == (e[0] - t[0]) * (n[1] - t[1]);
    })(t, n, e) && ((i = t[(r = +(t[0] === n[0]))]), (u = n[r]), (i <= (o = e[r]) && o <= u) || (u <= o && o <= i))
  );
}
function D$(t, n, e) {
  return function (r) {
    var i = _t(r),
      o = e ? Math.min(i[0], 0) : i[0],
      u = i[1],
      s = u - o,
      a = n ? Yn(o, u, t) : s / (t + 1);
    return re(o + a, u, a);
  };
}
function F$(t) {
  os.call(this, null, t);
}
function E$(t, n, e, r, i) {
  const o = t.x1 || 0,
    u = t.y1 || 0,
    s = n * e < 0;
  function a(t) {
    t.forEach(c);
  }
  function c(t) {
    s && t.reverse(), t.forEach(l);
  }
  function l(t) {
    (t[0] = (t[0] - o) * n + r), (t[1] = (t[1] - u) * e + i);
  }
  return function (t) {
    return t.coordinates.forEach(a), t;
  };
}
function S$(t, n, e) {
  const r = t >= 0 ? t : hs(n, e);
  return Math.round((Math.sqrt(4 * r * r + 1) - 1) / 2);
}
function C$(t) {
  return Mt(t) ? t : Ct(+t);
}
function N$() {
  var t = t => t[0],
    n = t => t[1],
    e = Y,
    r = [-1, -1],
    i = 960,
    o = 500,
    u = 2;
  function s(s, a) {
    const c = S$(r[0], s, t) >> u,
      l = S$(r[1], s, n) >> u,
      f = c ? c + 2 : 0,
      h = l ? l + 2 : 0,
      d = 2 * f + (i >> u),
      p = 2 * h + (o >> u),
      m = new Float32Array(d * p),
      v = new Float32Array(d * p);
    let g = m;
    s.forEach(r => {
      const i = f + (+t(r) >> u),
        o = h + (+n(r) >> u);
      i >= 0 && i < d && o >= 0 && o < p && (m[i + o * d] += +e(r));
    }),
      c > 0 && l > 0
        ? (B$(d, p, m, v, c),
          _$(d, p, v, m, l),
          B$(d, p, m, v, c),
          _$(d, p, v, m, l),
          B$(d, p, m, v, c),
          _$(d, p, v, m, l))
        : c > 0
        ? (B$(d, p, m, v, c), B$(d, p, v, m, c), B$(d, p, m, v, c), (g = v))
        : l > 0 && (_$(d, p, m, v, l), _$(d, p, v, m, l), _$(d, p, m, v, l), (g = v));
    const b = a ? Math.pow(2, -2 * u) : 1 / ie(g);
    for (let t = 0, n = d * p; t < n; ++t) g[t] *= b;
    return { values: g, scale: 1 << u, width: d, height: p, x1: f, y1: h, x2: f + (i >> u), y2: h + (o >> u) };
  }
  return (
    (s.x = function (n) {
      return arguments.length ? ((t = C$(n)), s) : t;
    }),
    (s.y = function (t) {
      return arguments.length ? ((n = C$(t)), s) : n;
    }),
    (s.weight = function (t) {
      return arguments.length ? ((e = C$(t)), s) : e;
    }),
    (s.size = function (t) {
      if (!arguments.length) return [i, o];
      var n = +t[0],
        e = +t[1];
      return (n >= 0 && e >= 0) || I('invalid size'), (i = n), (o = e), s;
    }),
    (s.cellSize = function (t) {
      return arguments.length
        ? ((t = +t) >= 1 || I('invalid cell size'), (u = Math.floor(Math.log(t) / Math.LN2)), s)
        : 1 << u;
    }),
    (s.bandwidth = function (t) {
      return arguments.length
        ? (1 === (t = At(t)).length && (t = [+t[0], +t[0]]), 2 !== t.length && I('invalid bandwidth'), (r = t), s)
        : r;
    }),
    s
  );
}
function B$(t, n, e, r, i) {
  const o = 1 + (i << 1);
  for (let u = 0; u < n; ++u)
    for (let n = 0, s = 0; n < t + i; ++n)
      n < t && (s += e[n + u * t]),
        n >= i && (n >= o && (s -= e[n - o + u * t]), (r[n - i + u * t] = s / Math.min(n + 1, t - 1 + o - n, o)));
}
function _$(t, n, e, r, i) {
  const o = 1 + (i << 1);
  for (let u = 0; u < t; ++u)
    for (let s = 0, a = 0; s < n + i; ++s)
      s < n && (a += e[u + s * t]),
        s >= i && (s >= o && (a -= e[u + (s - o) * t]), (r[u + (s - i) * t] = a / Math.min(s + 1, n - 1 + o - s, o)));
}
function z$(t) {
  os.call(this, null, t);
}
(F$.Definition = {
  type: 'Isocontour',
  metadata: { generates: !0 },
  params: [
    { name: 'field', type: 'field' },
    { name: 'thresholds', type: 'number', array: !0 },
    { name: 'levels', type: 'number' },
    { name: 'nice', type: 'boolean', default: !1 },
    { name: 'resolve', type: 'enum', values: ['shared', 'independent'], default: 'independent' },
    { name: 'zero', type: 'boolean', default: !0 },
    { name: 'smooth', type: 'boolean', default: !0 },
    { name: 'scale', type: 'number', expr: !0 },
    { name: 'translate', type: 'number', array: !0, expr: !0 },
    { name: 'as', type: 'string', null: !0, default: 'contour' },
  ],
}),
  It(F$, os, {
    transform(t, n) {
      if (this.value && !n.changed() && !t.modified()) return n.StopPropagation;
      var e = n.fork(n.NO_SOURCE | n.NO_FIELDS),
        r = n.materialize(n.SOURCE).source,
        i = t.field || G,
        o = A$().smooth(!1 !== t.smooth),
        u =
          t.thresholds ||
          (function (t, n, e) {
            const r = D$(e.levels || 10, e.nice, !1 !== e.zero);
            return 'shared' !== e.resolve ? r : r(t.map(t => Xn(n(t).values)));
          })(r, i, t),
        s = null === t.as ? null : t.as || 'contour',
        a = [];
      return (
        r.forEach(n => {
          const e = i(n),
            r = o.size([e.width, e.height])(e.values, K(u) ? u : u(e.values));
          !(function (t, n, e, r) {
            let i = r.scale || n.scale,
              o = r.translate || n.translate;
            if ((Mt(i) && (i = i(e, r)), Mt(o) && (o = o(e, r)), (1 === i || null == i) && !o)) return;
            const u = (Vt(i) ? i : i[0]) || 1,
              s = (Vt(i) ? i : i[1]) || 1;
            t.forEach(E$(n, u, s, (o && o[0]) || 0, (o && o[1]) || 0));
          })(r, e, n, t),
            r.forEach(t => {
              a.push(Su(n, Fu(null != s ? { [s]: t } : t)));
            });
        }),
        this.value && (e.rem = this.value),
        (this.value = e.source = e.add = a),
        e
      );
    },
  }),
  (z$.Definition = {
    type: 'KDE2D',
    metadata: { generates: !0 },
    params: [
      { name: 'size', type: 'number', array: !0, length: 2, required: !0 },
      { name: 'x', type: 'field', required: !0 },
      { name: 'y', type: 'field', required: !0 },
      { name: 'weight', type: 'field' },
      { name: 'groupby', type: 'field', array: !0 },
      { name: 'cellSize', type: 'number' },
      { name: 'bandwidth', type: 'number', array: !0, length: 2 },
      { name: 'counts', type: 'boolean', default: !1 },
      { name: 'as', type: 'string', default: 'grid' },
    ],
  });
const T$ = ['x', 'y', 'weight', 'size', 'cellSize', 'bandwidth'];
function P$(t, n) {
  return T$.forEach(e => (null != n[e] ? t[e](n[e]) : 0)), t;
}
function R$(t) {
  os.call(this, null, t);
}
It(z$, os, {
  transform(t, n) {
    if (this.value && !n.changed() && !t.modified()) return n.StopPropagation;
    var e,
      r = n.fork(n.NO_SOURCE | n.NO_FIELDS),
      i = (function (t, n) {
        var e,
          r,
          i,
          o,
          u,
          s,
          a = [],
          c = t => t(o);
        if (null == n) a.push(t);
        else
          for (e = {}, r = 0, i = t.length; r < i; ++r)
            (o = t[r]), (s = e[(u = n.map(c))]) || ((e[u] = s = []), (s.dims = u), a.push(s)), s.push(o);
        return a;
      })(n.materialize(n.SOURCE).source, t.groupby),
      o = (t.groupby || []).map(T),
      u = P$(N$(), t),
      s = t.as || 'grid';
    return (
      (e = i.map(n =>
        Fu(
          (function (t, n) {
            for (let e = 0; e < o.length; ++e) t[o[e]] = n[e];
            return t;
          })({ [s]: u(n, t.counts) }, n.dims),
        ),
      )),
      this.value && (r.rem = this.value),
      (this.value = r.source = r.add = e),
      r
    );
  },
}),
  (R$.Definition = {
    type: 'Contour',
    metadata: { generates: !0 },
    params: [
      { name: 'size', type: 'number', array: !0, length: 2, required: !0 },
      { name: 'values', type: 'number', array: !0 },
      { name: 'x', type: 'field' },
      { name: 'y', type: 'field' },
      { name: 'weight', type: 'field' },
      { name: 'cellSize', type: 'number' },
      { name: 'bandwidth', type: 'number' },
      { name: 'count', type: 'number' },
      { name: 'nice', type: 'boolean', default: !1 },
      { name: 'thresholds', type: 'number', array: !0 },
      { name: 'smooth', type: 'boolean', default: !0 },
    ],
  }),
  It(R$, os, {
    transform(t, n) {
      if (this.value && !n.changed() && !t.modified()) return n.StopPropagation;
      var e,
        r,
        i = n.fork(n.NO_SOURCE | n.NO_FIELDS),
        o = A$().smooth(!1 !== t.smooth),
        u = t.values,
        s = t.thresholds || D$(t.count || 10, t.nice, !!u),
        a = t.size;
      return (
        u ||
          ((u = n.materialize(n.SOURCE).source),
          (r = E$((e = P$(N$(), t)(u, !0)), e.scale || 1, e.scale || 1, 0, 0)),
          (a = [e.width, e.height]),
          (u = e.values)),
        (s = K(s) ? s : s(u)),
        (u = o.size(a)(u, s)),
        r && u.forEach(r),
        this.value && (i.rem = this.value),
        (this.value = i.source = i.add = (u || []).map(Fu)),
        i
      );
    },
  });
const L$ = 'Feature',
  q$ = 'FeatureCollection';
function I$(t) {
  os.call(this, null, t);
}
function U$(t) {
  os.call(this, null, t);
}
function W$(t) {
  os.call(this, null, t);
}
function H$(t) {
  os.call(this, null, t);
}
function G$(t) {
  os.call(this, [], t),
    (this.generator = (function () {
      var t,
        n,
        e,
        r,
        i,
        o,
        u,
        s,
        a,
        c,
        l,
        f,
        h = 10,
        d = h,
        p = 90,
        m = 360,
        v = 2.5;
      function g() {
        return { type: 'MultiLineString', coordinates: b() };
      }
      function b() {
        return re(yx(r / p) * p, e, p)
          .map(l)
          .concat(re(yx(s / m) * m, u, m).map(f))
          .concat(
            re(yx(n / h) * h, t, h)
              .filter(function (t) {
                return mx(t % p) > sx;
              })
              .map(a),
          )
          .concat(
            re(yx(o / d) * d, i, d)
              .filter(function (t) {
                return mx(t % m) > sx;
              })
              .map(c),
          );
      }
      return (
        (g.lines = function () {
          return b().map(function (t) {
            return { type: 'LineString', coordinates: t };
          });
        }),
        (g.outline = function () {
          return {
            type: 'Polygon',
            coordinates: [l(r).concat(f(u).slice(1), l(e).reverse().slice(1), f(s).reverse().slice(1))],
          };
        }),
        (g.extent = function (t) {
          return arguments.length ? g.extentMajor(t).extentMinor(t) : g.extentMinor();
        }),
        (g.extentMajor = function (t) {
          return arguments.length
            ? ((s = +t[0][1]),
              (u = +t[1][1]),
              (r = +t[0][0]) > (e = +t[1][0]) && ((t = r), (r = e), (e = t)),
              s > u && ((t = s), (s = u), (u = t)),
              g.precision(v))
            : [
                [r, s],
                [e, u],
              ];
        }),
        (g.extentMinor = function (e) {
          return arguments.length
            ? ((o = +e[0][1]),
              (i = +e[1][1]),
              (n = +e[0][0]) > (t = +e[1][0]) && ((e = n), (n = t), (t = e)),
              o > i && ((e = o), (o = i), (i = e)),
              g.precision(v))
            : [
                [n, o],
                [t, i],
              ];
        }),
        (g.step = function (t) {
          return arguments.length ? g.stepMajor(t).stepMinor(t) : g.stepMinor();
        }),
        (g.stepMajor = function (t) {
          return arguments.length ? ((p = +t[0]), (m = +t[1]), g) : [p, m];
        }),
        (g.stepMinor = function (t) {
          return arguments.length ? ((h = +t[0]), (d = +t[1]), g) : [h, d];
        }),
        (g.precision = function (h) {
          return arguments.length
            ? ((v = +h), (a = bk(o, i, 90)), (c = yk(n, t, v)), (l = bk(s, u, 90)), (f = yk(r, e, v)), g)
            : v;
        }),
        g
          .extentMajor([
            [-180, -89.999999],
            [180, 89.999999],
          ])
          .extentMinor([
            [-180, -80.000001],
            [180, 80.000001],
          ])
      );
    })());
}
function V$(t) {
  os.call(this, null, t);
}
function Y$(t) {
  if (!Mt(t)) return !1;
  const n = cn(P(t));
  return n.$x || n.$y || n.$value || n.$max;
}
function X$(t) {
  os.call(this, null, t), this.modified(!0);
}
function J$(t, n, e) {
  Mt(t[n]) && t[n](e);
}
(I$.Definition = {
  type: 'GeoJSON',
  metadata: {},
  params: [
    { name: 'fields', type: 'field', array: !0, length: 2 },
    { name: 'geojson', type: 'field' },
  ],
}),
  It(I$, os, {
    transform(t, n) {
      var e,
        r = this._features,
        i = this._points,
        o = t.fields,
        u = o && o[0],
        s = o && o[1],
        a = t.geojson || (!o && G),
        c = n.ADD;
      (e = t.modified() || n.changed(n.REM) || n.modified(P(a)) || (u && n.modified(P(u))) || (s && n.modified(P(s)))),
        (this.value && !e) || ((c = n.SOURCE), (this._features = r = []), (this._points = i = [])),
        a && n.visit(c, t => r.push(a(t))),
        u &&
          s &&
          (n.visit(c, t => {
            var n = u(t),
              e = s(t);
            null != n && null != e && (n = +n) === n && (e = +e) === e && i.push([n, e]);
          }),
          (r = r.concat({ type: L$, geometry: { type: 'MultiPoint', coordinates: i } }))),
        (this.value = { type: q$, features: r });
    },
  }),
  (U$.Definition = {
    type: 'GeoPath',
    metadata: { modifies: !0 },
    params: [
      { name: 'projection', type: 'projection' },
      { name: 'field', type: 'field' },
      { name: 'pointRadius', type: 'number', expr: !0 },
      { name: 'as', type: 'string', default: 'path' },
    ],
  }),
  It(U$, os, {
    transform(t, n) {
      var e = n.fork(n.ALL),
        r = this.value,
        i = t.field || G,
        o = t.as || 'path',
        u = e.SOURCE;
      !r || t.modified()
        ? ((this.value = r = w$(t.projection)), e.materialize().reflow())
        : (u = i === G || n.modified(i.fields) ? e.ADD_MOD : e.ADD);
      const s = (function (t, n) {
        const e = t.pointRadius();
        return t.context(null), null != n && t.pointRadius(n), e;
      })(r, t.pointRadius);
      return e.visit(u, t => (t[o] = r(i(t)))), r.pointRadius(s), e.modifies(o);
    },
  }),
  (W$.Definition = {
    type: 'GeoPoint',
    metadata: { modifies: !0 },
    params: [
      { name: 'projection', type: 'projection', required: !0 },
      { name: 'fields', type: 'field', array: !0, required: !0, length: 2 },
      { name: 'as', type: 'string', array: !0, length: 2, default: ['x', 'y'] },
    ],
  }),
  It(W$, os, {
    transform(t, n) {
      var e,
        r = t.projection,
        i = t.fields[0],
        o = t.fields[1],
        u = t.as || ['x', 'y'],
        s = u[0],
        a = u[1];
      function c(t) {
        const n = r([i(t), o(t)]);
        n ? ((t[s] = n[0]), (t[a] = n[1])) : ((t[s] = void 0), (t[a] = void 0));
      }
      return (
        t.modified()
          ? (n = n.materialize().reflow(!0).visit(n.SOURCE, c))
          : ((e = n.modified(i.fields) || n.modified(o.fields)), n.visit(e ? n.ADD_MOD : n.ADD, c)),
        n.modifies(u)
      );
    },
  }),
  (H$.Definition = {
    type: 'GeoShape',
    metadata: { modifies: !0, nomod: !0 },
    params: [
      { name: 'projection', type: 'projection' },
      { name: 'field', type: 'field', default: 'datum' },
      { name: 'pointRadius', type: 'number', expr: !0 },
      { name: 'as', type: 'string', default: 'shape' },
    ],
  }),
  It(H$, os, {
    transform(t, n) {
      var e = n.fork(n.ALL),
        r = this.value,
        i = t.as || 'shape',
        o = e.ADD;
      return (
        (r && !t.modified()) ||
          ((this.value = r =
            (function (t, n, e) {
              const r =
                null == e
                  ? e => t(n(e))
                  : r => {
                      var i = t.pointRadius(),
                        o = t.pointRadius(e)(n(r));
                      return t.pointRadius(i), o;
                    };
              return (r.context = n => (t.context(n), r)), r;
            })(w$(t.projection), t.field || W('datum'), t.pointRadius)),
          e.materialize().reflow(),
          (o = e.SOURCE)),
        e.visit(o, t => (t[i] = r)),
        e.modifies(i)
      );
    },
  }),
  (G$.Definition = {
    type: 'Graticule',
    metadata: { changes: !0, generates: !0 },
    params: [
      { name: 'extent', type: 'array', array: !0, length: 2, content: { type: 'number', array: !0, length: 2 } },
      { name: 'extentMajor', type: 'array', array: !0, length: 2, content: { type: 'number', array: !0, length: 2 } },
      { name: 'extentMinor', type: 'array', array: !0, length: 2, content: { type: 'number', array: !0, length: 2 } },
      { name: 'step', type: 'number', array: !0, length: 2 },
      { name: 'stepMajor', type: 'number', array: !0, length: 2, default: [90, 360] },
      { name: 'stepMinor', type: 'number', array: !0, length: 2, default: [10, 10] },
      { name: 'precision', type: 'number', default: 2.5 },
    ],
  }),
  It(G$, os, {
    transform(t, n) {
      var e,
        r = this.value,
        i = this.generator;
      if (!r.length || t.modified()) for (const n in t) Mt(i[n]) && i[n](t[n]);
      return (e = i()), r.length ? n.mod.push(Cu(r[0], e)) : n.add.push(Fu(e)), (r[0] = e), n;
    },
  }),
  (V$.Definition = {
    type: 'heatmap',
    metadata: { modifies: !0 },
    params: [
      { name: 'field', type: 'field' },
      { name: 'color', type: 'string', expr: !0 },
      { name: 'opacity', type: 'number', expr: !0 },
      { name: 'resolve', type: 'enum', values: ['shared', 'independent'], default: 'independent' },
      { name: 'as', type: 'string', default: 'image' },
    ],
  }),
  It(V$, os, {
    transform(t, n) {
      if (!n.changed() && !t.modified()) return n.StopPropagation;
      var e = n.materialize(n.SOURCE).source,
        r = 'shared' === t.resolve,
        i = t.field || G,
        o = (function (t, n) {
          let e;
          return (
            Mt(t)
              ? ((e = e => t(e, n)), (e.dep = Y$(t)))
              : t
              ? (e = Ct(t))
              : ((e = t => t.$value / t.$max || 0), (e.dep = !0)),
            e
          );
        })(t.opacity, t),
        u = (function (t, n) {
          let e;
          return Mt(t) ? ((e = e => vf(t(e, n))), (e.dep = Y$(t))) : (e = Ct(vf(t || '#888'))), e;
        })(t.color, t),
        s = t.as || 'image',
        a = { $x: 0, $y: 0, $value: 0, $max: r ? Xn(e.map(t => Xn(i(t).values))) : 0 };
      return (
        e.forEach(t => {
          const n = i(t),
            e = Bt({}, t, a);
          r || (e.$max = Xn(n.values || [])),
            (t[s] = (function (t, n, e, r) {
              const i = t.width,
                o = t.x1 || 0,
                u = t.y1 || 0,
                s = t.x2 || i,
                a = t.y2 || t.height,
                c = t.values,
                l = c ? t => c[t] : V,
                f = ql(s - o, a - u),
                h = f.getContext('2d'),
                d = h.getImageData(0, 0, s - o, a - u),
                p = d.data;
              for (let t = u, c = 0; t < a; ++t) {
                n.$y = t - u;
                for (let u = o, a = t * i; u < s; ++u, c += 4) {
                  (n.$x = u - o), (n.$value = l(u + a));
                  const t = e(n);
                  (p[c + 0] = t.r), (p[c + 1] = t.g), (p[c + 2] = t.b), (p[c + 3] = ~~(255 * r(n)));
                }
              }
              return h.putImageData(d, 0, 0), f;
            })(n, e, u.dep ? u : Ct(u(e)), o.dep ? o : Ct(o(e))));
        }),
        n.reflow(!0).modifies(s)
      );
    },
  }),
  It(X$, os, {
    transform(t, n) {
      let e = this.value;
      return (
        !e || t.modified('type')
          ? ((this.value = e =
              (function (t) {
                const n = y$((t || 'mercator').toLowerCase());
                return n || I('Unrecognized projection type: ' + t), n();
              })(t.type)),
            g$.forEach(n => {
              null != t[n] && J$(e, n, t[n]);
            }))
          : g$.forEach(n => {
              t.modified(n) && J$(e, n, t[n]);
            }),
        null != t.pointRadius && e.path.pointRadius(t.pointRadius),
        t.fit &&
          (function (t, n) {
            const e = (function (t) {
              return 1 === (t = At(t)).length
                ? t[0]
                : {
                    type: q$,
                    features: t.reduce(
                      (t, n) =>
                        t.concat(
                          (function (t) {
                            return t.type === q$
                              ? t.features
                              : At(t)
                                  .filter(t => null != t)
                                  .map(t => (t.type === L$ ? t : { type: L$, geometry: t }));
                          })(n),
                        ),
                      [],
                    ),
                  };
            })(n.fit);
            n.extent ? t.fitExtent(n.extent, e) : n.size && t.fitSize(n.size, e);
          })(e, t),
        n.fork(n.NO_SOURCE | n.NO_FIELDS)
      );
    },
  });
const Q$ = Object.freeze({
  __proto__: null,
  contour: R$,
  geojson: I$,
  geopath: U$,
  geopoint: W$,
  geoshape: H$,
  graticule: G$,
  heatmap: V$,
  isocontour: F$,
  kde2d: z$,
  projection: X$,
});
function Z$(t, n, e, r) {
  if (isNaN(n) || isNaN(e)) return t;
  var i,
    o,
    u,
    s,
    a,
    c,
    l,
    f,
    h,
    d = t._root,
    p = { data: r },
    m = t._x0,
    v = t._y0,
    g = t._x1,
    b = t._y1;
  if (!d) return (t._root = p), t;
  for (; d.length; )
    if (
      ((c = n >= (o = (m + g) / 2)) ? (m = o) : (g = o),
      (l = e >= (u = (v + b) / 2)) ? (v = u) : (b = u),
      (i = d),
      !(d = d[(f = (l << 1) | c)]))
    )
      return (i[f] = p), t;
  if (((s = +t._x.call(null, d.data)), (a = +t._y.call(null, d.data)), n === s && e === a))
    return (p.next = d), i ? (i[f] = p) : (t._root = p), t;
  do {
    (i = i ? (i[f] = new Array(4)) : (t._root = new Array(4))),
      (c = n >= (o = (m + g) / 2)) ? (m = o) : (g = o),
      (l = e >= (u = (v + b) / 2)) ? (v = u) : (b = u);
  } while ((f = (l << 1) | c) == (h = ((a >= u) << 1) | (s >= o)));
  return (i[h] = d), (i[f] = p), t;
}
function K$(t, n, e, r, i) {
  (this.node = t), (this.x0 = n), (this.y0 = e), (this.x1 = r), (this.y1 = i);
}
function tM(t) {
  return t[0];
}
function nM(t) {
  return t[1];
}
function eM(t, n, e) {
  var r = new rM(null == n ? tM : n, null == e ? nM : e, NaN, NaN, NaN, NaN);
  return null == t ? r : r.addAll(t);
}
function rM(t, n, e, r, i, o) {
  (this._x = t), (this._y = n), (this._x0 = e), (this._y0 = r), (this._x1 = i), (this._y1 = o), (this._root = void 0);
}
function iM(t) {
  for (var n = { data: t.data }, e = n; (t = t.next); ) e = e.next = { data: t.data };
  return n;
}
var oM = (eM.prototype = rM.prototype);
function uM(t) {
  return function () {
    return t;
  };
}
function sM(t) {
  return 1e-6 * (t() - 0.5);
}
function aM(t) {
  return t.x + t.vx;
}
function cM(t) {
  return t.y + t.vy;
}
function lM(t) {
  return t.index;
}
function fM(t, n) {
  var e = t.get(n);
  if (!e) throw new Error('node not found: ' + n);
  return e;
}
(oM.copy = function () {
  var t,
    n,
    e = new rM(this._x, this._y, this._x0, this._y0, this._x1, this._y1),
    r = this._root;
  if (!r) return e;
  if (!r.length) return (e._root = iM(r)), e;
  for (t = [{ source: r, target: (e._root = new Array(4)) }]; (r = t.pop()); )
    for (var i = 0; i < 4; ++i)
      (n = r.source[i]) &&
        (n.length ? t.push({ source: n, target: (r.target[i] = new Array(4)) }) : (r.target[i] = iM(n)));
  return e;
}),
  (oM.add = function (t) {
    const n = +this._x.call(null, t),
      e = +this._y.call(null, t);
    return Z$(this.cover(n, e), n, e, t);
  }),
  (oM.addAll = function (t) {
    var n,
      e,
      r,
      i,
      o = t.length,
      u = new Array(o),
      s = new Array(o),
      a = 1 / 0,
      c = 1 / 0,
      l = -1 / 0,
      f = -1 / 0;
    for (e = 0; e < o; ++e)
      isNaN((r = +this._x.call(null, (n = t[e])))) ||
        isNaN((i = +this._y.call(null, n))) ||
        ((u[e] = r), (s[e] = i), r < a && (a = r), r > l && (l = r), i < c && (c = i), i > f && (f = i));
    if (a > l || c > f) return this;
    for (this.cover(a, c).cover(l, f), e = 0; e < o; ++e) Z$(this, u[e], s[e], t[e]);
    return this;
  }),
  (oM.cover = function (t, n) {
    if (isNaN((t = +t)) || isNaN((n = +n))) return this;
    var e = this._x0,
      r = this._y0,
      i = this._x1,
      o = this._y1;
    if (isNaN(e)) (i = (e = Math.floor(t)) + 1), (o = (r = Math.floor(n)) + 1);
    else {
      for (var u, s, a = i - e || 1, c = this._root; e > t || t >= i || r > n || n >= o; )
        switch (((s = ((n < r) << 1) | (t < e)), ((u = new Array(4))[s] = c), (c = u), (a *= 2), s)) {
          case 0:
            (i = e + a), (o = r + a);
            break;
          case 1:
            (e = i - a), (o = r + a);
            break;
          case 2:
            (i = e + a), (r = o - a);
            break;
          case 3:
            (e = i - a), (r = o - a);
        }
      this._root && this._root.length && (this._root = c);
    }
    return (this._x0 = e), (this._y0 = r), (this._x1 = i), (this._y1 = o), this;
  }),
  (oM.data = function () {
    var t = [];
    return (
      this.visit(function (n) {
        if (!n.length)
          do {
            t.push(n.data);
          } while ((n = n.next));
      }),
      t
    );
  }),
  (oM.extent = function (t) {
    return arguments.length
      ? this.cover(+t[0][0], +t[0][1]).cover(+t[1][0], +t[1][1])
      : isNaN(this._x0)
      ? void 0
      : [
          [this._x0, this._y0],
          [this._x1, this._y1],
        ];
  }),
  (oM.find = function (t, n, e) {
    var r,
      i,
      o,
      u,
      s,
      a,
      c,
      l = this._x0,
      f = this._y0,
      h = this._x1,
      d = this._y1,
      p = [],
      m = this._root;
    for (
      m && p.push(new K$(m, l, f, h, d)),
        null == e ? (e = 1 / 0) : ((l = t - e), (f = n - e), (h = t + e), (d = n + e), (e *= e));
      (a = p.pop());

    )
      if (!(!(m = a.node) || (i = a.x0) > h || (o = a.y0) > d || (u = a.x1) < l || (s = a.y1) < f))
        if (m.length) {
          var v = (i + u) / 2,
            g = (o + s) / 2;
          p.push(
            new K$(m[3], v, g, u, s),
            new K$(m[2], i, g, v, s),
            new K$(m[1], v, o, u, g),
            new K$(m[0], i, o, v, g),
          ),
            (c = ((n >= g) << 1) | (t >= v)) &&
              ((a = p[p.length - 1]), (p[p.length - 1] = p[p.length - 1 - c]), (p[p.length - 1 - c] = a));
        } else {
          var b = t - +this._x.call(null, m.data),
            y = n - +this._y.call(null, m.data),
            w = b * b + y * y;
          if (w < e) {
            var x = Math.sqrt((e = w));
            (l = t - x), (f = n - x), (h = t + x), (d = n + x), (r = m.data);
          }
        }
    return r;
  }),
  (oM.remove = function (t) {
    if (isNaN((o = +this._x.call(null, t))) || isNaN((u = +this._y.call(null, t)))) return this;
    var n,
      e,
      r,
      i,
      o,
      u,
      s,
      a,
      c,
      l,
      f,
      h,
      d = this._root,
      p = this._x0,
      m = this._y0,
      v = this._x1,
      g = this._y1;
    if (!d) return this;
    if (d.length)
      for (;;) {
        if (
          ((c = o >= (s = (p + v) / 2)) ? (p = s) : (v = s),
          (l = u >= (a = (m + g) / 2)) ? (m = a) : (g = a),
          (n = d),
          !(d = d[(f = (l << 1) | c)]))
        )
          return this;
        if (!d.length) break;
        (n[(f + 1) & 3] || n[(f + 2) & 3] || n[(f + 3) & 3]) && ((e = n), (h = f));
      }
    for (; d.data !== t; ) if (((r = d), !(d = d.next))) return this;
    return (
      (i = d.next) && delete d.next,
      r
        ? (i ? (r.next = i) : delete r.next, this)
        : n
        ? (i ? (n[f] = i) : delete n[f],
          (d = n[0] || n[1] || n[2] || n[3]) &&
            d === (n[3] || n[2] || n[1] || n[0]) &&
            !d.length &&
            (e ? (e[h] = d) : (this._root = d)),
          this)
        : ((this._root = i), this)
    );
  }),
  (oM.removeAll = function (t) {
    for (var n = 0, e = t.length; n < e; ++n) this.remove(t[n]);
    return this;
  }),
  (oM.root = function () {
    return this._root;
  }),
  (oM.size = function () {
    var t = 0;
    return (
      this.visit(function (n) {
        if (!n.length)
          do {
            ++t;
          } while ((n = n.next));
      }),
      t
    );
  }),
  (oM.visit = function (t) {
    var n,
      e,
      r,
      i,
      o,
      u,
      s = [],
      a = this._root;
    for (a && s.push(new K$(a, this._x0, this._y0, this._x1, this._y1)); (n = s.pop()); )
      if (!t((a = n.node), (r = n.x0), (i = n.y0), (o = n.x1), (u = n.y1)) && a.length) {
        var c = (r + o) / 2,
          l = (i + u) / 2;
        (e = a[3]) && s.push(new K$(e, c, l, o, u)),
          (e = a[2]) && s.push(new K$(e, r, l, c, u)),
          (e = a[1]) && s.push(new K$(e, c, i, o, l)),
          (e = a[0]) && s.push(new K$(e, r, i, c, l));
      }
    return this;
  }),
  (oM.visitAfter = function (t) {
    var n,
      e = [],
      r = [];
    for (this._root && e.push(new K$(this._root, this._x0, this._y0, this._x1, this._y1)); (n = e.pop()); ) {
      var i = n.node;
      if (i.length) {
        var o,
          u = n.x0,
          s = n.y0,
          a = n.x1,
          c = n.y1,
          l = (u + a) / 2,
          f = (s + c) / 2;
        (o = i[0]) && e.push(new K$(o, u, s, l, f)),
          (o = i[1]) && e.push(new K$(o, l, s, a, f)),
          (o = i[2]) && e.push(new K$(o, u, f, l, c)),
          (o = i[3]) && e.push(new K$(o, l, f, a, c));
      }
      r.push(n);
    }
    for (; (n = r.pop()); ) t(n.node, n.x0, n.y0, n.x1, n.y1);
    return this;
  }),
  (oM.x = function (t) {
    return arguments.length ? ((this._x = t), this) : this._x;
  }),
  (oM.y = function (t) {
    return arguments.length ? ((this._y = t), this) : this._y;
  });
var hM = { value: () => {} };
function dM() {
  for (var t, n = 0, e = arguments.length, r = {}; n < e; ++n) {
    if (!(t = arguments[n] + '') || t in r || /[\s.]/.test(t)) throw new Error('illegal type: ' + t);
    r[t] = [];
  }
  return new pM(r);
}
function pM(t) {
  this._ = t;
}
function mM(t, n) {
  return t
    .trim()
    .split(/^|\s+/)
    .map(function (t) {
      var e = '',
        r = t.indexOf('.');
      if ((r >= 0 && ((e = t.slice(r + 1)), (t = t.slice(0, r))), t && !n.hasOwnProperty(t)))
        throw new Error('unknown type: ' + t);
      return { type: t, name: e };
    });
}
function vM(t, n) {
  for (var e, r = 0, i = t.length; r < i; ++r) if ((e = t[r]).name === n) return e.value;
}
function gM(t, n, e) {
  for (var r = 0, i = t.length; r < i; ++r)
    if (t[r].name === n) {
      (t[r] = hM), (t = t.slice(0, r).concat(t.slice(r + 1)));
      break;
    }
  return null != e && t.push({ name: n, value: e }), t;
}
pM.prototype = dM.prototype = {
  constructor: pM,
  on: function (t, n) {
    var e,
      r = this._,
      i = mM(t + '', r),
      o = -1,
      u = i.length;
    if (!(arguments.length < 2)) {
      if (null != n && 'function' != typeof n) throw new Error('invalid callback: ' + n);
      for (; ++o < u; )
        if ((e = (t = i[o]).type)) r[e] = gM(r[e], t.name, n);
        else if (null == n) for (e in r) r[e] = gM(r[e], t.name, null);
      return this;
    }
    for (; ++o < u; ) if ((e = (t = i[o]).type) && (e = vM(r[e], t.name))) return e;
  },
  copy: function () {
    var t = {},
      n = this._;
    for (var e in n) t[e] = n[e].slice();
    return new pM(t);
  },
  call: function (t, n) {
    if ((e = arguments.length - 2) > 0) for (var e, r, i = new Array(e), o = 0; o < e; ++o) i[o] = arguments[o + 2];
    if (!this._.hasOwnProperty(t)) throw new Error('unknown type: ' + t);
    for (o = 0, e = (r = this._[t]).length; o < e; ++o) r[o].value.apply(n, i);
  },
  apply: function (t, n, e) {
    if (!this._.hasOwnProperty(t)) throw new Error('unknown type: ' + t);
    for (var r = this._[t], i = 0, o = r.length; i < o; ++i) r[i].value.apply(n, e);
  },
};
var bM,
  yM,
  wM = 0,
  xM = 0,
  OM = 0,
  kM = 0,
  AM = 0,
  $M = 0,
  MM = 'object' == typeof performance && performance.now ? performance : Date,
  jM =
    'object' == typeof window && window.requestAnimationFrame
      ? window.requestAnimationFrame.bind(window)
      : function (t) {
          setTimeout(t, 17);
        };
function DM() {
  return AM || (jM(FM), (AM = MM.now() + $M));
}
function FM() {
  AM = 0;
}
function EM() {
  this._call = this._time = this._next = null;
}
function SM(t, n, e) {
  var r = new EM();
  return r.restart(t, n, e), r;
}
function CM() {
  (AM = (kM = MM.now()) + $M), (wM = xM = 0);
  try {
    !(function () {
      DM(), ++wM;
      for (var t, n = bM; n; ) (t = AM - n._time) >= 0 && n._call.call(void 0, t), (n = n._next);
      --wM;
    })();
  } finally {
    (wM = 0),
      (function () {
        for (var t, n, e = bM, r = 1 / 0; e; )
          e._call
            ? (r > e._time && (r = e._time), (t = e), (e = e._next))
            : ((n = e._next), (e._next = null), (e = t ? (t._next = n) : (bM = n)));
        (yM = t), BM(r);
      })(),
      (AM = 0);
  }
}
function NM() {
  var t = MM.now(),
    n = t - kM;
  n > 1e3 && (($M -= n), (kM = t));
}
function BM(t) {
  wM ||
    (xM && (xM = clearTimeout(xM)),
    t - AM > 24
      ? (t < 1 / 0 && (xM = setTimeout(CM, t - MM.now() - $M)), OM && (OM = clearInterval(OM)))
      : (OM || ((kM = MM.now()), (OM = setInterval(NM, 1e3))), (wM = 1), jM(CM)));
}
EM.prototype = SM.prototype = {
  constructor: EM,
  restart: function (t, n, e) {
    if ('function' != typeof t) throw new TypeError('callback is not a function');
    (e = (null == e ? DM() : +e) + (null == n ? 0 : +n)),
      this._next || yM === this || (yM ? (yM._next = this) : (bM = this), (yM = this)),
      (this._call = t),
      (this._time = e),
      BM();
  },
  stop: function () {
    this._call && ((this._call = null), (this._time = 1 / 0), BM());
  },
};
const _M = 4294967296;
function zM(t) {
  return t.x;
}
function TM(t) {
  return t.y;
}
var PM = Math.PI * (3 - Math.sqrt(5));
const RM = {
    center: function (t, n) {
      var e,
        r = 1;
      function i() {
        var i,
          o,
          u = e.length,
          s = 0,
          a = 0;
        for (i = 0; i < u; ++i) (s += (o = e[i]).x), (a += o.y);
        for (s = (s / u - t) * r, a = (a / u - n) * r, i = 0; i < u; ++i) ((o = e[i]).x -= s), (o.y -= a);
      }
      return (
        null == t && (t = 0),
        null == n && (n = 0),
        (i.initialize = function (t) {
          e = t;
        }),
        (i.x = function (n) {
          return arguments.length ? ((t = +n), i) : t;
        }),
        (i.y = function (t) {
          return arguments.length ? ((n = +t), i) : n;
        }),
        (i.strength = function (t) {
          return arguments.length ? ((r = +t), i) : r;
        }),
        i
      );
    },
    collide: function (t) {
      var n,
        e,
        r,
        i = 1,
        o = 1;
      function u() {
        for (var t, u, a, c, l, f, h, d = n.length, p = 0; p < o; ++p)
          for (u = eM(n, aM, cM).visitAfter(s), t = 0; t < d; ++t)
            (h = (f = e[(a = n[t]).index]) * f), (c = a.x + a.vx), (l = a.y + a.vy), u.visit(m);
        function m(t, n, e, o, u) {
          var s = t.data,
            d = t.r,
            p = f + d;
          if (!s) return n > c + p || o < c - p || e > l + p || u < l - p;
          if (s.index > a.index) {
            var m = c - s.x - s.vx,
              v = l - s.y - s.vy,
              g = m * m + v * v;
            g < p * p &&
              (0 === m && (g += (m = sM(r)) * m),
              0 === v && (g += (v = sM(r)) * v),
              (g = ((p - (g = Math.sqrt(g))) / g) * i),
              (a.vx += (m *= g) * (p = (d *= d) / (h + d))),
              (a.vy += (v *= g) * p),
              (s.vx -= m * (p = 1 - p)),
              (s.vy -= v * p));
          }
        }
      }
      function s(t) {
        if (t.data) return (t.r = e[t.data.index]);
        for (var n = (t.r = 0); n < 4; ++n) t[n] && t[n].r > t.r && (t.r = t[n].r);
      }
      function a() {
        if (n) {
          var r,
            i,
            o = n.length;
          for (e = new Array(o), r = 0; r < o; ++r) e[(i = n[r]).index] = +t(i, r, n);
        }
      }
      return (
        'function' != typeof t && (t = uM(null == t ? 1 : +t)),
        (u.initialize = function (t, e) {
          (n = t), (r = e), a();
        }),
        (u.iterations = function (t) {
          return arguments.length ? ((o = +t), u) : o;
        }),
        (u.strength = function (t) {
          return arguments.length ? ((i = +t), u) : i;
        }),
        (u.radius = function (n) {
          return arguments.length ? ((t = 'function' == typeof n ? n : uM(+n)), a(), u) : t;
        }),
        u
      );
    },
    nbody: function () {
      var t,
        n,
        e,
        r,
        i,
        o = uM(-30),
        u = 1,
        s = 1 / 0,
        a = 0.81;
      function c(e) {
        var i,
          o = t.length,
          u = eM(t, zM, TM).visitAfter(f);
        for (r = e, i = 0; i < o; ++i) (n = t[i]), u.visit(h);
      }
      function l() {
        if (t) {
          var n,
            e,
            r = t.length;
          for (i = new Array(r), n = 0; n < r; ++n) i[(e = t[n]).index] = +o(e, n, t);
        }
      }
      function f(t) {
        var n,
          e,
          r,
          o,
          u,
          s = 0,
          a = 0;
        if (t.length) {
          for (r = o = u = 0; u < 4; ++u)
            (n = t[u]) && (e = Math.abs(n.value)) && ((s += n.value), (a += e), (r += e * n.x), (o += e * n.y));
          (t.x = r / a), (t.y = o / a);
        } else {
          ((n = t).x = n.data.x), (n.y = n.data.y);
          do {
            s += i[n.data.index];
          } while ((n = n.next));
        }
        t.value = s;
      }
      function h(t, o, c, l) {
        if (!t.value) return !0;
        var f = t.x - n.x,
          h = t.y - n.y,
          d = l - o,
          p = f * f + h * h;
        if ((d * d) / a < p)
          return (
            p < s &&
              (0 === f && (p += (f = sM(e)) * f),
              0 === h && (p += (h = sM(e)) * h),
              p < u && (p = Math.sqrt(u * p)),
              (n.vx += (f * t.value * r) / p),
              (n.vy += (h * t.value * r) / p)),
            !0
          );
        if (!(t.length || p >= s)) {
          (t.data !== n || t.next) &&
            (0 === f && (p += (f = sM(e)) * f), 0 === h && (p += (h = sM(e)) * h), p < u && (p = Math.sqrt(u * p)));
          do {
            t.data !== n && ((n.vx += f * (d = (i[t.data.index] * r) / p)), (n.vy += h * d));
          } while ((t = t.next));
        }
      }
      return (
        (c.initialize = function (n, r) {
          (t = n), (e = r), l();
        }),
        (c.strength = function (t) {
          return arguments.length ? ((o = 'function' == typeof t ? t : uM(+t)), l(), c) : o;
        }),
        (c.distanceMin = function (t) {
          return arguments.length ? ((u = t * t), c) : Math.sqrt(u);
        }),
        (c.distanceMax = function (t) {
          return arguments.length ? ((s = t * t), c) : Math.sqrt(s);
        }),
        (c.theta = function (t) {
          return arguments.length ? ((a = t * t), c) : Math.sqrt(a);
        }),
        c
      );
    },
    link: function (t) {
      var n,
        e,
        r,
        i,
        o,
        u,
        s = lM,
        a = function (t) {
          return 1 / Math.min(i[t.source.index], i[t.target.index]);
        },
        c = uM(30),
        l = 1;
      function f(r) {
        for (var i = 0, s = t.length; i < l; ++i)
          for (var a, c, f, h, d, p, m, v = 0; v < s; ++v)
            (h = (f = (a = t[v]).target).x + f.vx - (c = a.source).x - c.vx || sM(u)),
              (d = f.y + f.vy - c.y - c.vy || sM(u)),
              (d *= p = (((p = Math.sqrt(h * h + d * d)) - e[v]) / p) * r * n[v]),
              (f.vx -= (h *= p) * (m = o[v])),
              (f.vy -= d * m),
              (c.vx += h * (m = 1 - m)),
              (c.vy += d * m);
      }
      function h() {
        if (r) {
          var u,
            a,
            c = r.length,
            l = t.length,
            f = new Map(r.map((t, n) => [s(t, n, r), t]));
          for (u = 0, i = new Array(c); u < l; ++u)
            ((a = t[u]).index = u),
              'object' != typeof a.source && (a.source = fM(f, a.source)),
              'object' != typeof a.target && (a.target = fM(f, a.target)),
              (i[a.source.index] = (i[a.source.index] || 0) + 1),
              (i[a.target.index] = (i[a.target.index] || 0) + 1);
          for (u = 0, o = new Array(l); u < l; ++u)
            o[u] = i[(a = t[u]).source.index] / (i[a.source.index] + i[a.target.index]);
          (n = new Array(l)), d(), (e = new Array(l)), p();
        }
      }
      function d() {
        if (r) for (var e = 0, i = t.length; e < i; ++e) n[e] = +a(t[e], e, t);
      }
      function p() {
        if (r) for (var n = 0, i = t.length; n < i; ++n) e[n] = +c(t[n], n, t);
      }
      return (
        null == t && (t = []),
        (f.initialize = function (t, n) {
          (r = t), (u = n), h();
        }),
        (f.links = function (n) {
          return arguments.length ? ((t = n), h(), f) : t;
        }),
        (f.id = function (t) {
          return arguments.length ? ((s = t), f) : s;
        }),
        (f.iterations = function (t) {
          return arguments.length ? ((l = +t), f) : l;
        }),
        (f.strength = function (t) {
          return arguments.length ? ((a = 'function' == typeof t ? t : uM(+t)), d(), f) : a;
        }),
        (f.distance = function (t) {
          return arguments.length ? ((c = 'function' == typeof t ? t : uM(+t)), p(), f) : c;
        }),
        f
      );
    },
    x: function (t) {
      var n,
        e,
        r,
        i = uM(0.1);
      function o(t) {
        for (var i, o = 0, u = n.length; o < u; ++o) (i = n[o]).vx += (r[o] - i.x) * e[o] * t;
      }
      function u() {
        if (n) {
          var o,
            u = n.length;
          for (e = new Array(u), r = new Array(u), o = 0; o < u; ++o)
            e[o] = isNaN((r[o] = +t(n[o], o, n))) ? 0 : +i(n[o], o, n);
        }
      }
      return (
        'function' != typeof t && (t = uM(null == t ? 0 : +t)),
        (o.initialize = function (t) {
          (n = t), u();
        }),
        (o.strength = function (t) {
          return arguments.length ? ((i = 'function' == typeof t ? t : uM(+t)), u(), o) : i;
        }),
        (o.x = function (n) {
          return arguments.length ? ((t = 'function' == typeof n ? n : uM(+n)), u(), o) : t;
        }),
        o
      );
    },
    y: function (t) {
      var n,
        e,
        r,
        i = uM(0.1);
      function o(t) {
        for (var i, o = 0, u = n.length; o < u; ++o) (i = n[o]).vy += (r[o] - i.y) * e[o] * t;
      }
      function u() {
        if (n) {
          var o,
            u = n.length;
          for (e = new Array(u), r = new Array(u), o = 0; o < u; ++o)
            e[o] = isNaN((r[o] = +t(n[o], o, n))) ? 0 : +i(n[o], o, n);
        }
      }
      return (
        'function' != typeof t && (t = uM(null == t ? 0 : +t)),
        (o.initialize = function (t) {
          (n = t), u();
        }),
        (o.strength = function (t) {
          return arguments.length ? ((i = 'function' == typeof t ? t : uM(+t)), u(), o) : i;
        }),
        (o.y = function (n) {
          return arguments.length ? ((t = 'function' == typeof n ? n : uM(+n)), u(), o) : t;
        }),
        o
      );
    },
  },
  LM = 'forces',
  qM = ['alpha', 'alphaMin', 'alphaTarget', 'velocityDecay', 'forces'],
  IM = ['static', 'iterations'],
  UM = ['x', 'y', 'vx', 'vy'];
function WM(t) {
  os.call(this, null, t);
}
function HM(t, n, e, r) {
  var i,
    o,
    u,
    s,
    a = At(n.forces);
  for (i = 0, o = qM.length; i < o; ++i) (u = qM[i]) !== LM && n.modified(u) && t[u](n[u]);
  for (i = 0, o = a.length; i < o; ++i)
    (s = LM + i), (u = e || n.modified(LM, i) ? VM(a[i]) : r && GM(a[i], r) ? t.force(s) : null) && t.force(s, u);
  for (o = t.numForces || 0; i < o; ++i) t.force(LM + i, null);
  return (t.numForces = a.length), t;
}
function GM(t, n) {
  var e, r;
  for (e in t) if (Mt((r = t[e])) && n.modified(P(r))) return 1;
  return 0;
}
function VM(t) {
  var n, e;
  for (e in (Pt(RM, t.force) || I('Unrecognized force: ' + t.force), (n = RM[t.force]()), t))
    Mt(n[e]) && YM(n[e], t[e], t);
  return n;
}
function YM(t, n, e) {
  t(Mt(n) ? t => n(t, e) : n);
}
(WM.Definition = {
  type: 'Force',
  metadata: { modifies: !0 },
  params: [
    { name: 'static', type: 'boolean', default: !1 },
    { name: 'restart', type: 'boolean', default: !1 },
    { name: 'iterations', type: 'number', default: 300 },
    { name: 'alpha', type: 'number', default: 1 },
    { name: 'alphaMin', type: 'number', default: 0.001 },
    { name: 'alphaTarget', type: 'number', default: 0 },
    { name: 'velocityDecay', type: 'number', default: 0.4 },
    {
      name: 'forces',
      type: 'param',
      array: !0,
      params: [
        {
          key: { force: 'center' },
          params: [
            { name: 'x', type: 'number', default: 0 },
            { name: 'y', type: 'number', default: 0 },
          ],
        },
        {
          key: { force: 'collide' },
          params: [
            { name: 'radius', type: 'number', expr: !0 },
            { name: 'strength', type: 'number', default: 0.7 },
            { name: 'iterations', type: 'number', default: 1 },
          ],
        },
        {
          key: { force: 'nbody' },
          params: [
            { name: 'strength', type: 'number', default: -30 },
            { name: 'theta', type: 'number', default: 0.9 },
            { name: 'distanceMin', type: 'number', default: 1 },
            { name: 'distanceMax', type: 'number' },
          ],
        },
        {
          key: { force: 'link' },
          params: [
            { name: 'links', type: 'data' },
            { name: 'id', type: 'field' },
            { name: 'distance', type: 'number', default: 30, expr: !0 },
            { name: 'strength', type: 'number', expr: !0 },
            { name: 'iterations', type: 'number', default: 1 },
          ],
        },
        {
          key: { force: 'x' },
          params: [
            { name: 'strength', type: 'number', default: 0.1 },
            { name: 'x', type: 'field' },
          ],
        },
        {
          key: { force: 'y' },
          params: [
            { name: 'strength', type: 'number', default: 0.1 },
            { name: 'y', type: 'field' },
          ],
        },
      ],
    },
    { name: 'as', type: 'string', array: !0, modify: !1, default: UM },
  ],
}),
  It(WM, os, {
    transform(t, n) {
      var e,
        r,
        i = this.value,
        o = n.changed(n.ADD_REM),
        u = t.modified(qM),
        s = t.iterations || 300;
      if (
        (i
          ? (o && (n.modifies('index'), i.nodes(n.source)), (u || n.changed(n.MOD)) && HM(i, t, 0, n))
          : ((this.value = i =
              (function (t, n) {
                const e = (function (t) {
                    var n,
                      e = 1,
                      r = 0.001,
                      i = 1 - Math.pow(r, 1 / 300),
                      o = 0,
                      u = 0.6,
                      s = new Map(),
                      a = SM(f),
                      c = dM('tick', 'end'),
                      l = (function () {
                        let t = 1;
                        return () => (t = (1664525 * t + 1013904223) % _M) / _M;
                      })();
                    function f() {
                      h(), c.call('tick', n), e < r && (a.stop(), c.call('end', n));
                    }
                    function h(r) {
                      var a,
                        c,
                        l = t.length;
                      void 0 === r && (r = 1);
                      for (var f = 0; f < r; ++f)
                        for (
                          e += (o - e) * i,
                            s.forEach(function (t) {
                              t(e);
                            }),
                            a = 0;
                          a < l;
                          ++a
                        )
                          null == (c = t[a]).fx ? (c.x += c.vx *= u) : ((c.x = c.fx), (c.vx = 0)),
                            null == c.fy ? (c.y += c.vy *= u) : ((c.y = c.fy), (c.vy = 0));
                      return n;
                    }
                    function d() {
                      for (var n, e = 0, r = t.length; e < r; ++e) {
                        if (
                          (((n = t[e]).index = e),
                          null != n.fx && (n.x = n.fx),
                          null != n.fy && (n.y = n.fy),
                          isNaN(n.x) || isNaN(n.y))
                        ) {
                          var i = 10 * Math.sqrt(0.5 + e),
                            o = e * PM;
                          (n.x = i * Math.cos(o)), (n.y = i * Math.sin(o));
                        }
                        (isNaN(n.vx) || isNaN(n.vy)) && (n.vx = n.vy = 0);
                      }
                    }
                    function p(n) {
                      return n.initialize && n.initialize(t, l), n;
                    }
                    return (
                      null == t && (t = []),
                      d(),
                      (n = {
                        tick: h,
                        restart: function () {
                          return a.restart(f), n;
                        },
                        stop: function () {
                          return a.stop(), n;
                        },
                        nodes: function (e) {
                          return arguments.length ? ((t = e), d(), s.forEach(p), n) : t;
                        },
                        alpha: function (t) {
                          return arguments.length ? ((e = +t), n) : e;
                        },
                        alphaMin: function (t) {
                          return arguments.length ? ((r = +t), n) : r;
                        },
                        alphaDecay: function (t) {
                          return arguments.length ? ((i = +t), n) : +i;
                        },
                        alphaTarget: function (t) {
                          return arguments.length ? ((o = +t), n) : o;
                        },
                        velocityDecay: function (t) {
                          return arguments.length ? ((u = 1 - t), n) : 1 - u;
                        },
                        randomSource: function (t) {
                          return arguments.length ? ((l = t), s.forEach(p), n) : l;
                        },
                        force: function (t, e) {
                          return arguments.length > 1 ? (null == e ? s.delete(t) : s.set(t, p(e)), n) : s.get(t);
                        },
                        find: function (n, e, r) {
                          var i,
                            o,
                            u,
                            s,
                            a,
                            c = 0,
                            l = t.length;
                          for (null == r ? (r = 1 / 0) : (r *= r), c = 0; c < l; ++c)
                            (u = (i = n - (s = t[c]).x) * i + (o = e - s.y) * o) < r && ((a = s), (r = u));
                          return a;
                        },
                        on: function (t, e) {
                          return arguments.length > 1 ? (c.on(t, e), n) : c.on(t);
                        },
                      })
                    );
                  })(t),
                  r = e.stop,
                  i = e.restart;
                let o = !1;
                return (
                  (e.stopped = () => o),
                  (e.restart = () => ((o = !1), i())),
                  (e.stop = () => ((o = !0), r())),
                  HM(e, n, !0).on('end', () => (o = !0))
                );
              })(n.source, t)),
            i.on('tick', ((e = n.dataflow), (r = this), () => e.touch(r).run())),
            t.static || ((o = !0), i.tick()),
            n.modifies('index')),
        u || o || t.modified(IM) || (n.changed() && t.restart))
      )
        if ((i.alpha(Math.max(i.alpha(), t.alpha || 1)).alphaDecay(1 - Math.pow(i.alphaMin(), 1 / s)), t.static))
          for (i.stop(); --s >= 0; ) i.tick();
        else if ((i.stopped() && i.restart(), !o)) return n.StopPropagation;
      return this.finish(t, n);
    },
    finish(t, n) {
      const e = n.dataflow;
      for (let t, n = this._argops, s = 0, a = n.length; s < a; ++s)
        if (((t = n[s]), t.name === LM && 'link' === t.op._argval.force))
          for (var r, i = t.op._argops, o = 0, u = i.length; o < u; ++o)
            if ('links' === i[o].name && (r = i[o].op.source)) {
              e.pulse(r, e.changeset().reflow());
              break;
            }
      return n.reflow(t.modified()).modifies(UM);
    },
  });
const XM = Object.freeze({ __proto__: null, force: WM });
function JM(t, n) {
  return t.parent === n.parent ? 1 : 2;
}
function QM(t, n) {
  return t + n.x;
}
function ZM(t, n) {
  return Math.max(t, n.y);
}
function KM(t) {
  var n = 0,
    e = t.children,
    r = e && e.length;
  if (r) for (; --r >= 0; ) n += e[r].value;
  else n = 1;
  t.value = n;
}
function tj(t, n) {
  t instanceof Map ? ((t = [void 0, t]), void 0 === n && (n = ej)) : void 0 === n && (n = nj);
  for (var e, r, i, o, u, s = new oj(t), a = [s]; (e = a.pop()); )
    if ((i = n(e.data)) && (u = (i = Array.from(i)).length))
      for (e.children = i, o = u - 1; o >= 0; --o)
        a.push((r = i[o] = new oj(i[o]))), (r.parent = e), (r.depth = e.depth + 1);
  return s.eachBefore(ij);
}
function nj(t) {
  return t.children;
}
function ej(t) {
  return Array.isArray(t) ? t[1] : null;
}
function rj(t) {
  void 0 !== t.data.value && (t.value = t.data.value), (t.data = t.data.data);
}
function ij(t) {
  var n = 0;
  do {
    t.height = n;
  } while ((t = t.parent) && t.height < ++n);
}
function oj(t) {
  (this.data = t), (this.depth = this.height = 0), (this.parent = null);
}
function uj(t) {
  return null == t ? null : sj(t);
}
function sj(t) {
  if ('function' != typeof t) throw new Error();
  return t;
}
function aj() {
  return 0;
}
function cj(t) {
  return function () {
    return t;
  };
}
oj.prototype = tj.prototype = {
  constructor: oj,
  count: function () {
    return this.eachAfter(KM);
  },
  each: function (t, n) {
    let e = -1;
    for (const r of this) t.call(n, r, ++e, this);
    return this;
  },
  eachAfter: function (t, n) {
    for (var e, r, i, o = this, u = [o], s = [], a = -1; (o = u.pop()); )
      if ((s.push(o), (e = o.children))) for (r = 0, i = e.length; r < i; ++r) u.push(e[r]);
    for (; (o = s.pop()); ) t.call(n, o, ++a, this);
    return this;
  },
  eachBefore: function (t, n) {
    for (var e, r, i = this, o = [i], u = -1; (i = o.pop()); )
      if ((t.call(n, i, ++u, this), (e = i.children))) for (r = e.length - 1; r >= 0; --r) o.push(e[r]);
    return this;
  },
  find: function (t, n) {
    let e = -1;
    for (const r of this) if (t.call(n, r, ++e, this)) return r;
  },
  sum: function (t) {
    return this.eachAfter(function (n) {
      for (var e = +t(n.data) || 0, r = n.children, i = r && r.length; --i >= 0; ) e += r[i].value;
      n.value = e;
    });
  },
  sort: function (t) {
    return this.eachBefore(function (n) {
      n.children && n.children.sort(t);
    });
  },
  path: function (t) {
    for (
      var n = this,
        e = (function (t, n) {
          if (t === n) return t;
          var e = t.ancestors(),
            r = n.ancestors(),
            i = null;
          for (t = e.pop(), n = r.pop(); t === n; ) (i = t), (t = e.pop()), (n = r.pop());
          return i;
        })(n, t),
        r = [n];
      n !== e;

    )
      r.push((n = n.parent));
    for (var i = r.length; t !== e; ) r.splice(i, 0, t), (t = t.parent);
    return r;
  },
  ancestors: function () {
    for (var t = this, n = [t]; (t = t.parent); ) n.push(t);
    return n;
  },
  descendants: function () {
    return Array.from(this);
  },
  leaves: function () {
    var t = [];
    return (
      this.eachBefore(function (n) {
        n.children || t.push(n);
      }),
      t
    );
  },
  links: function () {
    var t = this,
      n = [];
    return (
      t.each(function (e) {
        e !== t && n.push({ source: e.parent, target: e });
      }),
      n
    );
  },
  copy: function () {
    return tj(this).eachBefore(rj);
  },
  [Symbol.iterator]: function* () {
    var t,
      n,
      e,
      r,
      i = this,
      o = [i];
    do {
      for (t = o.reverse(), o = []; (i = t.pop()); )
        if ((yield i, (n = i.children))) for (e = 0, r = n.length; e < r; ++e) o.push(n[e]);
    } while (o.length);
  },
};
const lj = 4294967296;
function fj(t, n) {
  var e, r;
  if (pj(n, t)) return [n];
  for (e = 0; e < t.length; ++e) if (hj(n, t[e]) && pj(vj(t[e], n), t)) return [t[e], n];
  for (e = 0; e < t.length - 1; ++e)
    for (r = e + 1; r < t.length; ++r)
      if (hj(vj(t[e], t[r]), n) && hj(vj(t[e], n), t[r]) && hj(vj(t[r], n), t[e]) && pj(gj(t[e], t[r], n), t))
        return [t[e], t[r], n];
  throw new Error();
}
function hj(t, n) {
  var e = t.r - n.r,
    r = n.x - t.x,
    i = n.y - t.y;
  return e < 0 || e * e < r * r + i * i;
}
function dj(t, n) {
  var e = t.r - n.r + 1e-9 * Math.max(t.r, n.r, 1),
    r = n.x - t.x,
    i = n.y - t.y;
  return e > 0 && e * e > r * r + i * i;
}
function pj(t, n) {
  for (var e = 0; e < n.length; ++e) if (!dj(t, n[e])) return !1;
  return !0;
}
function mj(t) {
  switch (t.length) {
    case 1:
      return { x: (n = t[0]).x, y: n.y, r: n.r };
    case 2:
      return vj(t[0], t[1]);
    case 3:
      return gj(t[0], t[1], t[2]);
  }
  var n;
}
function vj(t, n) {
  var e = t.x,
    r = t.y,
    i = t.r,
    o = n.x,
    u = n.y,
    s = n.r,
    a = o - e,
    c = u - r,
    l = s - i,
    f = Math.sqrt(a * a + c * c);
  return { x: (e + o + (a / f) * l) / 2, y: (r + u + (c / f) * l) / 2, r: (f + i + s) / 2 };
}
function gj(t, n, e) {
  var r = t.x,
    i = t.y,
    o = t.r,
    u = n.x,
    s = n.y,
    a = n.r,
    c = e.x,
    l = e.y,
    f = e.r,
    h = r - u,
    d = r - c,
    p = i - s,
    m = i - l,
    v = a - o,
    g = f - o,
    b = r * r + i * i - o * o,
    y = b - u * u - s * s + a * a,
    w = b - c * c - l * l + f * f,
    x = d * p - h * m,
    O = (p * w - m * y) / (2 * x) - r,
    k = (m * v - p * g) / x,
    A = (d * y - h * w) / (2 * x) - i,
    $ = (h * g - d * v) / x,
    M = k * k + $ * $ - 1,
    j = 2 * (o + O * k + A * $),
    D = O * O + A * A - o * o,
    F = -(Math.abs(M) > 1e-6 ? (j + Math.sqrt(j * j - 4 * M * D)) / (2 * M) : D / j);
  return { x: r + O + k * F, y: i + A + $ * F, r: F };
}
function bj(t, n, e) {
  var r,
    i,
    o,
    u,
    s = t.x - n.x,
    a = t.y - n.y,
    c = s * s + a * a;
  c
    ? ((i = n.r + e.r),
      (u = t.r + e.r),
      (i *= i) > (u *= u)
        ? ((r = (c + u - i) / (2 * c)),
          (o = Math.sqrt(Math.max(0, u / c - r * r))),
          (e.x = t.x - r * s - o * a),
          (e.y = t.y - r * a + o * s))
        : ((r = (c + i - u) / (2 * c)),
          (o = Math.sqrt(Math.max(0, i / c - r * r))),
          (e.x = n.x + r * s - o * a),
          (e.y = n.y + r * a + o * s)))
    : ((e.x = n.x + e.r), (e.y = n.y));
}
function yj(t, n) {
  var e = t.r + n.r - 1e-6,
    r = n.x - t.x,
    i = n.y - t.y;
  return e > 0 && e * e > r * r + i * i;
}
function wj(t) {
  var n = t._,
    e = t.next._,
    r = n.r + e.r,
    i = (n.x * e.r + e.x * n.r) / r,
    o = (n.y * e.r + e.y * n.r) / r;
  return i * i + o * o;
}
function xj(t) {
  (this._ = t), (this.next = null), (this.previous = null);
}
function Oj(t) {
  return Math.sqrt(t.value);
}
function kj(t) {
  return function (n) {
    n.children || (n.r = Math.max(0, +t(n) || 0));
  };
}
function Aj(t, n, e) {
  return function (r) {
    if ((i = r.children)) {
      var i,
        o,
        u,
        s = i.length,
        a = t(r) * n || 0;
      if (a) for (o = 0; o < s; ++o) i[o].r += a;
      if (
        ((u = (function (t, n) {
          if (
            !(o = (t = (function (t) {
              return 'object' == typeof t && 'length' in t ? t : Array.from(t);
            })(t)).length)
          )
            return 0;
          var e, r, i, o, u, s, a, c, l, f, h;
          if ((((e = t[0]).x = 0), (e.y = 0), !(o > 1))) return e.r;
          if (((e.x = -(r = t[1]).r), (r.x = e.r), (r.y = 0), !(o > 2))) return e.r + r.r;
          bj(r, e, (i = t[2])),
            (e = new xj(e)),
            (r = new xj(r)),
            (i = new xj(i)),
            (e.next = i.previous = r),
            (r.next = e.previous = i),
            (i.next = r.previous = e);
          t: for (a = 3; a < o; ++a) {
            bj(e._, r._, (i = t[a])), (i = new xj(i)), (c = r.next), (l = e.previous), (f = r._.r), (h = e._.r);
            do {
              if (f <= h) {
                if (yj(c._, i._)) {
                  (e.next = r = c), (r.previous = e), --a;
                  continue t;
                }
                (f += c._.r), (c = c.next);
              } else {
                if (yj(l._, i._)) {
                  ((e = l).next = r), (r.previous = e), --a;
                  continue t;
                }
                (h += l._.r), (l = l.previous);
              }
            } while (c !== l.next);
            for (i.previous = e, i.next = r, e.next = r.previous = r = i, u = wj(e); (i = i.next) !== r; )
              (s = wj(i)) < u && ((e = i), (u = s));
            r = e.next;
          }
          for (e = [r._], i = r; (i = i.next) !== r; ) e.push(i._);
          for (
            i = (function (t, n) {
              for (
                var e,
                  r,
                  i = 0,
                  o = (t = (function (t, n) {
                    let e,
                      r,
                      i = t.length;
                    for (; i; ) (r = (n() * i--) | 0), (e = t[i]), (t[i] = t[r]), (t[r] = e);
                    return t;
                  })(Array.from(t), n)).length,
                  u = [];
                i < o;

              )
                (e = t[i]), r && dj(r, e) ? ++i : ((r = mj((u = fj(u, e)))), (i = 0));
              return r;
            })(e, n),
              a = 0;
            a < o;
            ++a
          )
            ((e = t[a]).x -= i.x), (e.y -= i.y);
          return i.r;
        })(i, e)),
        a)
      )
        for (o = 0; o < s; ++o) i[o].r -= a;
      r.r = u + a;
    }
  };
}
function $j(t) {
  return function (n) {
    var e = n.parent;
    (n.r *= t), e && ((n.x = e.x + t * n.x), (n.y = e.y + t * n.y));
  };
}
function Mj(t) {
  (t.x0 = Math.round(t.x0)), (t.y0 = Math.round(t.y0)), (t.x1 = Math.round(t.x1)), (t.y1 = Math.round(t.y1));
}
function jj(t, n, e, r, i) {
  for (var o, u = t.children, s = -1, a = u.length, c = t.value && (r - n) / t.value; ++s < a; )
    ((o = u[s]).y0 = e), (o.y1 = i), (o.x0 = n), (o.x1 = n += o.value * c);
}
var Dj = { depth: -1 },
  Fj = {},
  Ej = {};
function Sj(t) {
  return t.id;
}
function Cj(t) {
  return t.parentId;
}
function Nj() {
  var t,
    n = Sj,
    e = Cj;
  function r(r) {
    var i,
      o,
      u,
      s,
      a,
      c,
      l,
      f,
      h = Array.from(r),
      d = n,
      p = e,
      m = new Map();
    if (null != t) {
      const n = h.map((n, e) =>
          (function (t) {
            let n = (t = `${t}`).length;
            return _j(t, n - 1) && !_j(t, n - 2) && (t = t.slice(0, -1)), '/' === t[0] ? t : `/${t}`;
          })(t(n, e, r)),
        ),
        e = n.map(Bj),
        i = new Set(n).add('');
      for (const t of e) i.has(t) || (i.add(t), n.push(t), e.push(Bj(t)), h.push(Ej));
      (d = (t, e) => n[e]), (p = (t, n) => e[n]);
    }
    for (u = 0, i = h.length; u < i; ++u)
      (c = h[u] = new oj((o = h[u]))),
        null != (l = d(o, u, r)) && (l += '') && ((f = c.id = l), m.set(f, m.has(f) ? Fj : c)),
        null != (l = p(o, u, r)) && (l += '') && (c.parent = l);
    for (u = 0; u < i; ++u)
      if ((l = (c = h[u]).parent)) {
        if (!(a = m.get(l))) throw new Error('missing: ' + l);
        if (a === Fj) throw new Error('ambiguous: ' + l);
        a.children ? a.children.push(c) : (a.children = [c]), (c.parent = a);
      } else {
        if (s) throw new Error('multiple roots');
        s = c;
      }
    if (!s) throw new Error('no root');
    if (null != t) {
      for (; s.data === Ej && 1 === s.children.length; ) (s = s.children[0]), --i;
      for (let t = h.length - 1; t >= 0 && (c = h[t]).data === Ej; --t) c.data = null;
    }
    if (
      ((s.parent = Dj),
      s
        .eachBefore(function (t) {
          (t.depth = t.parent.depth + 1), --i;
        })
        .eachBefore(ij),
      (s.parent = null),
      i > 0)
    )
      throw new Error('cycle');
    return s;
  }
  return (
    (r.id = function (t) {
      return arguments.length ? ((n = uj(t)), r) : n;
    }),
    (r.parentId = function (t) {
      return arguments.length ? ((e = uj(t)), r) : e;
    }),
    (r.path = function (n) {
      return arguments.length ? ((t = uj(n)), r) : t;
    }),
    r
  );
}
function Bj(t) {
  let n = t.length;
  if (n < 2) return '';
  for (; --n > 1 && !_j(t, n); );
  return t.slice(0, n);
}
function _j(t, n) {
  if ('/' === t[n]) {
    let e = 0;
    for (; n > 0 && '\\' === t[--n]; ) ++e;
    if (0 == (1 & e)) return !0;
  }
  return !1;
}
function zj(t, n) {
  return t.parent === n.parent ? 1 : 2;
}
function Tj(t) {
  var n = t.children;
  return n ? n[0] : t.t;
}
function Pj(t) {
  var n = t.children;
  return n ? n[n.length - 1] : t.t;
}
function Rj(t, n, e) {
  var r = e / (n.i - t.i);
  (n.c -= r), (n.s += e), (t.c += r), (n.z += e), (n.m += e);
}
function Lj(t, n, e) {
  return t.a.parent === n.parent ? t.a : e;
}
function qj(t, n) {
  (this._ = t),
    (this.parent = null),
    (this.children = null),
    (this.A = null),
    (this.a = this),
    (this.z = 0),
    (this.m = 0),
    (this.c = 0),
    (this.s = 0),
    (this.t = null),
    (this.i = n);
}
function Ij(t, n, e, r, i) {
  for (var o, u = t.children, s = -1, a = u.length, c = t.value && (i - e) / t.value; ++s < a; )
    ((o = u[s]).x0 = n), (o.x1 = r), (o.y0 = e), (o.y1 = e += o.value * c);
}
qj.prototype = Object.create(oj.prototype);
var Uj = (1 + Math.sqrt(5)) / 2;
function Wj(t, n, e, r, i, o) {
  for (var u, s, a, c, l, f, h, d, p, m, v, g = [], b = n.children, y = 0, w = 0, x = b.length, O = n.value; y < x; ) {
    (a = i - e), (c = o - r);
    do {
      l = b[w++].value;
    } while (!l && w < x);
    for (f = h = l, v = l * l * (m = Math.max(c / a, a / c) / (O * t)), p = Math.max(h / v, v / f); w < x; ++w) {
      if (
        ((l += s = b[w].value), s < f && (f = s), s > h && (h = s), (v = l * l * m), (d = Math.max(h / v, v / f)) > p)
      ) {
        l -= s;
        break;
      }
      p = d;
    }
    g.push((u = { value: l, dice: a < c, children: b.slice(y, w) })),
      u.dice ? jj(u, e, r, i, O ? (r += (c * l) / O) : o) : Ij(u, e, r, O ? (e += (a * l) / O) : i, o),
      (O -= l),
      (y = w);
  }
  return g;
}
const Hj = (function t(n) {
    function e(t, e, r, i, o) {
      Wj(n, t, e, r, i, o);
    }
    return (
      (e.ratio = function (n) {
        return t((n = +n) > 1 ? n : 1);
      }),
      e
    );
  })(Uj),
  Gj = (function t(n) {
    function e(t, e, r, i, o) {
      if ((u = t._squarify) && u.ratio === n)
        for (var u, s, a, c, l, f = -1, h = u.length, d = t.value; ++f < h; ) {
          for (a = (s = u[f]).children, c = s.value = 0, l = a.length; c < l; ++c) s.value += a[c].value;
          s.dice
            ? jj(s, e, r, i, d ? (r += ((o - r) * s.value) / d) : o)
            : Ij(s, e, r, d ? (e += ((i - e) * s.value) / d) : i, o),
            (d -= s.value);
        }
      else (t._squarify = u = Wj(n, t, e, r, i, o)), (u.ratio = n);
    }
    return (
      (e.ratio = function (n) {
        return t((n = +n) > 1 ? n : 1);
      }),
      e
    );
  })(Uj);
function Vj(t, n, e) {
  const r = {};
  return (
    t.each(t => {
      const i = t.data;
      e(i) && (r[n(i)] = t);
    }),
    (t.lookup = r),
    t
  );
}
function Yj(t) {
  os.call(this, null, t);
}
Yj.Definition = {
  type: 'Nest',
  metadata: { treesource: !0, changes: !0 },
  params: [
    { name: 'keys', type: 'field', array: !0 },
    { name: 'generate', type: 'boolean' },
  ],
};
const Xj = t => t.values;
function Jj() {
  const t = [],
    n = { entries: t => r(e(t, 0), 0), key: e => (t.push(e), n) };
  function e(n, r) {
    if (r >= t.length) return n;
    const i = n.length,
      o = t[r++],
      u = {},
      s = {};
    let a,
      c,
      l,
      f = -1;
    for (; ++f < i; ) (a = o((c = n[f])) + ''), (l = u[a]) ? l.push(c) : (u[a] = [c]);
    for (a in u) s[a] = e(u[a], r);
    return s;
  }
  function r(n, e) {
    if (++e > t.length) return n;
    const i = [];
    for (const t in n) i.push({ key: t, values: r(n[t], e) });
    return i;
  }
  return n;
}
function Qj(t) {
  os.call(this, null, t);
}
It(Yj, os, {
  transform(t, n) {
    n.source || I('Nest transform requires an upstream data source.');
    var e = t.generate,
      r = t.modified(),
      i = n.clone(),
      o = this.value;
    return (
      (!o || r || n.changed()) &&
        (o &&
          o.each(t => {
            t.children && Mu(t.data) && i.rem.push(t.data);
          }),
        (this.value = o =
          tj(
            {
              values: At(t.keys)
                .reduce((t, n) => (t.key(n), t), Jj())
                .entries(i.source),
            },
            Xj,
          )),
        e &&
          o.each(t => {
            t.children && ((t = Fu(t.data)), i.add.push(t), i.source.push(t));
          }),
        Vj(o, ju, ju)),
      (i.source.root = o),
      i
    );
  },
});
const Zj = (t, n) => (t.parent === n.parent ? 1 : 2);
It(Qj, os, {
  transform(t, n) {
    (n.source && n.source.root) || I(this.constructor.name + ' transform requires a backing tree data source.');
    const e = this.layout(t.method),
      r = this.fields,
      i = n.source.root,
      o = t.as || r;
    t.field ? i.sum(t.field) : i.count(),
      t.sort && i.sort(Nu(t.sort, t => t.data)),
      (function (t, n, e) {
        for (let r, i = 0, o = n.length; i < o; ++i) (r = n[i]), r in e && t[r](e[r]);
      })(e, this.params, t),
      e.separation && e.separation(!1 !== t.separation ? Zj : Y);
    try {
      this.value = e(i);
    } catch (t) {
      I(t);
    }
    return (
      i.each(t =>
        (function (t, n, e) {
          const r = t.data,
            i = n.length - 1;
          for (let o = 0; o < i; ++o) r[e[o]] = t[n[o]];
          r[e[i]] = t.children ? t.children.length : 0;
        })(t, r, o),
      ),
      n.reflow(t.modified()).modifies(o).modifies('leaf')
    );
  },
});
const Kj = ['x', 'y', 'r', 'depth', 'children'];
function tD(t) {
  Qj.call(this, t);
}
(tD.Definition = {
  type: 'Pack',
  metadata: { tree: !0, modifies: !0 },
  params: [
    { name: 'field', type: 'field' },
    { name: 'sort', type: 'compare' },
    { name: 'padding', type: 'number', default: 0 },
    { name: 'radius', type: 'field', default: null },
    { name: 'size', type: 'number', array: !0, length: 2 },
    { name: 'as', type: 'string', array: !0, length: Kj.length, default: Kj },
  ],
}),
  It(tD, Qj, {
    layout: function () {
      var t = null,
        n = 1,
        e = 1,
        r = aj;
      function i(i) {
        const o = (function () {
          let t = 1;
          return () => (t = (1664525 * t + 1013904223) % lj) / lj;
        })();
        return (
          (i.x = n / 2),
          (i.y = e / 2),
          t
            ? i
                .eachBefore(kj(t))
                .eachAfter(Aj(r, 0.5, o))
                .eachBefore($j(1))
            : i
                .eachBefore(kj(Oj))
                .eachAfter(Aj(aj, 1, o))
                .eachAfter(Aj(r, i.r / Math.min(n, e), o))
                .eachBefore($j(Math.min(n, e) / (2 * i.r))),
          i
        );
      }
      return (
        (i.radius = function (n) {
          return arguments.length ? ((t = uj(n)), i) : t;
        }),
        (i.size = function (t) {
          return arguments.length ? ((n = +t[0]), (e = +t[1]), i) : [n, e];
        }),
        (i.padding = function (t) {
          return arguments.length ? ((r = 'function' == typeof t ? t : cj(+t)), i) : r;
        }),
        i
      );
    },
    params: ['radius', 'size', 'padding'],
    fields: Kj,
  });
const nD = ['x0', 'y0', 'x1', 'y1', 'depth', 'children'];
function eD(t) {
  Qj.call(this, t);
}
function rD(t) {
  os.call(this, null, t);
}
(eD.Definition = {
  type: 'Partition',
  metadata: { tree: !0, modifies: !0 },
  params: [
    { name: 'field', type: 'field' },
    { name: 'sort', type: 'compare' },
    { name: 'padding', type: 'number', default: 0 },
    { name: 'round', type: 'boolean', default: !1 },
    { name: 'size', type: 'number', array: !0, length: 2 },
    { name: 'as', type: 'string', array: !0, length: nD.length, default: nD },
  ],
}),
  It(eD, Qj, {
    layout: function () {
      var t = 1,
        n = 1,
        e = 0,
        r = !1;
      function i(i) {
        var o = i.height + 1;
        return (
          (i.x0 = i.y0 = e),
          (i.x1 = t),
          (i.y1 = n / o),
          i.eachBefore(
            (function (t, n) {
              return function (r) {
                r.children && jj(r, r.x0, (t * (r.depth + 1)) / n, r.x1, (t * (r.depth + 2)) / n);
                var i = r.x0,
                  o = r.y0,
                  u = r.x1 - e,
                  s = r.y1 - e;
                u < i && (i = u = (i + u) / 2),
                  s < o && (o = s = (o + s) / 2),
                  (r.x0 = i),
                  (r.y0 = o),
                  (r.x1 = u),
                  (r.y1 = s);
              };
            })(n, o),
          ),
          r && i.eachBefore(Mj),
          i
        );
      }
      return (
        (i.round = function (t) {
          return arguments.length ? ((r = !!t), i) : r;
        }),
        (i.size = function (e) {
          return arguments.length ? ((t = +e[0]), (n = +e[1]), i) : [t, n];
        }),
        (i.padding = function (t) {
          return arguments.length ? ((e = +t), i) : e;
        }),
        i
      );
    },
    params: ['size', 'round', 'padding'],
    fields: nD,
  }),
  (rD.Definition = {
    type: 'Stratify',
    metadata: { treesource: !0 },
    params: [
      { name: 'key', type: 'field', required: !0 },
      { name: 'parentKey', type: 'field', required: !0 },
    ],
  }),
  It(rD, os, {
    transform(t, n) {
      n.source || I('Stratify transform requires an upstream data source.');
      let e = this.value;
      const r = t.modified(),
        i = n.fork(n.ALL).materialize(n.SOURCE),
        o = !e || r || n.changed(n.ADD_REM) || n.modified(t.key.fields) || n.modified(t.parentKey.fields);
      return (
        (i.source = i.source.slice()),
        o &&
          (e = i.source.length
            ? Vj(Nj().id(t.key).parentId(t.parentKey)(i.source), t.key, X)
            : Vj(Nj()([{}]), t.key, t.key)),
        (i.source.root = this.value = e),
        i
      );
    },
  });
const iD = {
    tidy: function () {
      var t = zj,
        n = 1,
        e = 1,
        r = null;
      function i(i) {
        var a = (function (t) {
          for (var n, e, r, i, o, u = new qj(t, 0), s = [u]; (n = s.pop()); )
            if ((r = n._.children))
              for (n.children = new Array((o = r.length)), i = o - 1; i >= 0; --i)
                s.push((e = n.children[i] = new qj(r[i], i))), (e.parent = n);
          return ((u.parent = new qj(null, 0)).children = [u]), u;
        })(i);
        if ((a.eachAfter(o), (a.parent.m = -a.z), a.eachBefore(u), r)) i.eachBefore(s);
        else {
          var c = i,
            l = i,
            f = i;
          i.eachBefore(function (t) {
            t.x < c.x && (c = t), t.x > l.x && (l = t), t.depth > f.depth && (f = t);
          });
          var h = c === l ? 1 : t(c, l) / 2,
            d = h - c.x,
            p = n / (l.x + h + d),
            m = e / (f.depth || 1);
          i.eachBefore(function (t) {
            (t.x = (t.x + d) * p), (t.y = t.depth * m);
          });
        }
        return i;
      }
      function o(n) {
        var e = n.children,
          r = n.parent.children,
          i = n.i ? r[n.i - 1] : null;
        if (e) {
          !(function (t) {
            for (var n, e = 0, r = 0, i = t.children, o = i.length; --o >= 0; )
              ((n = i[o]).z += e), (n.m += e), (e += n.s + (r += n.c));
          })(n);
          var o = (e[0].z + e[e.length - 1].z) / 2;
          i ? ((n.z = i.z + t(n._, i._)), (n.m = n.z - o)) : (n.z = o);
        } else i && (n.z = i.z + t(n._, i._));
        n.parent.A = (function (n, e, r) {
          if (e) {
            for (
              var i, o = n, u = n, s = e, a = o.parent.children[0], c = o.m, l = u.m, f = s.m, h = a.m;
              (s = Pj(s)), (o = Tj(o)), s && o;

            )
              (a = Tj(a)),
                ((u = Pj(u)).a = n),
                (i = s.z + f - o.z - c + t(s._, o._)) > 0 && (Rj(Lj(s, n, r), n, i), (c += i), (l += i)),
                (f += s.m),
                (c += o.m),
                (h += a.m),
                (l += u.m);
            s && !Pj(u) && ((u.t = s), (u.m += f - l)), o && !Tj(a) && ((a.t = o), (a.m += c - h), (r = n));
          }
          return r;
        })(n, i, n.parent.A || r[0]);
      }
      function u(t) {
        (t._.x = t.z + t.parent.m), (t.m += t.parent.m);
      }
      function s(t) {
        (t.x *= n), (t.y = t.depth * e);
      }
      return (
        (i.separation = function (n) {
          return arguments.length ? ((t = n), i) : t;
        }),
        (i.size = function (t) {
          return arguments.length ? ((r = !1), (n = +t[0]), (e = +t[1]), i) : r ? null : [n, e];
        }),
        (i.nodeSize = function (t) {
          return arguments.length ? ((r = !0), (n = +t[0]), (e = +t[1]), i) : r ? [n, e] : null;
        }),
        i
      );
    },
    cluster: function () {
      var t = JM,
        n = 1,
        e = 1,
        r = !1;
      function i(i) {
        var o,
          u = 0;
        i.eachAfter(function (n) {
          var e = n.children;
          e
            ? ((n.x = (function (t) {
                return t.reduce(QM, 0) / t.length;
              })(e)),
              (n.y = (function (t) {
                return 1 + t.reduce(ZM, 0);
              })(e)))
            : ((n.x = o ? (u += t(n, o)) : 0), (n.y = 0), (o = n));
        });
        var s = (function (t) {
            for (var n; (n = t.children); ) t = n[0];
            return t;
          })(i),
          a = (function (t) {
            for (var n; (n = t.children); ) t = n[n.length - 1];
            return t;
          })(i),
          c = s.x - t(s, a) / 2,
          l = a.x + t(a, s) / 2;
        return i.eachAfter(
          r
            ? function (t) {
                (t.x = (t.x - i.x) * n), (t.y = (i.y - t.y) * e);
              }
            : function (t) {
                (t.x = ((t.x - c) / (l - c)) * n), (t.y = (1 - (i.y ? t.y / i.y : 1)) * e);
              },
        );
      }
      return (
        (i.separation = function (n) {
          return arguments.length ? ((t = n), i) : t;
        }),
        (i.size = function (t) {
          return arguments.length ? ((r = !1), (n = +t[0]), (e = +t[1]), i) : r ? null : [n, e];
        }),
        (i.nodeSize = function (t) {
          return arguments.length ? ((r = !0), (n = +t[0]), (e = +t[1]), i) : r ? [n, e] : null;
        }),
        i
      );
    },
  },
  oD = ['x', 'y', 'depth', 'children'];
function uD(t) {
  Qj.call(this, t);
}
function sD(t) {
  os.call(this, [], t);
}
(uD.Definition = {
  type: 'Tree',
  metadata: { tree: !0, modifies: !0 },
  params: [
    { name: 'field', type: 'field' },
    { name: 'sort', type: 'compare' },
    { name: 'method', type: 'enum', default: 'tidy', values: ['tidy', 'cluster'] },
    { name: 'size', type: 'number', array: !0, length: 2 },
    { name: 'nodeSize', type: 'number', array: !0, length: 2 },
    { name: 'separation', type: 'boolean', default: !0 },
    { name: 'as', type: 'string', array: !0, length: oD.length, default: oD },
  ],
}),
  It(uD, Qj, {
    layout(t) {
      const n = t || 'tidy';
      if (Pt(iD, n)) return iD[n]();
      I('Unrecognized Tree layout method: ' + n);
    },
    params: ['size', 'nodeSize'],
    fields: oD,
  }),
  (sD.Definition = { type: 'TreeLinks', metadata: { tree: !0, generates: !0, changes: !0 }, params: [] }),
  It(sD, os, {
    transform(t, n) {
      const e = this.value,
        r = n.source && n.source.root,
        i = n.fork(n.NO_SOURCE),
        o = {};
      return (
        r || I('TreeLinks transform requires a tree data source.'),
        n.changed(n.ADD_REM)
          ? ((i.rem = e),
            n.visit(n.SOURCE, t => (o[ju(t)] = 1)),
            r.each(t => {
              const n = t.data,
                e = t.parent && t.parent.data;
              e && o[ju(n)] && o[ju(e)] && i.add.push(Fu({ source: e, target: n }));
            }),
            (this.value = i.add))
          : n.changed(n.MOD) &&
            (n.visit(n.MOD, t => (o[ju(t)] = 1)),
            e.forEach(t => {
              (o[ju(t.source)] || o[ju(t.target)]) && i.mod.push(t);
            })),
        i
      );
    },
  });
const aD = {
    binary: function (t, n, e, r, i) {
      var o,
        u,
        s = t.children,
        a = s.length,
        c = new Array(a + 1);
      for (c[0] = u = o = 0; o < a; ++o) c[o + 1] = u += s[o].value;
      !(function t(n, e, r, i, o, u, a) {
        if (n >= e - 1) {
          var l = s[n];
          return (l.x0 = i), (l.y0 = o), (l.x1 = u), void (l.y1 = a);
        }
        for (var f = c[n], h = r / 2 + f, d = n + 1, p = e - 1; d < p; ) {
          var m = (d + p) >>> 1;
          c[m] < h ? (d = m + 1) : (p = m);
        }
        h - c[d - 1] < c[d] - h && n + 1 < d && --d;
        var v = c[d] - f,
          g = r - v;
        if (u - i > a - o) {
          var b = r ? (i * g + u * v) / r : u;
          t(n, d, v, i, o, b, a), t(d, e, g, b, o, u, a);
        } else {
          var y = r ? (o * g + a * v) / r : a;
          t(n, d, v, i, o, u, y), t(d, e, g, i, y, u, a);
        }
      })(0, a, t.value, n, e, r, i);
    },
    dice: jj,
    slice: Ij,
    slicedice: function (t, n, e, r, i) {
      (1 & t.depth ? Ij : jj)(t, n, e, r, i);
    },
    squarify: Hj,
    resquarify: Gj,
  },
  cD = ['x0', 'y0', 'x1', 'y1', 'depth', 'children'];
function lD(t) {
  Qj.call(this, t);
}
(lD.Definition = {
  type: 'Treemap',
  metadata: { tree: !0, modifies: !0 },
  params: [
    { name: 'field', type: 'field' },
    { name: 'sort', type: 'compare' },
    {
      name: 'method',
      type: 'enum',
      default: 'squarify',
      values: ['squarify', 'resquarify', 'binary', 'dice', 'slice', 'slicedice'],
    },
    { name: 'padding', type: 'number', default: 0 },
    { name: 'paddingInner', type: 'number', default: 0 },
    { name: 'paddingOuter', type: 'number', default: 0 },
    { name: 'paddingTop', type: 'number', default: 0 },
    { name: 'paddingRight', type: 'number', default: 0 },
    { name: 'paddingBottom', type: 'number', default: 0 },
    { name: 'paddingLeft', type: 'number', default: 0 },
    { name: 'ratio', type: 'number', default: 1.618033988749895 },
    { name: 'round', type: 'boolean', default: !1 },
    { name: 'size', type: 'number', array: !0, length: 2 },
    { name: 'as', type: 'string', array: !0, length: cD.length, default: cD },
  ],
}),
  It(lD, Qj, {
    layout() {
      const t = (function () {
        var t = Hj,
          n = !1,
          e = 1,
          r = 1,
          i = [0],
          o = aj,
          u = aj,
          s = aj,
          a = aj,
          c = aj;
        function l(t) {
          return (t.x0 = t.y0 = 0), (t.x1 = e), (t.y1 = r), t.eachBefore(f), (i = [0]), n && t.eachBefore(Mj), t;
        }
        function f(n) {
          var e = i[n.depth],
            r = n.x0 + e,
            l = n.y0 + e,
            f = n.x1 - e,
            h = n.y1 - e;
          f < r && (r = f = (r + f) / 2),
            h < l && (l = h = (l + h) / 2),
            (n.x0 = r),
            (n.y0 = l),
            (n.x1 = f),
            (n.y1 = h),
            n.children &&
              ((e = i[n.depth + 1] = o(n) / 2),
              (r += c(n) - e),
              (l += u(n) - e),
              (f -= s(n) - e) < r && (r = f = (r + f) / 2),
              (h -= a(n) - e) < l && (l = h = (l + h) / 2),
              t(n, r, l, f, h));
        }
        return (
          (l.round = function (t) {
            return arguments.length ? ((n = !!t), l) : n;
          }),
          (l.size = function (t) {
            return arguments.length ? ((e = +t[0]), (r = +t[1]), l) : [e, r];
          }),
          (l.tile = function (n) {
            return arguments.length ? ((t = sj(n)), l) : t;
          }),
          (l.padding = function (t) {
            return arguments.length ? l.paddingInner(t).paddingOuter(t) : l.paddingInner();
          }),
          (l.paddingInner = function (t) {
            return arguments.length ? ((o = 'function' == typeof t ? t : cj(+t)), l) : o;
          }),
          (l.paddingOuter = function (t) {
            return arguments.length ? l.paddingTop(t).paddingRight(t).paddingBottom(t).paddingLeft(t) : l.paddingTop();
          }),
          (l.paddingTop = function (t) {
            return arguments.length ? ((u = 'function' == typeof t ? t : cj(+t)), l) : u;
          }),
          (l.paddingRight = function (t) {
            return arguments.length ? ((s = 'function' == typeof t ? t : cj(+t)), l) : s;
          }),
          (l.paddingBottom = function (t) {
            return arguments.length ? ((a = 'function' == typeof t ? t : cj(+t)), l) : a;
          }),
          (l.paddingLeft = function (t) {
            return arguments.length ? ((c = 'function' == typeof t ? t : cj(+t)), l) : c;
          }),
          l
        );
      })();
      return (
        (t.ratio = n => {
          const e = t.tile();
          e.ratio && t.tile(e.ratio(n));
        }),
        (t.method = n => {
          Pt(aD, n) ? t.tile(aD[n]) : I('Unrecognized Treemap layout method: ' + n);
        }),
        t
      );
    },
    params: [
      'method',
      'ratio',
      'size',
      'round',
      'padding',
      'paddingInner',
      'paddingOuter',
      'paddingTop',
      'paddingRight',
      'paddingBottom',
      'paddingLeft',
    ],
    fields: cD,
  });
const fD = Object.freeze({
    __proto__: null,
    nest: Yj,
    pack: tD,
    partition: eD,
    stratify: rD,
    tree: uD,
    treelinks: sD,
    treemap: lD,
  }),
  hD = 4278190080;
function dD(t, n, e) {
  return new Uint32Array(t.getImageData(0, 0, n, e).data.buffer);
}
function pD(t, n, e) {
  if (!n.length) return;
  const r = n[0].mark.marktype;
  'group' === r
    ? n.forEach(n => {
        n.items.forEach(n => pD(t, n.items, e));
      })
    : Lg[r].draw(t, { items: e ? n.map(mD) : n });
}
function mD(t) {
  const n = Su(t, {});
  return (n.stroke && 0 !== n.strokeOpacity) || (n.fill && 0 !== n.fillOpacity)
    ? { ...n, strokeOpacity: 1, stroke: '#000', fillOpacity: 0 }
    : n;
}
const vD = 31,
  gD = new Uint32Array(33),
  bD = new Uint32Array(33);
(bD[0] = 0), (gD[0] = ~bD[0]);
for (let t = 1; t <= 32; ++t) (bD[t] = (bD[t - 1] << 1) | 1), (gD[t] = ~bD[t]);
function yD(t, n, e, r, i, o) {
  let u = e / 2;
  return t - u < 0 || t + u > i || n - (u = r / 2) < 0 || n + u > o;
}
function wD(t, n, e, r, i, o, u, s) {
  const a = (i * o) / (2 * r),
    c = t(n - a),
    l = t(n + a),
    f = t(e - (o /= 2)),
    h = t(e + o);
  return u.outOfBounds(c, f, l, h) || u.getRange(c, f, l, h) || (s && s.getRange(c, f, l, h));
}
const xD = [-1, -1, 1, 1],
  OD = [-1, 1, -1, 1],
  kD = ['right', 'center', 'left'],
  AD = ['bottom', 'middle', 'top'];
function $D(t, n, e, r, i, o, u, s, a, c, l, f) {
  return !(i.outOfBounds(t, e, n, r) || ((f && o) || i).getRange(t, e, n, r));
}
const MD = {
    'top-left': 0,
    top: 1,
    'top-right': 2,
    left: 4,
    middle: 5,
    right: 6,
    'bottom-left': 8,
    bottom: 9,
    'bottom-right': 10,
  },
  jD = {
    naive: function (t, n, e, r) {
      const i = t.width,
        o = t.height;
      return function (t) {
        const n = t.datum.datum.items[r].items,
          e = n.length,
          u = t.datum.fontSize,
          s = wg.width(t.datum, t.datum.text);
        let a,
          c,
          l,
          f,
          h,
          d,
          p,
          m = 0;
        for (let r = 0; r < e; ++r)
          (a = n[r].x),
            (l = n[r].y),
            (c = void 0 === n[r].x2 ? a : n[r].x2),
            (f = void 0 === n[r].y2 ? l : n[r].y2),
            (h = (a + c) / 2),
            (d = (l + f) / 2),
            (p = Math.abs(c - a + f - l)),
            p >= m && ((m = p), (t.x = h), (t.y = d));
        return (
          (h = s / 2),
          (d = u / 2),
          (a = t.x - h),
          (c = t.x + h),
          (l = t.y - d),
          (f = t.y + d),
          (t.align = 'center'),
          a < 0 && c <= i ? (t.align = 'left') : 0 <= a && i < c && (t.align = 'right'),
          (t.baseline = 'middle'),
          l < 0 && f <= o ? (t.baseline = 'top') : 0 <= l && o < f && (t.baseline = 'bottom'),
          !0
        );
      };
    },
    'reduced-search': function (t, n, e, r) {
      const i = t.width,
        o = t.height,
        u = n[0],
        s = n[1];
      function a(n, e, r, a, c) {
        const l = t.invert(n),
          f = t.invert(e);
        let h,
          d = r,
          p = o;
        if (!yD(l, f, a, c, i, o) && !wD(t, l, f, c, a, d, u, s) && !wD(t, l, f, c, a, c, u, null)) {
          for (; p - d >= 1; ) (h = (d + p) / 2), wD(t, l, f, c, a, h, u, s) ? (p = h) : (d = h);
          if (d > r) return [l, f, d, !0];
        }
      }
      return function (n) {
        const s = n.datum.datum.items[r].items,
          c = s.length,
          l = n.datum.fontSize,
          f = wg.width(n.datum, n.datum.text);
        let h,
          d,
          p,
          m,
          v,
          g,
          b,
          y,
          w,
          x,
          O,
          k,
          A,
          $,
          M,
          j,
          D,
          F = e ? l : 0,
          E = !1,
          S = !1,
          C = 0;
        for (let r = 0; r < c; ++r) {
          for (
            h = s[r].x,
              p = s[r].y,
              d = void 0 === s[r].x2 ? h : s[r].x2,
              m = void 0 === s[r].y2 ? p : s[r].y2,
              h > d && ((D = h), (h = d), (d = D)),
              p > m && ((D = p), (p = m), (m = D)),
              w = t(h),
              O = t(d),
              x = ~~((w + O) / 2),
              k = t(p),
              $ = t(m),
              A = ~~((k + $) / 2),
              b = x;
            b >= w;
            --b
          )
            for (y = A; y >= k; --y) (j = a(b, y, F, f, l)), j && ([n.x, n.y, F, E] = j);
          for (b = x; b <= O; ++b) for (y = A; y <= $; ++y) (j = a(b, y, F, f, l)), j && ([n.x, n.y, F, E] = j);
          E ||
            e ||
            ((M = Math.abs(d - h + m - p)),
            (v = (h + d) / 2),
            (g = (p + m) / 2),
            M >= C &&
              !yD(v, g, f, l, i, o) &&
              !wD(t, v, g, l, f, l, u, null) &&
              ((C = M), (n.x = v), (n.y = g), (S = !0)));
        }
        return !(
          (!E && !S) ||
          ((v = f / 2),
          (g = l / 2),
          u.setRange(t(n.x - v), t(n.y - g), t(n.x + v), t(n.y + g)),
          (n.align = 'center'),
          (n.baseline = 'middle'),
          0)
        );
      };
    },
    floodfill: function (t, n, e, r) {
      const i = t.width,
        o = t.height,
        u = n[0],
        s = n[1],
        a = t.bitmap();
      return function (n) {
        const c = n.datum.datum.items[r].items,
          l = c.length,
          f = n.datum.fontSize,
          h = wg.width(n.datum, n.datum.text),
          d = [];
        let p,
          m,
          v,
          g,
          b,
          y,
          w,
          x,
          O,
          k,
          A,
          $,
          M = e ? f : 0,
          j = !1,
          D = !1,
          F = 0;
        for (let r = 0; r < l; ++r) {
          for (
            p = c[r].x,
              v = c[r].y,
              m = void 0 === c[r].x2 ? p : c[r].x2,
              g = void 0 === c[r].y2 ? v : c[r].y2,
              d.push([t((p + m) / 2), t((v + g) / 2)]);
            d.length;

          )
            if ((([w, x] = d.pop()), !(u.get(w, x) || s.get(w, x) || a.get(w, x)))) {
              a.set(w, x);
              for (let t = 0; t < 4; ++t) (b = w + xD[t]), (y = x + OD[t]), a.outOfBounds(b, y, b, y) || d.push([b, y]);
              if (
                ((b = t.invert(w)),
                (y = t.invert(x)),
                (O = M),
                (k = o),
                !yD(b, y, h, f, i, o) && !wD(t, b, y, f, h, O, u, s) && !wD(t, b, y, f, h, f, u, null))
              ) {
                for (; k - O >= 1; ) (A = (O + k) / 2), wD(t, b, y, f, h, A, u, s) ? (k = A) : (O = A);
                O > M && ((n.x = b), (n.y = y), (M = O), (j = !0));
              }
            }
          j ||
            e ||
            (($ = Math.abs(m - p + g - v)),
            (b = (p + m) / 2),
            (y = (v + g) / 2),
            $ >= F &&
              !yD(b, y, h, f, i, o) &&
              !wD(t, b, y, f, h, f, u, null) &&
              ((F = $), (n.x = b), (n.y = y), (D = !0)));
        }
        return !(
          (!j && !D) ||
          ((b = h / 2),
          (y = f / 2),
          u.setRange(t(n.x - b), t(n.y - y), t(n.x + b), t(n.y + y)),
          (n.align = 'center'),
          (n.baseline = 'middle'),
          0)
        );
      };
    },
  };
function DD(t, n, e, r, i, o, u, s, a, c, l) {
  if (!t.length) return t;
  const f = Math.max(r.length, i.length),
    h = (function (t, n) {
      const e = new Float64Array(n),
        r = t.length;
      for (let n = 0; n < r; ++n) e[n] = t[n] || 0;
      for (let t = r; t < n; ++t) e[t] = e[r - 1];
      return e;
    })(r, f),
    d = (function (t, n) {
      const e = new Int8Array(n),
        r = t.length;
      for (let n = 0; n < r; ++n) e[n] |= MD[t[n]];
      for (let t = r; t < n; ++t) e[t] = e[r - 1];
      return e;
    })(i, f),
    p = (w = t[0].datum) && w.mark && w.mark.marktype,
    m = 'group' === p && t[0].datum.items[a].marktype,
    v = 'area' === m,
    g = (function (t, n, e, r) {
      const i = t => [t.x, t.x, t.x, t.y, t.y, t.y];
      return t
        ? 'line' === t || 'area' === t
          ? t => i(t.datum)
          : 'line' === n
          ? t => {
              const n = t.datum.items[r].items;
              return i(n.length ? n['start' === e ? 0 : n.length - 1] : { x: NaN, y: NaN });
            }
          : t => {
              const n = t.datum.bounds;
              return [n.x1, (n.x1 + n.x2) / 2, n.x2, n.y1, (n.y1 + n.y2) / 2, n.y2];
            }
        : i;
    })(p, m, s, a),
    b = null === c || c === 1 / 0,
    y = v && 'naive' === l;
  var w;
  let x = -1,
    O = -1;
  const k = t.map(t => {
    const n = b ? wg.width(t, t.text) : void 0;
    return (
      (x = Math.max(x, n)),
      (O = Math.max(O, t.fontSize)),
      { datum: t, opacity: 0, x: void 0, y: void 0, align: void 0, baseline: void 0, boundary: g(t), textWidth: n }
    );
  });
  c = null === c || c === 1 / 0 ? Math.max(x, O) + Math.max(...r) : c;
  const A = (function (t, n, e) {
    const r = Math.max(1, Math.sqrt((t * n) / 1e6)),
      i = ~~((t + 2 * e + r) / r),
      o = ~~((n + 2 * e + r) / r),
      u = t => ~~((t + e) / r);
    return (
      (u.invert = t => t * r - e),
      (u.bitmap = () =>
        (function (t, n) {
          const e = new Uint32Array(~~((t * n + 32) / 32));
          function r(t, n) {
            e[t] |= n;
          }
          function i(t, n) {
            e[t] &= n;
          }
          return {
            array: e,
            get: (n, r) => {
              const i = r * t + n;
              return e[i >>> 5] & (1 << (i & vD));
            },
            set: (n, e) => {
              const i = e * t + n;
              r(i >>> 5, 1 << (i & vD));
            },
            clear: (n, e) => {
              const r = e * t + n;
              i(r >>> 5, ~(1 << (r & vD)));
            },
            getRange: (n, r, i, o) => {
              let u,
                s,
                a,
                c,
                l = o;
              for (; l >= r; --l)
                if (((u = l * t + n), (s = l * t + i), (a = u >>> 5), (c = s >>> 5), a === c)) {
                  if (e[a] & gD[u & vD] & bD[1 + (s & vD)]) return !0;
                } else {
                  if (e[a] & gD[u & vD]) return !0;
                  if (e[c] & bD[1 + (s & vD)]) return !0;
                  for (let t = a + 1; t < c; ++t) if (e[t]) return !0;
                }
              return !1;
            },
            setRange: (n, e, i, o) => {
              let u, s, a, c, l;
              for (; e <= o; ++e)
                if (((u = e * t + n), (s = e * t + i), (a = u >>> 5), (c = s >>> 5), a === c))
                  r(a, gD[u & vD] & bD[1 + (s & vD)]);
                else for (r(a, gD[u & vD]), r(c, bD[1 + (s & vD)]), l = a + 1; l < c; ++l) r(l, 4294967295);
            },
            clearRange: (n, e, r, o) => {
              let u, s, a, c, l;
              for (; e <= o; ++e)
                if (((u = e * t + n), (s = e * t + r), (a = u >>> 5), (c = s >>> 5), a === c))
                  i(a, bD[u & vD] | gD[1 + (s & vD)]);
                else for (i(a, bD[u & vD]), i(c, gD[1 + (s & vD)]), l = a + 1; l < c; ++l) i(l, 0);
            },
            outOfBounds: (e, r, i, o) => e < 0 || r < 0 || o >= n || i >= t,
          };
        })(i, o)),
      (u.ratio = r),
      (u.padding = e),
      (u.width = t),
      (u.height = n),
      u
    );
  })(n[0], n[1], c);
  let $;
  if (!y) {
    e && k.sort((t, n) => e(t.datum, n.datum));
    let n = !1;
    for (let t = 0; t < d.length && !n; ++t) n = 5 === d[t] || h[t] < 0;
    const r = ((p && u) || v) && t.map(t => t.datum);
    $ =
      o.length || r
        ? (function (t, n, e, r, i) {
            const o = t.width,
              u = t.height,
              s = r || i,
              a = ql(o, u).getContext('2d'),
              c = ql(o, u).getContext('2d'),
              l = s && ql(o, u).getContext('2d');
            e.forEach(t => pD(a, t, !1)), pD(c, n, !1), s && pD(l, n, !0);
            const f = dD(a, o, u),
              h = dD(c, o, u),
              d = s && dD(l, o, u),
              p = t.bitmap(),
              m = s && t.bitmap();
            let v, g, b, y, w, x, O, k;
            for (g = 0; g < u; ++g)
              for (v = 0; v < o; ++v)
                (w = g * o + v),
                  (x = f[w] & hD),
                  (k = h[w] & hD),
                  (O = s && d[w] & hD),
                  (x || O || k) &&
                    ((b = t(v)), (y = t(g)), i || (!x && !k) || p.set(b, y), s && (x || O) && m.set(b, y));
            return [p, m];
          })(A, r || [], o, n, v)
        : (function (t, n) {
            const e = t.bitmap();
            return (n || []).forEach(n => e.set(t(n.boundary[0]), t(n.boundary[3]))), [e, void 0];
          })(A, u && k);
  }
  const M = v
    ? jD[l](A, $, u, a)
    : (function (t, n, e, r) {
        const i = t.width,
          o = t.height,
          u = n[0],
          s = n[1],
          a = r.length;
        return function (n) {
          var c;
          const l = n.boundary,
            f = n.datum.fontSize;
          if (l[2] < 0 || l[5] < 0 || l[0] > i || l[3] > o) return !1;
          let h,
            d,
            p,
            m,
            v,
            g,
            b,
            y,
            w,
            x,
            O,
            k,
            A,
            $,
            M,
            j = null !== (c = n.textWidth) && void 0 !== c ? c : 0;
          for (let i = 0; i < a; ++i) {
            if (
              ((h = (3 & e[i]) - 1),
              (d = ((e[i] >>> 2) & 3) - 1),
              (p = (0 === h && 0 === d) || r[i] < 0),
              (m = h && d ? Math.SQRT1_2 : 1),
              (v = r[i] < 0 ? -1 : 1),
              (g = l[1 + h] + r[i] * h * m),
              (O = l[4 + d] + (v * f * d) / 2 + r[i] * d * m),
              (y = O - f / 2),
              (w = O + f / 2),
              (k = t(g)),
              ($ = t(y)),
              (M = t(w)),
              !j)
            ) {
              if (!$D(k, k, $, M, u, s, 0, 0, 0, 0, 0, p)) continue;
              j = wg.width(n.datum, n.datum.text);
            }
            if (
              ((x = g + (v * j * h) / 2),
              (g = x - j / 2),
              (b = x + j / 2),
              (k = t(g)),
              (A = t(b)),
              $D(k, A, $, M, u, s, 0, 0, 0, 0, 0, p))
            )
              return (
                (n.x = h ? (h * v < 0 ? b : g) : x),
                (n.y = d ? (d * v < 0 ? w : y) : O),
                (n.align = kD[h * v + 1]),
                (n.baseline = AD[d * v + 1]),
                u.setRange(k, $, A, M),
                !0
              );
          }
          return !1;
        };
      })(A, $, d, h);
  return k.forEach(t => (t.opacity = +M(t))), k;
}
const FD = ['x', 'y', 'opacity', 'align', 'baseline'],
  ED = ['top-left', 'left', 'bottom-left', 'top', 'bottom', 'top-right', 'right', 'bottom-right'];
function SD(t) {
  os.call(this, null, t);
}
(SD.Definition = {
  type: 'Label',
  metadata: { modifies: !0 },
  params: [
    { name: 'size', type: 'number', array: !0, length: 2, required: !0 },
    { name: 'sort', type: 'compare' },
    { name: 'anchor', type: 'string', array: !0, default: ED },
    { name: 'offset', type: 'number', array: !0, default: [1] },
    { name: 'padding', type: 'number', default: 0, null: !0 },
    { name: 'lineAnchor', type: 'string', values: ['start', 'end'], default: 'end' },
    { name: 'markIndex', type: 'number', default: 0 },
    { name: 'avoidBaseMark', type: 'boolean', default: !0 },
    { name: 'avoidMarks', type: 'data', array: !0 },
    { name: 'method', type: 'string', default: 'naive' },
    { name: 'as', type: 'string', array: !0, length: FD.length, default: FD },
  ],
}),
  It(SD, os, {
    transform(t, n) {
      const e = t.modified();
      if (
        !(
          e ||
          n.changed(n.ADD_REM) ||
          (function () {
            const e = t.sort;
            return Mt(e) && n.modified(e.fields);
          })()
        )
      )
        return;
      (t.size && 2 === t.size.length) || I('Size parameter should be specified as a [width, height] array.');
      const r = t.as || FD;
      return (
        DD(
          n.materialize(n.SOURCE).source || [],
          t.size,
          t.sort,
          At(null == t.offset ? 1 : t.offset),
          At(t.anchor || ED),
          t.avoidMarks || [],
          !1 !== t.avoidBaseMark,
          t.lineAnchor || 'end',
          t.markIndex || 0,
          void 0 === t.padding ? 0 : t.padding,
          t.method || 'naive',
        ).forEach(t => {
          const n = t.datum;
          (n[r[0]] = t.x), (n[r[1]] = t.y), (n[r[2]] = t.opacity), (n[r[3]] = t.align), (n[r[4]] = t.baseline);
        }),
        n.reflow(e).modifies(r)
      );
    },
  });
const CD = Object.freeze({ __proto__: null, label: SD });
function ND(t, n) {
  var e,
    r,
    i,
    o,
    u,
    s,
    a = [],
    c = function (t) {
      return t(o);
    };
  if (null == n) a.push(t);
  else
    for (e = {}, r = 0, i = t.length; r < i; ++r)
      (o = t[r]), (s = e[(u = n.map(c))]) || ((e[u] = s = []), (s.dims = u), a.push(s)), s.push(o);
  return a;
}
function BD(t) {
  os.call(this, null, t);
}
(BD.Definition = {
  type: 'Loess',
  metadata: { generates: !0 },
  params: [
    { name: 'x', type: 'field', required: !0 },
    { name: 'y', type: 'field', required: !0 },
    { name: 'groupby', type: 'field', array: !0 },
    { name: 'bandwidth', type: 'number', default: 0.3 },
    { name: 'as', type: 'string', array: !0 },
  ],
}),
  It(BD, os, {
    transform(t, n) {
      const e = n.fork(n.NO_SOURCE | n.NO_FIELDS);
      if (!this.value || n.changed() || t.modified()) {
        const r = ND(n.materialize(n.SOURCE).source, t.groupby),
          i = (t.groupby || []).map(T),
          o = i.length,
          u = t.as || [T(t.x), T(t.y)],
          s = [];
        r.forEach(n => {
          Ys(n, t.x, t.y, t.bandwidth || 0.3).forEach(t => {
            const e = {};
            for (let t = 0; t < o; ++t) e[i[t]] = n.dims[t];
            (e[u[0]] = t[0]), (e[u[1]] = t[1]), s.push(Fu(e));
          });
        }),
          this.value && (e.rem = this.value),
          (this.value = e.add = e.source = s);
      }
      return e;
    },
  });
const _D = { linear: qs, log: Is, exp: Us, pow: Ws, quad: Hs, poly: Gs };
function zD(t) {
  os.call(this, null, t);
}
(zD.Definition = {
  type: 'Regression',
  metadata: { generates: !0 },
  params: [
    { name: 'x', type: 'field', required: !0 },
    { name: 'y', type: 'field', required: !0 },
    { name: 'groupby', type: 'field', array: !0 },
    { name: 'method', type: 'string', default: 'linear', values: Object.keys(_D) },
    { name: 'order', type: 'number', default: 3 },
    { name: 'extent', type: 'number', array: !0, length: 2 },
    { name: 'params', type: 'boolean', default: !1 },
    { name: 'as', type: 'string', array: !0 },
  ],
}),
  It(zD, os, {
    transform(t, n) {
      const e = n.fork(n.NO_SOURCE | n.NO_FIELDS);
      if (!this.value || n.changed() || t.modified()) {
        const r = ND(n.materialize(n.SOURCE).source, t.groupby),
          i = (t.groupby || []).map(T),
          o = t.method || 'linear',
          u = t.order || 3,
          s = ((t, n) => ('poly' === t ? n : 'quad' === t ? 2 : 1))(o, u),
          a = t.as || [T(t.x), T(t.y)],
          c = _D[o],
          l = [];
        let f = t.extent;
        Pt(_D, o) || I('Invalid regression method: ' + o),
          null != f &&
            'log' === o &&
            f[0] <= 0 &&
            (n.dataflow.warn('Ignoring extent with values <= 0 for log regression.'), (f = null)),
          r.forEach(e => {
            if (e.length <= s)
              return void n.dataflow.warn('Skipping regression with more parameters than data points.');
            const r = c(e, t.x, t.y, u);
            if (t.params) return void l.push(Fu({ keys: e.dims, coef: r.coef, rSquared: r.rSquared }));
            const h = f || _t(e, t.x),
              d = t => {
                const n = {};
                for (let t = 0; t < i.length; ++t) n[i[t]] = e.dims[t];
                (n[a[0]] = t[0]), (n[a[1]] = t[1]), l.push(Fu(n));
              };
            'linear' === o ? h.forEach(t => d([t, r.predict(t)])) : Zs(r.predict, h, 25, 200).forEach(d);
          }),
          this.value && (e.rem = this.value),
          (this.value = e.add = e.source = l);
      }
      return e;
    },
  });
const TD = Object.freeze({ __proto__: null, loess: BD, regression: zD }),
  PD = 134217729;
function RD(t, n, e, r, i) {
  let o,
    u,
    s,
    a,
    c = n[0],
    l = r[0],
    f = 0,
    h = 0;
  l > c == l > -c ? ((o = c), (c = n[++f])) : ((o = l), (l = r[++h]));
  let d = 0;
  if (f < t && h < e)
    for (
      l > c == l > -c ? ((u = c + o), (s = o - (u - c)), (c = n[++f])) : ((u = l + o), (s = o - (u - l)), (l = r[++h])),
        o = u,
        0 !== s && (i[d++] = s);
      f < t && h < e;

    )
      l > c == l > -c
        ? ((u = o + c), (a = u - o), (s = o - (u - a) + (c - a)), (c = n[++f]))
        : ((u = o + l), (a = u - o), (s = o - (u - a) + (l - a)), (l = r[++h])),
        (o = u),
        0 !== s && (i[d++] = s);
  for (; f < t; ) (u = o + c), (a = u - o), (s = o - (u - a) + (c - a)), (c = n[++f]), (o = u), 0 !== s && (i[d++] = s);
  for (; h < e; ) (u = o + l), (a = u - o), (s = o - (u - a) + (l - a)), (l = r[++h]), (o = u), 0 !== s && (i[d++] = s);
  return (0 === o && 0 !== d) || (i[d++] = o), d;
}
function LD(t) {
  return new Float64Array(t);
}
const qD = LD(4),
  ID = LD(8),
  UD = LD(12),
  WD = LD(16),
  HD = LD(4);
function GD(t, n, e, r, i, o) {
  const u = (n - o) * (e - i),
    s = (t - i) * (r - o),
    a = u - s;
  if (0 === u || 0 === s || u > 0 != s > 0) return a;
  const c = Math.abs(u + s);
  return Math.abs(a) >= 33306690738754716e-32 * c
    ? a
    : -(function (t, n, e, r, i, o, u) {
        let s, a, c, l, f, h, d, p, m, v, g, b, y, w, x, O, k, A;
        const $ = t - i,
          M = e - i,
          j = n - o,
          D = r - o;
        (w = $ * D),
          (h = PD * $),
          (d = h - (h - $)),
          (p = $ - d),
          (h = PD * D),
          (m = h - (h - D)),
          (v = D - m),
          (x = p * v - (w - d * m - p * m - d * v)),
          (O = j * M),
          (h = PD * j),
          (d = h - (h - j)),
          (p = j - d),
          (h = PD * M),
          (m = h - (h - M)),
          (v = M - m),
          (k = p * v - (O - d * m - p * m - d * v)),
          (g = x - k),
          (f = x - g),
          (qD[0] = x - (g + f) + (f - k)),
          (b = w + g),
          (f = b - w),
          (y = w - (b - f) + (g - f)),
          (g = y - O),
          (f = y - g),
          (qD[1] = y - (g + f) + (f - O)),
          (A = b + g),
          (f = A - b),
          (qD[2] = b - (A - f) + (g - f)),
          (qD[3] = A);
        let F = (function (t, n) {
            let e = n[0];
            for (let t = 1; t < 4; t++) e += n[t];
            return e;
          })(0, qD),
          E = 22204460492503146e-32 * u;
        if (F >= E || -F >= E) return F;
        if (
          ((f = t - $),
          (s = t - ($ + f) + (f - i)),
          (f = e - M),
          (c = e - (M + f) + (f - i)),
          (f = n - j),
          (a = n - (j + f) + (f - o)),
          (f = r - D),
          (l = r - (D + f) + (f - o)),
          0 === s && 0 === a && 0 === c && 0 === l)
        )
          return F;
        if (
          ((E = 11093356479670487e-47 * u + 33306690738754706e-32 * Math.abs(F)),
          (F += $ * l + D * s - (j * c + M * a)),
          F >= E || -F >= E)
        )
          return F;
        (w = s * D),
          (h = PD * s),
          (d = h - (h - s)),
          (p = s - d),
          (h = PD * D),
          (m = h - (h - D)),
          (v = D - m),
          (x = p * v - (w - d * m - p * m - d * v)),
          (O = a * M),
          (h = PD * a),
          (d = h - (h - a)),
          (p = a - d),
          (h = PD * M),
          (m = h - (h - M)),
          (v = M - m),
          (k = p * v - (O - d * m - p * m - d * v)),
          (g = x - k),
          (f = x - g),
          (HD[0] = x - (g + f) + (f - k)),
          (b = w + g),
          (f = b - w),
          (y = w - (b - f) + (g - f)),
          (g = y - O),
          (f = y - g),
          (HD[1] = y - (g + f) + (f - O)),
          (A = b + g),
          (f = A - b),
          (HD[2] = b - (A - f) + (g - f)),
          (HD[3] = A);
        const S = RD(4, qD, 4, HD, ID);
        (w = $ * l),
          (h = PD * $),
          (d = h - (h - $)),
          (p = $ - d),
          (h = PD * l),
          (m = h - (h - l)),
          (v = l - m),
          (x = p * v - (w - d * m - p * m - d * v)),
          (O = j * c),
          (h = PD * j),
          (d = h - (h - j)),
          (p = j - d),
          (h = PD * c),
          (m = h - (h - c)),
          (v = c - m),
          (k = p * v - (O - d * m - p * m - d * v)),
          (g = x - k),
          (f = x - g),
          (HD[0] = x - (g + f) + (f - k)),
          (b = w + g),
          (f = b - w),
          (y = w - (b - f) + (g - f)),
          (g = y - O),
          (f = y - g),
          (HD[1] = y - (g + f) + (f - O)),
          (A = b + g),
          (f = A - b),
          (HD[2] = b - (A - f) + (g - f)),
          (HD[3] = A);
        const C = RD(S, ID, 4, HD, UD);
        (w = s * l),
          (h = PD * s),
          (d = h - (h - s)),
          (p = s - d),
          (h = PD * l),
          (m = h - (h - l)),
          (v = l - m),
          (x = p * v - (w - d * m - p * m - d * v)),
          (O = a * c),
          (h = PD * a),
          (d = h - (h - a)),
          (p = a - d),
          (h = PD * c),
          (m = h - (h - c)),
          (v = c - m),
          (k = p * v - (O - d * m - p * m - d * v)),
          (g = x - k),
          (f = x - g),
          (HD[0] = x - (g + f) + (f - k)),
          (b = w + g),
          (f = b - w),
          (y = w - (b - f) + (g - f)),
          (g = y - O),
          (f = y - g),
          (HD[1] = y - (g + f) + (f - O)),
          (A = b + g),
          (f = A - b),
          (HD[2] = b - (A - f) + (g - f)),
          (HD[3] = A);
        const N = RD(C, UD, 4, HD, WD);
        return WD[N - 1];
      })(t, n, e, r, i, o, c);
}
const VD = Math.pow(2, -52),
  YD = new Uint32Array(512);
class XD {
  static from(t, n = nF, e = eF) {
    const r = t.length,
      i = new Float64Array(2 * r);
    for (let o = 0; o < r; o++) {
      const r = t[o];
      (i[2 * o] = n(r)), (i[2 * o + 1] = e(r));
    }
    return new XD(i);
  }
  constructor(t) {
    const n = t.length >> 1;
    if (n > 0 && 'number' != typeof t[0]) throw new Error('Expected coords to contain numbers.');
    this.coords = t;
    const e = Math.max(2 * n - 5, 0);
    (this._triangles = new Uint32Array(3 * e)),
      (this._halfedges = new Int32Array(3 * e)),
      (this._hashSize = Math.ceil(Math.sqrt(n))),
      (this._hullPrev = new Uint32Array(n)),
      (this._hullNext = new Uint32Array(n)),
      (this._hullTri = new Uint32Array(n)),
      (this._hullHash = new Int32Array(this._hashSize).fill(-1)),
      (this._ids = new Uint32Array(n)),
      (this._dists = new Float64Array(n)),
      this.update();
  }
  update() {
    const { coords: t, _hullPrev: n, _hullNext: e, _hullTri: r, _hullHash: i } = this,
      o = t.length >> 1;
    let u = 1 / 0,
      s = 1 / 0,
      a = -1 / 0,
      c = -1 / 0;
    for (let n = 0; n < o; n++) {
      const e = t[2 * n],
        r = t[2 * n + 1];
      e < u && (u = e), r < s && (s = r), e > a && (a = e), r > c && (c = r), (this._ids[n] = n);
    }
    const l = (u + a) / 2,
      f = (s + c) / 2;
    let h,
      d,
      p,
      m = 1 / 0;
    for (let n = 0; n < o; n++) {
      const e = JD(l, f, t[2 * n], t[2 * n + 1]);
      e < m && ((h = n), (m = e));
    }
    const v = t[2 * h],
      g = t[2 * h + 1];
    m = 1 / 0;
    for (let n = 0; n < o; n++) {
      if (n === h) continue;
      const e = JD(v, g, t[2 * n], t[2 * n + 1]);
      e < m && e > 0 && ((d = n), (m = e));
    }
    let b = t[2 * d],
      y = t[2 * d + 1],
      w = 1 / 0;
    for (let n = 0; n < o; n++) {
      if (n === h || n === d) continue;
      const e = ZD(v, g, b, y, t[2 * n], t[2 * n + 1]);
      e < w && ((p = n), (w = e));
    }
    let x = t[2 * p],
      O = t[2 * p + 1];
    if (w === 1 / 0) {
      for (let n = 0; n < o; n++) this._dists[n] = t[2 * n] - t[0] || t[2 * n + 1] - t[1];
      KD(this._ids, this._dists, 0, o - 1);
      const n = new Uint32Array(o);
      let e = 0;
      for (let t = 0, r = -1 / 0; t < o; t++) {
        const i = this._ids[t];
        this._dists[i] > r && ((n[e++] = i), (r = this._dists[i]));
      }
      return (
        (this.hull = n.subarray(0, e)),
        (this.triangles = new Uint32Array(0)),
        void (this.halfedges = new Uint32Array(0))
      );
    }
    if (GD(v, g, b, y, x, O) < 0) {
      const t = d,
        n = b,
        e = y;
      (d = p), (b = x), (y = O), (p = t), (x = n), (O = e);
    }
    const k = (function (t, n, e, r, i, o) {
      const u = e - t,
        s = r - n,
        a = i - t,
        c = o - n,
        l = u * u + s * s,
        f = a * a + c * c,
        h = 0.5 / (u * c - s * a);
      return { x: t + (c * l - s * f) * h, y: n + (u * f - a * l) * h };
    })(v, g, b, y, x, O);
    (this._cx = k.x), (this._cy = k.y);
    for (let n = 0; n < o; n++) this._dists[n] = JD(t[2 * n], t[2 * n + 1], k.x, k.y);
    KD(this._ids, this._dists, 0, o - 1), (this._hullStart = h);
    let A = 3;
    (e[h] = n[p] = d),
      (e[d] = n[h] = p),
      (e[p] = n[d] = h),
      (r[h] = 0),
      (r[d] = 1),
      (r[p] = 2),
      i.fill(-1),
      (i[this._hashKey(v, g)] = h),
      (i[this._hashKey(b, y)] = d),
      (i[this._hashKey(x, O)] = p),
      (this.trianglesLen = 0),
      this._addTriangle(h, d, p, -1, -1, -1);
    for (let o, u, s = 0; s < this._ids.length; s++) {
      const a = this._ids[s],
        c = t[2 * a],
        l = t[2 * a + 1];
      if (s > 0 && Math.abs(c - o) <= VD && Math.abs(l - u) <= VD) continue;
      if (((o = c), (u = l), a === h || a === d || a === p)) continue;
      let f = 0;
      for (
        let t = 0, n = this._hashKey(c, l);
        t < this._hashSize && ((f = i[(n + t) % this._hashSize]), -1 === f || f === e[f]);
        t++
      );
      f = n[f];
      let m,
        v = f;
      for (; (m = e[v]), GD(c, l, t[2 * v], t[2 * v + 1], t[2 * m], t[2 * m + 1]) >= 0; )
        if (((v = m), v === f)) {
          v = -1;
          break;
        }
      if (-1 === v) continue;
      let g = this._addTriangle(v, a, e[v], -1, -1, r[v]);
      (r[a] = this._legalize(g + 2)), (r[v] = g), A++;
      let b = e[v];
      for (; (m = e[b]), GD(c, l, t[2 * b], t[2 * b + 1], t[2 * m], t[2 * m + 1]) < 0; )
        (g = this._addTriangle(b, a, m, r[a], -1, r[b])), (r[a] = this._legalize(g + 2)), (e[b] = b), A--, (b = m);
      if (v === f)
        for (; (m = n[v]), GD(c, l, t[2 * m], t[2 * m + 1], t[2 * v], t[2 * v + 1]) < 0; )
          (g = this._addTriangle(m, a, v, -1, r[v], r[m])), this._legalize(g + 2), (r[m] = g), (e[v] = v), A--, (v = m);
      (this._hullStart = n[a] = v),
        (e[v] = n[b] = a),
        (e[a] = b),
        (i[this._hashKey(c, l)] = a),
        (i[this._hashKey(t[2 * v], t[2 * v + 1])] = v);
    }
    this.hull = new Uint32Array(A);
    for (let t = 0, n = this._hullStart; t < A; t++) (this.hull[t] = n), (n = e[n]);
    (this.triangles = this._triangles.subarray(0, this.trianglesLen)),
      (this.halfedges = this._halfedges.subarray(0, this.trianglesLen));
  }
  _hashKey(t, n) {
    return (
      Math.floor(
        (function (t, n) {
          const e = t / (Math.abs(t) + Math.abs(n));
          return (n > 0 ? 3 - e : 1 + e) / 4;
        })(t - this._cx, n - this._cy) * this._hashSize,
      ) % this._hashSize
    );
  }
  _legalize(t) {
    const { _triangles: n, _halfedges: e, coords: r } = this;
    let i = 0,
      o = 0;
    for (;;) {
      const u = e[t],
        s = t - (t % 3);
      if (((o = s + ((t + 2) % 3)), -1 === u)) {
        if (0 === i) break;
        t = YD[--i];
        continue;
      }
      const a = u - (u % 3),
        c = a + ((u + 2) % 3),
        l = n[o],
        f = n[t],
        h = n[s + ((t + 1) % 3)],
        d = n[c];
      if (QD(r[2 * l], r[2 * l + 1], r[2 * f], r[2 * f + 1], r[2 * h], r[2 * h + 1], r[2 * d], r[2 * d + 1])) {
        (n[t] = d), (n[u] = l);
        const r = e[c];
        if (-1 === r) {
          let n = this._hullStart;
          do {
            if (this._hullTri[n] === c) {
              this._hullTri[n] = t;
              break;
            }
            n = this._hullPrev[n];
          } while (n !== this._hullStart);
        }
        this._link(t, r), this._link(u, e[o]), this._link(o, c), i < YD.length && (YD[i++] = a + ((u + 1) % 3));
      } else {
        if (0 === i) break;
        t = YD[--i];
      }
    }
    return o;
  }
  _link(t, n) {
    (this._halfedges[t] = n), -1 !== n && (this._halfedges[n] = t);
  }
  _addTriangle(t, n, e, r, i, o) {
    const u = this.trianglesLen;
    return (
      (this._triangles[u] = t),
      (this._triangles[u + 1] = n),
      (this._triangles[u + 2] = e),
      this._link(u, r),
      this._link(u + 1, i),
      this._link(u + 2, o),
      (this.trianglesLen += 3),
      u
    );
  }
}
function JD(t, n, e, r) {
  const i = t - e,
    o = n - r;
  return i * i + o * o;
}
function QD(t, n, e, r, i, o, u, s) {
  const a = t - u,
    c = n - s,
    l = e - u,
    f = r - s,
    h = i - u,
    d = o - s,
    p = l * l + f * f,
    m = h * h + d * d;
  return a * (f * m - p * d) - c * (l * m - p * h) + (a * a + c * c) * (l * d - f * h) < 0;
}
function ZD(t, n, e, r, i, o) {
  const u = e - t,
    s = r - n,
    a = i - t,
    c = o - n,
    l = u * u + s * s,
    f = a * a + c * c,
    h = 0.5 / (u * c - s * a),
    d = (c * l - s * f) * h,
    p = (u * f - a * l) * h;
  return d * d + p * p;
}
function KD(t, n, e, r) {
  if (r - e <= 20)
    for (let i = e + 1; i <= r; i++) {
      const r = t[i],
        o = n[r];
      let u = i - 1;
      for (; u >= e && n[t[u]] > o; ) t[u + 1] = t[u--];
      t[u + 1] = r;
    }
  else {
    let i = e + 1,
      o = r;
    tF(t, (e + r) >> 1, i),
      n[t[e]] > n[t[r]] && tF(t, e, r),
      n[t[i]] > n[t[r]] && tF(t, i, r),
      n[t[e]] > n[t[i]] && tF(t, e, i);
    const u = t[i],
      s = n[u];
    for (;;) {
      do {
        i++;
      } while (n[t[i]] < s);
      do {
        o--;
      } while (n[t[o]] > s);
      if (o < i) break;
      tF(t, i, o);
    }
    (t[e + 1] = t[o]),
      (t[o] = u),
      r - i + 1 >= o - e ? (KD(t, n, i, r), KD(t, n, e, o - 1)) : (KD(t, n, e, o - 1), KD(t, n, i, r));
  }
}
function tF(t, n, e) {
  const r = t[n];
  (t[n] = t[e]), (t[e] = r);
}
function nF(t) {
  return t[0];
}
function eF(t) {
  return t[1];
}
const rF = 1e-6;
class iF {
  constructor() {
    (this._x0 = this._y0 = this._x1 = this._y1 = null), (this._ = '');
  }
  moveTo(t, n) {
    this._ += `M${(this._x0 = this._x1 = +t)},${(this._y0 = this._y1 = +n)}`;
  }
  closePath() {
    null !== this._x1 && ((this._x1 = this._x0), (this._y1 = this._y0), (this._ += 'Z'));
  }
  lineTo(t, n) {
    this._ += `L${(this._x1 = +t)},${(this._y1 = +n)}`;
  }
  arc(t, n, e) {
    const r = (t = +t) + (e = +e),
      i = (n = +n);
    if (e < 0) throw new Error('negative radius');
    null === this._x1
      ? (this._ += `M${r},${i}`)
      : (Math.abs(this._x1 - r) > rF || Math.abs(this._y1 - i) > rF) && (this._ += 'L' + r + ',' + i),
      e && (this._ += `A${e},${e},0,1,1,${t - e},${n}A${e},${e},0,1,1,${(this._x1 = r)},${(this._y1 = i)}`);
  }
  rect(t, n, e, r) {
    this._ += `M${(this._x0 = this._x1 = +t)},${(this._y0 = this._y1 = +n)}h${+e}v${+r}h${-e}Z`;
  }
  value() {
    return this._ || null;
  }
}
class oF {
  constructor() {
    this._ = [];
  }
  moveTo(t, n) {
    this._.push([t, n]);
  }
  closePath() {
    this._.push(this._[0].slice());
  }
  lineTo(t, n) {
    this._.push([t, n]);
  }
  value() {
    return this._.length ? this._ : null;
  }
}
class uF {
  constructor(t, [n, e, r, i] = [0, 0, 960, 500]) {
    if (!((r = +r) >= (n = +n) && (i = +i) >= (e = +e))) throw new Error('invalid bounds');
    (this.delaunay = t),
      (this._circumcenters = new Float64Array(2 * t.points.length)),
      (this.vectors = new Float64Array(2 * t.points.length)),
      (this.xmax = r),
      (this.xmin = n),
      (this.ymax = i),
      (this.ymin = e),
      this._init();
  }
  update() {
    return this.delaunay.update(), this._init(), this;
  }
  _init() {
    const {
        delaunay: { points: t, hull: n, triangles: e },
        vectors: r,
      } = this,
      i = (this.circumcenters = this._circumcenters.subarray(0, (e.length / 3) * 2));
    for (let n, r, o = 0, u = 0, s = e.length; o < s; o += 3, u += 2) {
      const s = 2 * e[o],
        a = 2 * e[o + 1],
        c = 2 * e[o + 2],
        l = t[s],
        f = t[s + 1],
        h = t[c],
        d = t[c + 1],
        p = t[a] - l,
        m = t[a + 1] - f,
        v = h - l,
        g = d - f,
        b = 2 * (p * g - m * v);
      if (Math.abs(b) < 1e-9) {
        let i = 1e9;
        const o = 2 * e[0];
        (i *= Math.sign((t[o] - l) * g - (t[o + 1] - f) * v)), (n = (l + h) / 2 - i * g), (r = (f + d) / 2 + i * v);
      } else {
        const t = 1 / b,
          e = p * p + m * m,
          i = v * v + g * g;
        (n = l + (g * e - m * i) * t), (r = f + (p * i - v * e) * t);
      }
      (i[u] = n), (i[u + 1] = r);
    }
    let o,
      u,
      s,
      a = n[n.length - 1],
      c = 4 * a,
      l = t[2 * a],
      f = t[2 * a + 1];
    r.fill(0);
    for (let e = 0; e < n.length; ++e)
      (a = n[e]),
        (o = c),
        (u = l),
        (s = f),
        (c = 4 * a),
        (l = t[2 * a]),
        (f = t[2 * a + 1]),
        (r[o + 2] = r[c] = s - f),
        (r[o + 3] = r[c + 1] = l - u);
  }
  render(t) {
    const n = null == t ? (t = new iF()) : void 0,
      {
        delaunay: { halfedges: e, inedges: r, hull: i },
        circumcenters: o,
        vectors: u,
      } = this;
    if (i.length <= 1) return null;
    for (let n = 0, r = e.length; n < r; ++n) {
      const r = e[n];
      if (r < n) continue;
      const i = 2 * Math.floor(n / 3),
        u = 2 * Math.floor(r / 3);
      this._renderSegment(o[i], o[i + 1], o[u], o[u + 1], t);
    }
    let s,
      a = i[i.length - 1];
    for (let n = 0; n < i.length; ++n) {
      (s = a), (a = i[n]);
      const e = 2 * Math.floor(r[a] / 3),
        c = o[e],
        l = o[e + 1],
        f = 4 * s,
        h = this._project(c, l, u[f + 2], u[f + 3]);
      h && this._renderSegment(c, l, h[0], h[1], t);
    }
    return n && n.value();
  }
  renderBounds(t) {
    const n = null == t ? (t = new iF()) : void 0;
    return t.rect(this.xmin, this.ymin, this.xmax - this.xmin, this.ymax - this.ymin), n && n.value();
  }
  renderCell(t, n) {
    const e = null == n ? (n = new iF()) : void 0,
      r = this._clip(t);
    if (null === r || !r.length) return;
    n.moveTo(r[0], r[1]);
    let i = r.length;
    for (; r[0] === r[i - 2] && r[1] === r[i - 1] && i > 1; ) i -= 2;
    for (let t = 2; t < i; t += 2) (r[t] === r[t - 2] && r[t + 1] === r[t - 1]) || n.lineTo(r[t], r[t + 1]);
    return n.closePath(), e && e.value();
  }
  *cellPolygons() {
    const {
      delaunay: { points: t },
    } = this;
    for (let n = 0, e = t.length / 2; n < e; ++n) {
      const t = this.cellPolygon(n);
      t && ((t.index = n), yield t);
    }
  }
  cellPolygon(t) {
    const n = new oF();
    return this.renderCell(t, n), n.value();
  }
  _renderSegment(t, n, e, r, i) {
    let o;
    const u = this._regioncode(t, n),
      s = this._regioncode(e, r);
    0 === u && 0 === s
      ? (i.moveTo(t, n), i.lineTo(e, r))
      : (o = this._clipSegment(t, n, e, r, u, s)) && (i.moveTo(o[0], o[1]), i.lineTo(o[2], o[3]));
  }
  contains(t, n, e) {
    return (n = +n) == n && (e = +e) == e && this.delaunay._step(t, n, e) === t;
  }
  *neighbors(t) {
    const n = this._clip(t);
    if (n)
      for (const e of this.delaunay.neighbors(t)) {
        const t = this._clip(e);
        if (t)
          t: for (let r = 0, i = n.length; r < i; r += 2)
            for (let o = 0, u = t.length; o < u; o += 2)
              if (
                n[r] == t[o] &&
                n[r + 1] == t[o + 1] &&
                n[(r + 2) % i] == t[(o + u - 2) % u] &&
                n[(r + 3) % i] == t[(o + u - 1) % u]
              ) {
                yield e;
                break t;
              }
      }
  }
  _cell(t) {
    const {
        circumcenters: n,
        delaunay: { inedges: e, halfedges: r, triangles: i },
      } = this,
      o = e[t];
    if (-1 === o) return null;
    const u = [];
    let s = o;
    do {
      const e = Math.floor(s / 3);
      if ((u.push(n[2 * e], n[2 * e + 1]), (s = s % 3 == 2 ? s - 2 : s + 1), i[s] !== t)) break;
      s = r[s];
    } while (s !== o && -1 !== s);
    return u;
  }
  _clip(t) {
    if (0 === t && 1 === this.delaunay.hull.length)
      return [this.xmax, this.ymin, this.xmax, this.ymax, this.xmin, this.ymax, this.xmin, this.ymin];
    const n = this._cell(t);
    if (null === n) return null;
    const { vectors: e } = this,
      r = 4 * t;
    return e[r] || e[r + 1] ? this._clipInfinite(t, n, e[r], e[r + 1], e[r + 2], e[r + 3]) : this._clipFinite(t, n);
  }
  _clipFinite(t, n) {
    const e = n.length;
    let r,
      i,
      o,
      u,
      s = null,
      a = n[e - 2],
      c = n[e - 1],
      l = this._regioncode(a, c),
      f = 0;
    for (let h = 0; h < e; h += 2)
      if (((r = a), (i = c), (a = n[h]), (c = n[h + 1]), (o = l), (l = this._regioncode(a, c)), 0 === o && 0 === l))
        (u = f), (f = 0), s ? s.push(a, c) : (s = [a, c]);
      else {
        let n, e, h, d, p;
        if (0 === o) {
          if (null === (n = this._clipSegment(r, i, a, c, o, l))) continue;
          [e, h, d, p] = n;
        } else {
          if (null === (n = this._clipSegment(a, c, r, i, l, o))) continue;
          ([d, p, e, h] = n),
            (u = f),
            (f = this._edgecode(e, h)),
            u && f && this._edge(t, u, f, s, s.length),
            s ? s.push(e, h) : (s = [e, h]);
        }
        (u = f),
          (f = this._edgecode(d, p)),
          u && f && this._edge(t, u, f, s, s.length),
          s ? s.push(d, p) : (s = [d, p]);
      }
    if (s) (u = f), (f = this._edgecode(s[0], s[1])), u && f && this._edge(t, u, f, s, s.length);
    else if (this.contains(t, (this.xmin + this.xmax) / 2, (this.ymin + this.ymax) / 2))
      return [this.xmax, this.ymin, this.xmax, this.ymax, this.xmin, this.ymax, this.xmin, this.ymin];
    return s;
  }
  _clipSegment(t, n, e, r, i, o) {
    for (;;) {
      if (0 === i && 0 === o) return [t, n, e, r];
      if (i & o) return null;
      let u,
        s,
        a = i || o;
      8 & a
        ? ((u = t + ((e - t) * (this.ymax - n)) / (r - n)), (s = this.ymax))
        : 4 & a
        ? ((u = t + ((e - t) * (this.ymin - n)) / (r - n)), (s = this.ymin))
        : 2 & a
        ? ((s = n + ((r - n) * (this.xmax - t)) / (e - t)), (u = this.xmax))
        : ((s = n + ((r - n) * (this.xmin - t)) / (e - t)), (u = this.xmin)),
        i ? (i = this._regioncode((t = u), (n = s))) : (o = this._regioncode((e = u), (r = s)));
    }
  }
  _clipInfinite(t, n, e, r, i, o) {
    let u,
      s = Array.from(n);
    if (
      ((u = this._project(s[0], s[1], e, r)) && s.unshift(u[0], u[1]),
      (u = this._project(s[s.length - 2], s[s.length - 1], i, o)) && s.push(u[0], u[1]),
      (s = this._clipFinite(t, s)))
    )
      for (let n, e = 0, r = s.length, i = this._edgecode(s[r - 2], s[r - 1]); e < r; e += 2)
        (n = i), (i = this._edgecode(s[e], s[e + 1])), n && i && ((e = this._edge(t, n, i, s, e)), (r = s.length));
    else
      this.contains(t, (this.xmin + this.xmax) / 2, (this.ymin + this.ymax) / 2) &&
        (s = [this.xmin, this.ymin, this.xmax, this.ymin, this.xmax, this.ymax, this.xmin, this.ymax]);
    return s;
  }
  _edge(t, n, e, r, i) {
    for (; n !== e; ) {
      let e, o;
      switch (n) {
        case 5:
          n = 4;
          continue;
        case 4:
          (n = 6), (e = this.xmax), (o = this.ymin);
          break;
        case 6:
          n = 2;
          continue;
        case 2:
          (n = 10), (e = this.xmax), (o = this.ymax);
          break;
        case 10:
          n = 8;
          continue;
        case 8:
          (n = 9), (e = this.xmin), (o = this.ymax);
          break;
        case 9:
          n = 1;
          continue;
        case 1:
          (n = 5), (e = this.xmin), (o = this.ymin);
      }
      (r[i] === e && r[i + 1] === o) || !this.contains(t, e, o) || (r.splice(i, 0, e, o), (i += 2));
    }
    if (r.length > 4)
      for (let t = 0; t < r.length; t += 2) {
        const n = (t + 2) % r.length,
          e = (t + 4) % r.length;
        ((r[t] === r[n] && r[n] === r[e]) || (r[t + 1] === r[n + 1] && r[n + 1] === r[e + 1])) &&
          (r.splice(n, 2), (t -= 2));
      }
    return i;
  }
  _project(t, n, e, r) {
    let i,
      o,
      u,
      s = 1 / 0;
    if (r < 0) {
      if (n <= this.ymin) return null;
      (i = (this.ymin - n) / r) < s && ((u = this.ymin), (o = t + (s = i) * e));
    } else if (r > 0) {
      if (n >= this.ymax) return null;
      (i = (this.ymax - n) / r) < s && ((u = this.ymax), (o = t + (s = i) * e));
    }
    if (e > 0) {
      if (t >= this.xmax) return null;
      (i = (this.xmax - t) / e) < s && ((o = this.xmax), (u = n + (s = i) * r));
    } else if (e < 0) {
      if (t <= this.xmin) return null;
      (i = (this.xmin - t) / e) < s && ((o = this.xmin), (u = n + (s = i) * r));
    }
    return [o, u];
  }
  _edgecode(t, n) {
    return (t === this.xmin ? 1 : t === this.xmax ? 2 : 0) | (n === this.ymin ? 4 : n === this.ymax ? 8 : 0);
  }
  _regioncode(t, n) {
    return (t < this.xmin ? 1 : t > this.xmax ? 2 : 0) | (n < this.ymin ? 4 : n > this.ymax ? 8 : 0);
  }
}
const sF = 2 * Math.PI,
  aF = Math.pow;
function cF(t) {
  return t[0];
}
function lF(t) {
  return t[1];
}
function fF(t, n, e) {
  return [t + Math.sin(t + n) * e, n + Math.cos(t - n) * e];
}
class hF {
  static from(t, n = cF, e = lF, r) {
    return new hF(
      'length' in t
        ? (function (t, n, e, r) {
            const i = t.length,
              o = new Float64Array(2 * i);
            for (let u = 0; u < i; ++u) {
              const i = t[u];
              (o[2 * u] = n.call(r, i, u, t)), (o[2 * u + 1] = e.call(r, i, u, t));
            }
            return o;
          })(t, n, e, r)
        : Float64Array.from(
            (function* (t, n, e, r) {
              let i = 0;
              for (const o of t) yield n.call(r, o, i, t), yield e.call(r, o, i, t), ++i;
            })(t, n, e, r),
          ),
    );
  }
  constructor(t) {
    (this._delaunator = new XD(t)),
      (this.inedges = new Int32Array(t.length / 2)),
      (this._hullIndex = new Int32Array(t.length / 2)),
      (this.points = this._delaunator.coords),
      this._init();
  }
  update() {
    return this._delaunator.update(), this._init(), this;
  }
  _init() {
    const t = this._delaunator,
      n = this.points;
    if (
      t.hull &&
      t.hull.length > 2 &&
      (function (t) {
        const { triangles: n, coords: e } = t;
        for (let t = 0; t < n.length; t += 3) {
          const r = 2 * n[t],
            i = 2 * n[t + 1],
            o = 2 * n[t + 2];
          if ((e[o] - e[r]) * (e[i + 1] - e[r + 1]) - (e[i] - e[r]) * (e[o + 1] - e[r + 1]) > 1e-10) return !1;
        }
        return !0;
      })(t)
    ) {
      this.collinear = Int32Array.from({ length: n.length / 2 }, (t, n) => n).sort(
        (t, e) => n[2 * t] - n[2 * e] || n[2 * t + 1] - n[2 * e + 1],
      );
      const t = this.collinear[0],
        e = this.collinear[this.collinear.length - 1],
        r = [n[2 * t], n[2 * t + 1], n[2 * e], n[2 * e + 1]],
        i = 1e-8 * Math.hypot(r[3] - r[1], r[2] - r[0]);
      for (let t = 0, e = n.length / 2; t < e; ++t) {
        const e = fF(n[2 * t], n[2 * t + 1], i);
        (n[2 * t] = e[0]), (n[2 * t + 1] = e[1]);
      }
      this._delaunator = new XD(n);
    } else delete this.collinear;
    const e = (this.halfedges = this._delaunator.halfedges),
      r = (this.hull = this._delaunator.hull),
      i = (this.triangles = this._delaunator.triangles),
      o = this.inedges.fill(-1),
      u = this._hullIndex.fill(-1);
    for (let t = 0, n = e.length; t < n; ++t) {
      const n = i[t % 3 == 2 ? t - 2 : t + 1];
      (-1 !== e[t] && -1 !== o[n]) || (o[n] = t);
    }
    for (let t = 0, n = r.length; t < n; ++t) u[r[t]] = t;
    r.length <= 2 &&
      r.length > 0 &&
      ((this.triangles = new Int32Array(3).fill(-1)),
      (this.halfedges = new Int32Array(3).fill(-1)),
      (this.triangles[0] = r[0]),
      (o[r[0]] = 1),
      2 === r.length && ((o[r[1]] = 0), (this.triangles[1] = r[1]), (this.triangles[2] = r[1])));
  }
  voronoi(t) {
    return new uF(this, t);
  }
  *neighbors(t) {
    const { inedges: n, hull: e, _hullIndex: r, halfedges: i, triangles: o, collinear: u } = this;
    if (u) {
      const n = u.indexOf(t);
      return n > 0 && (yield u[n - 1]), void (n < u.length - 1 && (yield u[n + 1]));
    }
    const s = n[t];
    if (-1 === s) return;
    let a = s,
      c = -1;
    do {
      if ((yield (c = o[a]), (a = a % 3 == 2 ? a - 2 : a + 1), o[a] !== t)) return;
      if (((a = i[a]), -1 === a)) {
        const n = e[(r[t] + 1) % e.length];
        return void (n !== c && (yield n));
      }
    } while (a !== s);
  }
  find(t, n, e = 0) {
    if ((t = +t) != t || (n = +n) != n) return -1;
    const r = e;
    let i;
    for (; (i = this._step(e, t, n)) >= 0 && i !== e && i !== r; ) e = i;
    return i;
  }
  _step(t, n, e) {
    const { inedges: r, hull: i, _hullIndex: o, halfedges: u, triangles: s, points: a } = this;
    if (-1 === r[t] || !a.length) return (t + 1) % (a.length >> 1);
    let c = t,
      l = aF(n - a[2 * t], 2) + aF(e - a[2 * t + 1], 2);
    const f = r[t];
    let h = f;
    do {
      let r = s[h];
      const f = aF(n - a[2 * r], 2) + aF(e - a[2 * r + 1], 2);
      if ((f < l && ((l = f), (c = r)), (h = h % 3 == 2 ? h - 2 : h + 1), s[h] !== t)) break;
      if (((h = u[h]), -1 === h)) {
        if (((h = i[(o[t] + 1) % i.length]), h !== r && aF(n - a[2 * h], 2) + aF(e - a[2 * h + 1], 2) < l)) return h;
        break;
      }
    } while (h !== f);
    return c;
  }
  render(t) {
    const n = null == t ? (t = new iF()) : void 0,
      { points: e, halfedges: r, triangles: i } = this;
    for (let n = 0, o = r.length; n < o; ++n) {
      const o = r[n];
      if (o < n) continue;
      const u = 2 * i[n],
        s = 2 * i[o];
      t.moveTo(e[u], e[u + 1]), t.lineTo(e[s], e[s + 1]);
    }
    return this.renderHull(t), n && n.value();
  }
  renderPoints(t, n) {
    void 0 !== n || (t && 'function' == typeof t.moveTo) || ((n = t), (t = null)), (n = null == n ? 2 : +n);
    const e = null == t ? (t = new iF()) : void 0,
      { points: r } = this;
    for (let e = 0, i = r.length; e < i; e += 2) {
      const i = r[e],
        o = r[e + 1];
      t.moveTo(i + n, o), t.arc(i, o, n, 0, sF);
    }
    return e && e.value();
  }
  renderHull(t) {
    const n = null == t ? (t = new iF()) : void 0,
      { hull: e, points: r } = this,
      i = 2 * e[0],
      o = e.length;
    t.moveTo(r[i], r[i + 1]);
    for (let n = 1; n < o; ++n) {
      const i = 2 * e[n];
      t.lineTo(r[i], r[i + 1]);
    }
    return t.closePath(), n && n.value();
  }
  hullPolygon() {
    const t = new oF();
    return this.renderHull(t), t.value();
  }
  renderTriangle(t, n) {
    const e = null == n ? (n = new iF()) : void 0,
      { points: r, triangles: i } = this,
      o = 2 * i[(t *= 3)],
      u = 2 * i[t + 1],
      s = 2 * i[t + 2];
    return n.moveTo(r[o], r[o + 1]), n.lineTo(r[u], r[u + 1]), n.lineTo(r[s], r[s + 1]), n.closePath(), e && e.value();
  }
  *trianglePolygons() {
    const { triangles: t } = this;
    for (let n = 0, e = t.length / 3; n < e; ++n) yield this.trianglePolygon(n);
  }
  trianglePolygon(t) {
    const n = new oF();
    return this.renderTriangle(t, n), n.value();
  }
}
function dF(t) {
  os.call(this, null, t);
}
dF.Definition = {
  type: 'Voronoi',
  metadata: { modifies: !0 },
  params: [
    { name: 'x', type: 'field', required: !0 },
    { name: 'y', type: 'field', required: !0 },
    { name: 'size', type: 'number', array: !0, length: 2 },
    {
      name: 'extent',
      type: 'array',
      array: !0,
      length: 2,
      default: [
        [-1e5, -1e5],
        [1e5, 1e5],
      ],
      content: { type: 'number', array: !0, length: 2 },
    },
    { name: 'as', type: 'string', default: 'path' },
  ],
};
const pF = [-1e5, -1e5, 1e5, 1e5];
function mF(t) {
  const n = t[0][0],
    e = t[0][1];
  let r = t.length - 1;
  for (; t[r][0] === n && t[r][1] === e; --r);
  return 'M' + t.slice(0, r + 1).join('L') + 'Z';
}
It(dF, os, {
  transform(t, n) {
    const e = t.as || 'path',
      r = n.source;
    if (!r || !r.length) return n;
    let i = t.size;
    i = i ? [0, 0, i[0], i[1]] : (i = t.extent) ? [i[0][0], i[0][1], i[1][0], i[1][1]] : pF;
    const o = (this.value = hF.from(r, t.x, t.y).voronoi(i));
    for (let t = 0, n = r.length; t < n; ++t) {
      const n = o.cellPolygon(t);
      r[t][e] = n ? mF(n) : null;
    }
    return n.reflow(t.modified()).modifies(e);
  },
});
const vF = Object.freeze({ __proto__: null, voronoi: dF });
var gF = Math.PI / 180,
  bF = 2048;
function yF(t, n, e, r) {
  if (!n.sprite) {
    var i = t.context,
      o = t.ratio;
    i.clearRect(0, 0, 2048 / o, bF / o);
    var u,
      s,
      a,
      c,
      l,
      f = 0,
      h = 0,
      d = 0,
      p = e.length;
    for (--r; ++r < p; ) {
      if (
        ((n = e[r]),
        i.save(),
        (i.font = n.style + ' ' + n.weight + ' ' + ~~((n.size + 1) / o) + 'px ' + n.font),
        (u = i.measureText(n.text + 'm').width * o),
        (a = n.size << 1),
        n.rotate)
      ) {
        var m = Math.sin(n.rotate * gF),
          v = Math.cos(n.rotate * gF),
          g = u * v,
          b = u * m,
          y = a * v,
          w = a * m;
        (u = ((Math.max(Math.abs(g + w), Math.abs(g - w)) + 31) >> 5) << 5),
          (a = ~~Math.max(Math.abs(b + y), Math.abs(b - y)));
      } else u = ((u + 31) >> 5) << 5;
      if ((a > d && (d = a), f + u >= 2048 && ((f = 0), (h += d), (d = 0)), h + a >= bF)) break;
      i.translate((f + (u >> 1)) / o, (h + (a >> 1)) / o),
        n.rotate && i.rotate(n.rotate * gF),
        i.fillText(n.text, 0, 0),
        n.padding && ((i.lineWidth = 2 * n.padding), i.strokeText(n.text, 0, 0)),
        i.restore(),
        (n.width = u),
        (n.height = a),
        (n.xoff = f),
        (n.yoff = h),
        (n.x1 = u >> 1),
        (n.y1 = a >> 1),
        (n.x0 = -n.x1),
        (n.y0 = -n.y1),
        (n.hasText = !0),
        (f += u);
    }
    for (var x = i.getImageData(0, 0, 2048 / o, bF / o).data, O = []; --r >= 0; )
      if ((n = e[r]).hasText) {
        for (s = (u = n.width) >> 5, a = n.y1 - n.y0, c = 0; c < a * s; c++) O[c] = 0;
        if (null == (f = n.xoff)) return;
        h = n.yoff;
        var k = 0,
          A = -1;
        for (l = 0; l < a; l++) {
          for (c = 0; c < u; c++) {
            var $ = x[(2048 * (h + l) + (f + c)) << 2] ? 1 << (31 - (c % 32)) : 0;
            (O[s * l + (c >> 5)] |= $), (k |= $);
          }
          k ? (A = l) : (n.y0++, a--, l--, h++);
        }
        (n.y1 = n.y0 + A), (n.sprite = O.slice(0, (n.y1 - n.y0) * s));
      }
  }
}
function wF(t, n, e) {
  for (
    var r,
      i = t.sprite,
      o = t.width >> 5,
      u = t.x - (o << 4),
      s = 127 & u,
      a = 32 - s,
      c = t.y1 - t.y0,
      l = (t.y + t.y0) * (e >>= 5) + (u >> 5),
      f = 0;
    f < c;
    f++
  ) {
    r = 0;
    for (var h = 0; h <= o; h++) if (((r << a) | (h < o ? (r = i[f * o + h]) >>> s : 0)) & n[l + h]) return !0;
    l += e;
  }
  return !1;
}
function xF(t, n) {
  var e = t[0],
    r = t[1];
  n.x + n.x0 < e.x && (e.x = n.x + n.x0),
    n.y + n.y0 < e.y && (e.y = n.y + n.y0),
    n.x + n.x1 > r.x && (r.x = n.x + n.x1),
    n.y + n.y1 > r.y && (r.y = n.y + n.y1);
}
function OF(t, n) {
  return t.x + t.x1 > n[0].x && t.x + t.x0 < n[1].x && t.y + t.y1 > n[0].y && t.y + t.y0 < n[1].y;
}
function kF(t) {
  var n = t[0] / t[1];
  return function (t) {
    return [n * (t *= 0.1) * Math.cos(t), t * Math.sin(t)];
  };
}
function AF(t) {
  return 'function' == typeof t
    ? t
    : function () {
        return t;
      };
}
var $F = {
  archimedean: kF,
  rectangular: function (t) {
    var n = (4 * t[0]) / t[1],
      e = 0,
      r = 0;
    return function (t) {
      var i = t < 0 ? -1 : 1;
      switch ((Math.sqrt(1 + 4 * i * t) - i) & 3) {
        case 0:
          e += n;
          break;
        case 1:
          r += 4;
          break;
        case 2:
          e -= n;
          break;
        default:
          r -= 4;
      }
      return [e, r];
    };
  },
};
const MF = ['x', 'y', 'font', 'fontSize', 'fontStyle', 'fontWeight', 'angle'],
  jF = ['text', 'font', 'rotate', 'fontSize', 'fontStyle', 'fontWeight'];
function DF(t) {
  os.call(
    this,
    (function () {
      var t,
        n,
        e,
        r,
        i,
        o,
        u,
        s = [256, 256],
        a = kF,
        c = [],
        l = Math.random,
        f = {};
      function h(t, n, e) {
        for (
          var r,
            i,
            o,
            u = n.x,
            c = n.y,
            f = Math.sqrt(s[0] * s[0] + s[1] * s[1]),
            h = a(s),
            d = l() < 0.5 ? 1 : -1,
            p = -d;
          (r = h((p += d))) && ((i = ~~r[0]), (o = ~~r[1]), !(Math.min(Math.abs(i), Math.abs(o)) >= f));

        )
          if (
            ((n.x = u + i),
            (n.y = c + o),
            !(n.x + n.x0 < 0 || n.y + n.y0 < 0 || n.x + n.x1 > s[0] || n.y + n.y1 > s[1]) &&
              (!e || !wF(n, t, s[0])) &&
              (!e || OF(n, e)))
          ) {
            for (
              var m,
                v = n.sprite,
                g = n.width >> 5,
                b = s[0] >> 5,
                y = n.x - (g << 4),
                w = 127 & y,
                x = 32 - w,
                O = n.y1 - n.y0,
                k = (n.y + n.y0) * b + (y >> 5),
                A = 0;
              A < O;
              A++
            ) {
              m = 0;
              for (var $ = 0; $ <= g; $++) t[k + $] |= (m << x) | ($ < g ? (m = v[A * g + $]) >>> w : 0);
              k += b;
            }
            return (n.sprite = null), !0;
          }
        return !1;
      }
      return (
        (f.layout = function () {
          for (
            var a = (function (t) {
                t.width = t.height = 1;
                var n = Math.sqrt(t.getContext('2d').getImageData(0, 0, 1, 1).data.length >> 2);
                (t.width = 2048 / n), (t.height = bF / n);
                var e = t.getContext('2d');
                return (e.fillStyle = e.strokeStyle = 'red'), (e.textAlign = 'center'), { context: e, ratio: n };
              })(ql()),
              f = (function (t) {
                for (var n = [], e = -1; ++e < t; ) n[e] = 0;
                return n;
              })((s[0] >> 5) * s[1]),
              d = null,
              p = c.length,
              m = -1,
              v = [],
              g = c
                .map(s => ({
                  text: t(s),
                  font: n(s),
                  style: r(s),
                  weight: i(s),
                  rotate: o(s),
                  size: ~~(e(s) + 1e-14),
                  padding: u(s),
                  xoff: 0,
                  yoff: 0,
                  x1: 0,
                  y1: 0,
                  x0: 0,
                  y0: 0,
                  hasText: !1,
                  sprite: null,
                  datum: s,
                }))
                .sort((t, n) => n.size - t.size);
            ++m < p;

          ) {
            var b = g[m];
            (b.x = (s[0] * (l() + 0.5)) >> 1),
              (b.y = (s[1] * (l() + 0.5)) >> 1),
              yF(a, b, g, m),
              b.hasText &&
                h(f, b, d) &&
                (v.push(b),
                d
                  ? xF(d, b)
                  : (d = [
                      { x: b.x + b.x0, y: b.y + b.y0 },
                      { x: b.x + b.x1, y: b.y + b.y1 },
                    ]),
                (b.x -= s[0] >> 1),
                (b.y -= s[1] >> 1));
          }
          return v;
        }),
        (f.words = function (t) {
          return arguments.length ? ((c = t), f) : c;
        }),
        (f.size = function (t) {
          return arguments.length ? ((s = [+t[0], +t[1]]), f) : s;
        }),
        (f.font = function (t) {
          return arguments.length ? ((n = AF(t)), f) : n;
        }),
        (f.fontStyle = function (t) {
          return arguments.length ? ((r = AF(t)), f) : r;
        }),
        (f.fontWeight = function (t) {
          return arguments.length ? ((i = AF(t)), f) : i;
        }),
        (f.rotate = function (t) {
          return arguments.length ? ((o = AF(t)), f) : o;
        }),
        (f.text = function (n) {
          return arguments.length ? ((t = AF(n)), f) : t;
        }),
        (f.spiral = function (t) {
          return arguments.length ? ((a = $F[t] || t), f) : a;
        }),
        (f.fontSize = function (t) {
          return arguments.length ? ((e = AF(t)), f) : e;
        }),
        (f.padding = function (t) {
          return arguments.length ? ((u = AF(t)), f) : u;
        }),
        (f.random = function (t) {
          return arguments.length ? ((l = t), f) : l;
        }),
        f
      );
    })(),
    t,
  );
}
(DF.Definition = {
  type: 'Wordcloud',
  metadata: { modifies: !0 },
  params: [
    { name: 'size', type: 'number', array: !0, length: 2 },
    { name: 'font', type: 'string', expr: !0, default: 'sans-serif' },
    { name: 'fontStyle', type: 'string', expr: !0, default: 'normal' },
    { name: 'fontWeight', type: 'string', expr: !0, default: 'normal' },
    { name: 'fontSize', type: 'number', expr: !0, default: 14 },
    { name: 'fontSizeRange', type: 'number', array: 'nullable', default: [10, 50] },
    { name: 'rotate', type: 'number', expr: !0, default: 0 },
    { name: 'text', type: 'field' },
    { name: 'spiral', type: 'string', values: ['archimedean', 'rectangular'] },
    { name: 'padding', type: 'number', expr: !0 },
    { name: 'as', type: 'string', array: !0, length: 7, default: MF },
  ],
}),
  It(DF, os, {
    transform(t, n) {
      !t.size || (t.size[0] && t.size[1]) || I('Wordcloud size dimensions must be non-zero.');
      const e = t.modified();
      if (
        !(
          e ||
          n.changed(n.ADD_REM) ||
          jF.some(function (e) {
            const r = t[e];
            return Mt(r) && n.modified(r.fields);
          })
        )
      )
        return;
      const r = n.materialize(n.SOURCE).source,
        i = this.value,
        o = t.as || MF;
      let u,
        s = t.fontSize || 14;
      if ((Mt(s) ? (u = t.fontSizeRange) : (s = Ct(s)), u)) {
        const t = s,
          n = ip('sqrt')().domain(_t(r, t)).range(u);
        s = e => n(t(e));
      }
      r.forEach(t => {
        (t[o[0]] = NaN), (t[o[1]] = NaN), (t[o[3]] = 0);
      });
      const a = i
          .words(r)
          .text(t.text)
          .size(t.size || [500, 500])
          .padding(t.padding || 1)
          .spiral(t.spiral || 'archimedean')
          .rotate(t.rotate || 0)
          .font(t.font || 'sans-serif')
          .fontStyle(t.fontStyle || 'normal')
          .fontWeight(t.fontWeight || 'normal')
          .fontSize(s)
          .random(ps)
          .layout(),
        c = i.size(),
        l = c[0] >> 1,
        f = c[1] >> 1,
        h = a.length;
      for (let t, n, e = 0; e < h; ++e)
        (t = a[e]),
          (n = t.datum),
          (n[o[0]] = t.x + l),
          (n[o[1]] = t.y + f),
          (n[o[2]] = t.font),
          (n[o[3]] = t.size),
          (n[o[4]] = t.style),
          (n[o[5]] = t.weight),
          (n[o[6]] = t.rotate);
      return n.reflow(e).modifies(o);
    },
  });
const FF = Object.freeze({ __proto__: null, wordcloud: DF }),
  EF = t => new Uint8Array(t),
  SF = t => new Uint16Array(t),
  CF = t => new Uint32Array(t);
function NF(t, n, e) {
  const r = (n < 257 ? EF : n < 65537 ? SF : CF)(t);
  return e && r.set(e), r;
}
function BF(t, n, e) {
  const r = 1 << n;
  return {
    one: r,
    zero: ~r,
    range: e.slice(),
    bisect: t.bisect,
    index: t.index,
    size: t.size,
    onAdd(t, n) {
      const e = this,
        i = e.bisect(e.range, t.value),
        o = t.index,
        u = i[0],
        s = i[1],
        a = o.length;
      let c;
      for (c = 0; c < u; ++c) n[o[c]] |= r;
      for (c = s; c < a; ++c) n[o[c]] |= r;
      return e;
    },
  };
}
function _F() {
  let t = CF(0),
    n = [],
    e = 0;
  return {
    insert: function (r, i, o) {
      if (!i.length) return [];
      const u = e,
        s = i.length,
        a = CF(s);
      let c,
        l,
        f,
        h = Array(s);
      for (f = 0; f < s; ++f) (h[f] = r(i[f])), (a[f] = f);
      if (
        ((h = (function (t, n) {
          return (
            t.sort.call(n, (n, e) => {
              const r = t[n],
                i = t[e];
              return r < i ? -1 : r > i ? 1 : 0;
            }),
            (function (t, n) {
              return Array.from(n, n => t[n]);
            })(t, n)
          );
        })(h, a)),
        u)
      )
        (c = n),
          (l = t),
          (n = Array(u + s)),
          (t = CF(u + s)),
          (function (t, n, e, r, i, o, u, s, a) {
            let c,
              l = 0,
              f = 0;
            for (c = 0; l < r && f < u; ++c)
              n[l] < i[f] ? ((s[c] = n[l]), (a[c] = e[l++])) : ((s[c] = i[f]), (a[c] = o[f++] + t));
            for (; l < r; ++l, ++c) (s[c] = n[l]), (a[c] = e[l]);
            for (; f < u; ++f, ++c) (s[c] = i[f]), (a[c] = o[f] + t);
          })(o, c, l, u, h, a, s, n, t);
      else {
        if (o > 0) for (f = 0; f < s; ++f) a[f] += o;
        (n = h), (t = a);
      }
      return (e = u + s), { index: a, value: h };
    },
    remove: function (r, i) {
      const o = e;
      let u, s, a;
      for (s = 0; !i[t[s]] && s < o; ++s);
      for (a = s; s < o; ++s) i[(u = t[s])] || ((t[a] = u), (n[a] = n[s]), ++a);
      e = o - r;
    },
    bisect: function (t, r) {
      let i;
      return r ? (i = r.length) : ((r = n), (i = e)), [Nn(r, t[0], 0, i), Cn(r, t[1], 0, i)];
    },
    reindex: function (n) {
      for (let r = 0, i = e; r < i; ++r) t[r] = n[t[r]];
    },
    index: () => t,
    size: () => e,
  };
}
function zF(t) {
  os.call(
    this,
    (function () {
      let t = 8,
        n = [],
        e = CF(0),
        r = NF(0, t),
        i = NF(0, t);
      return {
        data: () => n,
        seen: () =>
          (e = (function (t, n, e) {
            return t.length >= n ? t : ((e = e || new t.constructor(n)).set(t), e);
          })(e, n.length)),
        add(t) {
          for (let e, r = 0, i = n.length, o = t.length; r < o; ++r) (e = t[r]), (e._index = i++), n.push(e);
        },
        remove(t, e) {
          const o = n.length,
            u = Array(o - t),
            s = n;
          let a, c, l;
          for (c = 0; !e[c] && c < o; ++c) (u[c] = n[c]), (s[c] = c);
          for (l = c; c < o; ++c)
            (a = n[c]),
              e[c] ? (s[c] = -1) : ((s[c] = l), (r[l] = r[c]), (i[l] = i[c]), (u[l] = a), (a._index = l++)),
              (r[c] = 0);
          return (n = u), s;
        },
        size: () => n.length,
        curr: () => r,
        prev: () => i,
        reset: t => (i[t] = r[t]),
        all: () => (t < 257 ? 255 : t < 65537 ? 65535 : 4294967295),
        set(t, n) {
          r[t] |= n;
        },
        clear(t, n) {
          r[t] &= ~n;
        },
        resize(n, e) {
          (n > r.length || e > t) && ((t = Math.max(e, t)), (r = NF(n, t, r)), (i = NF(n, t)));
        },
      };
    })(),
    t,
  ),
    (this._indices = null),
    (this._dims = null);
}
function TF(t) {
  os.call(this, null, t);
}
(zF.Definition = {
  type: 'CrossFilter',
  metadata: {},
  params: [
    { name: 'fields', type: 'field', array: !0, required: !0 },
    { name: 'query', type: 'array', array: !0, required: !0, content: { type: 'number', array: !0, length: 2 } },
  ],
}),
  It(zF, os, {
    transform(t, n) {
      return this._dims
        ? t.modified('fields') || t.fields.some(t => n.modified(t.fields))
          ? this.reinit(t, n)
          : this.eval(t, n)
        : this.init(t, n);
    },
    init(t, n) {
      const e = t.fields,
        r = t.query,
        i = (this._indices = {}),
        o = (this._dims = []),
        u = r.length;
      let s,
        a,
        c = 0;
      for (; c < u; ++c) (s = e[c].fname), (a = i[s] || (i[s] = _F())), o.push(BF(a, c, r[c]));
      return this.eval(t, n);
    },
    reinit(t, n) {
      const e = n.materialize().fork(),
        r = t.fields,
        i = t.query,
        o = this._indices,
        u = this._dims,
        s = this.value,
        a = s.curr(),
        c = s.prev(),
        l = s.all(),
        f = (e.rem = e.add),
        h = e.mod,
        d = i.length,
        p = {};
      let m, v, g, b, y, w, x, O, k;
      if ((c.set(a), n.rem.length && (y = this.remove(t, n, e)), n.add.length && s.add(n.add), n.mod.length))
        for (w = {}, b = n.mod, x = 0, O = b.length; x < O; ++x) w[b[x]._index] = 1;
      for (x = 0; x < d; ++x)
        (k = r[x]),
          (!u[x] || t.modified('fields', x) || n.modified(k.fields)) &&
            ((g = k.fname),
            (m = p[g]) || ((o[g] = v = _F()), (p[g] = m = v.insert(k, n.source, 0))),
            (u[x] = BF(v, x, i[x]).onAdd(m, a)));
      for (x = 0, O = s.data().length; x < O; ++x)
        y[x] || (c[x] !== a[x] ? f.push(x) : w[x] && a[x] !== l && h.push(x));
      return (s.mask = (1 << d) - 1), e;
    },
    eval(t, n) {
      const e = n.materialize().fork(),
        r = this._dims.length;
      let i = 0;
      return (
        n.rem.length && (this.remove(t, n, e), (i |= (1 << r) - 1)),
        t.modified('query') && !t.modified('fields') && (i |= this.update(t, n, e)),
        n.add.length && (this.insert(t, n, e), (i |= (1 << r) - 1)),
        n.mod.length && (this.modify(n, e), (i |= (1 << r) - 1)),
        (this.value.mask = i),
        e
      );
    },
    insert(t, n, e) {
      const r = n.add,
        i = this.value,
        o = this._dims,
        u = this._indices,
        s = t.fields,
        a = {},
        c = e.add,
        l = i.size() + r.length,
        f = o.length;
      let h,
        d,
        p,
        m = i.size();
      i.resize(l, f), i.add(r);
      const v = i.curr(),
        g = i.prev(),
        b = i.all();
      for (h = 0; h < f; ++h) (d = s[h].fname), (p = a[d] || (a[d] = u[d].insert(s[h], r, m))), o[h].onAdd(p, v);
      for (; m < l; ++m) (g[m] = b), v[m] !== b && c.push(m);
    },
    modify(t, n) {
      const e = n.mod,
        r = this.value,
        i = r.curr(),
        o = r.all(),
        u = t.mod;
      let s, a, c;
      for (s = 0, a = u.length; s < a; ++s) (c = u[s]._index), i[c] !== o && e.push(c);
    },
    remove(t, n, e) {
      const r = this._indices,
        i = this.value,
        o = i.curr(),
        u = i.prev(),
        s = i.all(),
        a = {},
        c = e.rem,
        l = n.rem;
      let f, h, d, p;
      for (f = 0, h = l.length; f < h; ++f)
        (d = l[f]._index), (a[d] = 1), (u[d] = p = o[d]), (o[d] = s), p !== s && c.push(d);
      for (d in r) r[d].remove(h, a);
      return this.reindex(n, h, a), a;
    },
    reindex(t, n, e) {
      const r = this._indices,
        i = this.value;
      t.runAfter(() => {
        const t = i.remove(n, e);
        for (const n in r) r[n].reindex(t);
      });
    },
    update(t, n, e) {
      const r = this._dims,
        i = t.query,
        o = n.stamp,
        u = r.length;
      let s,
        a,
        c = 0;
      for (e.filters = 0, a = 0; a < u; ++a) t.modified('query', a) && ((s = a), ++c);
      if (1 === c) (c = r[s].one), this.incrementOne(r[s], i[s], e.add, e.rem);
      else
        for (a = 0, c = 0; a < u; ++a)
          t.modified('query', a) && ((c |= r[a].one), this.incrementAll(r[a], i[a], o, e.add), (e.rem = e.add));
      return c;
    },
    incrementAll(t, n, e, r) {
      const i = this.value,
        o = i.seen(),
        u = i.curr(),
        s = i.prev(),
        a = t.index(),
        c = t.bisect(t.range),
        l = t.bisect(n),
        f = l[0],
        h = l[1],
        d = c[0],
        p = c[1],
        m = t.one;
      let v, g, b;
      if (f < d)
        for (v = f, g = Math.min(d, h); v < g; ++v)
          (b = a[v]), o[b] !== e && ((s[b] = u[b]), (o[b] = e), r.push(b)), (u[b] ^= m);
      else if (f > d)
        for (v = d, g = Math.min(f, p); v < g; ++v)
          (b = a[v]), o[b] !== e && ((s[b] = u[b]), (o[b] = e), r.push(b)), (u[b] ^= m);
      if (h > p)
        for (v = Math.max(f, p), g = h; v < g; ++v)
          (b = a[v]), o[b] !== e && ((s[b] = u[b]), (o[b] = e), r.push(b)), (u[b] ^= m);
      else if (h < p)
        for (v = Math.max(d, h), g = p; v < g; ++v)
          (b = a[v]), o[b] !== e && ((s[b] = u[b]), (o[b] = e), r.push(b)), (u[b] ^= m);
      t.range = n.slice();
    },
    incrementOne(t, n, e, r) {
      const i = this.value.curr(),
        o = t.index(),
        u = t.bisect(t.range),
        s = t.bisect(n),
        a = s[0],
        c = s[1],
        l = u[0],
        f = u[1],
        h = t.one;
      let d, p, m;
      if (a < l) for (d = a, p = Math.min(l, c); d < p; ++d) (m = o[d]), (i[m] ^= h), e.push(m);
      else if (a > l) for (d = l, p = Math.min(a, f); d < p; ++d) (m = o[d]), (i[m] ^= h), r.push(m);
      if (c > f) for (d = Math.max(a, f), p = c; d < p; ++d) (m = o[d]), (i[m] ^= h), e.push(m);
      else if (c < f) for (d = Math.max(l, c), p = f; d < p; ++d) (m = o[d]), (i[m] ^= h), r.push(m);
      t.range = n.slice();
    },
  }),
  (TF.Definition = {
    type: 'ResolveFilter',
    metadata: {},
    params: [
      { name: 'ignore', type: 'number', required: !0, description: 'A bit mask indicating which filters to ignore.' },
      {
        name: 'filter',
        type: 'object',
        required: !0,
        description: 'Per-tuple filter bitmaps from a CrossFilter transform.',
      },
    ],
  }),
  It(TF, os, {
    transform(t, n) {
      const e = ~(t.ignore || 0),
        r = t.filter,
        i = r.mask;
      if (0 == (i & e)) return n.StopPropagation;
      const o = n.fork(n.ALL),
        u = r.data(),
        s = r.curr(),
        a = r.prev(),
        c = t => (s[t] & e ? null : u[t]);
      return (
        o.filter(o.MOD, c),
        i & (i - 1)
          ? (o.filter(o.ADD, t => {
              const n = s[t] & e;
              return !n && n ^ (a[t] & e) ? u[t] : null;
            }),
            o.filter(o.REM, t => {
              const n = s[t] & e;
              return !n || n ^ n ^ (a[t] & e) ? null : u[t];
            }))
          : (o.filter(o.ADD, c), o.filter(o.REM, t => ((s[t] & e) === i ? u[t] : null))),
        o.filter(o.SOURCE, t => c(t._index))
      );
    },
  });
const PF = Object.freeze({ __proto__: null, crossfilter: zF, resolvefilter: TF }),
  RF = 'Literal',
  LF = 'CallExpression';
function qF(t) {
  this.type = t;
}
var IF, UF, WF, HF, GF;
(qF.prototype.visit = function (t) {
  let n, e, r;
  if (t(this)) return 1;
  for (
    n = (function (t) {
      switch (t.type) {
        case 'ArrayExpression':
          return t.elements;
        case 'BinaryExpression':
        case 'LogicalExpression':
          return [t.left, t.right];
        case LF:
          return [t.callee].concat(t.arguments);
        case 'ConditionalExpression':
          return [t.test, t.consequent, t.alternate];
        case 'MemberExpression':
          return [t.object, t.property];
        case 'ObjectExpression':
          return t.properties;
        case 'Property':
          return [t.key, t.value];
        case 'UnaryExpression':
          return [t.argument];
        default:
          return [];
      }
    })(this),
      e = 0,
      r = n.length;
    e < r;
    ++e
  )
    if (n[e].visit(t)) return 1;
}),
  ((IF = {})[1] = 'Boolean'),
  (IF[2] = '<end>'),
  (IF[3] = 'Identifier'),
  (IF[4] = 'Keyword'),
  (IF[5] = 'Null'),
  (IF[6] = 'Numeric'),
  (IF[7] = 'Punctuator'),
  (IF[8] = 'String'),
  (IF[9] = 'RegularExpression');
var VF = 'Identifier',
  YF = 'Unexpected token %0',
  XF = 'Invalid regular expression',
  JF = 'Invalid regular expression: missing /',
  QF = 'Octal literals are not allowed in strict mode.',
  ZF = 'ILLEGAL',
  KF = 'Disabled.',
  tE = new RegExp(
    '[\\xAA\\xB5\\xBA\\xC0-\\xD6\\xD8-\\xF6\\xF8-\\u02C1\\u02C6-\\u02D1\\u02E0-\\u02E4\\u02EC\\u02EE\\u0370-\\u0374\\u0376\\u0377\\u037A-\\u037D\\u037F\\u0386\\u0388-\\u038A\\u038C\\u038E-\\u03A1\\u03A3-\\u03F5\\u03F7-\\u0481\\u048A-\\u052F\\u0531-\\u0556\\u0559\\u0561-\\u0587\\u05D0-\\u05EA\\u05F0-\\u05F2\\u0620-\\u064A\\u066E\\u066F\\u0671-\\u06D3\\u06D5\\u06E5\\u06E6\\u06EE\\u06EF\\u06FA-\\u06FC\\u06FF\\u0710\\u0712-\\u072F\\u074D-\\u07A5\\u07B1\\u07CA-\\u07EA\\u07F4\\u07F5\\u07FA\\u0800-\\u0815\\u081A\\u0824\\u0828\\u0840-\\u0858\\u08A0-\\u08B2\\u0904-\\u0939\\u093D\\u0950\\u0958-\\u0961\\u0971-\\u0980\\u0985-\\u098C\\u098F\\u0990\\u0993-\\u09A8\\u09AA-\\u09B0\\u09B2\\u09B6-\\u09B9\\u09BD\\u09CE\\u09DC\\u09DD\\u09DF-\\u09E1\\u09F0\\u09F1\\u0A05-\\u0A0A\\u0A0F\\u0A10\\u0A13-\\u0A28\\u0A2A-\\u0A30\\u0A32\\u0A33\\u0A35\\u0A36\\u0A38\\u0A39\\u0A59-\\u0A5C\\u0A5E\\u0A72-\\u0A74\\u0A85-\\u0A8D\\u0A8F-\\u0A91\\u0A93-\\u0AA8\\u0AAA-\\u0AB0\\u0AB2\\u0AB3\\u0AB5-\\u0AB9\\u0ABD\\u0AD0\\u0AE0\\u0AE1\\u0B05-\\u0B0C\\u0B0F\\u0B10\\u0B13-\\u0B28\\u0B2A-\\u0B30\\u0B32\\u0B33\\u0B35-\\u0B39\\u0B3D\\u0B5C\\u0B5D\\u0B5F-\\u0B61\\u0B71\\u0B83\\u0B85-\\u0B8A\\u0B8E-\\u0B90\\u0B92-\\u0B95\\u0B99\\u0B9A\\u0B9C\\u0B9E\\u0B9F\\u0BA3\\u0BA4\\u0BA8-\\u0BAA\\u0BAE-\\u0BB9\\u0BD0\\u0C05-\\u0C0C\\u0C0E-\\u0C10\\u0C12-\\u0C28\\u0C2A-\\u0C39\\u0C3D\\u0C58\\u0C59\\u0C60\\u0C61\\u0C85-\\u0C8C\\u0C8E-\\u0C90\\u0C92-\\u0CA8\\u0CAA-\\u0CB3\\u0CB5-\\u0CB9\\u0CBD\\u0CDE\\u0CE0\\u0CE1\\u0CF1\\u0CF2\\u0D05-\\u0D0C\\u0D0E-\\u0D10\\u0D12-\\u0D3A\\u0D3D\\u0D4E\\u0D60\\u0D61\\u0D7A-\\u0D7F\\u0D85-\\u0D96\\u0D9A-\\u0DB1\\u0DB3-\\u0DBB\\u0DBD\\u0DC0-\\u0DC6\\u0E01-\\u0E30\\u0E32\\u0E33\\u0E40-\\u0E46\\u0E81\\u0E82\\u0E84\\u0E87\\u0E88\\u0E8A\\u0E8D\\u0E94-\\u0E97\\u0E99-\\u0E9F\\u0EA1-\\u0EA3\\u0EA5\\u0EA7\\u0EAA\\u0EAB\\u0EAD-\\u0EB0\\u0EB2\\u0EB3\\u0EBD\\u0EC0-\\u0EC4\\u0EC6\\u0EDC-\\u0EDF\\u0F00\\u0F40-\\u0F47\\u0F49-\\u0F6C\\u0F88-\\u0F8C\\u1000-\\u102A\\u103F\\u1050-\\u1055\\u105A-\\u105D\\u1061\\u1065\\u1066\\u106E-\\u1070\\u1075-\\u1081\\u108E\\u10A0-\\u10C5\\u10C7\\u10CD\\u10D0-\\u10FA\\u10FC-\\u1248\\u124A-\\u124D\\u1250-\\u1256\\u1258\\u125A-\\u125D\\u1260-\\u1288\\u128A-\\u128D\\u1290-\\u12B0\\u12B2-\\u12B5\\u12B8-\\u12BE\\u12C0\\u12C2-\\u12C5\\u12C8-\\u12D6\\u12D8-\\u1310\\u1312-\\u1315\\u1318-\\u135A\\u1380-\\u138F\\u13A0-\\u13F4\\u1401-\\u166C\\u166F-\\u167F\\u1681-\\u169A\\u16A0-\\u16EA\\u16EE-\\u16F8\\u1700-\\u170C\\u170E-\\u1711\\u1720-\\u1731\\u1740-\\u1751\\u1760-\\u176C\\u176E-\\u1770\\u1780-\\u17B3\\u17D7\\u17DC\\u1820-\\u1877\\u1880-\\u18A8\\u18AA\\u18B0-\\u18F5\\u1900-\\u191E\\u1950-\\u196D\\u1970-\\u1974\\u1980-\\u19AB\\u19C1-\\u19C7\\u1A00-\\u1A16\\u1A20-\\u1A54\\u1AA7\\u1B05-\\u1B33\\u1B45-\\u1B4B\\u1B83-\\u1BA0\\u1BAE\\u1BAF\\u1BBA-\\u1BE5\\u1C00-\\u1C23\\u1C4D-\\u1C4F\\u1C5A-\\u1C7D\\u1CE9-\\u1CEC\\u1CEE-\\u1CF1\\u1CF5\\u1CF6\\u1D00-\\u1DBF\\u1E00-\\u1F15\\u1F18-\\u1F1D\\u1F20-\\u1F45\\u1F48-\\u1F4D\\u1F50-\\u1F57\\u1F59\\u1F5B\\u1F5D\\u1F5F-\\u1F7D\\u1F80-\\u1FB4\\u1FB6-\\u1FBC\\u1FBE\\u1FC2-\\u1FC4\\u1FC6-\\u1FCC\\u1FD0-\\u1FD3\\u1FD6-\\u1FDB\\u1FE0-\\u1FEC\\u1FF2-\\u1FF4\\u1FF6-\\u1FFC\\u2071\\u207F\\u2090-\\u209C\\u2102\\u2107\\u210A-\\u2113\\u2115\\u2119-\\u211D\\u2124\\u2126\\u2128\\u212A-\\u212D\\u212F-\\u2139\\u213C-\\u213F\\u2145-\\u2149\\u214E\\u2160-\\u2188\\u2C00-\\u2C2E\\u2C30-\\u2C5E\\u2C60-\\u2CE4\\u2CEB-\\u2CEE\\u2CF2\\u2CF3\\u2D00-\\u2D25\\u2D27\\u2D2D\\u2D30-\\u2D67\\u2D6F\\u2D80-\\u2D96\\u2DA0-\\u2DA6\\u2DA8-\\u2DAE\\u2DB0-\\u2DB6\\u2DB8-\\u2DBE\\u2DC0-\\u2DC6\\u2DC8-\\u2DCE\\u2DD0-\\u2DD6\\u2DD8-\\u2DDE\\u2E2F\\u3005-\\u3007\\u3021-\\u3029\\u3031-\\u3035\\u3038-\\u303C\\u3041-\\u3096\\u309D-\\u309F\\u30A1-\\u30FA\\u30FC-\\u30FF\\u3105-\\u312D\\u3131-\\u318E\\u31A0-\\u31BA\\u31F0-\\u31FF\\u3400-\\u4DB5\\u4E00-\\u9FCC\\uA000-\\uA48C\\uA4D0-\\uA4FD\\uA500-\\uA60C\\uA610-\\uA61F\\uA62A\\uA62B\\uA640-\\uA66E\\uA67F-\\uA69D\\uA6A0-\\uA6EF\\uA717-\\uA71F\\uA722-\\uA788\\uA78B-\\uA78E\\uA790-\\uA7AD\\uA7B0\\uA7B1\\uA7F7-\\uA801\\uA803-\\uA805\\uA807-\\uA80A\\uA80C-\\uA822\\uA840-\\uA873\\uA882-\\uA8B3\\uA8F2-\\uA8F7\\uA8FB\\uA90A-\\uA925\\uA930-\\uA946\\uA960-\\uA97C\\uA984-\\uA9B2\\uA9CF\\uA9E0-\\uA9E4\\uA9E6-\\uA9EF\\uA9FA-\\uA9FE\\uAA00-\\uAA28\\uAA40-\\uAA42\\uAA44-\\uAA4B\\uAA60-\\uAA76\\uAA7A\\uAA7E-\\uAAAF\\uAAB1\\uAAB5\\uAAB6\\uAAB9-\\uAABD\\uAAC0\\uAAC2\\uAADB-\\uAADD\\uAAE0-\\uAAEA\\uAAF2-\\uAAF4\\uAB01-\\uAB06\\uAB09-\\uAB0E\\uAB11-\\uAB16\\uAB20-\\uAB26\\uAB28-\\uAB2E\\uAB30-\\uAB5A\\uAB5C-\\uAB5F\\uAB64\\uAB65\\uABC0-\\uABE2\\uAC00-\\uD7A3\\uD7B0-\\uD7C6\\uD7CB-\\uD7FB\\uF900-\\uFA6D\\uFA70-\\uFAD9\\uFB00-\\uFB06\\uFB13-\\uFB17\\uFB1D\\uFB1F-\\uFB28\\uFB2A-\\uFB36\\uFB38-\\uFB3C\\uFB3E\\uFB40\\uFB41\\uFB43\\uFB44\\uFB46-\\uFBB1\\uFBD3-\\uFD3D\\uFD50-\\uFD8F\\uFD92-\\uFDC7\\uFDF0-\\uFDFB\\uFE70-\\uFE74\\uFE76-\\uFEFC\\uFF21-\\uFF3A\\uFF41-\\uFF5A\\uFF66-\\uFFBE\\uFFC2-\\uFFC7\\uFFCA-\\uFFCF\\uFFD2-\\uFFD7\\uFFDA-\\uFFDC]',
  ),
  nE = new RegExp(
    '[\\xAA\\xB5\\xBA\\xC0-\\xD6\\xD8-\\xF6\\xF8-\\u02C1\\u02C6-\\u02D1\\u02E0-\\u02E4\\u02EC\\u02EE\\u0300-\\u0374\\u0376\\u0377\\u037A-\\u037D\\u037F\\u0386\\u0388-\\u038A\\u038C\\u038E-\\u03A1\\u03A3-\\u03F5\\u03F7-\\u0481\\u0483-\\u0487\\u048A-\\u052F\\u0531-\\u0556\\u0559\\u0561-\\u0587\\u0591-\\u05BD\\u05BF\\u05C1\\u05C2\\u05C4\\u05C5\\u05C7\\u05D0-\\u05EA\\u05F0-\\u05F2\\u0610-\\u061A\\u0620-\\u0669\\u066E-\\u06D3\\u06D5-\\u06DC\\u06DF-\\u06E8\\u06EA-\\u06FC\\u06FF\\u0710-\\u074A\\u074D-\\u07B1\\u07C0-\\u07F5\\u07FA\\u0800-\\u082D\\u0840-\\u085B\\u08A0-\\u08B2\\u08E4-\\u0963\\u0966-\\u096F\\u0971-\\u0983\\u0985-\\u098C\\u098F\\u0990\\u0993-\\u09A8\\u09AA-\\u09B0\\u09B2\\u09B6-\\u09B9\\u09BC-\\u09C4\\u09C7\\u09C8\\u09CB-\\u09CE\\u09D7\\u09DC\\u09DD\\u09DF-\\u09E3\\u09E6-\\u09F1\\u0A01-\\u0A03\\u0A05-\\u0A0A\\u0A0F\\u0A10\\u0A13-\\u0A28\\u0A2A-\\u0A30\\u0A32\\u0A33\\u0A35\\u0A36\\u0A38\\u0A39\\u0A3C\\u0A3E-\\u0A42\\u0A47\\u0A48\\u0A4B-\\u0A4D\\u0A51\\u0A59-\\u0A5C\\u0A5E\\u0A66-\\u0A75\\u0A81-\\u0A83\\u0A85-\\u0A8D\\u0A8F-\\u0A91\\u0A93-\\u0AA8\\u0AAA-\\u0AB0\\u0AB2\\u0AB3\\u0AB5-\\u0AB9\\u0ABC-\\u0AC5\\u0AC7-\\u0AC9\\u0ACB-\\u0ACD\\u0AD0\\u0AE0-\\u0AE3\\u0AE6-\\u0AEF\\u0B01-\\u0B03\\u0B05-\\u0B0C\\u0B0F\\u0B10\\u0B13-\\u0B28\\u0B2A-\\u0B30\\u0B32\\u0B33\\u0B35-\\u0B39\\u0B3C-\\u0B44\\u0B47\\u0B48\\u0B4B-\\u0B4D\\u0B56\\u0B57\\u0B5C\\u0B5D\\u0B5F-\\u0B63\\u0B66-\\u0B6F\\u0B71\\u0B82\\u0B83\\u0B85-\\u0B8A\\u0B8E-\\u0B90\\u0B92-\\u0B95\\u0B99\\u0B9A\\u0B9C\\u0B9E\\u0B9F\\u0BA3\\u0BA4\\u0BA8-\\u0BAA\\u0BAE-\\u0BB9\\u0BBE-\\u0BC2\\u0BC6-\\u0BC8\\u0BCA-\\u0BCD\\u0BD0\\u0BD7\\u0BE6-\\u0BEF\\u0C00-\\u0C03\\u0C05-\\u0C0C\\u0C0E-\\u0C10\\u0C12-\\u0C28\\u0C2A-\\u0C39\\u0C3D-\\u0C44\\u0C46-\\u0C48\\u0C4A-\\u0C4D\\u0C55\\u0C56\\u0C58\\u0C59\\u0C60-\\u0C63\\u0C66-\\u0C6F\\u0C81-\\u0C83\\u0C85-\\u0C8C\\u0C8E-\\u0C90\\u0C92-\\u0CA8\\u0CAA-\\u0CB3\\u0CB5-\\u0CB9\\u0CBC-\\u0CC4\\u0CC6-\\u0CC8\\u0CCA-\\u0CCD\\u0CD5\\u0CD6\\u0CDE\\u0CE0-\\u0CE3\\u0CE6-\\u0CEF\\u0CF1\\u0CF2\\u0D01-\\u0D03\\u0D05-\\u0D0C\\u0D0E-\\u0D10\\u0D12-\\u0D3A\\u0D3D-\\u0D44\\u0D46-\\u0D48\\u0D4A-\\u0D4E\\u0D57\\u0D60-\\u0D63\\u0D66-\\u0D6F\\u0D7A-\\u0D7F\\u0D82\\u0D83\\u0D85-\\u0D96\\u0D9A-\\u0DB1\\u0DB3-\\u0DBB\\u0DBD\\u0DC0-\\u0DC6\\u0DCA\\u0DCF-\\u0DD4\\u0DD6\\u0DD8-\\u0DDF\\u0DE6-\\u0DEF\\u0DF2\\u0DF3\\u0E01-\\u0E3A\\u0E40-\\u0E4E\\u0E50-\\u0E59\\u0E81\\u0E82\\u0E84\\u0E87\\u0E88\\u0E8A\\u0E8D\\u0E94-\\u0E97\\u0E99-\\u0E9F\\u0EA1-\\u0EA3\\u0EA5\\u0EA7\\u0EAA\\u0EAB\\u0EAD-\\u0EB9\\u0EBB-\\u0EBD\\u0EC0-\\u0EC4\\u0EC6\\u0EC8-\\u0ECD\\u0ED0-\\u0ED9\\u0EDC-\\u0EDF\\u0F00\\u0F18\\u0F19\\u0F20-\\u0F29\\u0F35\\u0F37\\u0F39\\u0F3E-\\u0F47\\u0F49-\\u0F6C\\u0F71-\\u0F84\\u0F86-\\u0F97\\u0F99-\\u0FBC\\u0FC6\\u1000-\\u1049\\u1050-\\u109D\\u10A0-\\u10C5\\u10C7\\u10CD\\u10D0-\\u10FA\\u10FC-\\u1248\\u124A-\\u124D\\u1250-\\u1256\\u1258\\u125A-\\u125D\\u1260-\\u1288\\u128A-\\u128D\\u1290-\\u12B0\\u12B2-\\u12B5\\u12B8-\\u12BE\\u12C0\\u12C2-\\u12C5\\u12C8-\\u12D6\\u12D8-\\u1310\\u1312-\\u1315\\u1318-\\u135A\\u135D-\\u135F\\u1380-\\u138F\\u13A0-\\u13F4\\u1401-\\u166C\\u166F-\\u167F\\u1681-\\u169A\\u16A0-\\u16EA\\u16EE-\\u16F8\\u1700-\\u170C\\u170E-\\u1714\\u1720-\\u1734\\u1740-\\u1753\\u1760-\\u176C\\u176E-\\u1770\\u1772\\u1773\\u1780-\\u17D3\\u17D7\\u17DC\\u17DD\\u17E0-\\u17E9\\u180B-\\u180D\\u1810-\\u1819\\u1820-\\u1877\\u1880-\\u18AA\\u18B0-\\u18F5\\u1900-\\u191E\\u1920-\\u192B\\u1930-\\u193B\\u1946-\\u196D\\u1970-\\u1974\\u1980-\\u19AB\\u19B0-\\u19C9\\u19D0-\\u19D9\\u1A00-\\u1A1B\\u1A20-\\u1A5E\\u1A60-\\u1A7C\\u1A7F-\\u1A89\\u1A90-\\u1A99\\u1AA7\\u1AB0-\\u1ABD\\u1B00-\\u1B4B\\u1B50-\\u1B59\\u1B6B-\\u1B73\\u1B80-\\u1BF3\\u1C00-\\u1C37\\u1C40-\\u1C49\\u1C4D-\\u1C7D\\u1CD0-\\u1CD2\\u1CD4-\\u1CF6\\u1CF8\\u1CF9\\u1D00-\\u1DF5\\u1DFC-\\u1F15\\u1F18-\\u1F1D\\u1F20-\\u1F45\\u1F48-\\u1F4D\\u1F50-\\u1F57\\u1F59\\u1F5B\\u1F5D\\u1F5F-\\u1F7D\\u1F80-\\u1FB4\\u1FB6-\\u1FBC\\u1FBE\\u1FC2-\\u1FC4\\u1FC6-\\u1FCC\\u1FD0-\\u1FD3\\u1FD6-\\u1FDB\\u1FE0-\\u1FEC\\u1FF2-\\u1FF4\\u1FF6-\\u1FFC\\u200C\\u200D\\u203F\\u2040\\u2054\\u2071\\u207F\\u2090-\\u209C\\u20D0-\\u20DC\\u20E1\\u20E5-\\u20F0\\u2102\\u2107\\u210A-\\u2113\\u2115\\u2119-\\u211D\\u2124\\u2126\\u2128\\u212A-\\u212D\\u212F-\\u2139\\u213C-\\u213F\\u2145-\\u2149\\u214E\\u2160-\\u2188\\u2C00-\\u2C2E\\u2C30-\\u2C5E\\u2C60-\\u2CE4\\u2CEB-\\u2CF3\\u2D00-\\u2D25\\u2D27\\u2D2D\\u2D30-\\u2D67\\u2D6F\\u2D7F-\\u2D96\\u2DA0-\\u2DA6\\u2DA8-\\u2DAE\\u2DB0-\\u2DB6\\u2DB8-\\u2DBE\\u2DC0-\\u2DC6\\u2DC8-\\u2DCE\\u2DD0-\\u2DD6\\u2DD8-\\u2DDE\\u2DE0-\\u2DFF\\u2E2F\\u3005-\\u3007\\u3021-\\u302F\\u3031-\\u3035\\u3038-\\u303C\\u3041-\\u3096\\u3099\\u309A\\u309D-\\u309F\\u30A1-\\u30FA\\u30FC-\\u30FF\\u3105-\\u312D\\u3131-\\u318E\\u31A0-\\u31BA\\u31F0-\\u31FF\\u3400-\\u4DB5\\u4E00-\\u9FCC\\uA000-\\uA48C\\uA4D0-\\uA4FD\\uA500-\\uA60C\\uA610-\\uA62B\\uA640-\\uA66F\\uA674-\\uA67D\\uA67F-\\uA69D\\uA69F-\\uA6F1\\uA717-\\uA71F\\uA722-\\uA788\\uA78B-\\uA78E\\uA790-\\uA7AD\\uA7B0\\uA7B1\\uA7F7-\\uA827\\uA840-\\uA873\\uA880-\\uA8C4\\uA8D0-\\uA8D9\\uA8E0-\\uA8F7\\uA8FB\\uA900-\\uA92D\\uA930-\\uA953\\uA960-\\uA97C\\uA980-\\uA9C0\\uA9CF-\\uA9D9\\uA9E0-\\uA9FE\\uAA00-\\uAA36\\uAA40-\\uAA4D\\uAA50-\\uAA59\\uAA60-\\uAA76\\uAA7A-\\uAAC2\\uAADB-\\uAADD\\uAAE0-\\uAAEF\\uAAF2-\\uAAF6\\uAB01-\\uAB06\\uAB09-\\uAB0E\\uAB11-\\uAB16\\uAB20-\\uAB26\\uAB28-\\uAB2E\\uAB30-\\uAB5A\\uAB5C-\\uAB5F\\uAB64\\uAB65\\uABC0-\\uABEA\\uABEC\\uABED\\uABF0-\\uABF9\\uAC00-\\uD7A3\\uD7B0-\\uD7C6\\uD7CB-\\uD7FB\\uF900-\\uFA6D\\uFA70-\\uFAD9\\uFB00-\\uFB06\\uFB13-\\uFB17\\uFB1D-\\uFB28\\uFB2A-\\uFB36\\uFB38-\\uFB3C\\uFB3E\\uFB40\\uFB41\\uFB43\\uFB44\\uFB46-\\uFBB1\\uFBD3-\\uFD3D\\uFD50-\\uFD8F\\uFD92-\\uFDC7\\uFDF0-\\uFDFB\\uFE00-\\uFE0F\\uFE20-\\uFE2D\\uFE33\\uFE34\\uFE4D-\\uFE4F\\uFE70-\\uFE74\\uFE76-\\uFEFC\\uFF10-\\uFF19\\uFF21-\\uFF3A\\uFF3F\\uFF41-\\uFF5A\\uFF66-\\uFFBE\\uFFC2-\\uFFC7\\uFFCA-\\uFFCF\\uFFD2-\\uFFD7\\uFFDA-\\uFFDC]',
  );
function eE(t, n) {
  if (!t) throw new Error('ASSERT: ' + n);
}
function rE(t) {
  return t >= 48 && t <= 57;
}
function iE(t) {
  return '0123456789abcdefABCDEF'.indexOf(t) >= 0;
}
function oE(t) {
  return '01234567'.indexOf(t) >= 0;
}
function uE(t) {
  return (
    32 === t ||
    9 === t ||
    11 === t ||
    12 === t ||
    160 === t ||
    (t >= 5760 &&
      [5760, 6158, 8192, 8193, 8194, 8195, 8196, 8197, 8198, 8199, 8200, 8201, 8202, 8239, 8287, 12288, 65279].indexOf(
        t,
      ) >= 0)
  );
}
function sE(t) {
  return 10 === t || 13 === t || 8232 === t || 8233 === t;
}
function aE(t) {
  return (
    36 === t ||
    95 === t ||
    (t >= 65 && t <= 90) ||
    (t >= 97 && t <= 122) ||
    92 === t ||
    (t >= 128 && tE.test(String.fromCharCode(t)))
  );
}
function cE(t) {
  return (
    36 === t ||
    95 === t ||
    (t >= 65 && t <= 90) ||
    (t >= 97 && t <= 122) ||
    (t >= 48 && t <= 57) ||
    92 === t ||
    (t >= 128 && nE.test(String.fromCharCode(t)))
  );
}
const lE = {
  if: 1,
  in: 1,
  do: 1,
  var: 1,
  for: 1,
  new: 1,
  try: 1,
  let: 1,
  this: 1,
  else: 1,
  case: 1,
  void: 1,
  with: 1,
  enum: 1,
  while: 1,
  break: 1,
  catch: 1,
  throw: 1,
  const: 1,
  yield: 1,
  class: 1,
  super: 1,
  return: 1,
  typeof: 1,
  delete: 1,
  switch: 1,
  export: 1,
  import: 1,
  public: 1,
  static: 1,
  default: 1,
  finally: 1,
  extends: 1,
  package: 1,
  private: 1,
  function: 1,
  continue: 1,
  debugger: 1,
  interface: 1,
  protected: 1,
  instanceof: 1,
  implements: 1,
};
function fE() {
  for (; WF < HF; ) {
    const t = UF.charCodeAt(WF);
    if (!uE(t) && !sE(t)) break;
    ++WF;
  }
}
function hE(t) {
  var n,
    e,
    r,
    i = 0;
  for (e = 'u' === t ? 4 : 2, n = 0; n < e; ++n)
    WF < HF && iE(UF[WF])
      ? ((r = UF[WF++]), (i = 16 * i + '0123456789abcdef'.indexOf(r.toLowerCase())))
      : ME({}, YF, ZF);
  return String.fromCharCode(i);
}
function dE() {
  var t, n;
  for (n = 0, '}' === (t = UF[WF]) && ME({}, YF, ZF); WF < HF && iE((t = UF[WF++])); )
    n = 16 * n + '0123456789abcdef'.indexOf(t.toLowerCase());
  return (
    (n > 1114111 || '}' !== t) && ME({}, YF, ZF),
    n <= 65535 ? String.fromCharCode(n) : String.fromCharCode(55296 + ((n - 65536) >> 10), 56320 + ((n - 65536) & 1023))
  );
}
function pE() {
  var t, n;
  for (
    t = UF.charCodeAt(WF++),
      n = String.fromCharCode(t),
      92 === t &&
        (117 !== UF.charCodeAt(WF) && ME({}, YF, ZF),
        ++WF,
        ((t = hE('u')) && '\\' !== t && aE(t.charCodeAt(0))) || ME({}, YF, ZF),
        (n = t));
    WF < HF && cE((t = UF.charCodeAt(WF)));

  )
    ++WF,
      (n += String.fromCharCode(t)),
      92 === t &&
        ((n = n.substr(0, n.length - 1)),
        117 !== UF.charCodeAt(WF) && ME({}, YF, ZF),
        ++WF,
        ((t = hE('u')) && '\\' !== t && cE(t.charCodeAt(0))) || ME({}, YF, ZF),
        (n += t));
  return n;
}
function mE() {
  var t,
    n,
    e,
    r,
    i = WF,
    o = UF.charCodeAt(WF),
    u = UF[WF];
  switch (o) {
    case 46:
    case 40:
    case 41:
    case 59:
    case 44:
    case 123:
    case 125:
    case 91:
    case 93:
    case 58:
    case 63:
    case 126:
      return ++WF, { type: 7, value: String.fromCharCode(o), start: i, end: WF };
    default:
      if (61 === (t = UF.charCodeAt(WF + 1)))
        switch (o) {
          case 43:
          case 45:
          case 47:
          case 60:
          case 62:
          case 94:
          case 124:
          case 37:
          case 38:
          case 42:
            return (WF += 2), { type: 7, value: String.fromCharCode(o) + String.fromCharCode(t), start: i, end: WF };
          case 33:
          case 61:
            return 61 === UF.charCodeAt((WF += 2)) && ++WF, { type: 7, value: UF.slice(i, WF), start: i, end: WF };
        }
  }
  return '>>>=' === (r = UF.substr(WF, 4))
    ? { type: 7, value: r, start: i, end: (WF += 4) }
    : '>>>' === (e = r.substr(0, 3)) || '<<=' === e || '>>=' === e
    ? { type: 7, value: e, start: i, end: (WF += 3) }
    : (u === (n = e.substr(0, 2))[1] && '+-<>&|'.indexOf(u) >= 0) || '=>' === n
    ? { type: 7, value: n, start: i, end: (WF += 2) }
    : ('//' === n && ME({}, YF, ZF),
      '<>=!+-*%&|^/'.indexOf(u) >= 0 ? { type: 7, value: u, start: i, end: ++WF } : void ME({}, YF, ZF));
}
function vE() {
  var t, n, e;
  if (
    (eE(
      rE((e = UF[WF]).charCodeAt(0)) || '.' === e,
      'Numeric literal must start with a decimal digit or a decimal point',
    ),
    (n = WF),
    (t = ''),
    '.' !== e)
  ) {
    if (((t = UF[WF++]), (e = UF[WF]), '0' === t)) {
      if ('x' === e || 'X' === e)
        return (
          ++WF,
          (function (t) {
            let n = '';
            for (; WF < HF && iE(UF[WF]); ) n += UF[WF++];
            return (
              0 === n.length && ME({}, YF, ZF),
              aE(UF.charCodeAt(WF)) && ME({}, YF, ZF),
              { type: 6, value: parseInt('0x' + n, 16), start: t, end: WF }
            );
          })(n)
        );
      if (oE(e))
        return (function (t) {
          let n = '0' + UF[WF++];
          for (; WF < HF && oE(UF[WF]); ) n += UF[WF++];
          return (
            (aE(UF.charCodeAt(WF)) || rE(UF.charCodeAt(WF))) && ME({}, YF, ZF),
            { type: 6, value: parseInt(n, 8), octal: !0, start: t, end: WF }
          );
        })(n);
      e && rE(e.charCodeAt(0)) && ME({}, YF, ZF);
    }
    for (; rE(UF.charCodeAt(WF)); ) t += UF[WF++];
    e = UF[WF];
  }
  if ('.' === e) {
    for (t += UF[WF++]; rE(UF.charCodeAt(WF)); ) t += UF[WF++];
    e = UF[WF];
  }
  if ('e' === e || 'E' === e)
    if (((t += UF[WF++]), ('+' !== (e = UF[WF]) && '-' !== e) || (t += UF[WF++]), rE(UF.charCodeAt(WF))))
      for (; rE(UF.charCodeAt(WF)); ) t += UF[WF++];
    else ME({}, YF, ZF);
  return aE(UF.charCodeAt(WF)) && ME({}, YF, ZF), { type: 6, value: parseFloat(t), start: n, end: WF };
}
function gE() {
  if ((fE(), WF >= HF)) return { type: 2, start: WF, end: WF };
  const t = UF.charCodeAt(WF);
  return aE(t)
    ? (function () {
        var t, n;
        return (
          (t = WF),
          (n =
            92 === UF.charCodeAt(WF)
              ? pE()
              : (function () {
                  var t, n;
                  for (t = WF++; WF < HF; ) {
                    if (92 === (n = UF.charCodeAt(WF))) return (WF = t), pE();
                    if (!cE(n)) break;
                    ++WF;
                  }
                  return UF.slice(t, WF);
                })()),
          {
            type:
              1 === n.length ? 3 : lE.hasOwnProperty(n) ? 4 : 'null' === n ? 5 : 'true' === n || 'false' === n ? 1 : 3,
            value: n,
            start: t,
            end: WF,
          }
        );
      })()
    : 40 === t || 41 === t || 59 === t
    ? mE()
    : 39 === t || 34 === t
    ? (function () {
        var t,
          n,
          e,
          r,
          i = '',
          o = !1;
        for (
          eE("'" === (t = UF[WF]) || '"' === t, 'String literal must starts with a quote'), n = WF, ++WF;
          WF < HF;

        ) {
          if ((e = UF[WF++]) === t) {
            t = '';
            break;
          }
          if ('\\' === e)
            if ((e = UF[WF++]) && sE(e.charCodeAt(0))) '\r' === e && '\n' === UF[WF] && ++WF;
            else
              switch (e) {
                case 'u':
                case 'x':
                  '{' === UF[WF] ? (++WF, (i += dE())) : (i += hE(e));
                  break;
                case 'n':
                  i += '\n';
                  break;
                case 'r':
                  i += '\r';
                  break;
                case 't':
                  i += '\t';
                  break;
                case 'b':
                  i += '\b';
                  break;
                case 'f':
                  i += '\f';
                  break;
                case 'v':
                  i += '\v';
                  break;
                default:
                  oE(e)
                    ? (0 !== (r = '01234567'.indexOf(e)) && (o = !0),
                      WF < HF &&
                        oE(UF[WF]) &&
                        ((o = !0),
                        (r = 8 * r + '01234567'.indexOf(UF[WF++])),
                        '0123'.indexOf(e) >= 0 && WF < HF && oE(UF[WF]) && (r = 8 * r + '01234567'.indexOf(UF[WF++]))),
                      (i += String.fromCharCode(r)))
                    : (i += e);
              }
          else {
            if (sE(e.charCodeAt(0))) break;
            i += e;
          }
        }
        return '' !== t && ME({}, YF, ZF), { type: 8, value: i, octal: o, start: n, end: WF };
      })()
    : 46 === t
    ? rE(UF.charCodeAt(WF + 1))
      ? vE()
      : mE()
    : rE(t)
    ? vE()
    : mE();
}
function bE() {
  const t = GF;
  return (WF = t.end), (GF = gE()), (WF = t.end), t;
}
function yE() {
  const t = WF;
  (GF = gE()), (WF = t);
}
function wE(t, n, e) {
  const r = new qF('||' === t || '&&' === t ? 'LogicalExpression' : 'BinaryExpression');
  return (r.operator = t), (r.left = n), (r.right = e), r;
}
function xE(t, n) {
  const e = new qF('CallExpression');
  return (e.callee = t), (e.arguments = n), e;
}
function OE(t) {
  const n = new qF(VF);
  return (n.name = t), n;
}
function kE(t) {
  const n = new qF('Literal');
  return (
    (n.value = t.value),
    (n.raw = UF.slice(t.start, t.end)),
    t.regex && ('//' === n.raw && (n.raw = '/(?:)/'), (n.regex = t.regex)),
    n
  );
}
function AE(t, n, e) {
  const r = new qF('MemberExpression');
  return (r.computed = '[' === t), (r.object = n), (r.property = e), r.computed || (e.member = !0), r;
}
function $E(t, n, e) {
  const r = new qF('Property');
  return (r.key = n), (r.value = e), (r.kind = t), r;
}
function ME(t, n) {
  var e,
    r = Array.prototype.slice.call(arguments, 2),
    i = n.replace(/%(\d)/g, (t, n) => (eE(n < r.length, 'Message reference must be in range'), r[n]));
  throw (((e = new Error(i)).index = WF), (e.description = i), e);
}
function jE(t) {
  2 === t.type && ME(t, 'Unexpected end of input'),
    6 === t.type && ME(t, 'Unexpected number'),
    8 === t.type && ME(t, 'Unexpected string'),
    3 === t.type && ME(t, 'Unexpected identifier'),
    4 === t.type && ME(t, 'Unexpected reserved word'),
    ME(t, YF, t.value);
}
function DE(t) {
  const n = bE();
  (7 === n.type && n.value === t) || jE(n);
}
function FE(t) {
  return 7 === GF.type && GF.value === t;
}
function EE(t) {
  return 4 === GF.type && GF.value === t;
}
function SE() {
  WF = GF.start;
  const t = bE();
  return 8 === t.type || 6 === t.type ? (t.octal && ME(t, QF), kE(t)) : OE(t.value);
}
function CE() {
  var t, n, e;
  return (
    (WF = GF.start),
    3 === (t = GF).type
      ? ((e = SE()), DE(':'), $E('init', e, LE()))
      : 2 !== t.type && 7 !== t.type
      ? ((n = SE()), DE(':'), $E('init', n, LE()))
      : void jE(t)
  );
}
const NE = { if: 1 };
function BE() {
  var t, n, e;
  if (FE('('))
    return (function () {
      DE('(');
      const t = qE();
      return DE(')'), t;
    })();
  if (FE('['))
    return (function () {
      const t = [];
      for (WF = GF.start, DE('['); !FE(']'); ) FE(',') ? (bE(), t.push(null)) : (t.push(LE()), FE(']') || DE(','));
      return (
        bE(),
        (function (t) {
          const n = new qF('ArrayExpression');
          return (n.elements = t), n;
        })(t)
      );
    })();
  if (FE('{'))
    return (function () {
      var t,
        n,
        e = [],
        r = {},
        i = String;
      for (WF = GF.start, DE('{'); !FE('}'); )
        (n = '$' + ((t = CE()).key.type === VF ? t.key.name : i(t.key.value))),
          Object.prototype.hasOwnProperty.call(r, n)
            ? ME({}, 'Duplicate data property in object literal not allowed in strict mode')
            : (r[n] = !0),
          e.push(t),
          FE('}') || DE(',');
      return (
        DE('}'),
        (function (t) {
          const n = new qF('ObjectExpression');
          return (n.properties = t), n;
        })(e)
      );
    })();
  if (((WF = GF.start), 3 === (t = GF.type) || NE[GF.value])) e = OE(bE().value);
  else if (8 === t || 6 === t) GF.octal && ME(GF, QF), (e = kE(bE()));
  else {
    if (4 === t) throw new Error(KF);
    1 === t
      ? (((n = bE()).value = 'true' === n.value), (e = kE(n)))
      : 5 === t
      ? (((n = bE()).value = null), (e = kE(n)))
      : FE('/') || FE('/=')
      ? ((e = kE(
          (function () {
            var t, n, e, r;
            return (
              (GF = null),
              fE(),
              (t = WF),
              (n = (function () {
                var t, n, e, r;
                for (
                  eE('/' === (t = UF[WF]), 'Regular expression literal must start with a slash'),
                    n = UF[WF++],
                    e = !1,
                    r = !1;
                  WF < HF;

                )
                  if (((n += t = UF[WF++]), '\\' === t)) sE((t = UF[WF++]).charCodeAt(0)) && ME({}, JF), (n += t);
                  else if (sE(t.charCodeAt(0))) ME({}, JF);
                  else if (e) ']' === t && (e = !1);
                  else {
                    if ('/' === t) {
                      r = !0;
                      break;
                    }
                    '[' === t && (e = !0);
                  }
                return r || ME({}, JF), { value: n.substr(1, n.length - 2), literal: n };
              })()),
              (e = (function () {
                var t, n, e;
                for (n = '', e = ''; WF < HF && cE((t = UF[WF]).charCodeAt(0)); )
                  ++WF, '\\' === t && WF < HF ? ME({}, YF, ZF) : ((e += t), (n += t));
                return e.search(/[^gimuy]/g) >= 0 && ME({}, XF, e), { value: e, literal: n };
              })()),
              (r = (function (t, n) {
                let e = t;
                n.indexOf('u') >= 0 &&
                  (e = e
                    .replace(/\\u\{([0-9a-fA-F]+)\}/g, (t, n) => {
                      if (parseInt(n, 16) <= 1114111) return 'x';
                      ME({}, XF);
                    })
                    .replace(/[\uD800-\uDBFF][\uDC00-\uDFFF]/g, 'x'));
                try {
                  return new RegExp(t, n);
                } catch (t) {
                  return null;
                }
              })(n.value, e.value)),
              {
                literal: n.literal + e.literal,
                value: r,
                regex: { pattern: n.value, flags: e.value },
                start: t,
                end: WF,
              }
            );
          })(),
        )),
        yE())
      : jE(bE());
  }
  return e;
}
function _E() {
  const t = [];
  if ((DE('('), !FE(')'))) for (; WF < HF && (t.push(LE()), !FE(')')); ) DE(',');
  return DE(')'), t;
}
function zE() {
  DE('[');
  const t = qE();
  return DE(']'), t;
}
function TE() {
  const t = (function () {
    var t;
    for (t = BE(); ; )
      if (FE('.'))
        t = AE(
          '.',
          t,
          (DE('.'),
          (function () {
            WF = GF.start;
            const t = bE();
            return (
              (function (t) {
                return 3 === t.type || 4 === t.type || 1 === t.type || 5 === t.type;
              })(t) || jE(t),
              OE(t.value)
            );
          })()),
        );
      else if (FE('(')) t = xE(t, _E());
      else {
        if (!FE('[')) break;
        t = AE('[', t, zE());
      }
    return t;
  })();
  if (7 === GF.type && (FE('++') || FE('--'))) throw new Error(KF);
  return t;
}
function PE() {
  var t, n;
  if (7 !== GF.type && 4 !== GF.type) n = TE();
  else {
    if (FE('++') || FE('--')) throw new Error(KF);
    if (FE('+') || FE('-') || FE('~') || FE('!'))
      (t = bE()),
        (n = PE()),
        (n = (function (t, n) {
          const e = new qF('UnaryExpression');
          return (e.operator = t), (e.argument = n), (e.prefix = !0), e;
        })(t.value, n));
    else {
      if (EE('delete') || EE('void') || EE('typeof')) throw new Error(KF);
      n = TE();
    }
  }
  return n;
}
function RE(t) {
  let n = 0;
  if (7 !== t.type && 4 !== t.type) return 0;
  switch (t.value) {
    case '||':
      n = 1;
      break;
    case '&&':
      n = 2;
      break;
    case '|':
      n = 3;
      break;
    case '^':
      n = 4;
      break;
    case '&':
      n = 5;
      break;
    case '==':
    case '!=':
    case '===':
    case '!==':
      n = 6;
      break;
    case '<':
    case '>':
    case '<=':
    case '>=':
    case 'instanceof':
    case 'in':
      n = 7;
      break;
    case '<<':
    case '>>':
    case '>>>':
      n = 8;
      break;
    case '+':
    case '-':
      n = 9;
      break;
    case '*':
    case '/':
    case '%':
      n = 11;
  }
  return n;
}
function LE() {
  var t, n;
  return (
    (t = (function () {
      var t, n, e, r, i, o, u, s, a, c;
      if (((t = GF), (a = PE()), 0 === (i = RE((r = GF))))) return a;
      for (r.prec = i, bE(), n = [t, GF], o = [a, r, (u = PE())]; (i = RE(GF)) > 0; ) {
        for (; o.length > 2 && i <= o[o.length - 2].prec; )
          (u = o.pop()), (s = o.pop().value), (a = o.pop()), n.pop(), (e = wE(s, a, u)), o.push(e);
        ((r = bE()).prec = i), o.push(r), n.push(GF), (e = PE()), o.push(e);
      }
      for (e = o[(c = o.length - 1)], n.pop(); c > 1; ) n.pop(), (e = wE(o[c - 1].value, o[c - 2], e)), (c -= 2);
      return e;
    })()),
    FE('?') &&
      (bE(),
      (n = LE()),
      DE(':'),
      (t = (function (t, n, e) {
        const r = new qF('ConditionalExpression');
        return (r.test = t), (r.consequent = n), (r.alternate = e), r;
      })(t, n, LE()))),
    t
  );
}
function qE() {
  const t = LE();
  if (FE(',')) throw new Error(KF);
  return t;
}
function IE(t) {
  (WF = 0), (HF = (UF = t).length), (GF = null), yE();
  const n = qE();
  if (2 !== GF.type) throw new Error('Unexpect token after expression.');
  return n;
}
var UE = {
  NaN: 'NaN',
  E: 'Math.E',
  LN2: 'Math.LN2',
  LN10: 'Math.LN10',
  LOG2E: 'Math.LOG2E',
  LOG10E: 'Math.LOG10E',
  PI: 'Math.PI',
  SQRT1_2: 'Math.SQRT1_2',
  SQRT2: 'Math.SQRT2',
  MIN_VALUE: 'Number.MIN_VALUE',
  MAX_VALUE: 'Number.MAX_VALUE',
};
function WE(t) {
  function n(n, e, r) {
    return i =>
      (function (n, e, r, i) {
        let o = t(e[0]);
        return (
          r && ((o = r + '(' + o + ')'), 0 === r.lastIndexOf('new ', 0) && (o = '(' + o + ')')),
          o + '.' + n + (i < 0 ? '' : 0 === i ? '()' : '(' + e.slice(1).map(t).join(',') + ')')
        );
      })(n, i, e, r);
  }
  const e = 'new Date',
    r = 'String',
    i = 'RegExp';
  return {
    isNaN: 'Number.isNaN',
    isFinite: 'Number.isFinite',
    abs: 'Math.abs',
    acos: 'Math.acos',
    asin: 'Math.asin',
    atan: 'Math.atan',
    atan2: 'Math.atan2',
    ceil: 'Math.ceil',
    cos: 'Math.cos',
    exp: 'Math.exp',
    floor: 'Math.floor',
    log: 'Math.log',
    max: 'Math.max',
    min: 'Math.min',
    pow: 'Math.pow',
    random: 'Math.random',
    round: 'Math.round',
    sin: 'Math.sin',
    sqrt: 'Math.sqrt',
    tan: 'Math.tan',
    clamp: function (n) {
      n.length < 3 && I('Missing arguments to clamp function.'),
        n.length > 3 && I('Too many arguments to clamp function.');
      const e = n.map(t);
      return 'Math.max(' + e[1] + ', Math.min(' + e[2] + ',' + e[0] + '))';
    },
    now: 'Date.now',
    utc: 'Date.UTC',
    datetime: e,
    date: n('getDate', e, 0),
    day: n('getDay', e, 0),
    year: n('getFullYear', e, 0),
    month: n('getMonth', e, 0),
    hours: n('getHours', e, 0),
    minutes: n('getMinutes', e, 0),
    seconds: n('getSeconds', e, 0),
    milliseconds: n('getMilliseconds', e, 0),
    time: n('getTime', e, 0),
    timezoneoffset: n('getTimezoneOffset', e, 0),
    utcdate: n('getUTCDate', e, 0),
    utcday: n('getUTCDay', e, 0),
    utcyear: n('getUTCFullYear', e, 0),
    utcmonth: n('getUTCMonth', e, 0),
    utchours: n('getUTCHours', e, 0),
    utcminutes: n('getUTCMinutes', e, 0),
    utcseconds: n('getUTCSeconds', e, 0),
    utcmilliseconds: n('getUTCMilliseconds', e, 0),
    length: n('length', null, -1),
    parseFloat: 'parseFloat',
    parseInt: 'parseInt',
    upper: n('toUpperCase', r, 0),
    lower: n('toLowerCase', r, 0),
    substring: n('substring', r),
    split: n('split', r),
    trim: n('trim', r, 0),
    regexp: i,
    test: n('test', i),
    if: function (n) {
      n.length < 3 && I('Missing arguments to if function.'), n.length > 3 && I('Too many arguments to if function.');
      const e = n.map(t);
      return '(' + e[0] + '?' + e[1] + ':' + e[2] + ')';
    },
  };
}
function HE(t) {
  const n = (t = t || {}).allowed ? cn(t.allowed) : {},
    e = t.forbidden ? cn(t.forbidden) : {},
    r = t.constants || UE,
    i = (t.functions || WE)(f),
    o = t.globalvar,
    u = t.fieldvar,
    s = Mt(o) ? o : t => `${o}["${t}"]`;
  let a = {},
    c = {},
    l = 0;
  function f(t) {
    if (Xt(t)) return t;
    const n = h[t.type];
    return null == n && I('Unsupported type: ' + t.type), n(t);
  }
  const h = {
    Literal: t => t.raw,
    Identifier: t => {
      const i = t.name;
      return l > 0 ? i : Pt(e, i) ? I('Illegal identifier: ' + i) : Pt(r, i) ? r[i] : Pt(n, i) ? i : ((a[i] = 1), s(i));
    },
    MemberExpression: t => {
      const n = !t.computed,
        e = f(t.object);
      n && (l += 1);
      const r = f(t.property);
      return (
        e === u &&
          (c[
            (function (t) {
              const n = t && t.length - 1;
              return n && (('"' === t[0] && '"' === t[n]) || ("'" === t[0] && "'" === t[n])) ? t.slice(1, -1) : t;
            })(r)
          ] = 1),
        n && (l -= 1),
        e + (n ? '.' + r : '[' + r + ']')
      );
    },
    CallExpression: t => {
      'Identifier' !== t.callee.type && I('Illegal callee type: ' + t.callee.type);
      const n = t.callee.name,
        e = t.arguments,
        r = Pt(i, n) && i[n];
      return r || I('Unrecognized function: ' + n), Mt(r) ? r(e) : r + '(' + e.map(f).join(',') + ')';
    },
    ArrayExpression: t => '[' + t.elements.map(f).join(',') + ']',
    BinaryExpression: t => '(' + f(t.left) + ' ' + t.operator + ' ' + f(t.right) + ')',
    UnaryExpression: t => '(' + t.operator + f(t.argument) + ')',
    ConditionalExpression: t => '(' + f(t.test) + '?' + f(t.consequent) + ':' + f(t.alternate) + ')',
    LogicalExpression: t => '(' + f(t.left) + t.operator + f(t.right) + ')',
    ObjectExpression: t => '{' + t.properties.map(f).join(',') + '}',
    Property: t => {
      l += 1;
      const n = f(t.key);
      return (l -= 1), n + ':' + f(t.value);
    },
  };
  function d(t) {
    const n = { code: f(t), globals: Object.keys(a), fields: Object.keys(c) };
    return (a = {}), (c = {}), n;
  }
  return (d.functions = i), (d.constants = r), d;
}
function GE(t, n) {
  return null == t || null == n ? NaN : t < n ? -1 : t > n ? 1 : t >= n ? 0 : NaN;
}
function VE(t) {
  return t instanceof zn ? t : new zn(t);
}
const YE = 'intersect',
  XE = 'union',
  JE = '_vgsid_',
  QE = W(JE),
  ZE = 'index:unit';
function KE(t, n) {
  for (var e, r, i = n.fields, o = n.values, u = i.length, s = 0; s < u; ++s)
    if (
      (((r = i[s]).getter = W.getter || W(r.field)),
      Ht((e = r.getter(t))) && (e = ut(e)),
      Ht(o[s]) && (o[s] = ut(o[s])),
      Ht(o[s][0]) && (o[s] = o[s].map(ut)),
      'E' === r.type)
    ) {
      if (K(o[s]) ? o[s].indexOf(e) < 0 : e !== o[s]) return !1;
    } else if ('R' === r.type) {
      if (!Ut(e, o[s])) return !1;
    } else if ('R-RE' === r.type) {
      if (!Ut(e, o[s], !0, !1)) return !1;
    } else if ('R-E' === r.type) {
      if (!Ut(e, o[s], !1, !1)) return !1;
    } else if ('R-LE' === r.type && !Ut(e, o[s], !1, !0)) return !1;
  return !0;
}
const tS = (function (t) {
    let n = t,
      e = t,
      r = t;
    function i(t, n, i = 0, o = t.length) {
      if (i < o) {
        if (0 !== e(n, n)) return o;
        do {
          const e = (i + o) >>> 1;
          r(t[e], n) < 0 ? (i = e + 1) : (o = e);
        } while (i < o);
      }
      return i;
    }
    return (
      2 !== t.length && ((n = (n, e) => t(n) - e), (e = GE), (r = (n, e) => GE(t(n), e))),
      {
        left: i,
        center: function (t, e, r = 0, o = t.length) {
          const u = i(t, e, r, o - 1);
          return u > r && n(t[u - 1], e) > -n(t[u], e) ? u - 1 : u;
        },
        right: function (t, n, i = 0, o = t.length) {
          if (i < o) {
            if (0 !== e(n, n)) return o;
            do {
              const e = (i + o) >>> 1;
              r(t[e], n) <= 0 ? (i = e + 1) : (o = e);
            } while (i < o);
          }
          return i;
        },
      }
    );
  })(QE),
  nS = tS.left,
  eS = tS.right;
var rS = {
  [''.concat(JE, '_union')]: function (...t) {
    const n = new zn();
    for (const e of t) for (const t of e) n.add(t);
    return n;
  },
  [''.concat(JE, '_intersect')]: function (t, ...n) {
    (t = new zn(t)), (n = n.map(VE));
    t: for (const e of t)
      for (const r of n)
        if (!r.has(e)) {
          t.delete(e);
          continue t;
        }
    return t;
  },
  E_union: function (t, n) {
    if (!t.length) return n;
    for (var e = 0, r = n.length; e < r; ++e) t.indexOf(n[e]) < 0 && t.push(n[e]);
    return t;
  },
  E_intersect: function (t, n) {
    return t.length ? t.filter(t => n.indexOf(t) >= 0) : n;
  },
  R_union: function (t, n) {
    var e = ut(n[0]),
      r = ut(n[1]);
    return e > r && ((e = n[1]), (r = n[0])), t.length ? (t[0] > e && (t[0] = e), t[1] < r && (t[1] = r), t) : [e, r];
  },
  R_intersect: function (t, n) {
    var e = ut(n[0]),
      r = ut(n[1]);
    return (
      e > r && ((e = n[1]), (r = n[0])),
      t.length ? (r < t[0] || t[1] < e ? [] : (t[0] < e && (t[0] = e), t[1] > r && (t[1] = r), t)) : [e, r]
    );
  },
};
function iS(t, n, e, r) {
  n[0].type !== RF && I('First argument to selection functions must be a string literal.');
  const i = n[0].value,
    o = 'unit',
    u = '@' + o,
    s = ':' + i;
  (n.length >= 2 && ot(n).value) !== YE || Pt(r, u) || (r[u] = e.getData(i).indataRef(e, o)),
    Pt(r, s) || (r[s] = e.getData(i).tuplesRef());
}
function oS(t) {
  const n = this.context.data[t];
  return n ? n.values.value : [];
}
const uS = t =>
    function (n, e) {
      return this.context.dataflow.locale()[t](e)(n);
    },
  sS = uS('format'),
  aS = uS('timeFormat'),
  cS = uS('utcFormat'),
  lS = uS('timeParse'),
  fS = uS('utcParse'),
  hS = new Date(2e3, 0, 1);
function dS(t, n, e) {
  return Number.isInteger(t) && Number.isInteger(n)
    ? (hS.setYear(2e3), hS.setMonth(t), hS.setDate(n), aS.call(this, hS, e))
    : '';
}
function pS(t, n, e, r) {
  n[0].type !== RF && I('First argument to data functions must be a string literal.');
  const i = n[0].value,
    o = ':' + i;
  if (!Pt(o, r))
    try {
      r[o] = e.getData(i).tuplesRef();
    } catch (t) {}
}
function mS(t, n, e, r) {
  if (n[0].type === RF) vS(e, r, n[0].value);
  else for (t in e.scales) vS(e, r, t);
}
function vS(t, n, e) {
  const r = '%' + e;
  if (!Pt(n, r))
    try {
      n[r] = t.scaleRef(e);
    } catch (t) {}
}
function gS(t, n) {
  let e;
  return Mt(t) ? t : Xt(t) ? (e = n.scales[t]) && e.value : void 0;
}
function bS(t, n) {
  return function (e, r, i) {
    if (e) {
      const n = gS(e, (i || this).context);
      return n && n.path[t](r);
    }
    return n(r);
  };
}
const yS = bS('area', function (t) {
    return (tO = new Bn()), zx(t, nO), 2 * tO;
  }),
  wS = bS('bounds', function (t) {
    var n, e, r, i, o, u, s;
    if (((Hx = Wx = -(Ix = Ux = 1 / 0)), (Qx = []), zx(t, FO), (e = Qx.length))) {
      for (Qx.sort(PO), n = 1, o = [(r = Qx[0])]; n < e; ++n)
        RO(r, (i = Qx[n])[0]) || RO(r, i[1])
          ? (TO(r[0], i[1]) > TO(r[0], r[1]) && (r[1] = i[1]), TO(i[0], r[1]) > TO(r[0], r[1]) && (r[0] = i[0]))
          : o.push((r = i));
      for (u = -1 / 0, n = 0, r = o[(e = o.length - 1)]; n <= e; r = i, ++n)
        (s = TO(r[1], (i = o[n])[0])) > u && ((u = s), (Ix = i[0]), (Wx = r[1]));
    }
    return (
      (Qx = Zx = null),
      Ix === 1 / 0 || Ux === 1 / 0
        ? [
            [NaN, NaN],
            [NaN, NaN],
          ]
        : [
            [Ix, Ux],
            [Wx, Hx],
          ]
    );
  }),
  xS = bS('centroid', function (t) {
    (dO = pO = mO = vO = gO = bO = yO = wO = 0), (xO = new Bn()), (OO = new Bn()), (kO = new Bn()), zx(t, LO);
    var n = +xO,
      e = +OO,
      r = +kO,
      i = xx(n, e, r);
    return i < ax && ((n = bO), (e = yO), (r = wO), pO < sx && ((n = mO), (e = vO), (r = gO)), (i = xx(n, e, r)) < ax)
      ? [NaN, NaN]
      : [gx(e, n) * dx, Fx(r / i) * dx];
  });
function OS(t, n, e) {
  try {
    t[n].apply(t, ['EXPRESSION'].concat([].slice.call(e)));
  } catch (n) {
    t.warn(n);
  }
  return e[e.length - 1];
}
function kS(t) {
  const n = t / 255;
  return n <= 0.03928 ? n / 12.92 : Math.pow((n + 0.055) / 1.055, 2.4);
}
function AS(t) {
  const n = vf(t);
  return 0.2126 * kS(n.r) + 0.7152 * kS(n.g) + 0.0722 * kS(n.b);
}
function $S(t, n) {
  return (
    t === n ||
    (t != t && n != n) ||
    (K(t)
      ? !(!K(n) || t.length !== n.length) &&
        (function (t, n) {
          for (let e = 0, r = t.length; e < r; ++e) if (!$S(t[e], n[e])) return !1;
          return !0;
        })(t, n)
      : !(!tt(t) || !tt(n)) && MS(t, n))
  );
}
function MS(t, n) {
  for (const e in t) if (!$S(t[e], n[e])) return !1;
  return !0;
}
function jS(t) {
  return n => MS(t, n);
}
const DS = {};
function FS(t) {
  return K(t) || ArrayBuffer.isView(t) ? t : null;
}
function ES(t) {
  return FS(t) || (Xt(t) ? t : null);
}
const SS = t => t.data;
function CS(t, n) {
  const e = oS.call(n, t);
  return (e.root && e.root.lookup) || {};
}
const NS = () => ('undefined' != typeof window && window) || null;
function BS(t, n, e) {
  if (!t) return [];
  const [r, i] = t,
    o = new Um().set(r[0], r[1], i[0], i[1]);
  return by(
    e || this.context.dataflow.scenegraph().root,
    o,
    (function (t) {
      let n = null;
      if (t) {
        const e = At(t.marktype),
          r = At(t.markname);
        n = t => (!e.length || e.some(n => t.marktype === n)) && (!r.length || r.some(n => t.name === n));
      }
      return n;
    })(n),
  );
}
const _S = {
    random: () => ps(),
    cumulativeNormal: Os,
    cumulativeLogNormal: Ds,
    cumulativeUniform: Bs,
    densityNormal: xs,
    densityLogNormal: js,
    densityUniform: Ns,
    quantileNormal: ks,
    quantileLogNormal: Fs,
    quantileUniform: _s,
    sampleNormal: ws,
    sampleLogNormal: Ms,
    sampleUniform: Cs,
    isArray: K,
    isBoolean: Wt,
    isDate: Ht,
    isDefined: t => void 0 !== t,
    isNumber: Vt,
    isObject: tt,
    isRegExp: Yt,
    isString: Xt,
    isTuple: Mu,
    isValid: t => null != t && t == t,
    toBoolean: on,
    toDate: t => sn(t),
    toNumber: ut,
    toString: an,
    indexof: function (t) {
      for (var n = arguments.length, e = new Array(n > 1 ? n - 1 : 0), r = 1; r < n; r++) e[r - 1] = arguments[r];
      return ES(t).indexOf(...e);
    },
    join: function (t) {
      for (var n = arguments.length, e = new Array(n > 1 ? n - 1 : 0), r = 1; r < n; r++) e[r - 1] = arguments[r];
      return FS(t).join(...e);
    },
    lastindexof: function (t) {
      for (var n = arguments.length, e = new Array(n > 1 ? n - 1 : 0), r = 1; r < n; r++) e[r - 1] = arguments[r];
      return ES(t).lastIndexOf(...e);
    },
    replace: function (t, n, e) {
      return Mt(e) && I('Function argument passed to replace.'), String(t).replace(n, e);
    },
    reverse: function (t) {
      return FS(t).slice().reverse();
    },
    slice: function (t) {
      for (var n = arguments.length, e = new Array(n > 1 ? n - 1 : 0), r = 1; r < n; r++) e[r - 1] = arguments[r];
      return ES(t).slice(...e);
    },
    flush: qt,
    lerp: Qt,
    merge: function () {
      const t = [].slice.call(arguments);
      return t.unshift({}), Bt(...t);
    },
    pad: nn,
    peek: ot,
    pluck: function (t, n) {
      const e = DS[n] || (DS[n] = W(n));
      return K(t) ? t.map(e) : e(t);
    },
    span: en,
    inrange: Ut,
    truncate: ln,
    rgb: vf,
    lab: Pf,
    hcl: Hf,
    hsl: $f,
    luminance: AS,
    contrast: function (t, n) {
      const e = AS(t),
        r = AS(n);
      return (Math.max(e, r) + 0.05) / (Math.min(e, r) + 0.05);
    },
    sequence: re,
    format: sS,
    utcFormat: cS,
    utcParse: fS,
    utcOffset: Yr,
    utcSequence: Qr,
    timeFormat: aS,
    timeParse: lS,
    timeOffset: Vr,
    timeSequence: Jr,
    timeUnitSpecifier: yr,
    monthFormat: function (t) {
      return dS.call(this, t, 1, '%B');
    },
    monthAbbrevFormat: function (t) {
      return dS.call(this, t, 1, '%b');
    },
    dayFormat: function (t) {
      return dS.call(this, 0, 2 + t, '%A');
    },
    dayAbbrevFormat: function (t) {
      return dS.call(this, 0, 2 + t, '%a');
    },
    quarter: Ot,
    utcquarter: kt,
    week: kr,
    utcweek: Fr,
    dayofyear: Or,
    utcdayofyear: Dr,
    warn: function () {
      return OS(this.context.dataflow, 'warn', arguments);
    },
    info: function () {
      return OS(this.context.dataflow, 'info', arguments);
    },
    debug: function () {
      return OS(this.context.dataflow, 'debug', arguments);
    },
    extent: t => _t(t),
    inScope: function (t) {
      const n = this.context.group;
      let e = !1;
      if (n)
        for (; t; ) {
          if (t === n) {
            e = !0;
            break;
          }
          t = t.mark.group;
        }
      return e;
    },
    intersect: BS,
    clampRange: $t,
    pinchDistance: function (t) {
      const n = t.touches,
        e = n[0].clientX - n[1].clientX,
        r = n[0].clientY - n[1].clientY;
      return Math.sqrt(e * e + r * r);
    },
    pinchAngle: function (t) {
      const n = t.touches;
      return Math.atan2(n[0].clientY - n[1].clientY, n[0].clientX - n[1].clientX);
    },
    screen: function () {
      const t = NS();
      return t ? t.screen : {};
    },
    containerSize: function () {
      const t = this.context.dataflow,
        n = t.container && t.container();
      return n ? [n.clientWidth, n.clientHeight] : [void 0, void 0];
    },
    windowSize: function () {
      const t = NS();
      return t ? [t.innerWidth, t.innerHeight] : [void 0, void 0];
    },
    bandspace: function (t, n, e) {
      return Fd(t || 0, n || 0, e || 0);
    },
    setdata: function (t, n) {
      const e = this.context.dataflow;
      return e.pulse(this.context.data[t].input, e.changeset().remove(X).insert(n)), 1;
    },
    pathShape: function (t) {
      let n = null;
      return function (e) {
        return e ? hm(e, (n = n || nm(t))) : t;
      };
    },
    panLinear: dt,
    panLog: pt,
    panPow: mt,
    panSymlog: vt,
    zoomLinear: bt,
    zoomLog: yt,
    zoomPow: wt,
    zoomSymlog: xt,
    encode: function (t, n, e) {
      if (t) {
        const e = this.context.dataflow;
        e.pulse(t.mark.source, e.changeset().encode(t, n));
      }
      return void 0 !== e ? e : t;
    },
    modify: function (t, n, e, r, i, o) {
      const u = this.context.dataflow,
        s = this.context.data[t],
        a = s.input,
        c = u.stamp();
      let l,
        f,
        h = s.changes;
      if (!1 === u._trigger || !(a.value.length || n || r)) return 0;
      if (
        ((!h || h.stamp < c) &&
          ((s.changes = h = u.changeset()),
          (h.stamp = c),
          u.runAfter(
            () => {
              (s.modified = !0), u.pulse(a, h).run();
            },
            !0,
            1,
          )),
        e && ((l = !0 === e ? X : K(e) || Mu(e) ? e : jS(e)), h.remove(l)),
        n && h.insert(n),
        r && ((l = jS(r)), a.value.some(l) ? h.remove(l) : h.insert(r)),
        i)
      )
        for (f in o) h.modify(i, f, o[f]);
      return 1;
    },
    lassoAppend: function (t, n, e) {
      let r = arguments.length > 3 && void 0 !== arguments[3] ? arguments[3] : 5;
      const i = t[t.length - 1];
      return void 0 === i || Math.sqrt((i[0] - n) ** 2 + (i[1] - e) ** 2) > r ? (t.push([n, e]), [...t]) : t;
    },
    lassoPath: function (t) {
      return (null != t ? t : []).reduce((n, e, r) => {
        let [i, o] = e;
        return (
          n +
          (0 == r ? 'M '.concat(i, ',').concat(o, ' ') : r === t.length - 1 ? ' Z' : 'L '.concat(i, ',').concat(o, ' '))
        );
      }, '');
    },
    intersectLasso: function (t, n, e) {
      const { x: r, y: i, mark: o } = e,
        u = new Um().set(
          Number.MAX_SAFE_INTEGER,
          Number.MAX_SAFE_INTEGER,
          Number.MIN_SAFE_INTEGER,
          Number.MIN_SAFE_INTEGER,
        );
      for (const [t, e] of n)
        t < u.x1 && (u.x1 = t), t > u.x2 && (u.x2 = t), e < u.y1 && (u.y1 = e), e > u.y2 && (u.y2 = e);
      return (
        u.translate(r, i),
        BS(
          [
            [u.x1, u.y1],
            [u.x2, u.y2],
          ],
          t,
          o,
        ).filter(t =>
          (function (t, n, e) {
            let r = 0;
            for (let i = 0, o = e.length - 1; i < e.length; o = i++) {
              const [u, s] = e[o],
                [a, c] = e[i];
              c > n != s > n && t < ((u - a) * (n - c)) / (s - c) + a && r++;
            }
            return 1 & r;
          })(t.x, t.y, n),
        )
      );
    },
  },
  zS = ['view', 'item', 'group', 'xy', 'x', 'y'],
  TS = 'this.',
  PS = {},
  RS = {
    forbidden: ['_'],
    allowed: ['datum', 'event', 'item'],
    fieldvar: 'datum',
    globalvar: t => '_['.concat(rn('$' + t), ']'),
    functions: function (t) {
      const n = WE(t);
      zS.forEach(t => (n[t] = 'event.vega.' + t));
      for (const t in _S) n[t] = TS + t;
      return (
        Bt(
          n,
          (function (t, n, e) {
            (n.__bandwidth = t => (t && t.bandwidth ? t.bandwidth() : 0)),
              (e._bandwidth = mS),
              (e._range = mS),
              (e._scale = mS);
            const r = n => '_[' + (n.type === RF ? rn('%' + n.value) : rn('%') + '+' + t(n)) + ']';
            return {
              _bandwidth: t => 'this.__bandwidth('.concat(r(t[0]), ')'),
              _range: t => ''.concat(r(t[0]), '.range()'),
              _scale: n => ''.concat(r(n[0]), '(').concat(t(n[1]), ')'),
            };
          })(t, _S, PS),
        ),
        n
      );
    },
    constants: UE,
    visitors: PS,
  },
  LS = HE(RS);
function qS(t, n, e) {
  return 1 === arguments.length ? _S[t] : ((_S[t] = n), e && (PS[t] = e), LS && (LS.functions[t] = TS + t), this);
}
function IS(t, n) {
  const e = {};
  let r;
  try {
    r = IE((t = Xt(t) ? t : rn(t) + ''));
  } catch (n) {
    I('Expression parse error: ' + t);
  }
  r.visit(t => {
    if (t.type !== LF) return;
    const r = t.callee.name,
      i = RS.visitors[r];
    i && i(r, t.arguments, n, e);
  });
  const i = LS(r);
  return (
    i.globals.forEach(t => {
      const r = '$' + t;
      !Pt(e, r) && n.getSignal(t) && (e[r] = n.signalRef(t));
    }),
    { $expr: Bt({ code: i.code }, n.options.ast ? { ast: r } : null), $fields: i.fields, $params: e }
  );
}
qS(
  'bandwidth',
  function (t, n) {
    const e = gS(t, (n || this).context);
    return e && e.bandwidth ? e.bandwidth() : 0;
  },
  mS,
),
  qS(
    'copy',
    function (t, n) {
      const e = gS(t, (n || this).context);
      return e ? e.copy() : void 0;
    },
    mS,
  ),
  qS(
    'domain',
    function (t, n) {
      const e = gS(t, (n || this).context);
      return e ? e.domain() : [];
    },
    mS,
  ),
  qS(
    'range',
    function (t, n) {
      const e = gS(t, (n || this).context);
      return e && e.range ? e.range() : [];
    },
    mS,
  ),
  qS(
    'invert',
    function (t, n, e) {
      const r = gS(t, (e || this).context);
      return r ? (K(n) ? (r.invertRange || r.invert)(n) : (r.invert || r.invertExtent)(n)) : void 0;
    },
    mS,
  ),
  qS(
    'scale',
    function (t, n, e) {
      const r = gS(t, (e || this).context);
      return r ? r(n) : void 0;
    },
    mS,
  ),
  qS(
    'gradient',
    function (t, n, e, r, i) {
      t = gS(t, (i || this).context);
      const o = Vp(n, e);
      let u = t.domain(),
        s = u[0],
        a = ot(u),
        c = G;
      return (
        a - s
          ? (c = gp(t, s, a))
          : (t = (
              t.interpolator
                ? ip('sequential')().interpolator(t.interpolator())
                : ip('linear')().interpolate(t.interpolate()).range(t.range())
            ).domain([(s = 0), (a = 1)])),
        t.ticks && ((u = t.ticks(+r || 15)), s !== u[0] && u.unshift(s), a !== ot(u) && u.push(a)),
        u.forEach(n => o.stop(c(n), t(n))),
        o
      );
    },
    mS,
  ),
  qS('geoArea', yS, mS),
  qS('geoBounds', wS, mS),
  qS('geoCentroid', xS, mS),
  qS(
    'geoShape',
    function (t, n, e) {
      const r = gS(t, (e || this).context);
      return function (t) {
        return r ? r.path.context(t)(n) : '';
      };
    },
    mS,
  ),
  qS(
    'indata',
    function (t, n, e) {
      const r = this.context.data[t]['index:' + n],
        i = r ? r.value.get(e) : void 0;
      return i ? i.count : i;
    },
    function (t, n, e, r) {
      n[0].type !== RF && I('First argument to indata must be a string literal.'),
        n[1].type !== RF && I('Second argument to indata must be a string literal.');
      const i = n[0].value,
        o = n[1].value,
        u = '@' + o;
      Pt(u, r) || (r[u] = e.getData(i).indataRef(e, o));
    },
  ),
  qS('data', oS, pS),
  qS(
    'treePath',
    function (t, n, e) {
      const r = CS(t, this),
        i = r[n],
        o = r[e];
      return i && o ? i.path(o).map(SS) : void 0;
    },
    pS,
  ),
  qS(
    'treeAncestors',
    function (t, n) {
      const e = CS(t, this)[n];
      return e ? e.ancestors().map(SS) : void 0;
    },
    pS,
  ),
  qS(
    'vlSelectionTest',
    function (t, n, e) {
      for (
        var r,
          i,
          o,
          u,
          s,
          a = this.context.data[t],
          c = a ? a.values.value : [],
          l = a ? a[ZE] && a[ZE].value : void 0,
          f = e === YE,
          h = c.length,
          d = 0;
        d < h;
        ++d
      )
        if (((r = c[d]), l && f)) {
          if (-1 === (o = (i = i || {})[(u = r.unit)] || 0)) continue;
          if (((s = KE(n, r)), (i[u] = s ? -1 : ++o), s && 1 === l.size)) return !0;
          if (!s && o === l.get(u).count) return !1;
        } else if (f ^ (s = KE(n, r))) return s;
      return h && f;
    },
    iS,
  ),
  qS(
    'vlSelectionIdTest',
    function (t, n, e) {
      const r = this.context.data[t],
        i = r ? r.values.value : [],
        o = r ? r[ZE] && r[ZE].value : void 0,
        u = e === YE,
        s = QE(n),
        a = nS(i, s);
      if (a === i.length) return !1;
      if (QE(i[a]) !== s) return !1;
      if (o && u) {
        if (1 === o.size) return !0;
        if (eS(i, s) - a < o.size) return !1;
      }
      return !0;
    },
    iS,
  ),
  qS(
    'vlSelectionResolve',
    function (t, n, e, r) {
      for (
        var i,
          o,
          u,
          s,
          a,
          c,
          l,
          f,
          h,
          d,
          p,
          m,
          v = this.context.data[t],
          g = v ? v.values.value : [],
          b = {},
          y = {},
          w = {},
          x = g.length,
          O = 0;
        O < x;
        ++O
      )
        if (((s = (i = g[O]).unit), (u = i.values), (o = i.fields) && u)) {
          for (p = 0, m = o.length; p < m; ++p)
            (f = (l = b[(a = o[p]).field] || (b[a.field] = {}))[s] || (l[s] = [])),
              (w[a.field] = h = a.type.charAt(0)),
              (d = rS[''.concat(h, '_union')]),
              (l[s] = d(f, At(u[p])));
          e && (f = y[s] || (y[s] = [])).push(At(u).reduce((t, n, e) => ((t[o[e].field] = n), t), {}));
        } else
          (a = JE),
            (c = QE(i)),
            (f = (l = b[a] || (b[a] = {}))[s] || (l[s] = [])).push(c),
            e && (f = y[s] || (y[s] = [])).push({ [JE]: c });
      return (
        (n = n || XE),
        b[JE]
          ? (b[JE] = rS[''.concat(JE, '_').concat(n)](...Object.values(b[JE])))
          : Object.keys(b).forEach(t => {
              b[t] = Object.keys(b[t])
                .map(n => b[t][n])
                .reduce((e, r) => (void 0 === e ? r : rS[''.concat(w[t], '_').concat(n)](e, r)));
            }),
        (g = Object.keys(y)),
        e &&
          g.length &&
          (b[r ? 'vlPoint' : 'vlMulti'] =
            n === XE ? { or: g.reduce((t, n) => (t.push(...y[n]), t), []) } : { and: g.map(t => ({ or: y[t] })) }),
        b
      );
    },
    iS,
  ),
  qS('vlSelectionTuples', function (t, n) {
    return t.map(t =>
      Bt(
        n.fields
          ? { values: n.fields.map(n => (n.getter || (n.getter = W(n.field)))(t.datum)) }
          : { [JE]: QE(t.datum) },
        n,
      ),
    );
  });
const US = cn(['rule']),
  WS = cn(['group', 'image', 'rect']);
function HS(t) {
  return (t + '').toLowerCase();
}
function GS(t, n, e) {
  ';' !== e[e.length - 1] && (e = 'return(' + e + ');');
  const r = Function(...n.concat(e));
  return t && t.functions ? r.bind(t.functions) : r;
}
var VS = {
  operator: (t, n) => GS(t, ['_'], n.code),
  parameter: (t, n) => GS(t, ['datum', '_'], n.code),
  event: (t, n) => GS(t, ['event'], n.code),
  handler: (t, n) => GS(t, ['_', 'event'], 'var datum=event.item&&event.item.datum;return '.concat(n.code, ';')),
  encode: (t, n) => {
    const { marktype: e, channels: r } = n;
    let i = 'var o=item,datum=o.datum,m=0,$;';
    for (const t in r) {
      const n = 'o[' + rn(t) + ']';
      i += '$='.concat(r[t].code, ';if(').concat(n, '!==$)').concat(n, '=$,m=1;');
    }
    return (
      (i += (function (t, n) {
        let e = '';
        return (
          US[n] ||
            (t.x2 &&
              (t.x
                ? (WS[n] && (e += 'if(o.x>o.x2)$=o.x,o.x=o.x2,o.x2=$;'), (e += 'o.width=o.x2-o.x;'))
                : (e += 'o.x=o.x2-(o.width||0);')),
            t.xc && (e += 'o.x=o.xc-(o.width||0)/2;'),
            t.y2 &&
              (t.y
                ? (WS[n] && (e += 'if(o.y>o.y2)$=o.y,o.y=o.y2,o.y2=$;'), (e += 'o.height=o.y2-o.y;'))
                : (e += 'o.y=o.y2-(o.height||0);')),
            t.yc && (e += 'o.y=o.yc-(o.height||0)/2;')),
          e
        );
      })(r, e)),
      (i += 'return m;'),
      GS(t, ['item', '_'], i)
    );
  },
  codegen: {
    get(t) {
      const n = '['.concat(t.map(rn).join(']['), ']'),
        e = Function('_', 'return _'.concat(n, ';'));
      return (e.path = n), e;
    },
    comparator(t, n) {
      let e;
      const r = Function(
        'a',
        'b',
        'var u, v; return ' +
          t
            .map((t, r) => {
              const i = n[r];
              let o, u;
              return (
                t.path
                  ? ((o = 'a'.concat(t.path)), (u = 'b'.concat(t.path)))
                  : (((e = e || {})['f' + r] = t), (o = 'this.f'.concat(r, '(a)')), (u = 'this.f'.concat(r, '(b)'))),
                (function (t, n, e, r) {
                  return '((u = '
                    .concat(t, ') < (v = ')
                    .concat(n, ') || u == null) && v != null ? ')
                    .concat(e, '\n  : (u > v || v == null) && u != null ? ')
                    .concat(
                      r,
                      '\n  : ((v = v instanceof Date ? +v : v), (u = u instanceof Date ? +u : u)) !== u && v === v ? ',
                    )
                    .concat(e, '\n  : v !== v && u === u ? ')
                    .concat(r, ' : ');
                })(o, u, -i, i)
              );
            })
            .join('') +
          '0;',
      );
      return e ? r.bind(e) : r;
    },
  },
};
function YS(t, n, e) {
  if (!t || !tt(t)) return t;
  for (let r, i = 0, o = XS.length; i < o; ++i) if (((r = XS[i]), Pt(t, r.key))) return r.parse(t, n, e);
  return t;
}
var XS = [
  {
    key: '$ref',
    parse: function (t, n) {
      return n.get(t.$ref) || I('Operator not defined: ' + t.$ref);
    },
  },
  {
    key: '$key',
    parse: function (t, n) {
      const e = 'k:' + t.$key + '_' + !!t.$flat;
      return n.fn[e] || (n.fn[e] = Jt(t.$key, t.$flat, n.expr.codegen));
    },
  },
  {
    key: '$expr',
    parse: function (t, n, e) {
      t.$params && n.parseParameters(t.$params, e);
      const r = 'e:' + t.$expr.code + '_' + t.$name;
      return n.fn[r] || (n.fn[r] = z(n.parameterExpression(t.$expr), t.$fields, t.$name));
    },
  },
  {
    key: '$field',
    parse: function (t, n) {
      if (!t.$field) return null;
      const e = 'f:' + t.$field + '_' + t.$name;
      return n.fn[e] || (n.fn[e] = W(t.$field, t.$name, n.expr.codegen));
    },
  },
  {
    key: '$encode',
    parse: function (t, n) {
      const e = t.$encode,
        r = {};
      for (const t in e) {
        const i = e[t];
        (r[t] = z(n.encodeExpression(i.$expr), i.$fields)), (r[t].output = i.$output);
      }
      return r;
    },
  },
  {
    key: '$compare',
    parse: function (t, n) {
      const e = 'c:' + t.$compare + '_' + t.$order,
        r = At(t.$compare).map(t => (t && t.$tupleid ? ju : t));
      return n.fn[e] || (n.fn[e] = jt(r, t.$order, n.expr.codegen));
    },
  },
  {
    key: '$context',
    parse: function (t, n) {
      return n;
    },
  },
  {
    key: '$subflow',
    parse: function (t, n) {
      const e = t.$subflow;
      return function (t, r, i) {
        const o = n.fork().parse(e),
          u = o.get(e.operators[0].id),
          s = o.signals.parent;
        return s && s.set(i), (u.detachSubflow = () => n.detach(o)), u;
      };
    },
  },
  {
    key: '$tupleid',
    parse: function () {
      return ju;
    },
  },
];
const JS = { skip: !0 };
function QS(t, n, e, r) {
  return new ZS(t, n, e, r);
}
function ZS(t, n, e, r) {
  (this.dataflow = t),
    (this.transforms = n),
    (this.events = t.events.bind(t)),
    (this.expr = r || VS),
    (this.signals = {}),
    (this.scales = {}),
    (this.nodes = {}),
    (this.data = {}),
    (this.fn = {}),
    e && ((this.functions = Object.create(e)), (this.functions.context = this));
}
function KS(t) {
  (this.dataflow = t.dataflow),
    (this.transforms = t.transforms),
    (this.events = t.events),
    (this.expr = t.expr),
    (this.signals = Object.create(t.signals)),
    (this.scales = Object.create(t.scales)),
    (this.nodes = Object.create(t.nodes)),
    (this.data = Object.create(t.data)),
    (this.fn = Object.create(t.fn)),
    t.functions && ((this.functions = Object.create(t.functions)), (this.functions.context = this));
}
function tC(t, n) {
  t && (null == n ? t.removeAttribute('aria-label') : t.setAttribute('aria-label', n));
}
ZS.prototype = KS.prototype = {
  fork() {
    const t = new KS(this);
    return (this.subcontext || (this.subcontext = [])).push(t), t;
  },
  detach(t) {
    this.subcontext = this.subcontext.filter(n => n !== t);
    const n = Object.keys(t.nodes);
    for (const e of n) t.nodes[e]._targets = null;
    for (const e of n) t.nodes[e].detach();
    t.nodes = null;
  },
  get(t) {
    return this.nodes[t];
  },
  set(t, n) {
    return (this.nodes[t] = n);
  },
  add(t, n) {
    const e = this,
      r = e.dataflow,
      i = t.value;
    if (
      (e.set(t.id, n),
      'collect' === HS(t.type) &&
        i &&
        (i.$ingest
          ? r.ingest(n, i.$ingest, i.$format)
          : i.$request
          ? r.preload(n, i.$request, i.$format)
          : r.pulse(n, r.changeset().insert(i))),
      t.root && (e.root = n),
      t.parent)
    ) {
      let i = e.get(t.parent.$ref);
      i
        ? (r.connect(i, [n]), n.targets().add(i))
        : (e.unresolved = e.unresolved || []).push(() => {
            (i = e.get(t.parent.$ref)), r.connect(i, [n]), n.targets().add(i);
          });
    }
    if ((t.signal && (e.signals[t.signal] = n), t.scale && (e.scales[t.scale] = n), t.data))
      for (const r in t.data) {
        const i = e.data[r] || (e.data[r] = {});
        t.data[r].forEach(t => (i[t] = n));
      }
  },
  resolve() {
    return (this.unresolved || []).forEach(t => t()), delete this.unresolved, this;
  },
  operator(t, n) {
    this.add(t, this.dataflow.add(t.value, n));
  },
  transform(t, n) {
    this.add(t, this.dataflow.add(this.transforms[HS(n)]));
  },
  stream(t, n) {
    this.set(t.id, n);
  },
  update(t, n, e, r, i) {
    this.dataflow.on(n, e, r, i, t.options);
  },
  operatorExpression(t) {
    return this.expr.operator(this, t);
  },
  parameterExpression(t) {
    return this.expr.parameter(this, t);
  },
  eventExpression(t) {
    return this.expr.event(this, t);
  },
  handlerExpression(t) {
    return this.expr.handler(this, t);
  },
  encodeExpression(t) {
    return this.expr.encode(this, t);
  },
  parse: function (t) {
    const n = this,
      e = t.operators || [];
    return (
      t.background && (n.background = t.background),
      t.eventConfig && (n.eventConfig = t.eventConfig),
      t.locale && (n.locale = t.locale),
      e.forEach(t => n.parseOperator(t)),
      e.forEach(t => n.parseOperatorParameters(t)),
      (t.streams || []).forEach(t => n.parseStream(t)),
      (t.updates || []).forEach(t => n.parseUpdate(t)),
      n.resolve()
    );
  },
  parseOperator: function (t) {
    const n = this;
    'operator' !== HS(t.type) && t.type
      ? n.transform(t, t.type)
      : n.operator(t, t.update ? n.operatorExpression(t.update) : null);
  },
  parseOperatorParameters: function (t) {
    const n = this;
    if (t.params) {
      const e = n.get(t.id);
      e || I('Invalid operator id: ' + t.id),
        n.dataflow.connect(e, e.parameters(n.parseParameters(t.params), t.react, t.initonly));
    }
  },
  parseParameters: function (t, n) {
    n = n || {};
    const e = this;
    for (const r in t) {
      const i = t[r];
      n[r] = K(i) ? i.map(t => YS(t, e, n)) : YS(i, e, n);
    }
    return n;
  },
  parseStream: function (t) {
    var n,
      e = this,
      r = null != t.filter ? e.eventExpression(t.filter) : void 0,
      i = null != t.stream ? e.get(t.stream) : void 0;
    t.source
      ? (i = e.events(t.source, t.type, r))
      : t.merge && (i = (n = t.merge.map(t => e.get(t)))[0].merge.apply(n[0], n.slice(1))),
      t.between && ((n = t.between.map(t => e.get(t))), (i = i.between(n[0], n[1]))),
      t.filter && (i = i.filter(r)),
      null != t.throttle && (i = i.throttle(+t.throttle)),
      null != t.debounce && (i = i.debounce(+t.debounce)),
      null == i && I('Invalid stream definition: ' + JSON.stringify(t)),
      t.consume && i.consume(!0),
      e.stream(t, i);
  },
  parseUpdate: function (t) {
    var n,
      e = this,
      r = tt((r = t.source)) ? r.$ref : r,
      i = e.get(r),
      o = t.update,
      u = void 0;
    i || I('Source not defined: ' + t.source),
      (n = t.target && t.target.$expr ? e.eventExpression(t.target.$expr) : e.get(t.target)),
      o && o.$expr && (o.$params && (u = e.parseParameters(o.$params)), (o = e.handlerExpression(o.$expr))),
      e.update(t, i, n, o, u);
  },
  getState: function (t) {
    var n = this,
      e = {};
    if (t.signals) {
      var r = (e.signals = {});
      Object.keys(n.signals).forEach(e => {
        const i = n.signals[e];
        t.signals(e, i) && (r[e] = i.value);
      });
    }
    if (t.data) {
      var i = (e.data = {});
      Object.keys(n.data).forEach(e => {
        const r = n.data[e];
        t.data(e, r) && (i[e] = r.input.value);
      });
    }
    return n.subcontext && !1 !== t.recurse && (e.subcontext = n.subcontext.map(n => n.getState(t))), e;
  },
  setState: function (t) {
    var n = this,
      e = n.dataflow,
      r = t.data,
      i = t.signals;
    Object.keys(i || {}).forEach(t => {
      e.update(n.signals[t], i[t], JS);
    }),
      Object.keys(r || {}).forEach(t => {
        e.pulse(n.data[t].input, e.changeset().remove(X).insert(r[t]));
      }),
      (t.subcontext || []).forEach((t, e) => {
        const r = n.subcontext[e];
        r && r.setState(t);
      });
  },
};
const nC = 'default';
function eC(t, n) {
  const e = t.globalCursor() ? 'undefined' != typeof document && document.body : t.container();
  if (e) return null == n ? e.style.removeProperty('cursor') : (e.style.cursor = n);
}
function rC(t, n) {
  var e = t._runtime.data;
  return Pt(e, n) || I('Unrecognized data set: ' + n), e[n];
}
function iC(t, n) {
  Bu(n) || I('Second argument to changes must be a changeset.');
  const e = rC(this, t);
  return (e.modified = !0), this.pulse(e.input, n);
}
function oC(t) {
  var n = t.padding();
  return Math.max(0, t._viewWidth + n.left + n.right);
}
function uC(t) {
  var n = t.padding();
  return Math.max(0, t._viewHeight + n.top + n.bottom);
}
function sC(t) {
  var n = t.padding(),
    e = t._origin;
  return [n.left + e[0], n.top + e[1]];
}
const aC = 'view',
  cC = { trap: !1 };
function lC(t, n, e, r) {
  t._eventListeners.push({ type: e, sources: At(n), handler: r });
}
function fC(t, n, e) {
  const r = t._eventConfig && t._eventConfig[n];
  return !(!1 === r || (tt(r) && !r[e])) || (t.warn('Blocked '.concat(n, ' ').concat(e, ' event listener.')), !1);
}
function hC(t) {
  return t.item;
}
function dC(t) {
  return t.item.mark.source;
}
function pC(t) {
  return function (n, e) {
    return e.vega.view().changeset().encode(e.item, t);
  };
}
function mC(t, n, e) {
  const r = document.createElement(t);
  for (const t in n) r.setAttribute(t, n[t]);
  return null != e && (r.textContent = e), r;
}
function vC(t, n, e, r) {
  const i = e.event || 'input',
    o = () => t.update(n.value);
  r.signal(e.signal, n.value),
    n.addEventListener(i, o),
    lC(r, n, i, o),
    (t.set = t => {
      (n.value = t),
        n.dispatchEvent(
          (function (t) {
            return 'undefined' != typeof Event ? new Event(t) : { type: t };
          })(i),
        );
    });
}
function gC(t, n, e, r) {
  const i = r.signal(e.signal),
    o = mC('div', { class: 'vega-bind' }),
    u = 'radio' === e.input ? o : o.appendChild(mC('label'));
  u.appendChild(mC('span', { class: 'vega-bind-name' }, e.name || e.signal)), n.appendChild(o);
  let s = bC;
  switch (e.input) {
    case 'checkbox':
      s = yC;
      break;
    case 'select':
      s = wC;
      break;
    case 'radio':
      s = xC;
      break;
    case 'range':
      s = OC;
  }
  s(t, u, e, i);
}
function bC(t, n, e, r) {
  const i = mC('input');
  for (const t in e) 'signal' !== t && 'element' !== t && i.setAttribute('input' === t ? 'type' : t, e[t]);
  i.setAttribute('name', e.signal),
    (i.value = r),
    n.appendChild(i),
    i.addEventListener('input', () => t.update(i.value)),
    (t.elements = [i]),
    (t.set = t => (i.value = t));
}
function yC(t, n, e, r) {
  const i = { type: 'checkbox', name: e.signal };
  r && (i.checked = !0);
  const o = mC('input', i);
  n.appendChild(o),
    o.addEventListener('change', () => t.update(o.checked)),
    (t.elements = [o]),
    (t.set = t => (o.checked = !!t || null));
}
function wC(t, n, e, r) {
  const i = mC('select', { name: e.signal }),
    o = e.labels || [];
  e.options.forEach((t, n) => {
    const e = { value: t };
    kC(t, r) && (e.selected = !0), i.appendChild(mC('option', e, (o[n] || t) + ''));
  }),
    n.appendChild(i),
    i.addEventListener('change', () => {
      t.update(e.options[i.selectedIndex]);
    }),
    (t.elements = [i]),
    (t.set = t => {
      for (let n = 0, r = e.options.length; n < r; ++n) if (kC(e.options[n], t)) return void (i.selectedIndex = n);
    });
}
function xC(t, n, e, r) {
  const i = mC('span', { class: 'vega-bind-radio' }),
    o = e.labels || [];
  n.appendChild(i),
    (t.elements = e.options.map((n, u) => {
      const s = { type: 'radio', name: e.signal, value: n };
      kC(n, r) && (s.checked = !0);
      const a = mC('input', s);
      a.addEventListener('change', () => t.update(n));
      const c = mC('label', {}, (o[u] || n) + '');
      return c.prepend(a), i.appendChild(c), a;
    })),
    (t.set = n => {
      const e = t.elements,
        r = e.length;
      for (let t = 0; t < r; ++t) kC(e[t].value, n) && (e[t].checked = !0);
    });
}
function OC(t, n, e, r) {
  r = void 0 !== r ? r : (+e.max + +e.min) / 2;
  const i = null != e.max ? e.max : Math.max(100, +r) || 100,
    o = e.min || Math.min(0, i, +r) || 0,
    u = e.step || Yn(o, i, 100),
    s = mC('input', { type: 'range', name: e.signal, min: o, max: i, step: u });
  s.value = r;
  const a = mC('span', {}, +r);
  n.appendChild(s), n.appendChild(a);
  const c = () => {
    (a.textContent = s.value), t.update(+s.value);
  };
  s.addEventListener('input', c),
    s.addEventListener('change', c),
    (t.elements = [s]),
    (t.set = t => {
      (s.value = t), (a.textContent = t);
    });
}
function kC(t, n) {
  return t === n || t + '' == n + '';
}
function AC(t, n, e, r, i, o) {
  return (n = n || new r(t.loader())).initialize(e, oC(t), uC(t), sC(t), i, o).background(t.background());
}
function $C(t, n) {
  return n
    ? function () {
        try {
          n.apply(this, arguments);
        } catch (n) {
          t.error(n);
        }
      }
    : null;
}
function MC(t, n, e) {
  if ('string' == typeof n) {
    if ('undefined' == typeof document) return t.error('DOM document instance not found.'), null;
    if (!(n = document.querySelector(n))) return t.error('Signal bind element not found: ' + n), null;
  }
  if (n && e)
    try {
      n.textContent = '';
    } catch (e) {
      (n = null), t.error(e);
    }
  return n;
}
const jC = t => +t || 0;
function DC(t) {
  return tt(t)
    ? { top: jC(t.top), bottom: jC(t.bottom), left: jC(t.left), right: jC(t.right) }
    : (t => ({ top: t, bottom: t, left: t, right: t }))(jC(t));
}
async function FC(t, n, e, r) {
  const i = gy(n),
    o = i && i.headless;
  return (
    o || I('Unrecognized renderer type: ' + n),
    await t.runAsync(),
    AC(t, null, null, o, e, r).renderAsync(t._scenegraph.root)
  );
}
var EC = 'width',
  SC = 'height',
  CC = 'padding',
  NC = { skip: !0 };
function BC(t, n) {
  var e = t.autosize(),
    r = t.padding();
  return n - (e && e.contains === CC ? r.left + r.right : 0);
}
function _C(t, n) {
  var e = t.autosize(),
    r = t.padding();
  return n - (e && e.contains === CC ? r.top + r.bottom : 0);
}
function zC(t, n) {
  return n.modified && K(n.input.value) && t.indexOf('_:vega:_');
}
function TC(t, n) {
  return !('parent' === t || n instanceof us.proxy);
}
function PC(t, n, e, r) {
  const i = t.element();
  i &&
    i.setAttribute(
      'title',
      (function (t) {
        return null == t
          ? ''
          : K(t)
          ? RC(t)
          : tt(t) && !Ht(t)
          ? ((n = t),
            Object.keys(n)
              .map(t => {
                const e = n[t];
                return t + ': ' + (K(e) ? RC(e) : LC(e));
              })
              .join('\n'))
          : t + '';
        var n;
      })(r),
    );
}
function RC(t) {
  return '[' + t.map(LC).join(', ') + ']';
}
function LC(t) {
  return K(t) ? '[…]' : tt(t) && !Ht(t) ? '{…}' : t;
}
function qC(t, n) {
  const e = this;
  if (
    ((n = n || {}),
    rs.call(e),
    n.loader && e.loader(n.loader),
    n.logger && e.logger(n.logger),
    null != n.logLevel && e.logLevel(n.logLevel),
    n.locale || t.locale)
  ) {
    const r = Bt({}, t.locale, n.locale);
    e.locale(Yo(r.number, r.time));
  }
  (e._el = null), (e._elBind = null), (e._renderType = n.renderer || my.Canvas), (e._scenegraph = new Yg());
  const r = e._scenegraph.root;
  (e._renderer = null),
    (e._tooltip = n.tooltip || PC),
    (e._redraw = !0),
    (e._handler = new wb().scene(r)),
    (e._globalCursor = !1),
    (e._preventDefault = !1),
    (e._timers = []),
    (e._eventListeners = []),
    (e._resizeListeners = []),
    (e._eventConfig = (function (t) {
      const n = Bt({ defaults: {} }, t),
        e = (t, n) => {
          n.forEach(n => {
            K(t[n]) && (t[n] = cn(t[n]));
          });
        };
      return e(n.defaults, ['prevent', 'allow']), e(n, ['view', 'window', 'selector']), n;
    })(t.eventConfig)),
    e.globalCursor(e._eventConfig.globalCursor);
  const i = (function (t, n, e) {
    return QS(t, us, _S, e).parse(n);
  })(e, t, n.expr);
  (e._runtime = i),
    (e._signals = i.signals),
    (e._bind = (t.bindings || []).map(t => ({ state: null, param: Bt({}, t) }))),
    i.root && i.root.set(r),
    (r.source = i.data.root.input),
    e.pulse(i.data.root.input, e.changeset().insert(r.items)),
    (e._width = e.width()),
    (e._height = e.height()),
    (e._viewWidth = BC(e, e._width)),
    (e._viewHeight = _C(e, e._height)),
    (e._origin = [0, 0]),
    (e._resize = 0),
    (e._autosize = 1),
    (function (t) {
      var n = t._signals,
        e = n[EC],
        r = n[SC],
        i = n[CC];
      function o() {
        t._autosize = t._resize = 1;
      }
      (t._resizeWidth = t.add(
        null,
        n => {
          (t._width = n.size), (t._viewWidth = BC(t, n.size)), o();
        },
        { size: e },
      )),
        (t._resizeHeight = t.add(
          null,
          n => {
            (t._height = n.size), (t._viewHeight = _C(t, n.size)), o();
          },
          { size: r },
        ));
      const u = t.add(null, o, { pad: i });
      (t._resizeWidth.rank = e.rank + 1), (t._resizeHeight.rank = r.rank + 1), (u.rank = i.rank + 1);
    })(e),
    (function (t) {
      t.add(null, n => ((t._background = n.bg), (t._resize = 1), n.bg), { bg: t._signals.background });
    })(e),
    (function (t) {
      const n = t._signals.cursor || (t._signals.cursor = t.add({ user: nC, item: null }));
      t.on(t.events('view', 'mousemove'), n, (t, e) => {
        const r = n.value,
          i = r ? (Xt(r) ? r : r.user) : nC,
          o = (e.item && e.item.cursor) || null;
        return r && i === r.user && o == r.item ? r : { user: i, item: o };
      }),
        t.add(
          null,
          function (n) {
            let e = n.cursor,
              r = this.value;
            return Xt(e) || ((r = e.item), (e = e.user)), eC(t, e && e !== nC ? e : r || e), r;
          },
          { cursor: n },
        );
    })(e),
    e.description(t.description),
    n.hover && e.hover(),
    n.container && e.initialize(n.container, n.bind);
}
function IC(t, n) {
  return Pt(t._signals, n) ? t._signals[n] : I('Unrecognized signal name: ' + rn(n));
}
function UC(t, n) {
  const e = (t._targets || []).filter(t => t._update && t._update.handler === n);
  return e.length ? e[0] : null;
}
function WC(t, n, e, r) {
  let i = UC(e, r);
  return i || ((i = $C(t, () => r(n, e.value))), (i.handler = r), t.on(e, null, i)), t;
}
function HC(t, n, e) {
  const r = UC(n, e);
  return r && n._targets.remove(r), t;
}
It(qC, rs, {
  async evaluate(t, n, e) {
    if ((await rs.prototype.evaluate.call(this, t, n), this._redraw || this._resize))
      try {
        this._renderer &&
          (this._resize &&
            ((this._resize = 0),
            (function (t) {
              var n = sC(t),
                e = oC(t),
                r = uC(t);
              t._renderer.background(t.background()),
                t._renderer.resize(e, r, n),
                t._handler.origin(n),
                t._resizeListeners.forEach(n => {
                  try {
                    n(e, r);
                  } catch (n) {
                    t.error(n);
                  }
                });
            })(this)),
          await this._renderer.renderAsync(this._scenegraph.root)),
          (this._redraw = !1);
      } catch (t) {
        this.error(t);
      }
    return e && ku(this, e), this;
  },
  dirty(t) {
    (this._redraw = !0), this._renderer && this._renderer.dirty(t);
  },
  description(t) {
    if (arguments.length) {
      const n = null != t ? t + '' : null;
      return n !== this._desc && tC(this._el, (this._desc = n)), this;
    }
    return this._desc;
  },
  container() {
    return this._el;
  },
  scenegraph() {
    return this._scenegraph;
  },
  origin() {
    return this._origin.slice();
  },
  signal(t, n, e) {
    const r = IC(this, t);
    return 1 === arguments.length ? r.value : this.update(r, n, e);
  },
  width(t) {
    return arguments.length ? this.signal('width', t) : this.signal('width');
  },
  height(t) {
    return arguments.length ? this.signal('height', t) : this.signal('height');
  },
  padding(t) {
    return arguments.length ? this.signal('padding', DC(t)) : DC(this.signal('padding'));
  },
  autosize(t) {
    return arguments.length ? this.signal('autosize', t) : this.signal('autosize');
  },
  background(t) {
    return arguments.length ? this.signal('background', t) : this.signal('background');
  },
  renderer(t) {
    return arguments.length
      ? (gy(t) || I('Unrecognized renderer type: ' + t),
        t !== this._renderType && ((this._renderType = t), this._resetRenderer()),
        this)
      : this._renderType;
  },
  tooltip(t) {
    return arguments.length
      ? (t !== this._tooltip && ((this._tooltip = t), this._resetRenderer()), this)
      : this._tooltip;
  },
  loader(t) {
    return arguments.length
      ? (t !== this._loader && (rs.prototype.loader.call(this, t), this._resetRenderer()), this)
      : this._loader;
  },
  resize() {
    return (this._autosize = 1), this.touch(IC(this, 'autosize'));
  },
  _resetRenderer() {
    this._renderer && ((this._renderer = null), this.initialize(this._el, this._elBind));
  },
  _resizeView: function (t, n, e, r, i, o) {
    this.runAfter(
      u => {
        let s = 0;
        (u._autosize = 0),
          u.width() !== e && ((s = 1), u.signal(EC, e, NC), u._resizeWidth.skip(!0)),
          u.height() !== r && ((s = 1), u.signal(SC, r, NC), u._resizeHeight.skip(!0)),
          u._viewWidth !== t && ((u._resize = 1), (u._viewWidth = t)),
          u._viewHeight !== n && ((u._resize = 1), (u._viewHeight = n)),
          (u._origin[0] === i[0] && u._origin[1] === i[1]) || ((u._resize = 1), (u._origin = i)),
          s && u.run('enter'),
          o && u.runAfter(t => t.resize());
      },
      !1,
      1,
    );
  },
  addEventListener(t, n, e) {
    let r = n;
    return (e && !1 === e.trap) || ((r = $C(this, n)), (r.raw = n)), this._handler.on(t, r), this;
  },
  removeEventListener(t, n) {
    for (var e, r, i = this._handler.handlers(t), o = i.length; --o >= 0; )
      if (((e = i[o].handler), t === (r = i[o].type) && (n === e || n === e.raw))) {
        this._handler.off(r, e);
        break;
      }
    return this;
  },
  addResizeListener(t) {
    const n = this._resizeListeners;
    return n.indexOf(t) < 0 && n.push(t), this;
  },
  removeResizeListener(t) {
    var n = this._resizeListeners,
      e = n.indexOf(t);
    return e >= 0 && n.splice(e, 1), this;
  },
  addSignalListener(t, n) {
    return WC(this, t, IC(this, t), n);
  },
  removeSignalListener(t, n) {
    return HC(this, IC(this, t), n);
  },
  addDataListener(t, n) {
    return WC(this, t, rC(this, t).values, n);
  },
  removeDataListener(t, n) {
    return HC(this, rC(this, t).values, n);
  },
  globalCursor(t) {
    if (arguments.length) {
      if (this._globalCursor !== !!t) {
        const n = eC(this, null);
        (this._globalCursor = !!t), n && eC(this, n);
      }
      return this;
    }
    return this._globalCursor;
  },
  preventDefault(t) {
    return arguments.length ? ((this._preventDefault = t), this) : this._preventDefault;
  },
  timer: function (t, n) {
    this._timers.push(
      (function (t, n, e) {
        var r = new EM(),
          i = n;
        return null == n
          ? (r.restart(t, n, e), r)
          : ((r._restart = r.restart),
            (r.restart = function (t, n, e) {
              (n = +n),
                (e = null == e ? DM() : +e),
                r._restart(
                  function o(u) {
                    (u += i), r._restart(o, (i += n), e), t(u);
                  },
                  n,
                  e,
                );
            }),
            r.restart(t, n, e),
            r);
      })(function (n) {
        t({ timestamp: Date.now(), elapsed: n });
      }, n),
    );
  },
  events: function (t, n, e) {
    var r,
      i = this,
      o = new Uu(e),
      u = function (e, r) {
        i.runAsync(null, () => {
          t === aC &&
            (function (t, n) {
              var e = t._eventConfig.defaults,
                r = e.prevent,
                i = e.allow;
              return !1 !== r && !0 !== i && (!0 === r || !1 === i || (r ? r[n] : i ? !i[n] : t.preventDefault()));
            })(i, n) &&
            e.preventDefault(),
            o.receive(
              (function (t, n, e) {
                var r,
                  i,
                  o = t._renderer,
                  u = o && o.canvas();
                return (
                  u &&
                    ((i = sC(t)), ((r = nb(n.changedTouches ? n.changedTouches[0] : n, u))[0] -= i[0]), (r[1] -= i[1])),
                  (n.dataflow = t),
                  (n.item = e),
                  (n.vega = (function (t, n, e) {
                    const r = n ? ('group' === n.mark.marktype ? n : n.mark.group) : null;
                    function i(t) {
                      var e,
                        i = r;
                      if (t)
                        for (e = n; e; e = e.mark.group)
                          if (e.mark.name === t) {
                            i = e;
                            break;
                          }
                      return i && i.mark && i.mark.interactive ? i : {};
                    }
                    function o(t) {
                      if (!t) return e;
                      Xt(t) && (t = i(t));
                      const n = e.slice();
                      for (; t; ) (n[0] -= t.x || 0), (n[1] -= t.y || 0), (t = t.mark && t.mark.group);
                      return n;
                    }
                    return { view: Ct(t), item: Ct(n || {}), group: i, xy: o, x: t => o(t)[0], y: t => o(t)[1] };
                  })(t, e, r)),
                  n
                );
              })(i, e, r),
            );
        });
      };
    if ('timer' === t) fC(i, 'timer', n) && i.timer(u, n);
    else if (t === aC) fC(i, 'view', n) && i.addEventListener(n, u, cC);
    else if (
      ('window' === t
        ? fC(i, 'window', n) && 'undefined' != typeof window && (r = [window])
        : 'undefined' != typeof document && fC(i, 'selector', n) && (r = document.querySelectorAll(t)),
      r)
    ) {
      for (var s = 0, a = r.length; s < a; ++s) r[s].addEventListener(n, u);
      lC(i, r, n, u);
    } else i.warn('Can not resolve event source: ' + t);
    return o;
  },
  finalize: function () {
    var t,
      n,
      e,
      r = this._tooltip,
      i = this._timers,
      o = this._eventListeners;
    for (t = i.length; --t >= 0; ) i[t].stop();
    for (t = o.length; --t >= 0; )
      for (n = (e = o[t]).sources.length; --n >= 0; ) e.sources[n].removeEventListener(e.type, e.handler);
    return r && r.call(this, this._handler, null, null, null), this;
  },
  hover: function (t, n) {
    return (
      (n = [n || 'update', (t = [t || 'hover'])[0]]),
      this.on(this.events('view', 'mouseover', hC), dC, pC(t)),
      this.on(this.events('view', 'mouseout', hC), dC, pC(n)),
      this
    );
  },
  data: function (t, n) {
    return arguments.length < 2 ? rC(this, t).values.value : iC.call(this, t, _u().remove(X).insert(n));
  },
  change: iC,
  insert: function (t, n) {
    return iC.call(this, t, _u().insert(n));
  },
  remove: function (t, n) {
    return iC.call(this, t, _u().remove(n));
  },
  scale: function (t) {
    var n = this._runtime.scales;
    return Pt(n, t) || I('Unrecognized scale or projection: ' + t), n[t].value;
  },
  initialize: function (t, n) {
    const e = this,
      r = e._renderType,
      i = e._eventConfig.bind,
      o = gy(r);
    (t = e._el = t ? MC(e, t, !0) : null),
      (function (t) {
        const n = t.container();
        n &&
          (n.setAttribute('role', 'graphics-document'),
          n.setAttribute('aria-roleDescription', 'visualization'),
          tC(n, t.description()));
      })(e),
      o || e.error('Unrecognized renderer type: ' + r);
    const u = o.handler || wb,
      s = t ? o.renderer : o.headless;
    return (
      (e._renderer = s ? AC(e, e._renderer, t, s) : null),
      (e._handler = (function (t, n, e, r) {
        const i = new r(t.loader(), $C(t, t.tooltip())).scene(t.scenegraph().root).initialize(e, sC(t), t);
        return (
          n &&
            n.handlers().forEach(t => {
              i.on(t.type, t.handler);
            }),
          i
        );
      })(e, e._handler, t, u)),
      (e._redraw = !0),
      t &&
        'none' !== i &&
        ((n = n ? (e._elBind = MC(e, n, !0)) : t.appendChild(mC('form', { class: 'vega-bindings' }))),
        e._bind.forEach(t => {
          t.param.element && 'container' !== i && (t.element = MC(e, t.param.element, !!t.param.input));
        }),
        e._bind.forEach(t => {
          !(function (t, n, e) {
            if (!n) return;
            const r = e.param;
            let i = e.state;
            i ||
              ((i = e.state =
                {
                  elements: null,
                  active: !1,
                  set: null,
                  update: n => {
                    n != t.signal(r.signal) &&
                      t.runAsync(null, () => {
                        (i.source = !0), t.signal(r.signal, n);
                      });
                  },
                }),
              r.debounce && (i.update = Nt(r.debounce, i.update))),
              (null == r.input && r.element ? vC : gC)(i, n, r, t),
              i.active ||
                (t.on(t._signals[r.signal], null, () => {
                  i.source ? (i.source = !1) : i.set(t.signal(r.signal));
                }),
                (i.active = !0));
          })(e, t.element || n, t);
        })),
      e
    );
  },
  toImageURL: async function (t, n) {
    t !== my.Canvas && t !== my.SVG && t !== my.PNG && I('Unrecognized image type: ' + t);
    const e = await FC(this, t, n);
    return t === my.SVG
      ? (function (t) {
          const n = new Blob([t], { type: 'image/svg+xml' });
          return window.URL.createObjectURL(n);
        })(e.svg())
      : e.canvas().toDataURL('image/png');
  },
  toCanvas: async function (t, n) {
    return (await FC(this, my.Canvas, t, n)).canvas();
  },
  toSVG: async function (t) {
    return (await FC(this, my.SVG, t)).svg();
  },
  getState: function (t) {
    return this._runtime.getState(t || { data: zC, signals: TC, recurse: !0 });
  },
  setState: function (t) {
    return (
      this.runAsync(
        null,
        n => {
          (n._trigger = !1), n._runtime.setState(t);
        },
        t => {
          t._trigger = !0;
        },
      ),
      this
    );
  },
});
const GC = /[[\]{}]/,
  VC = {
    '*': 1,
    arc: 1,
    area: 1,
    group: 1,
    image: 1,
    line: 1,
    path: 1,
    rect: 1,
    rule: 1,
    shape: 1,
    symbol: 1,
    text: 1,
    trail: 1,
  };
let YC, XC;
function JC(t, n, e) {
  return (YC = n || 'view'), (XC = e || VC), ZC(t.trim()).map(KC);
}
function QC(t, n, e, r, i) {
  const o = t.length;
  let u,
    s = 0;
  for (; n < o; ++n) {
    if (((u = t[n]), !s && u === e)) return n;
    i && i.indexOf(u) >= 0 ? --s : r && r.indexOf(u) >= 0 && ++s;
  }
  return n;
}
function ZC(t) {
  const n = [],
    e = t.length;
  let r = 0,
    i = 0;
  for (; i < e; ) (i = QC(t, i, ',', '[{', ']}')), n.push(t.substring(r, i).trim()), (r = ++i);
  if (0 === n.length) throw 'Empty event selector: ' + t;
  return n;
}
function KC(t) {
  return '[' === t[0]
    ? (function (t) {
        const n = t.length;
        let e,
          r = 1;
        if (((r = QC(t, r, ']', '[', ']')), r === n)) throw 'Empty between selector: ' + t;
        if (((e = ZC(t.substring(1, r))), 2 !== e.length)) throw 'Between selector must have two elements: ' + t;
        if ('>' !== (t = t.slice(r + 1).trim())[0]) throw "Expected '>' after between selector: " + t;
        e = e.map(KC);
        const i = KC(t.slice(1).trim());
        return i.between ? { between: e, stream: i } : ((i.between = e), i);
      })(t)
    : (function (t) {
        const n = { source: YC },
          e = [];
        let r,
          i,
          o = [0, 0],
          u = 0,
          s = 0,
          a = t.length,
          c = 0;
        if ('}' === t[a - 1]) {
          if (((c = t.lastIndexOf('{')), !(c >= 0))) throw 'Unmatched right brace: ' + t;
          try {
            o = (function (t) {
              const n = t.split(',');
              if (!t.length || n.length > 2) throw t;
              return n.map(n => {
                const e = +n;
                if (e != e) throw t;
                return e;
              });
            })(t.substring(c + 1, a - 1));
          } catch (n) {
            throw 'Invalid throttle specification: ' + t;
          }
          (a = (t = t.slice(0, c).trim()).length), (c = 0);
        }
        if (!a) throw t;
        if (
          ('@' === t[0] && (u = ++c),
          (r = QC(t, c, ':')),
          r < a && (e.push(t.substring(s, r).trim()), (s = c = ++r)),
          (c = QC(t, c, '[')),
          c === a)
        )
          e.push(t.substring(s, a).trim());
        else if ((e.push(t.substring(s, c).trim()), (i = []), (s = ++c), s === a)) throw 'Unmatched left bracket: ' + t;
        for (; c < a; ) {
          if (((c = QC(t, c, ']')), c === a)) throw 'Unmatched left bracket: ' + t;
          if ((i.push(t.substring(s, c).trim()), c < a - 1 && '[' !== t[++c])) throw 'Expected left bracket: ' + t;
          s = ++c;
        }
        if (!(a = e.length) || GC.test(e[a - 1])) throw 'Invalid event selector: ' + t;
        return (
          a > 1
            ? ((n.type = e[1]), u ? (n.markname = e[0].slice(1)) : XC[e[0]] ? (n.marktype = e[0]) : (n.source = e[0]))
            : (n.type = e[0]),
          '!' === n.type.slice(-1) && ((n.consume = !0), (n.type = n.type.slice(0, -1))),
          null != i && (n.filter = i),
          o[0] && (n.throttle = o[0]),
          o[1] && (n.debounce = o[1]),
          n
        );
      })(t);
}
function tN(t) {
  return tt(t) ? t : { type: t || 'pad' };
}
const nN = t => +t || 0;
function eN(t) {
  return tt(t)
    ? t.signal
      ? t
      : { top: nN(t.top), bottom: nN(t.bottom), left: nN(t.left), right: nN(t.right) }
    : { top: (n = nN(t)), bottom: n, left: n, right: n };
  var n;
}
const rN = t => (tt(t) && !K(t) ? Bt({}, t) : { value: t });
function iN(t, n, e, r) {
  return null != e
    ? ((tt(e) && !K(e)) || (K(e) && e.length && tt(e[0])) ? (t.update[n] = e) : (t[r || 'enter'][n] = { value: e }), 1)
    : 0;
}
function oN(t, n, e) {
  for (const e in n) iN(t, e, n[e]);
  for (const n in e) iN(t, n, e[n], 'update');
}
function uN(t, n, e) {
  for (const r in n) (e && Pt(e, r)) || (t[r] = Bt(t[r] || {}, n[r]));
  return t;
}
function sN(t, n) {
  return n && ((n.enter && n.enter[t]) || (n.update && n.update[t]));
}
const aN = 'mark',
  cN = 'frame',
  lN = 'scope',
  fN = 'legend-label';
function hN(t, n, e) {
  t[n] = e && e.signal ? { signal: e.signal } : { value: e };
}
const dN = t => (Xt(t) ? rn(t) : t.signal ? `(${t.signal})` : gN(t));
function pN(t) {
  if (null != t.gradient)
    return (function (t) {
      const n = [t.start, t.stop, t.count].map(t => (null == t ? null : rn(t)));
      for (; n.length && null == ot(n); ) n.pop();
      return n.unshift(dN(t.gradient)), `gradient(${n.join(',')})`;
    })(t);
  let n = t.signal
    ? `(${t.signal})`
    : t.color
    ? (function (t) {
        return t.c
          ? mN('hcl', t.h, t.c, t.l)
          : t.h || t.s
          ? mN('hsl', t.h, t.s, t.l)
          : t.l || t.a
          ? mN('lab', t.l, t.a, t.b)
          : t.r || t.g || t.b
          ? mN('rgb', t.r, t.g, t.b)
          : null;
      })(t.color)
    : null != t.field
    ? gN(t.field)
    : void 0 !== t.value
    ? rn(t.value)
    : void 0;
  return (
    null != t.scale &&
      (n = (function (t, n) {
        const e = dN(t.scale);
        return (
          null != t.range
            ? (n = `lerp(_range(${e}), ${+t.range})`)
            : (void 0 !== n && (n = `_scale(${e}, ${n})`),
              t.band &&
                ((n = (n ? n + '+' : '') + `_bandwidth(${e})` + (1 == +t.band ? '' : '*' + vN(t.band))),
                t.extra && (n = `(datum.extra ? _scale(${e}, datum.extra.value) : ${n})`)),
              null == n && (n = '0')),
          n
        );
      })(t, n)),
    void 0 === n && (n = null),
    null != t.exponent && (n = `pow(${n},${vN(t.exponent)})`),
    null != t.mult && (n += `*${vN(t.mult)}`),
    null != t.offset && (n += `+${vN(t.offset)}`),
    t.round && (n = `round(${n})`),
    n
  );
}
const mN = (t, n, e, r) => `(${t}(${[n, e, r].map(pN).join(',')})+'')`;
function vN(t) {
  return tt(t) ? '(' + pN(t) + ')' : t;
}
function gN(t) {
  return bN(tt(t) ? t : { datum: t });
}
function bN(t) {
  let n, e, r;
  if (t.signal) (n = 'datum'), (r = t.signal);
  else if (t.group || t.parent) {
    for (e = Math.max(1, t.level || 1), n = 'item'; e-- > 0; ) n += '.mark.group';
    t.parent ? ((r = t.parent), (n += '.datum')) : (r = t.group);
  } else t.datum ? ((n = 'datum'), (r = t.datum)) : I('Invalid field reference: ' + rn(t));
  return t.signal || (r = Xt(r) ? U(r).map(rn).join('][') : bN(r)), n + '[' + r + ']';
}
function yN(t, n, e, r, i, o) {
  const u = {};
  ((o = o || {}).encoders = { $encode: u }),
    (t = (function (t, n, e, r, i) {
      const o = {},
        u = {};
      let s, a, c, l;
      for (a in ((a = 'lineBreak'),
      'text' !== n || null == i[a] || sN(a, t) || hN(o, a, i[a]),
      ('legend' == e || String(e).startsWith('axis')) && (e = null),
      (l = e === cN ? i.group : e === aN ? Bt({}, i.mark, i[n]) : null),
      l))
        (c = sN(a, t) || (('fill' === a || 'stroke' === a) && (sN('fill', t) || sN('stroke', t)))), c || hN(o, a, l[a]);
      for (a in (At(r).forEach(n => {
        const e = i.style && i.style[n];
        for (const n in e) sN(n, t) || hN(o, n, e[n]);
      }),
      (t = Bt({}, t)),
      o))
        (l = o[a]), l.signal ? ((s = s || {})[a] = l) : (u[a] = l);
      return (t.enter = Bt(u, t.enter)), s && (t.update = Bt(s, t.update)), t;
    })(t, n, e, r, i.config));
  for (const e in t) u[e] = wN(t[e], n, o, i);
  return o;
}
function wN(t, n, e, r) {
  const i = {},
    o = {};
  for (const n in t)
    null != t[n] &&
      (i[n] = xN(
        K((u = t[n]))
          ? (function (t) {
              let n = '';
              return (
                t.forEach(t => {
                  const e = pN(t);
                  n += t.test ? `(${t.test})?${e}:` : e;
                }),
                ':' === ot(n) && (n += 'null'),
                n
              );
            })(u)
          : pN(u),
        r,
        e,
        o,
      ));
  var u;
  return { $expr: { marktype: n, channels: i }, $fields: Object.keys(o), $output: Object.keys(t) };
}
function xN(t, n, e, r) {
  const i = IS(t, n);
  return i.$fields.forEach(t => (r[t] = 1)), Bt(e, i.$params), i.$expr;
}
const ON = ['value', 'update', 'init', 'react', 'bind'];
function kN(t, n) {
  I(t + ' for "outer" push: ' + rn(n));
}
function AN(t, n) {
  const e = t.name;
  if ('outer' === t.push)
    n.signals[e] || kN('No prior signal definition', e),
      ON.forEach(n => {
        void 0 !== t[n] && kN('Invalid property ', n);
      });
  else {
    const r = n.addSignal(e, t.value);
    !1 === t.react && (r.react = !1), t.bind && n.addBinding(e, t.bind);
  }
}
function $N(t, n, e, r) {
  (this.id = -1), (this.type = t), (this.value = n), (this.params = e), r && (this.parent = r);
}
function MN(t, n, e, r) {
  return new $N(t, n, e, r);
}
function jN(t, n) {
  return MN('operator', t, n);
}
function DN(t) {
  const n = { $ref: t.id };
  return t.id < 0 && (t.refs = t.refs || []).push(n), n;
}
function FN(t, n) {
  return n ? { $field: t, $name: n } : { $field: t };
}
const EN = FN('key');
function SN(t, n) {
  return { $compare: t, $order: n };
}
function CN(t, n) {
  return (t && t.signal ? '$' + t.signal : t || '') + (t && n ? '_' : '') + (n && n.signal ? '$' + n.signal : n || '');
}
const NN = 'scope',
  BN = 'view';
function _N(t) {
  return t && t.signal;
}
function zN(t) {
  if (_N(t)) return !0;
  if (tt(t)) for (const n in t) if (zN(t[n])) return !0;
  return !1;
}
function TN(t, n) {
  return null != t ? t : n;
}
function PN(t) {
  return (t && t.signal) || t;
}
const RN = 'timer';
function LN(t, n) {
  return (t.merge ? qN : t.stream ? IN : t.type ? UN : I('Invalid stream specification: ' + rn(t)))(t, n);
}
function qN(t, n) {
  const e = WN({ merge: t.merge.map(t => LN(t, n)) }, t, n);
  return n.addStream(e).id;
}
function IN(t, n) {
  const e = WN({ stream: LN(t.stream, n) }, t, n);
  return n.addStream(e).id;
}
function UN(t, n) {
  let e;
  t.type === RN
    ? ((e = n.event(RN, t.throttle)), (t = { between: t.between, filter: t.filter }))
    : (e = n.event(
        (function (t) {
          return t === NN ? BN : t || BN;
        })(t.source),
        t.type,
      ));
  const r = WN({ stream: e }, t, n);
  return 1 === Object.keys(r).length ? e : n.addStream(r).id;
}
function WN(t, n, e) {
  let r = n.between;
  return (
    r &&
      (2 !== r.length && I('Stream "between" parameter must have 2 entries: ' + rn(n)),
      (t.between = [LN(r[0], e), LN(r[1], e)])),
    (r = n.filter ? [].concat(n.filter) : []),
    (n.marktype || n.markname || n.markrole) &&
      r.push(
        (function (t, n, e) {
          const r = 'event.item';
          return (
            r +
            (t && '*' !== t ? '&&' + r + ".mark.marktype==='" + t + "'" : '') +
            (e ? '&&' + r + ".mark.role==='" + e + "'" : '') +
            (n ? '&&' + r + ".mark.name==='" + n + "'" : '')
          );
        })(n.marktype, n.markname, n.markrole),
      ),
    n.source === NN && r.push('inScope(event.item)'),
    r.length && (t.filter = IS('(' + r.join(')&&(') + ')', e).$expr),
    null != (r = n.throttle) && (t.throttle = +r),
    null != (r = n.debounce) && (t.debounce = +r),
    n.consume && (t.consume = !0),
    t
  );
}
const HN = { code: '_.$value', ast: { type: 'Identifier', value: 'value' } };
function GN(t) {
  return { signal: '[' + t.map(t => (t.scale ? 'scale("' + t.scale + '")' : t.signal)) + ']' };
}
const VN = t => (n, e, r) => MN(t, e, n || void 0, r),
  YN = VN('aggregate'),
  XN = VN('axisticks'),
  JN = VN('bound'),
  QN = VN('collect'),
  ZN = VN('compare'),
  KN = VN('datajoin'),
  tB = VN('encode'),
  nB = VN('expression'),
  eB = VN('facet'),
  rB = VN('field'),
  iB = VN('key'),
  oB = VN('legendentries'),
  uB = VN('load'),
  sB = VN('mark'),
  aB = VN('multiextent'),
  cB = VN('multivalues'),
  lB = VN('overlap'),
  fB = VN('params'),
  hB = VN('prefacet'),
  dB = VN('projection'),
  pB = VN('proxy'),
  mB = VN('relay'),
  vB = VN('render'),
  gB = VN('scale'),
  bB = VN('sieve'),
  yB = VN('sortitems'),
  wB = VN('viewlayout'),
  xB = VN('values');
let OB = 0;
const kB = { min: 'min', max: 'max', count: 'sum' };
function AB(t, n) {
  const e = n.getScale(t.name).params;
  let r;
  for (r in ((e.domain = DB(t.domain, t, n)),
  null != t.range && (e.range = zB(t, n, e)),
  null != t.interpolate &&
    (function (t, n) {
      (n.interpolate = $B(t.type || t)), null != t.gamma && (n.interpolateGamma = $B(t.gamma));
    })(t.interpolate, e),
  null != t.nice && (e.nice = tt((i = t.nice)) ? { interval: $B(i.interval), step: $B(i.step) } : $B(i)),
  null != t.bins &&
    (e.bins = (function (t, n) {
      return t.signal || K(t) ? MB(t, n) : n.objectProperty(t);
    })(t.bins, n)),
  t))
    Pt(e, r) || 'name' === r || (e[r] = $B(t[r], n));
  var i;
}
function $B(t, n) {
  return tt(t) ? (t.signal ? n.signalRef(t.signal) : I('Unsupported object: ' + rn(t))) : t;
}
function MB(t, n) {
  return t.signal ? n.signalRef(t.signal) : t.map(t => $B(t, n));
}
function jB(t) {
  I('Can not find data set: ' + rn(t));
}
function DB(t, n, e) {
  if (t) return t.signal ? e.signalRef(t.signal) : (K(t) ? FB : t.fields ? SB : EB)(t, n, e);
  (null == n.domainMin && null == n.domainMax) || I('No scale domain defined for domainMin/domainMax to override.');
}
function FB(t, n, e) {
  return t.map(t => $B(t, e));
}
function EB(t, n, e) {
  const r = e.getData(t.data);
  return (
    r || jB(t.data),
    ap(n.type)
      ? r.valuesRef(e, t.field, NB(t.sort, !1))
      : hp(n.type)
      ? r.domainRef(e, t.field)
      : r.extentRef(e, t.field)
  );
}
function SB(t, n, e) {
  const r = t.data,
    i = t.fields.reduce(
      (t, n) => (
        (n = Xt(n)
          ? { data: r, field: n }
          : K(n) || n.signal
          ? (function (t, n) {
              const e = '_:vega:_' + OB++,
                r = QN({});
              if (K(t)) r.value = { $ingest: t };
              else if (t.signal) {
                const i = 'setdata(' + rn(e) + ',' + t.signal + ')';
                r.params.input = n.signalRef(i);
              }
              return n.addDataPipeline(e, [r, bB({})]), { data: e, field: 'data' };
            })(n, e)
          : n),
        t.push(n),
        t
      ),
      [],
    );
  return (ap(n.type) ? CB : hp(n.type) ? BB : _B)(t, e, i);
}
function CB(t, n, e) {
  const r = NB(t.sort, !0);
  let i, o;
  const u = e.map(t => {
      const e = n.getData(t.data);
      return e || jB(t.data), e.countsRef(n, t.field, r);
    }),
    s = { groupby: EN, pulse: u };
  r &&
    ((i = r.op || 'count'),
    (o = r.field ? CN(i, r.field) : 'count'),
    (s.ops = [kB[i]]),
    (s.fields = [n.fieldRef(o)]),
    (s.as = [o])),
    (i = n.add(YN(s)));
  const a = n.add(QN({ pulse: DN(i) }));
  return (o = n.add(xB({ field: EN, sort: n.sortRef(r), pulse: DN(a) }))), DN(o);
}
function NB(t, n) {
  return (
    t &&
      (t.field || t.op
        ? t.field || 'count' === t.op
          ? n && t.field && t.op && !kB[t.op] && I('Multiple domain scales can not be sorted using ' + t.op)
          : I('No field provided for sort aggregate op: ' + t.op)
        : tt(t)
        ? (t.field = 'key')
        : (t = { field: 'key' })),
    t
  );
}
function BB(t, n, e) {
  const r = e.map(t => {
    const e = n.getData(t.data);
    return e || jB(t.data), e.domainRef(n, t.field);
  });
  return DN(n.add(cB({ values: r })));
}
function _B(t, n, e) {
  const r = e.map(t => {
    const e = n.getData(t.data);
    return e || jB(t.data), e.extentRef(n, t.field);
  });
  return DN(n.add(aB({ extents: r })));
}
function zB(t, n, e) {
  const r = n.config.range;
  let i = t.range;
  if (i.signal) return n.signalRef(i.signal);
  if (Xt(i)) {
    if (r && Pt(r, i)) return zB((t = Bt({}, t, { range: r[i] })), n, e);
    'width' === i
      ? (i = [0, { signal: 'width' }])
      : 'height' === i
      ? (i = ap(t.type) ? [0, { signal: 'height' }] : [{ signal: 'height' }, 0])
      : I('Unrecognized scale range value: ' + rn(i));
  } else {
    if (i.scheme)
      return (
        (e.scheme = K(i.scheme) ? MB(i.scheme, n) : $B(i.scheme, n)),
        i.extent && (e.schemeExtent = MB(i.extent, n)),
        void (i.count && (e.schemeCount = $B(i.count, n)))
      );
    if (i.step) return void (e.rangeStep = $B(i.step, n));
    if (ap(t.type) && !K(i)) return DB(i, t, n);
    K(i) || I('Unsupported range type: ' + rn(i));
  }
  return i.map(t => (K(t) ? MB : $B)(t, n));
}
function TB(t, n, e) {
  return K(t)
    ? t.map(t => TB(t, n, e))
    : tt(t)
    ? t.signal
      ? e.signalRef(t.signal)
      : 'fit' === n
      ? t
      : I('Unsupported parameter object: ' + rn(t))
    : t;
}
const PB = 'top',
  RB = 'left',
  LB = 'right',
  qB = 'bottom',
  IB = 'center',
  UB = 'index',
  WB = 'label',
  HB = 'perc',
  GB = 'value',
  VB = 'guide-label',
  YB = 'guide-title',
  XB = 'symbol',
  JB = 'gradient',
  QB = 'discrete',
  ZB = 'size',
  KB = [ZB, 'shape', 'fill', 'stroke', 'strokeWidth', 'strokeDash', 'opacity'],
  t_ = { name: 1, style: 1, interactive: 1 },
  n_ = { value: 0 },
  e_ = { value: 1 },
  r_ = 'group',
  i_ = 'rect',
  o_ = 'rule',
  u_ = 'text';
function s_(t) {
  return (t.type = r_), (t.interactive = t.interactive || !1), t;
}
function a_(t, n) {
  const e = (e, r) => TN(t[e], TN(n[e], r));
  return (
    (e.isVertical = e => 'vertical' === TN(t.direction, n.direction || (e ? n.symbolDirection : n.gradientDirection))),
    (e.gradientLength = () => TN(t.gradientLength, n.gradientLength || n.gradientWidth)),
    (e.gradientThickness = () => TN(t.gradientThickness, n.gradientThickness || n.gradientHeight)),
    (e.entryColumns = () => TN(t.columns, TN(n.columns, +e.isVertical(!0)))),
    e
  );
}
function c_(t, n) {
  const e = n && ((n.update && n.update[t]) || (n.enter && n.enter[t]));
  return e && e.signal ? e : e ? e.value : null;
}
function l_(t, n, e) {
  return `item.anchor === 'start' ? ${t} : item.anchor === 'end' ? ${n} : ${e}`;
}
const f_ = l_(rn(RB), rn(LB), rn(IB));
function h_(t, n) {
  return n ? (t ? (tt(t) ? Object.assign({}, t, { offset: h_(t.offset, n) }) : { value: t, offset: n }) : n) : t;
}
function d_(t, n) {
  return (
    n
      ? ((t.name = n.name),
        (t.style = n.style || t.style),
        (t.interactive = !!n.interactive),
        (t.encode = uN(t.encode, n, t_)))
      : (t.interactive = !1),
    t
  );
}
function p_(t, n, e, r) {
  const i = a_(t, e),
    o = i.isVertical(),
    u = i.gradientThickness(),
    s = i.gradientLength();
  let a, c, l, f, h;
  o ? ((c = [0, 1]), (l = [0, 0]), (f = u), (h = s)) : ((c = [0, 0]), (l = [1, 0]), (f = s), (h = u));
  const d = {
    enter: (a = { opacity: n_, x: n_, y: n_, width: rN(f), height: rN(h) }),
    update: Bt({}, a, { opacity: e_, fill: { gradient: n, start: c, stop: l } }),
    exit: { opacity: n_ },
  };
  return (
    oN(
      d,
      { stroke: i('gradientStrokeColor'), strokeWidth: i('gradientStrokeWidth') },
      { opacity: i('gradientOpacity') },
    ),
    d_({ type: i_, role: 'legend-gradient', encode: d }, r)
  );
}
function m_(t, n, e, r, i) {
  const o = a_(t, e),
    u = o.isVertical(),
    s = o.gradientThickness(),
    a = o.gradientLength();
  let c,
    l,
    f,
    h,
    d = '';
  u
    ? ((c = 'y'), (f = 'y2'), (l = 'x'), (h = 'width'), (d = '1-'))
    : ((c = 'x'), (f = 'x2'), (l = 'y'), (h = 'height'));
  const p = { opacity: n_, fill: { scale: n, field: GB } };
  (p[c] = { signal: d + 'datum.' + HB, mult: a }),
    (p[l] = n_),
    (p[f] = { signal: d + 'datum.perc2', mult: a }),
    (p[h] = rN(s));
  const m = { enter: p, update: Bt({}, p, { opacity: e_ }), exit: { opacity: n_ } };
  return (
    oN(
      m,
      { stroke: o('gradientStrokeColor'), strokeWidth: o('gradientStrokeWidth') },
      { opacity: o('gradientOpacity') },
    ),
    d_({ type: i_, role: 'legend-band', key: GB, from: i, encode: m }, r)
  );
}
const v_ = `datum.${HB}<=0?"${RB}":datum.${HB}>=1?"${LB}":"${IB}"`,
  g_ = `datum.${HB}<=0?"${qB}":datum.${HB}>=1?"${PB}":"middle"`;
function b_(t, n, e, r) {
  const i = a_(t, n),
    o = i.isVertical(),
    u = rN(i.gradientThickness()),
    s = i.gradientLength();
  let a,
    c,
    l,
    f,
    h = i('labelOverlap'),
    d = '';
  const p = { enter: (a = { opacity: n_ }), update: (c = { opacity: e_, text: { field: WB } }), exit: { opacity: n_ } };
  return (
    oN(p, {
      fill: i('labelColor'),
      fillOpacity: i('labelOpacity'),
      font: i('labelFont'),
      fontSize: i('labelFontSize'),
      fontStyle: i('labelFontStyle'),
      fontWeight: i('labelFontWeight'),
      limit: TN(t.labelLimit, n.gradientLabelLimit),
    }),
    o
      ? ((a.align = { value: 'left' }), (a.baseline = c.baseline = { signal: g_ }), (l = 'y'), (f = 'x'), (d = '1-'))
      : ((a.align = c.align = { signal: v_ }), (a.baseline = { value: 'top' }), (l = 'x'), (f = 'y')),
    (a[l] = c[l] = { signal: d + 'datum.' + HB, mult: s }),
    (a[f] = c[f] = u),
    (u.offset = TN(t.labelOffset, n.gradientLabelOffset) || 0),
    (h = h ? { separation: i('labelSeparation'), method: h, order: 'datum.' + UB } : void 0),
    d_({ type: u_, role: fN, style: VB, key: GB, from: r, encode: p, overlap: h }, e)
  );
}
function y_(t, n, e, r, i) {
  const o = a_(t, n),
    u = e.entries,
    s = !(!u || !u.interactive),
    a = u ? u.name : void 0,
    c = o('clipHeight'),
    l = o('symbolOffset'),
    f = { data: 'value' },
    h = `(${i}) ? datum.offset : datum.${ZB}`,
    d = c ? rN(c) : { field: ZB },
    p = `datum.${UB}`,
    m = `max(1, ${i})`;
  let v, g, b, y, w;
  (d.mult = 0.5),
    (v = {
      enter: (g = { opacity: n_, x: { signal: h, mult: 0.5, offset: l }, y: d }),
      update: (b = { opacity: e_, x: g.x, y: g.y }),
      exit: { opacity: n_ },
    });
  let x = null,
    O = null;
  t.fill || ((x = n.symbolBaseFillColor), (O = n.symbolBaseStrokeColor)),
    oN(
      v,
      {
        fill: o('symbolFillColor', x),
        shape: o('symbolType'),
        size: o('symbolSize'),
        stroke: o('symbolStrokeColor', O),
        strokeDash: o('symbolDash'),
        strokeDashOffset: o('symbolDashOffset'),
        strokeWidth: o('symbolStrokeWidth'),
      },
      { opacity: o('symbolOpacity') },
    ),
    KB.forEach(n => {
      t[n] && (b[n] = g[n] = { scale: t[n], field: GB });
    });
  const k = d_({ type: 'symbol', role: 'legend-symbol', key: GB, from: f, clip: !!c || void 0, encode: v }, e.symbols),
    A = rN(l);
  (A.offset = o('labelOffset')),
    (v = {
      enter: (g = { opacity: n_, x: { signal: h, offset: A }, y: d }),
      update: (b = { opacity: e_, text: { field: WB }, x: g.x, y: g.y }),
      exit: { opacity: n_ },
    }),
    oN(v, {
      align: o('labelAlign'),
      baseline: o('labelBaseline'),
      fill: o('labelColor'),
      fillOpacity: o('labelOpacity'),
      font: o('labelFont'),
      fontSize: o('labelFontSize'),
      fontStyle: o('labelFontStyle'),
      fontWeight: o('labelFontWeight'),
      limit: o('labelLimit'),
    });
  const $ = d_({ type: u_, role: fN, style: VB, key: GB, from: f, encode: v }, e.labels);
  return (
    (v = {
      enter: { noBound: { value: !c }, width: n_, height: c ? rN(c) : n_, opacity: n_ },
      exit: { opacity: n_ },
      update: (b = { opacity: e_, row: { signal: null }, column: { signal: null } }),
    }),
    o.isVertical(!0)
      ? ((y = `ceil(item.mark.items.length / ${m})`),
        (b.row.signal = `${p}%${y}`),
        (b.column.signal = `floor(${p} / ${y})`),
        (w = { field: ['row', p] }))
      : ((b.row.signal = `floor(${p} / ${m})`), (b.column.signal = `${p} % ${m}`), (w = { field: p })),
    (b.column.signal = `(${i})?${b.column.signal}:${p}`),
    s_({
      role: lN,
      from: (r = { facet: { data: r, name: 'value', groupby: UB } }),
      encode: uN(v, u, t_),
      marks: [k, $],
      name: a,
      interactive: s,
      sort: w,
    })
  );
}
const w_ = 'item.orient === "left"',
  x_ = 'item.orient === "right"',
  O_ = `(${w_} || ${x_})`,
  k_ = `datum.vgrad && ${O_}`,
  A_ = l_('"top"', '"bottom"', '"middle"'),
  $_ = `datum.vgrad && ${x_} ? (${l_(
    '"right"',
    '"left"',
    '"center"',
  )}) : (${O_} && !(datum.vgrad && ${w_})) ? "left" : ${f_}`,
  M_ = `item._anchor || (${O_} ? "middle" : "start")`,
  j_ = `${k_} ? (${w_} ? -90 : 90) : 0`,
  D_ = `${O_} ? (datum.vgrad ? (${x_} ? "bottom" : "top") : ${A_}) : "top"`;
function F_(t, n) {
  let e;
  return (
    tt(t) &&
      (t.signal
        ? (e = t.signal)
        : t.path
        ? (e = 'pathShape(' + E_(t.path) + ')')
        : t.sphere && (e = 'geoShape(' + E_(t.sphere) + ', {type: "Sphere"})')),
    e ? n.signalRef(e) : !!t
  );
}
function E_(t) {
  return tt(t) && t.signal ? t.signal : rn(t);
}
function S_(t) {
  const n = t.role || '';
  return n.indexOf('axis') && n.indexOf('legend') && n.indexOf('title') ? (t.type === r_ ? lN : n || aN) : n;
}
function C_(t) {
  return {
    marktype: t.type,
    name: t.name || void 0,
    role: t.role || S_(t),
    zindex: +t.zindex || void 0,
    aria: t.aria,
    description: t.description,
  };
}
function N_(t, n) {
  return t && t.signal ? n.signalRef(t.signal) : !1 !== t;
}
function B_(t, n) {
  const e = ss(t.type);
  e || I('Unrecognized transform type: ' + rn(t.type));
  const r = MN(e.type.toLowerCase(), null, __(e, t, n));
  return t.signal && n.addSignal(t.signal, n.proxy(r)), (r.metadata = e.metadata || {}), r;
}
function __(t, n, e) {
  const r = {},
    i = t.params.length;
  for (let o = 0; o < i; ++o) {
    const i = t.params[o];
    r[i.name] = z_(i, n, e);
  }
  return r;
}
function z_(t, n, e) {
  const r = t.type,
    i = n[t.name];
  return 'index' === r
    ? (function (t, n, e) {
        return (
          Xt(n.from) || I('Lookup "from" parameter must be a string literal.'), e.getData(n.from).lookupRef(e, n.key)
        );
      })(0, n, e)
    : void 0 !== i
    ? 'param' === r
      ? (function (t, n, e) {
          const r = n[t.name];
          return t.array
            ? (K(r) || I('Expected an array of sub-parameters. Instead: ' + rn(r)), r.map(n => P_(t, n, e)))
            : P_(t, r, e);
        })(t, n, e)
      : 'projection' === r
      ? e.projectionRef(n[t.name])
      : t.array && !_N(i)
      ? i.map(n => T_(t, n, e))
      : T_(t, i, e)
    : void (t.required && I('Missing required ' + rn(n.type) + ' parameter: ' + rn(t.name)));
}
function T_(t, n, e) {
  const r = t.type;
  if (_N(n))
    return I_(r)
      ? I('Expression references can not be signals.')
      : U_(r)
      ? e.fieldRef(n)
      : W_(r)
      ? e.compareRef(n)
      : e.signalRef(n.signal);
  {
    const i = t.expr || U_(r);
    return i && R_(n)
      ? e.exprRef(n.expr, n.as)
      : i && L_(n)
      ? FN(n.field, n.as)
      : I_(r)
      ? IS(n, e)
      : q_(r)
      ? DN(e.getData(n).values)
      : U_(r)
      ? FN(n)
      : W_(r)
      ? e.compareRef(n)
      : n;
  }
}
function P_(t, n, e) {
  const r = t.params.length;
  let i;
  for (let e = 0; e < r; ++e) {
    i = t.params[e];
    for (const t in i.key)
      if (i.key[t] !== n[t]) {
        i = null;
        break;
      }
    if (i) break;
  }
  i || I('Unsupported parameter: ' + rn(n));
  const o = Bt(__(i, n, e), i.key);
  return DN(e.add(fB(o)));
}
const R_ = t => t && t.expr,
  L_ = t => t && t.field,
  q_ = t => 'data' === t,
  I_ = t => 'expr' === t,
  U_ = t => 'field' === t,
  W_ = t => 'compare' === t;
function H_(t, n) {
  return t.$ref ? t : t.data && t.data.$ref ? t.data : DN(n.getData(t.data).output);
}
function G_(t, n, e, r, i) {
  (this.scope = t), (this.input = n), (this.output = e), (this.values = r), (this.aggregate = i), (this.index = {});
}
function V_(t) {
  return Xt(t) ? t : null;
}
function Y_(t, n, e) {
  const r = CN(e.op, e.field);
  let i;
  if (n.ops) {
    for (let t = 0, e = n.as.length; t < e; ++t) if (n.as[t] === r) return;
  } else (n.ops = ['count']), (n.fields = [null]), (n.as = ['count']);
  e.op && (n.ops.push((i = e.op.signal) ? t.signalRef(i) : e.op), n.fields.push(t.fieldRef(e.field)), n.as.push(r));
}
function X_(t, n, e, r, i, o, u) {
  const s = n[e] || (n[e] = {}),
    a = (function (t) {
      return tt(t) ? ('descending' === t.order ? '-' : '+') + CN(t.op, t.field) : '';
    })(o);
  let c,
    l,
    f = V_(i);
  if ((null != f && ((t = n.scope), (f += a ? '|' + a : ''), (c = s[f])), !c)) {
    const e = o ? { field: EN, pulse: n.countsRef(t, i, o) } : { field: t.fieldRef(i), pulse: DN(n.output) };
    a && (e.sort = t.sortRef(o)),
      (l = t.add(MN(r, void 0, e))),
      u && (n.index[i] = l),
      (c = DN(l)),
      null != f && (s[f] = c);
  }
  return c;
}
function J_(t, n, e) {
  const r = t.remove,
    i = t.insert,
    o = t.toggle,
    u = t.modify,
    s = t.values,
    a = n.add(jN()),
    c = IS(
      'if(' +
        t.trigger +
        ',modify("' +
        e +
        '",' +
        [i, r, o, u, s].map(t => (null == t ? 'null' : t)).join(',') +
        '),0)',
      n,
    );
  (a.update = c.$expr), (a.params = c.$params);
}
function Q_(t, n) {
  const e = S_(t),
    r = t.type === r_,
    i = t.from && t.from.facet,
    o = t.overlap;
  let u,
    s,
    a,
    c,
    l,
    f,
    h,
    d = t.layout || e === lN || e === cN;
  const p = e === aN || d || i,
    m = (function (t, n, e) {
      let r, i, o, u, s;
      return (
        t
          ? (r = t.facet) &&
            (n || I('Only group marks can be faceted.'),
            null != r.field
              ? (u = s = H_(r, e))
              : (t.data
                  ? (s = DN(e.getData(t.data).aggregate))
                  : ((o = B_(Bt({ type: 'aggregate', groupby: At(r.groupby) }, r.aggregate), e)),
                    (o.params.key = e.keyRef(r.groupby)),
                    (o.params.pulse = H_(r, e)),
                    (u = s = DN(e.add(o)))),
                (i = e.keyRef(r.groupby, !0))))
          : (u = DN(e.add(QN(null, [{}])))),
        u || (u = H_(t, e)),
        { key: i, pulse: u, parent: s }
      );
    })(t.from, r, n);
  s = n.add(KN({ key: m.key || (t.key ? FN(t.key) : void 0), pulse: m.pulse, clean: !r }));
  const v = DN(s);
  (s = a = n.add(QN({ pulse: v }))),
    (s = n.add(
      sB({
        markdef: C_(t),
        interactive: N_(t.interactive, n),
        clip: F_(t.clip, n),
        context: { $context: !0 },
        groups: n.lookup(),
        parent: n.signals.parent ? n.signalRef('parent') : null,
        index: n.markpath(),
        pulse: DN(s),
      }),
    ));
  const g = DN(s);
  (s = c = n.add(tB(yN(t.encode, t.type, e, t.style, n, { mod: !1, pulse: g })))),
    (s.params.parent = n.encode()),
    t.transform &&
      t.transform.forEach(t => {
        const e = B_(t, n),
          r = e.metadata;
        (r.generates || r.changes) && I('Mark transforms should not generate new data.'),
          r.nomod || (c.params.mod = !0),
          (e.params.pulse = DN(s)),
          n.add((s = e));
      }),
    t.sort && (s = n.add(yB({ sort: n.compareRef(t.sort), pulse: DN(s) })));
  const b = DN(s);
  (i || d) &&
    ((d = n.add(wB({ layout: n.objectProperty(t.layout), legends: n.legends, mark: g, pulse: b }))), (f = DN(d)));
  const y = n.add(JN({ mark: g, pulse: f || b }));
  (h = DN(y)),
    r &&
      (p && ((u = n.operators), u.pop(), d && u.pop()),
      n.pushState(b, f || h, v),
      i
        ? (function (t, n, e) {
            const r = t.from.facet,
              i = r.name,
              o = H_(r, n);
            let u;
            r.name || I('Facet must have a name: ' + rn(r)),
              r.data || I('Facet must reference a data set: ' + rn(r)),
              r.field
                ? (u = n.add(hB({ field: n.fieldRef(r.field), pulse: o })))
                : r.groupby
                ? (u = n.add(eB({ key: n.keyRef(r.groupby), group: DN(n.proxy(e.parent)), pulse: o })))
                : I('Facet must specify groupby or field: ' + rn(r));
            const s = n.fork(),
              a = s.add(QN()),
              c = s.add(bB({ pulse: DN(a) }));
            s.addData(i, new G_(s, a, a, c)),
              s.addSignal('parent', null),
              (u.params.subflow = { $subflow: s.parse(t).toRuntime() });
          })(t, n, m)
        : p
        ? (function (t, n, e) {
            const r = n.add(hB({ pulse: e.pulse })),
              i = n.fork();
            i.add(bB()), i.addSignal('parent', null), (r.params.subflow = { $subflow: i.parse(t).toRuntime() });
          })(t, n, m)
        : n.parse(t),
      n.popState(),
      p && (d && u.push(d), u.push(y))),
    o &&
      (h = (function (t, n, e) {
        const r = t.method,
          i = t.bound,
          o = t.separation,
          u = { separation: _N(o) ? e.signalRef(o.signal) : o, method: _N(r) ? e.signalRef(r.signal) : r, pulse: n };
        if ((t.order && (u.sort = e.compareRef({ field: t.order })), i)) {
          const t = i.tolerance;
          (u.boundTolerance = _N(t) ? e.signalRef(t.signal) : +t),
            (u.boundScale = e.scaleRef(i.scale)),
            (u.boundOrient = i.orient);
        }
        return DN(e.add(lB(u)));
      })(o, h, n));
  const w = n.add(vB({ pulse: h })),
    x = n.add(bB({ pulse: DN(w) }, void 0, n.parent()));
  null != t.name &&
    ((l = t.name),
    n.addData(l, new G_(n, a, w, x)),
    t.on &&
      t.on.forEach(t => {
        (t.insert || t.remove || t.toggle) && I('Marks only support modify triggers.'), J_(t, n, l);
      }));
}
function Z_(t, n, e) {
  const r = { enter: {}, update: {} };
  return (
    oN(r, {
      orient: t('orient'),
      offset: t('offset'),
      padding: t('padding'),
      titlePadding: t('titlePadding'),
      cornerRadius: t('cornerRadius'),
      fill: t('fillColor'),
      stroke: t('strokeColor'),
      strokeWidth: e.strokeWidth,
      strokeDash: e.strokeDash,
      x: t('legendX'),
      y: t('legendY'),
      format: n.format,
      formatType: n.formatType,
    }),
    r
  );
}
function K_(t, n, e) {
  return n[t] ? `scale("${n[t]}",datum)` : c_(t, e[0].encode);
}
(G_.fromEntries = function (t, n) {
  const e = n.length,
    r = n[e - 1],
    i = n[e - 2];
  let o = n[0],
    u = null,
    s = 1;
  for (o && 'load' === o.type && (o = n[1]), t.add(n[0]); s < e; ++s)
    (n[s].params.pulse = DN(n[s - 1])), t.add(n[s]), 'aggregate' === n[s].type && (u = n[s]);
  return new G_(t, o, i, r, u);
}),
  (G_.prototype = {
    countsRef(t, n, e) {
      const r = this,
        i = r.counts || (r.counts = {}),
        o = V_(n);
      let u, s, a;
      return (
        null != o && ((t = r.scope), (u = i[o])),
        u
          ? e && e.field && Y_(t, u.agg.params, e)
          : ((a = { groupby: t.fieldRef(n, 'key'), pulse: DN(r.output) }),
            e && e.field && Y_(t, a, e),
            (s = t.add(YN(a))),
            (u = t.add(QN({ pulse: DN(s) }))),
            (u = { agg: s, ref: DN(u) }),
            null != o && (i[o] = u)),
        u.ref
      );
    },
    tuplesRef() {
      return DN(this.values);
    },
    extentRef(t, n) {
      return X_(t, this, 'extent', 'extent', n, !1);
    },
    domainRef(t, n) {
      return X_(t, this, 'domain', 'values', n, !1);
    },
    valuesRef(t, n, e) {
      return X_(t, this, 'vals', 'values', n, e || !0);
    },
    lookupRef(t, n) {
      return X_(t, this, 'lookup', 'tupleindex', n, !1);
    },
    indataRef(t, n) {
      return X_(t, this, 'indata', 'tupleindex', n, !0, !0);
    },
  });
const tz = `item.orient==="${RB}"?-90:item.orient==="${LB}"?90:0`;
function nz(t, n) {
  const e = { enter: {}, update: {} };
  return (
    oN(e, {
      orient: t('orient'),
      anchor: t('anchor'),
      align: { signal: f_ },
      angle: { signal: tz },
      limit: t('limit'),
      frame: t('frame'),
      offset: t('offset') || 0,
      padding: t('subtitlePadding'),
    }),
    uN(e, n, t_)
  );
}
function ez(t) {
  const n = QN({}, t);
  return (n.metadata = { source: !0 }), n;
}
function rz(t, n) {
  return uB({
    url: n.url ? t.property(n.url) : void 0,
    async: n.async ? t.property(n.async) : void 0,
    values: n.values ? t.property(n.values) : void 0,
    format: t.objectProperty(n.format),
  });
}
const iz = t => t === qB || t === PB,
  oz = (t, n, e) => (_N(t) ? fz(t.signal, n, e) : t === RB || t === PB ? n : e),
  uz = (t, n, e) => (_N(t) ? cz(t.signal, n, e) : iz(t) ? n : e),
  sz = (t, n, e) => (_N(t) ? lz(t.signal, n, e) : iz(t) ? e : n),
  az = (t, n, e) => (_N(t) ? hz(t.signal, n, e) : t === PB ? { value: n } : { value: e }),
  cz = (t, n, e) => dz(`${t} === '${PB}' || ${t} === '${qB}'`, n, e),
  lz = (t, n, e) => dz(`${t} !== '${PB}' && ${t} !== '${qB}'`, n, e),
  fz = (t, n, e) => mz(`${t} === '${RB}' || ${t} === '${PB}'`, n, e),
  hz = (t, n, e) => mz(`${t} === '${PB}'`, n, e),
  dz = (t, n, e) => (
    (n = null != n ? rN(n) : n),
    (e = null != e ? rN(e) : e),
    pz(n) && pz(e)
      ? {
          signal: `${t} ? (${(n = n ? n.signal || rn(n.value) : null)}) : (${(e = e
            ? e.signal || rn(e.value)
            : null)})`,
        }
      : [Bt({ test: t }, n)].concat(e || [])
  ),
  pz = t => null == t || 1 === Object.keys(t).length,
  mz = (t, n, e) => ({ signal: `${t} ? (${gz(n)}) : (${gz(e)})` }),
  vz = (t, n, e, r, i) => ({
    signal:
      (null != r ? `${t} === '${RB}' ? (${gz(r)}) : ` : '') +
      (null != e ? `${t} === '${qB}' ? (${gz(e)}) : ` : '') +
      (null != i ? `${t} === '${LB}' ? (${gz(i)}) : ` : '') +
      (null != n ? `${t} === '${PB}' ? (${gz(n)}) : ` : '') +
      '(null)',
  }),
  gz = t => (_N(t) ? t.signal : null == t ? null : rn(t)),
  bz = (t, n) => {
    const e = t.signal;
    return e && e.endsWith('(null)') ? { signal: e.slice(0, -6) + n.signal } : t;
  };
function yz(t, n, e, r) {
  let i;
  if (n && Pt(n, t)) return n[t];
  if (Pt(e, t)) return e[t];
  if (t.startsWith('title')) {
    switch (t) {
      case 'titleColor':
        i = 'fill';
        break;
      case 'titleFont':
      case 'titleFontSize':
      case 'titleFontWeight':
        i = t[5].toLowerCase() + t.slice(6);
    }
    return r[YB][i];
  }
  if (t.startsWith('label')) {
    switch (t) {
      case 'labelColor':
        i = 'fill';
        break;
      case 'labelFont':
      case 'labelFontSize':
        i = t[5].toLowerCase() + t.slice(6);
    }
    return r[VB][i];
  }
  return null;
}
function wz(t) {
  const n = {};
  for (const e of t) if (e) for (const t in e) n[t] = 1;
  return Object.keys(n);
}
function xz(t, n) {
  return { scale: t.scale, range: n };
}
function Oz(t, n, e, r, i) {
  return {
    signal: 'flush(range("' + t + '"), scale("' + t + '", datum.value), ' + n + ',' + e + ',' + r + ',' + i + ')',
  };
}
function kz(t, n, e, r, i, o) {
  const u = a_(t, n),
    s = t.orient,
    a = t.scale,
    c = oz(s, -1, 1),
    l = PN(u('labelFlush')),
    f = PN(u('labelFlushOffset')),
    h = u('labelAlign'),
    d = u('labelBaseline');
  let p,
    m = 0 === l || !!l;
  const v = rN(i);
  (v.mult = c), (v.offset = rN(u('labelPadding') || 0)), (v.offset.mult = c);
  const g = { scale: a, field: GB, band: 0.5, offset: h_(o.offset, u('labelOffset')) },
    b = uz(
      s,
      m ? Oz(a, l, '"left"', '"right"', '"center"') : { value: 'center' },
      ((t, n, e) =>
        _N(t) ? ((t, n, e) => mz(`${t} === '${LB}'`, n, e))(t.signal, n, e) : t === LB ? { value: n } : { value: e })(
        s,
        'left',
        'right',
      ),
    ),
    y = uz(s, az(s, 'bottom', 'top'), m ? Oz(a, l, '"top"', '"bottom"', '"middle"') : { value: 'middle' }),
    w = Oz(a, l, `-(${f})`, f, 0);
  m = m && f;
  const x = { opacity: n_, x: uz(s, g, v), y: sz(s, g, v) },
    O = {
      enter: x,
      update: (p = { opacity: e_, text: { field: WB }, x: x.x, y: x.y, align: b, baseline: y }),
      exit: { opacity: n_, x: x.x, y: x.y },
    };
  oN(O, { dx: !h && m ? uz(s, w) : null, dy: !d && m ? sz(s, w) : null }),
    oN(
      O,
      {
        angle: u('labelAngle'),
        fill: u('labelColor'),
        fillOpacity: u('labelOpacity'),
        font: u('labelFont'),
        fontSize: u('labelFontSize'),
        fontWeight: u('labelFontWeight'),
        fontStyle: u('labelFontStyle'),
        limit: u('labelLimit'),
        lineHeight: u('labelLineHeight'),
      },
      { align: h, baseline: d },
    );
  const k = u('labelBound');
  let A = u('labelOverlap');
  return (
    (A =
      A || k
        ? {
            separation: u('labelSeparation'),
            method: A,
            order: 'datum.index',
            bound: k ? { scale: a, orient: s, tolerance: k } : null,
          }
        : void 0),
    p.align !== b && (p.align = bz(p.align, b)),
    p.baseline !== y && (p.baseline = bz(p.baseline, y)),
    d_({ type: u_, role: 'axis-label', style: VB, key: GB, from: r, encode: O, overlap: A }, e)
  );
}
function Az(t, n) {
  const e = (function (t, n) {
      var e,
        r,
        i,
        o = n.config,
        u = o.style,
        s = o.axis,
        a = 'band' === n.scaleType(t.scale) && o.axisBand,
        c = t.orient;
      if (_N(c)) {
        const t = wz([o.axisX, o.axisY]),
          n = wz([o.axisTop, o.axisBottom, o.axisLeft, o.axisRight]);
        for (i of ((e = {}), t)) e[i] = uz(c, yz(i, o.axisX, s, u), yz(i, o.axisY, s, u));
        for (i of ((r = {}), n))
          r[i] = vz(
            c.signal,
            yz(i, o.axisTop, s, u),
            yz(i, o.axisBottom, s, u),
            yz(i, o.axisLeft, s, u),
            yz(i, o.axisRight, s, u),
          );
      } else (e = c === PB || c === qB ? o.axisX : o.axisY), (r = o['axis' + c[0].toUpperCase() + c.slice(1)]);
      return e || r || a ? Bt({}, s, e, r, a) : s;
    })(t, n),
    r = t.encode || {},
    i = r.axis || {},
    o = i.name || void 0,
    u = i.interactive,
    s = i.style,
    a = a_(t, e),
    c = (function (t) {
      const n = t('tickBand');
      let e,
        r,
        i = t('tickOffset');
      return (
        n
          ? n.signal
            ? ((e = { signal: `(${n.signal}) === 'extent' ? 1 : 0.5` }),
              (r = { signal: `(${n.signal}) === 'extent'` }),
              tt(i) || (i = { signal: `(${n.signal}) === 'extent' ? 0 : ${i}` }))
            : 'extent' === n
            ? ((e = 1), (r = !0), (i = 0))
            : ((e = 0.5), (r = !1))
          : ((e = t('bandPosition')), (r = t('tickExtra'))),
        { extra: r, band: e, offset: i }
      );
    })(a),
    l = {
      scale: t.scale,
      ticks: !!a('ticks'),
      labels: !!a('labels'),
      grid: !!a('grid'),
      domain: !!a('domain'),
      title: null != t.title,
    },
    f = DN(n.add(QN({}, [l]))),
    h = DN(
      n.add(
        XN({
          scale: n.scaleRef(t.scale),
          extra: n.property(c.extra),
          count: n.objectProperty(t.tickCount),
          values: n.objectProperty(t.values),
          minstep: n.property(t.tickMinStep),
          formatType: n.property(t.formatType),
          formatSpecifier: n.property(t.format),
        }),
      ),
    ),
    d = [];
  let p;
  return (
    l.grid &&
      d.push(
        (function (t, n, e, r, i) {
          const o = a_(t, n),
            u = t.orient,
            s = t.gridScale,
            a = oz(u, 1, -1),
            c = (function (t, n) {
              if (1 === n);
              else if (tt(t)) {
                let e = (t = Bt({}, t));
                for (; null != e.mult; ) {
                  if (!tt(e.mult)) return (e.mult = _N(n) ? { signal: `(${e.mult}) * (${n.signal})` } : e.mult * n), t;
                  e = e.mult = Bt({}, e.mult);
                }
                e.mult = n;
              } else t = _N(n) ? { signal: `(${n.signal}) * (${t || 0})` } : n * (t || 0);
              return t;
            })(t.offset, a);
          let l, f, h;
          const d = { enter: (l = { opacity: n_ }), update: (h = { opacity: e_ }), exit: (f = { opacity: n_ }) };
          oN(d, {
            stroke: o('gridColor'),
            strokeCap: o('gridCap'),
            strokeDash: o('gridDash'),
            strokeDashOffset: o('gridDashOffset'),
            strokeOpacity: o('gridOpacity'),
            strokeWidth: o('gridWidth'),
          });
          const p = {
              scale: t.scale,
              field: GB,
              band: i.band,
              extra: i.extra,
              offset: i.offset,
              round: o('tickRound'),
            },
            m = uz(u, { signal: 'height' }, { signal: 'width' }),
            v = s ? { scale: s, range: 0, mult: a, offset: c } : { value: 0, offset: c },
            g = s ? { scale: s, range: 1, mult: a, offset: c } : Bt(m, { mult: a, offset: c });
          return (
            (l.x = h.x = uz(u, p, v)),
            (l.y = h.y = sz(u, p, v)),
            (l.x2 = h.x2 = sz(u, g)),
            (l.y2 = h.y2 = uz(u, g)),
            (f.x = uz(u, p)),
            (f.y = sz(u, p)),
            d_({ type: o_, role: 'axis-grid', key: GB, from: r, encode: d }, e)
          );
        })(t, e, r.grid, h, c),
      ),
    l.ticks &&
      ((p = a('tickSize')),
      d.push(
        (function (t, n, e, r, i, o) {
          const u = a_(t, n),
            s = t.orient,
            a = oz(s, -1, 1);
          let c, l, f;
          const h = { enter: (c = { opacity: n_ }), update: (f = { opacity: e_ }), exit: (l = { opacity: n_ }) };
          oN(h, {
            stroke: u('tickColor'),
            strokeCap: u('tickCap'),
            strokeDash: u('tickDash'),
            strokeDashOffset: u('tickDashOffset'),
            strokeOpacity: u('tickOpacity'),
            strokeWidth: u('tickWidth'),
          });
          const d = rN(i);
          d.mult = a;
          const p = {
            scale: t.scale,
            field: GB,
            band: o.band,
            extra: o.extra,
            offset: o.offset,
            round: u('tickRound'),
          };
          return (
            (f.y = c.y = uz(s, n_, p)),
            (f.y2 = c.y2 = uz(s, d)),
            (l.x = uz(s, p)),
            (f.x = c.x = sz(s, n_, p)),
            (f.x2 = c.x2 = sz(s, d)),
            (l.y = sz(s, p)),
            d_({ type: o_, role: 'axis-tick', key: GB, from: r, encode: h }, e)
          );
        })(t, e, r.ticks, h, p, c),
      )),
    l.labels && ((p = l.ticks ? p : 0), d.push(kz(t, e, r.labels, h, p, c))),
    l.domain &&
      d.push(
        (function (t, n, e, r) {
          const i = a_(t, n),
            o = t.orient;
          let u, s;
          const a = { enter: (u = { opacity: n_ }), update: (s = { opacity: e_ }), exit: { opacity: n_ } };
          oN(a, {
            stroke: i('domainColor'),
            strokeCap: i('domainCap'),
            strokeDash: i('domainDash'),
            strokeDashOffset: i('domainDashOffset'),
            strokeWidth: i('domainWidth'),
            strokeOpacity: i('domainOpacity'),
          });
          const c = xz(t, 0),
            l = xz(t, 1);
          return (
            (u.x = s.x = uz(o, c, n_)),
            (u.x2 = s.x2 = uz(o, l)),
            (u.y = s.y = sz(o, c, n_)),
            (u.y2 = s.y2 = sz(o, l)),
            d_({ type: o_, role: 'axis-domain', from: r, encode: a }, e)
          );
        })(t, e, r.domain, f),
      ),
    l.title &&
      d.push(
        (function (t, n, e, r) {
          const i = a_(t, n),
            o = t.orient,
            u = oz(o, -1, 1);
          let s, a;
          const c = {
              enter: (s = { opacity: n_, anchor: rN(i('titleAnchor', null)), align: { signal: f_ } }),
              update: (a = Bt({}, s, { opacity: e_, text: rN(t.title) })),
              exit: { opacity: n_ },
            },
            l = { signal: `lerp(range("${t.scale}"), ${l_(0, 1, 0.5)})` };
          return (
            (a.x = uz(o, l)),
            (a.y = sz(o, l)),
            (s.angle = uz(o, n_, (t => (_N(t) ? { signal: `(${t.signal}) * 90` } : { value: 90 * t }))(u))),
            (s.baseline = uz(o, az(o, qB, PB), { value: qB })),
            (a.angle = s.angle),
            (a.baseline = s.baseline),
            oN(
              c,
              {
                fill: i('titleColor'),
                fillOpacity: i('titleOpacity'),
                font: i('titleFont'),
                fontSize: i('titleFontSize'),
                fontStyle: i('titleFontStyle'),
                fontWeight: i('titleFontWeight'),
                limit: i('titleLimit'),
                lineHeight: i('titleLineHeight'),
              },
              { align: i('titleAlign'), angle: i('titleAngle'), baseline: i('titleBaseline') },
            ),
            (function (t, n, e, r) {
              const i = (t, n) => (null != t ? ((e.update[n] = bz(rN(t), e.update[n])), !1) : !sN(n, r)),
                o = i(t('titleX'), 'x'),
                u = i(t('titleY'), 'y');
              e.enter.auto = u === o ? rN(u) : uz(n, rN(u), rN(o));
            })(i, o, c, e),
            (c.update.align = bz(c.update.align, s.align)),
            (c.update.angle = bz(c.update.angle, s.angle)),
            (c.update.baseline = bz(c.update.baseline, s.baseline)),
            d_({ type: u_, role: 'axis-title', style: YB, from: r, encode: c }, e)
          );
        })(t, e, r.title, f),
      ),
    Q_(
      s_({
        role: 'axis',
        from: f,
        encode: uN($z(a, t), i, t_),
        marks: d,
        aria: a('aria'),
        description: a('description'),
        zindex: a('zindex'),
        name: o,
        interactive: u,
        style: s,
      }),
      n,
    )
  );
}
function $z(t, n) {
  const e = { enter: {}, update: {} };
  return (
    oN(e, {
      orient: t('orient'),
      offset: t('offset') || 0,
      position: TN(n.position, 0),
      titlePadding: t('titlePadding'),
      minExtent: t('minExtent'),
      maxExtent: t('maxExtent'),
      range: { signal: `abs(span(range("${n.scale}")))` },
      translate: t('translate'),
      format: n.format,
      formatType: n.formatType,
    }),
    e
  );
}
function Mz(t, n, e) {
  const r = At(t.signals),
    i = At(t.scales);
  return (
    e || r.forEach(t => AN(t, n)),
    At(t.projections).forEach(t =>
      (function (t, n) {
        const e = n.config.projection || {},
          r = {};
        for (const e in t) 'name' !== e && (r[e] = TB(t[e], e, n));
        for (const t in e) null == r[t] && (r[t] = TB(e[t], t, n));
        n.addProjection(t.name, r);
      })(t, n),
    ),
    i.forEach(t =>
      (function (t, n) {
        const e = t.type || 'linear';
        op(e) || I('Unrecognized scale type: ' + rn(e)), n.addScale(t.name, { type: e, domain: void 0 });
      })(t, n),
    ),
    At(t.data).forEach(t =>
      (function (t, n) {
        const e = [];
        t.transform &&
          t.transform.forEach(t => {
            e.push(B_(t, n));
          }),
          t.on &&
            t.on.forEach(e => {
              J_(e, n, t.name);
            }),
          n.addDataPipeline(
            t.name,
            (function (t, n, e) {
              const r = [];
              let i,
                o,
                u,
                s,
                a,
                c = null,
                l = !1,
                f = !1;
              for (
                t.values
                  ? _N(t.values) || zN(t.format)
                    ? (r.push(rz(n, t)), r.push((c = ez())))
                    : r.push((c = ez({ $ingest: t.values, $format: t.format })))
                  : t.url
                  ? zN(t.url) || zN(t.format)
                    ? (r.push(rz(n, t)), r.push((c = ez())))
                    : r.push((c = ez({ $request: t.url, $format: t.format })))
                  : t.source && ((c = i = At(t.source).map(t => DN(n.getData(t).output))), r.push(null)),
                  o = 0,
                  u = e.length;
                o < u;
                ++o
              )
                (s = e[o]),
                  (a = s.metadata),
                  c || a.source || r.push((c = ez())),
                  r.push(s),
                  a.generates && (f = !0),
                  a.modifies && !f && (l = !0),
                  a.source ? (c = s) : a.changes && (c = null);
              return (
                i &&
                  ((u = i.length - 1),
                  (r[0] = mB({ derive: l, pulse: u ? i : i[0] })),
                  (l || u) && r.splice(1, 0, ez())),
                c || r.push(ez()),
                r.push(bB({})),
                r
              );
            })(t, n, e),
          );
      })(t, n),
    ),
    i.forEach(t => AB(t, n)),
    (e || r).forEach(t =>
      (function (t, n) {
        const e = n.getSignal(t.name);
        let r = t.update;
        t.init &&
          (r ? I('Signals can not include both init and update expressions.') : ((r = t.init), (e.initonly = !0))),
          r && ((r = IS(r, n)), (e.update = r.$expr), (e.params = r.$params)),
          t.on &&
            t.on.forEach(t =>
              (function (t, n, e) {
                const r = t.encode,
                  i = { target: e };
                let o = t.events,
                  u = t.update,
                  s = [];
                o || I('Signal update missing events specification.'),
                  Xt(o) && (o = JC(o, n.isSubscope() ? NN : BN)),
                  (o = At(o).filter(t => (t.signal || t.scale ? (s.push(t), 0) : 1))),
                  s.length > 1 && (s = [GN(s)]),
                  o.length && s.push(o.length > 1 ? { merge: o } : o[0]),
                  null != r &&
                    (u && I('Signal encode and update are mutually exclusive.'), (u = 'encode(item(),' + rn(r) + ')')),
                  (i.update = Xt(u)
                    ? IS(u, n)
                    : null != u.expr
                    ? IS(u.expr, n)
                    : null != u.value
                    ? u.value
                    : null != u.signal
                    ? { $expr: HN, $params: { $value: n.signalRef(u.signal) } }
                    : I('Invalid signal update specification.')),
                  t.force && (i.options = { force: !0 }),
                  s.forEach(t =>
                    n.addUpdate(
                      Bt(
                        (function (t, n) {
                          return {
                            source: t.signal ? n.signalRef(t.signal) : t.scale ? n.scaleRef(t.scale) : LN(t, n),
                          };
                        })(t, n),
                        i,
                      ),
                    ),
                  );
              })(t, n, e.id),
            );
      })(t, n),
    ),
    At(t.axes).forEach(t => Az(t, n)),
    At(t.marks).forEach(t => Q_(t, n)),
    At(t.legends).forEach(t =>
      (function (t, n) {
        const e = n.config.legend,
          r = t.encode || {},
          i = a_(t, e),
          o = r.legend || {},
          u = o.name || void 0,
          s = o.interactive,
          a = o.style,
          c = {};
        let l,
          f,
          h,
          d = 0;
        KB.forEach(n => (t[n] ? ((c[n] = t[n]), (d = d || t[n])) : 0)), d || I('Missing valid scale for legend.');
        const p = (function (t, n) {
            let e = t.type || XB;
            return (
              t.type ||
                1 !==
                  (function (t) {
                    return KB.reduce((n, e) => n + (t[e] ? 1 : 0), 0);
                  })(t) ||
                (!t.fill && !t.stroke) ||
                (e = sp(n) ? JB : cp(n) ? QB : XB),
              e !== JB ? e : cp(n) ? QB : JB
            );
          })(t, n.scaleType(d)),
          m = { title: null != t.title, scales: c, type: p, vgrad: 'symbol' !== p && i.isVertical() },
          v = DN(n.add(QN(null, [m]))),
          g = DN(
            n.add(
              oB(
                (f = {
                  type: p,
                  scale: n.scaleRef(d),
                  count: n.objectProperty(i('tickCount')),
                  limit: n.property(i('symbolLimit')),
                  values: n.objectProperty(t.values),
                  minstep: n.property(t.tickMinStep),
                  formatType: n.property(t.formatType),
                  formatSpecifier: n.property(t.format),
                }),
              ),
            ),
          );
        return (
          p === JB
            ? ((h = [p_(t, d, e, r.gradient), b_(t, e, r.labels, g)]),
              (f.count = f.count || n.signalRef(`max(2,2*floor((${PN(i.gradientLength())})/100))`)))
            : p === QB
            ? (h = [m_(t, d, e, r.gradient, g), b_(t, e, r.labels, g)])
            : ((l = (function (t, n) {
                const e = a_(t, n);
                return {
                  align: e('gridAlign'),
                  columns: e.entryColumns(),
                  center: { row: !0, column: !1 },
                  padding: { row: e('rowPadding'), column: e('columnPadding') },
                };
              })(t, e)),
              (h = [y_(t, e, r, g, PN(l.columns))]),
              (f.size = (function (t, n, e) {
                const r = PN(K_('size', t, e)),
                  i = PN(K_('strokeWidth', t, e)),
                  o = PN(
                    (function (t, n, e) {
                      return (
                        c_('fontSize', t) ||
                        (function (t, n, e) {
                          const r = n.config.style[e];
                          return r && r.fontSize;
                        })(0, n, e)
                      );
                    })(e[1].encode, n, VB),
                  );
                return IS(`max(ceil(sqrt(${r})+${i}),${o})`, n);
              })(t, n, h[0].marks))),
          (h = [
            s_({
              role: 'legend-entry',
              from: v,
              encode: { enter: { x: { value: 0 }, y: { value: 0 } } },
              marks: h,
              layout: l,
              interactive: s,
            }),
          ]),
          m.title &&
            h.push(
              (function (t, n, e, r) {
                const i = a_(t, n),
                  o = {
                    enter: { opacity: n_ },
                    update: { opacity: e_, x: { field: { group: 'padding' } }, y: { field: { group: 'padding' } } },
                    exit: { opacity: n_ },
                  };
                return (
                  oN(
                    o,
                    {
                      orient: i('titleOrient'),
                      _anchor: i('titleAnchor'),
                      anchor: { signal: M_ },
                      angle: { signal: j_ },
                      align: { signal: $_ },
                      baseline: { signal: D_ },
                      text: t.title,
                      fill: i('titleColor'),
                      fillOpacity: i('titleOpacity'),
                      font: i('titleFont'),
                      fontSize: i('titleFontSize'),
                      fontStyle: i('titleFontStyle'),
                      fontWeight: i('titleFontWeight'),
                      limit: i('titleLimit'),
                      lineHeight: i('titleLineHeight'),
                    },
                    { align: i('titleAlign'), baseline: i('titleBaseline') },
                  ),
                  d_({ type: u_, role: 'legend-title', style: YB, from: r, encode: o }, e)
                );
              })(t, e, r.title, v),
            ),
          Q_(
            s_({
              role: 'legend',
              from: v,
              encode: uN(Z_(i, t, e), o, t_),
              marks: h,
              aria: i('aria'),
              description: i('description'),
              zindex: i('zindex'),
              name: u,
              interactive: s,
              style: a,
            }),
            n,
          )
        );
      })(t, n),
    ),
    t.title &&
      (function (t, n) {
        const e = a_((t = Xt(t) ? { text: t } : t), n.config.title),
          r = t.encode || {},
          i = r.group || {},
          o = i.name || void 0,
          u = i.interactive,
          s = i.style,
          a = [],
          c = DN(n.add(QN(null, [{}])));
        a.push(
          (function (t, n, e, r) {
            const i = { value: 0 },
              o = { enter: { opacity: i }, update: { opacity: { value: 1 } }, exit: { opacity: i } };
            return (
              oN(
                o,
                {
                  text: t.text,
                  align: { signal: 'item.mark.group.align' },
                  angle: { signal: 'item.mark.group.angle' },
                  limit: { signal: 'item.mark.group.limit' },
                  baseline: 'top',
                  dx: n('dx'),
                  dy: n('dy'),
                  fill: n('color'),
                  font: n('font'),
                  fontSize: n('fontSize'),
                  fontStyle: n('fontStyle'),
                  fontWeight: n('fontWeight'),
                  lineHeight: n('lineHeight'),
                },
                { align: n('align'), angle: n('angle'), baseline: n('baseline') },
              ),
              d_({ type: u_, role: 'title-text', style: 'group-title', from: r, encode: o }, e)
            );
          })(
            t,
            e,
            (function (t) {
              const n = t.encode;
              return (n && n.title) || Bt({ name: t.name, interactive: t.interactive, style: t.style }, n);
            })(t),
            c,
          ),
        ),
          t.subtitle &&
            a.push(
              (function (t, n, e, r) {
                const i = { value: 0 },
                  o = { enter: { opacity: i }, update: { opacity: { value: 1 } }, exit: { opacity: i } };
                return (
                  oN(
                    o,
                    {
                      text: t.subtitle,
                      align: { signal: 'item.mark.group.align' },
                      angle: { signal: 'item.mark.group.angle' },
                      limit: { signal: 'item.mark.group.limit' },
                      baseline: 'top',
                      dx: n('dx'),
                      dy: n('dy'),
                      fill: n('subtitleColor'),
                      font: n('subtitleFont'),
                      fontSize: n('subtitleFontSize'),
                      fontStyle: n('subtitleFontStyle'),
                      fontWeight: n('subtitleFontWeight'),
                      lineHeight: n('subtitleLineHeight'),
                    },
                    { align: n('align'), angle: n('angle'), baseline: n('baseline') },
                  ),
                  d_({ type: u_, role: 'title-subtitle', style: 'group-subtitle', from: r, encode: o }, e)
                );
              })(t, e, r.subtitle, c),
            ),
          Q_(
            s_({
              role: 'title',
              from: c,
              encode: nz(e, i),
              marks: a,
              aria: e('aria'),
              description: e('description'),
              zindex: e('zindex'),
              name: o,
              interactive: u,
              style: s,
            }),
            n,
          );
      })(t.title, n),
    n.parseLambdas(),
    n
  );
}
function jz(t, n) {
  return n && n.signal ? { name: t, update: n.signal } : { name: t, value: n };
}
function Dz(t, n) {
  (this.config = t || {}),
    (this.options = n || {}),
    (this.bindings = []),
    (this.field = {}),
    (this.signals = {}),
    (this.lambdas = {}),
    (this.scales = {}),
    (this.events = {}),
    (this.data = {}),
    (this.streams = []),
    (this.updates = []),
    (this.operators = []),
    (this.eventConfig = null),
    (this.locale = null),
    (this._id = 0),
    (this._subid = 0),
    (this._nextsub = [0]),
    (this._parent = []),
    (this._encode = []),
    (this._lookup = []),
    (this._markpath = []);
}
function Fz(t) {
  (this.config = t.config),
    (this.options = t.options),
    (this.legends = t.legends),
    (this.field = Object.create(t.field)),
    (this.signals = Object.create(t.signals)),
    (this.lambdas = Object.create(t.lambdas)),
    (this.scales = Object.create(t.scales)),
    (this.events = Object.create(t.events)),
    (this.data = Object.create(t.data)),
    (this.streams = []),
    (this.updates = []),
    (this.operators = []),
    (this._id = 0),
    (this._subid = ++t._nextsub[0]),
    (this._nextsub = t._nextsub),
    (this._parent = t._parent.slice()),
    (this._encode = t._encode.slice()),
    (this._lookup = t._lookup.slice()),
    (this._markpath = t._markpath);
}
function Ez(t) {
  return (K(t) ? Sz : Cz)(t);
}
function Sz(t) {
  const n = t.length;
  let e = '[';
  for (let r = 0; r < n; ++r) {
    const n = t[r];
    e += (r > 0 ? ',' : '') + (tt(n) ? n.signal || Ez(n) : rn(n));
  }
  return e + ']';
}
function Cz(t) {
  let n,
    e,
    r = '{',
    i = 0;
  for (n in t) (e = t[n]), (r += (++i > 1 ? ',' : '') + rn(n) + ':' + (tt(e) ? e.signal || Ez(e) : rn(e)));
  return r + '}';
}
(Dz.prototype = Fz.prototype =
  {
    parse(t) {
      return Mz(t, this);
    },
    fork() {
      return new Fz(this);
    },
    isSubscope() {
      return this._subid > 0;
    },
    toRuntime() {
      return (
        this.finish(),
        {
          description: this.description,
          operators: this.operators,
          streams: this.streams,
          updates: this.updates,
          bindings: this.bindings,
          eventConfig: this.eventConfig,
          locale: this.locale,
        }
      );
    },
    id() {
      return (this._subid ? this._subid + ':' : 0) + this._id++;
    },
    add(t) {
      return (
        this.operators.push(t),
        (t.id = this.id()),
        t.refs &&
          (t.refs.forEach(n => {
            n.$ref = t.id;
          }),
          (t.refs = null)),
        t
      );
    },
    proxy(t) {
      const n = t instanceof $N ? DN(t) : t;
      return this.add(pB({ value: n }));
    },
    addStream(t) {
      return this.streams.push(t), (t.id = this.id()), t;
    },
    addUpdate(t) {
      return this.updates.push(t), t;
    },
    finish() {
      let t, n;
      for (t in (this.root && (this.root.root = !0), this.signals)) this.signals[t].signal = t;
      for (t in this.scales) this.scales[t].scale = t;
      function e(t, n, e) {
        let r, i;
        t && ((r = t.data || (t.data = {})), (i = r[n] || (r[n] = [])), i.push(e));
      }
      for (t in this.data) {
        (n = this.data[t]), e(n.input, t, 'input'), e(n.output, t, 'output'), e(n.values, t, 'values');
        for (const r in n.index) e(n.index[r], t, 'index:' + r);
      }
      return this;
    },
    pushState(t, n, e) {
      this._encode.push(DN(this.add(bB({ pulse: t })))),
        this._parent.push(n),
        this._lookup.push(e ? DN(this.proxy(e)) : null),
        this._markpath.push(-1);
    },
    popState() {
      this._encode.pop(), this._parent.pop(), this._lookup.pop(), this._markpath.pop();
    },
    parent() {
      return ot(this._parent);
    },
    encode() {
      return ot(this._encode);
    },
    lookup() {
      return ot(this._lookup);
    },
    markpath() {
      const t = this._markpath;
      return ++t[t.length - 1];
    },
    fieldRef(t, n) {
      if (Xt(t)) return FN(t, n);
      t.signal || I('Unsupported field reference: ' + rn(t));
      const e = t.signal;
      let r = this.field[e];
      if (!r) {
        const t = { name: this.signalRef(e) };
        n && (t.as = n), (this.field[e] = r = DN(this.add(rB(t))));
      }
      return r;
    },
    compareRef(t) {
      let n = !1;
      const e = t =>
          _N(t)
            ? ((n = !0), this.signalRef(t.signal))
            : (function (t) {
                return t && t.expr;
              })(t)
            ? ((n = !0), this.exprRef(t.expr))
            : t,
        r = At(t.field).map(e),
        i = At(t.order).map(e);
      return n ? DN(this.add(ZN({ fields: r, orders: i }))) : SN(r, i);
    },
    keyRef(t, n) {
      let e = !1;
      const r = this.signals;
      return (
        (t = At(t).map(t => (_N(t) ? ((e = !0), DN(r[t.signal])) : t))),
        e
          ? DN(this.add(iB({ fields: t, flat: n })))
          : (function (t, n) {
              const e = { $key: t };
              return n && (e.$flat = !0), e;
            })(t, n)
      );
    },
    sortRef(t) {
      if (!t) return t;
      const n = CN(t.op, t.field),
        e = t.order || 'ascending';
      return e.signal ? DN(this.add(ZN({ fields: n, orders: this.signalRef(e.signal) }))) : SN(n, e);
    },
    event(t, n) {
      const e = t + ':' + n;
      if (!this.events[e]) {
        const r = this.id();
        this.streams.push({ id: r, source: t, type: n }), (this.events[e] = r);
      }
      return this.events[e];
    },
    hasOwnSignal(t) {
      return Pt(this.signals, t);
    },
    addSignal(t, n) {
      this.hasOwnSignal(t) && I('Duplicate signal name: ' + rn(t));
      const e = n instanceof $N ? n : this.add(jN(n));
      return (this.signals[t] = e);
    },
    getSignal(t) {
      return this.signals[t] || I('Unrecognized signal name: ' + rn(t)), this.signals[t];
    },
    signalRef(t) {
      return this.signals[t]
        ? DN(this.signals[t])
        : (Pt(this.lambdas, t) || (this.lambdas[t] = this.add(jN(null))), DN(this.lambdas[t]));
    },
    parseLambdas() {
      const t = Object.keys(this.lambdas);
      for (let n = 0, e = t.length; n < e; ++n) {
        const e = t[n],
          r = IS(e, this),
          i = this.lambdas[e];
        (i.params = r.$params), (i.update = r.$expr);
      }
    },
    property(t) {
      return t && t.signal ? this.signalRef(t.signal) : t;
    },
    objectProperty(t) {
      return t && tt(t) ? this.signalRef(t.signal || Ez(t)) : t;
    },
    exprRef(t, n) {
      const e = { expr: IS(t, this) };
      return n && (e.expr.$name = n), DN(this.add(nB(e)));
    },
    addBinding(t, n) {
      this.bindings || I('Nested signals do not support binding: ' + rn(t)), this.bindings.push(Bt({ signal: t }, n));
    },
    addScaleProj(t, n) {
      Pt(this.scales, t) && I('Duplicate scale or projection name: ' + rn(t)), (this.scales[t] = this.add(n));
    },
    addScale(t, n) {
      this.addScaleProj(t, gB(n));
    },
    addProjection(t, n) {
      this.addScaleProj(t, dB(n));
    },
    getScale(t) {
      return this.scales[t] || I('Unrecognized scale name: ' + rn(t)), this.scales[t];
    },
    scaleRef(t) {
      return DN(this.getScale(t));
    },
    scaleType(t) {
      return this.getScale(t).params.type;
    },
    projectionRef(t) {
      return this.scaleRef(t);
    },
    projectionType(t) {
      return this.scaleType(t);
    },
    addData(t, n) {
      return Pt(this.data, t) && I('Duplicate data set name: ' + rn(t)), (this.data[t] = n);
    },
    getData(t) {
      return this.data[t] || I('Undefined data set name: ' + rn(t)), this.data[t];
    },
    addDataPipeline(t, n) {
      return Pt(this.data, t) && I('Duplicate data set name: ' + rn(t)), this.addData(t, G_.fromEntries(this, n));
    },
  }),
  Bt(us, $c, Fw, ux, Q$, XM, CD, fD, TD, vF, FF, PF);
const Nz = Object.freeze({
  __proto__: null,
  version: '5.22.1',
  Dataflow: rs,
  EventStream: Uu,
  MultiPulse: Ku,
  Operator: Lu,
  Parameters: Tu,
  Pulse: Xu,
  Transform: os,
  changeset: _u,
  definition: ss,
  ingest: Fu,
  isTuple: Mu,
  transform: as,
  transforms: us,
  tupleid: ju,
  interpolate: bp,
  interpolateColors: mp,
  interpolateRange: pp,
  quantizeInterpolator: vp,
  scale: ip,
  scheme: Op,
  projection: y$,
  View: qC,
  defaultLocale: Xo,
  formatLocale: qo,
  locale: Yo,
  resetDefaultLocale: function () {
    return Ro(), Wo(), Xo();
  },
  timeFormatLocale: Go,
  expressionFunction: qS,
  parse: function (t, n, e) {
    return (
      tt(t) || I('Input Vega specification must be an object.'),
      (n = et(
        (function () {
          const t = 'sans-serif',
            n = '#4c78a8',
            e = '#000',
            r = '#888',
            i = '#ddd';
          return {
            description: 'Vega visualization',
            padding: 0,
            autosize: 'pad',
            background: null,
            events: { defaults: { allow: ['wheel'] } },
            group: null,
            mark: null,
            arc: { fill: n },
            area: { fill: n },
            image: null,
            line: { stroke: n, strokeWidth: 2 },
            path: { stroke: n },
            rect: { fill: n },
            rule: { stroke: e },
            shape: { stroke: n },
            symbol: { fill: n, size: 64 },
            text: { fill: e, font: t, fontSize: 11 },
            trail: { fill: n, size: 2 },
            style: {
              'guide-label': { fill: e, font: t, fontSize: 10 },
              'guide-title': { fill: e, font: t, fontSize: 11, fontWeight: 'bold' },
              'group-title': { fill: e, font: t, fontSize: 13, fontWeight: 'bold' },
              'group-subtitle': { fill: e, font: t, fontSize: 12 },
              point: { size: 30, strokeWidth: 2, shape: 'circle' },
              circle: { size: 30, strokeWidth: 2 },
              square: { size: 30, strokeWidth: 2, shape: 'square' },
              cell: { fill: 'transparent', stroke: i },
            },
            title: { orient: 'top', anchor: 'middle', offset: 4, subtitlePadding: 3 },
            axis: {
              minExtent: 0,
              maxExtent: 200,
              bandPosition: 0.5,
              domain: !0,
              domainWidth: 1,
              domainColor: r,
              grid: !1,
              gridWidth: 1,
              gridColor: i,
              labels: !0,
              labelAngle: 0,
              labelLimit: 180,
              labelOffset: 0,
              labelPadding: 2,
              ticks: !0,
              tickColor: r,
              tickOffset: 0,
              tickRound: !0,
              tickSize: 5,
              tickWidth: 1,
              titlePadding: 4,
            },
            axisBand: { tickOffset: -0.5 },
            projection: { type: 'mercator' },
            legend: {
              orient: 'right',
              padding: 0,
              gridAlign: 'each',
              columnPadding: 10,
              rowPadding: 2,
              symbolDirection: 'vertical',
              gradientDirection: 'vertical',
              gradientLength: 200,
              gradientThickness: 16,
              gradientStrokeColor: i,
              gradientStrokeWidth: 0,
              gradientLabelOffset: 2,
              labelAlign: 'left',
              labelBaseline: 'middle',
              labelLimit: 160,
              labelOffset: 4,
              labelOverlap: !0,
              symbolLimit: 30,
              symbolType: 'circle',
              symbolSize: 100,
              symbolOffset: 0,
              symbolStrokeWidth: 1.5,
              symbolBaseFillColor: 'transparent',
              symbolBaseStrokeColor: r,
              titleLimit: 180,
              titleOrient: 'top',
              titlePadding: 5,
              layout: {
                offset: 18,
                direction: 'horizontal',
                left: { direction: 'vertical' },
                right: { direction: 'vertical' },
              },
            },
            range: {
              category: { scheme: 'tableau10' },
              ordinal: { scheme: 'blues' },
              heatmap: { scheme: 'yellowgreenblue' },
              ramp: { scheme: 'blues' },
              diverging: { scheme: 'blueorange', extent: [1, 0] },
              symbol: [
                'circle',
                'square',
                'triangle-up',
                'cross',
                'diamond',
                'triangle-right',
                'triangle-down',
                'triangle-left',
              ],
            },
          };
        })(),
        n,
        t.config,
      )),
      (function (t, n) {
        const e = n.config,
          r = DN((n.root = n.add(jN()))),
          i = (function (t, n) {
            const e = e => TN(t[e], n[e]),
              r = [
                jz('background', e('background')),
                jz('autosize', tN(e('autosize'))),
                jz('padding', eN(e('padding'))),
                jz('width', e('width') || 0),
                jz('height', e('height') || 0),
              ],
              i = r.reduce((t, n) => ((t[n.name] = n), t), {}),
              o = {};
            return (
              At(t.signals).forEach(t => {
                Pt(i, t.name) ? (t = Bt(i[t.name], t)) : r.push(t), (o[t.name] = t);
              }),
              At(n.signals).forEach(t => {
                Pt(o, t.name) || Pt(i, t.name) || r.push(t);
              }),
              r
            );
          })(t, e);
        i.forEach(t => AN(t, n)),
          (n.description = t.description || e.description),
          (n.eventConfig = e.events),
          (n.legends = n.objectProperty(e.legend && e.legend.layout)),
          (n.locale = e.locale);
        const o = n.add(QN()),
          u = n.add(
            tB(
              yN(
                (t =>
                  uN(
                    {
                      enter: { x: { value: 0 }, y: { value: 0 } },
                      update: { width: { signal: 'width' }, height: { signal: 'height' } },
                    },
                    t,
                  ))(t.encode),
                r_,
                cN,
                t.style,
                n,
                { pulse: DN(o) },
              ),
            ),
          ),
          s = n.add(
            wB({
              layout: n.objectProperty(t.layout),
              legends: n.legends,
              autosize: n.signalRef('autosize'),
              mark: r,
              pulse: DN(u),
            }),
          );
        n.operators.pop(), n.pushState(DN(u), DN(s), null), Mz(t, n, i), n.operators.push(s);
        let a = n.add(JN({ mark: r, pulse: DN(s) }));
        return (
          (a = n.add(vB({ pulse: DN(a) }))), (a = n.add(bB({ pulse: DN(a) }))), n.addData('root', new G_(n, o, o, a)), n
        );
      })(t, new Dz(n, e)).toRuntime()
    );
  },
  runtimeContext: QS,
  codegenExpression: HE,
  parseExpression: IE,
  parseSelector: JC,
  Debug: 4,
  Error: 1,
  Info: 3,
  None: 0,
  Warn: 2,
  accessor: z,
  accessorFields: P,
  accessorName: T,
  array: At,
  ascending: Dt,
  clampRange: $t,
  compare: jt,
  constant: Ct,
  debounce: Nt,
  error: I,
  extend: Bt,
  extent: _t,
  extentIndex: zt,
  falsy: J,
  fastmap: Lt,
  field: W,
  flush: qt,
  hasOwnProperty: Pt,
  id: H,
  identity: G,
  inherits: It,
  inrange: Ut,
  isArray: K,
  isBoolean: Wt,
  isDate: Ht,
  isFunction: Mt,
  isIterable: Gt,
  isNumber: Vt,
  isObject: tt,
  isRegExp: Yt,
  isString: Xt,
  key: Jt,
  lerp: Qt,
  logger: Z,
  lruCache: Zt,
  merge: Kt,
  mergeConfig: et,
  one: Y,
  pad: nn,
  panLinear: dt,
  panLog: pt,
  panPow: mt,
  panSymlog: vt,
  peek: ot,
  quarter: Ot,
  repeat: tn,
  span: en,
  splitAccessPath: U,
  stringValue: rn,
  toBoolean: on,
  toDate: sn,
  toNumber: ut,
  toSet: cn,
  toString: an,
  truncate: ln,
  truthy: X,
  utcquarter: kt,
  visitArray: fn,
  writeConfig: rt,
  zero: V,
  zoomLinear: bt,
  zoomLog: yt,
  zoomPow: wt,
  zoomSymlog: xt,
  bandwidthNRD: hs,
  bin: ds,
  bootstrapCI: ms,
  cumulativeLogNormal: Ds,
  cumulativeNormal: Os,
  cumulativeUniform: Bs,
  densityLogNormal: js,
  densityNormal: xs,
  densityUniform: Ns,
  dotbin: vs,
  quantileLogNormal: Fs,
  quantileNormal: ks,
  quantileUniform: _s,
  quantiles: ls,
  quartiles: fs,
  get random() {
    return ps;
  },
  randomInteger: function (t, n) {
    let e, r, i;
    null == n && ((n = t), (t = 0));
    const o = {
      min(t) {
        return arguments.length ? ((e = t || 0), (i = r - e), o) : e;
      },
      max(t) {
        return arguments.length ? ((r = t || 0), (i = r - e), o) : r;
      },
      sample: () => e + Math.floor(i * ps()),
      pdf: t => (t === Math.floor(t) && t >= e && t < r ? 1 / i : 0),
      cdf(t) {
        const n = Math.floor(t);
        return n < e ? 0 : n >= r ? 1 : (n - e + 1) / i;
      },
      icdf: t => (t >= 0 && t <= 1 ? e - 1 + Math.floor(t * i) : NaN),
    };
    return o.min(t).max(n);
  },
  randomKDE: $s,
  randomLCG: function (t) {
    return function () {
      return (t = (1103515245 * t + 12345) % 2147483647) / 2147483647;
    };
  },
  randomLogNormal: Es,
  randomMixture: Ss,
  randomNormal: As,
  randomUniform: zs,
  regressionExp: Us,
  regressionLinear: qs,
  regressionLoess: Ys,
  regressionLog: Is,
  regressionPoly: Gs,
  regressionPow: Ws,
  regressionQuad: Hs,
  sampleCurve: Zs,
  sampleLogNormal: Ms,
  sampleNormal: ws,
  sampleUniform: Cs,
  setRandom: function (t) {
    ps = t;
  },
  DATE: ar,
  DAY: cr,
  DAYOFYEAR: lr,
  HOURS: fr,
  MILLISECONDS: pr,
  MINUTES: hr,
  MONTH: ur,
  QUARTER: or,
  SECONDS: dr,
  TIME_UNITS: mr,
  WEEK: sr,
  YEAR: ir,
  dayofyear: Or,
  timeBin: si,
  timeFloor: Pr,
  timeInterval: Wr,
  timeOffset: Vr,
  timeSequence: Jr,
  timeUnitSpecifier: yr,
  timeUnits: gr,
  utcFloor: qr,
  utcInterval: Hr,
  utcOffset: Yr,
  utcSequence: Qr,
  utcdayofyear: Dr,
  utcweek: Fr,
  week: kr,
  format: gu,
  formats: bu,
  inferType: lu,
  inferTypes: fu,
  loader: xu,
  read: wu,
  responseType: yu,
  typeParsers: su,
  path: Gc,
  Bounds: Um,
  CanvasHandler: wb,
  CanvasRenderer: $b,
  Gradient: Vp,
  GroupItem: Hm,
  Handler: eb,
  Item: Wm,
  Marks: Lg,
  RenderType: my,
  Renderer: ib,
  ResourceLoader: Gm,
  SVGHandler: jb,
  SVGRenderer: Zb,
  SVGStringRenderer: hy,
  Scenegraph: Yg,
  boundClip: ky,
  boundContext: dv,
  boundItem: qg,
  boundMark: Ug,
  boundStroke: Xm,
  domChild: Zg,
  domClear: Kg,
  domCreate: Jg,
  domFind: Qg,
  font: Cg,
  fontFamily: Sg,
  fontSize: Mg,
  intersect: by,
  intersectBoxLine: Av,
  intersectPath: wv,
  intersectPoint: xv,
  intersectRule: kv,
  lineHeight: jg,
  markup: Wb,
  multiLineOffset: Fg,
  pathCurves: Xp,
  pathEqual: $y,
  pathParse: nm,
  pathRectangle: $m,
  pathRender: hm,
  pathSymbols: vm,
  pathTrail: Mm,
  point: nb,
  renderModule: gy,
  resetSVGClipId: qm,
  resetSVGDefIds: function () {
    qm(), (Ip = 0);
  },
  sceneEqual: Ay,
  sceneFromJSON: Gg,
  scenePickVisit: _v,
  sceneToJSON: Hg,
  sceneVisit: Bv,
  sceneZOrder: Nv,
  serializeXML: Hb,
  textMetrics: wg,
});
var Bz = {
    NaN: NaN,
    E: Math.E,
    LN2: Math.LN2,
    LN10: Math.LN10,
    LOG2E: Math.LOG2E,
    LOG10E: Math.LOG10E,
    PI: Math.PI,
    SQRT1_2: Math.SQRT1_2,
    SQRT2: Math.SQRT2,
    MIN_VALUE: Number.MIN_VALUE,
    MAX_VALUE: Number.MAX_VALUE,
  },
  _z = {
    '*': (t, n) => t * n,
    '+': (t, n) => t + n,
    '-': (t, n) => t - n,
    '/': (t, n) => t / n,
    '%': (t, n) => t % n,
    '>': (t, n) => t > n,
    '<': (t, n) => t < n,
    '<=': (t, n) => t <= n,
    '>=': (t, n) => t >= n,
    '==': (t, n) => t == n,
    '!=': (t, n) => t != n,
    '===': (t, n) => t === n,
    '!==': (t, n) => t !== n,
    '&': (t, n) => t & n,
    '|': (t, n) => t | n,
    '^': (t, n) => t ^ n,
    '<<': (t, n) => t << n,
    '>>': (t, n) => t >> n,
    '>>>': (t, n) => t >>> n,
  },
  zz = { '+': t => +t, '-': t => -t, '~': t => ~t, '!': t => !t };
const Tz = Array.prototype.slice,
  Pz = (t, n, e) => {
    const r = e ? e(n[0]) : n[0];
    return r[t].apply(r, Tz.call(n, 1));
  };
var Rz = {
  isNaN: Number.isNaN,
  isFinite: Number.isFinite,
  abs: Math.abs,
  acos: Math.acos,
  asin: Math.asin,
  atan: Math.atan,
  atan2: Math.atan2,
  ceil: Math.ceil,
  cos: Math.cos,
  exp: Math.exp,
  floor: Math.floor,
  log: Math.log,
  max: Math.max,
  min: Math.min,
  pow: Math.pow,
  random: Math.random,
  round: Math.round,
  sin: Math.sin,
  sqrt: Math.sqrt,
  tan: Math.tan,
  clamp: (t, n, e) => Math.max(n, Math.min(e, t)),
  now: Date.now,
  utc: Date.UTC,
  datetime: (t, n, e, r, i, o, u) => new Date(t, n || 0, null != e ? e : 1, r || 0, i || 0, o || 0, u || 0),
  date: t => new Date(t).getDate(),
  day: t => new Date(t).getDay(),
  year: t => new Date(t).getFullYear(),
  month: t => new Date(t).getMonth(),
  hours: t => new Date(t).getHours(),
  minutes: t => new Date(t).getMinutes(),
  seconds: t => new Date(t).getSeconds(),
  milliseconds: t => new Date(t).getMilliseconds(),
  time: t => new Date(t).getTime(),
  timezoneoffset: t => new Date(t).getTimezoneOffset(),
  utcdate: t => new Date(t).getUTCDate(),
  utcday: t => new Date(t).getUTCDay(),
  utcyear: t => new Date(t).getUTCFullYear(),
  utcmonth: t => new Date(t).getUTCMonth(),
  utchours: t => new Date(t).getUTCHours(),
  utcminutes: t => new Date(t).getUTCMinutes(),
  utcseconds: t => new Date(t).getUTCSeconds(),
  utcmilliseconds: t => new Date(t).getUTCMilliseconds(),
  length: t => t.length,
  join: function () {
    return Pz('join', arguments);
  },
  indexof: function () {
    return Pz('indexOf', arguments);
  },
  lastindexof: function () {
    return Pz('lastIndexOf', arguments);
  },
  slice: function () {
    return Pz('slice', arguments);
  },
  reverse: t => t.slice().reverse(),
  parseFloat,
  parseInt,
  upper: t => String(t).toUpperCase(),
  lower: t => String(t).toLowerCase(),
  substring: function () {
    return Pz('substring', arguments, String);
  },
  split: function () {
    return Pz('split', arguments, String);
  },
  replace: function () {
    return Pz('replace', arguments, String);
  },
  trim: t => String(t).trim(),
  regexp: RegExp,
  test: (t, n) => RegExp(t).test(n),
};
const Lz = ['view', 'item', 'group', 'xy', 'x', 'y'],
  qz = {
    Literal: (t, n) => n.value,
    Identifier: (t, n) => {
      const e = n.name;
      return t.memberDepth > 0
        ? e
        : 'datum' === e
        ? t.datum
        : 'event' === e
        ? t.event
        : 'item' === e
        ? t.item
        : Bz[e] || t.params['$' + e];
    },
    MemberExpression: (t, n) => {
      const e = !n.computed,
        r = t(n.object);
      e && (t.memberDepth += 1);
      const i = t(n.property);
      return e && (t.memberDepth -= 1), r[i];
    },
    CallExpression: (t, n) => {
      const e = n.arguments;
      let r = n.callee.name;
      return (
        r.startsWith('_') && (r = r.slice(1)),
        'if' === r ? (t(e[0]) ? t(e[1]) : t(e[2])) : (t.fn[r] || Rz[r]).apply(t.fn, e.map(t))
      );
    },
    ArrayExpression: (t, n) => n.elements.map(t),
    BinaryExpression: (t, n) => _z[n.operator](t(n.left), t(n.right)),
    UnaryExpression: (t, n) => zz[n.operator](t(n.argument)),
    ConditionalExpression: (t, n) => (t(n.test) ? t(n.consequent) : t(n.alternate)),
    LogicalExpression: (t, n) => ('&&' === n.operator ? t(n.left) && t(n.right) : t(n.left) || t(n.right)),
    ObjectExpression: (t, n) =>
      n.properties.reduce((n, e) => {
        t.memberDepth += 1;
        const r = t(e.key);
        return (t.memberDepth -= 1), (n[r] = t(e.value)), n;
      }, {}),
  };
function Iz(t, n, e, r, i, o) {
  const u = t => qz[t.type](u, t);
  return (
    (u.memberDepth = 0),
    (u.fn = Object.create(n)),
    (u.params = e),
    (u.datum = r),
    (u.event = i),
    (u.item = o),
    Lz.forEach(t => (u.fn[t] = (...n) => i.vega[t](...n))),
    u(t)
  );
}
var Uz = {
  operator(t, n) {
    const e = n.ast,
      r = t.functions;
    return t => Iz(e, r, t);
  },
  parameter(t, n) {
    const e = n.ast,
      r = t.functions;
    return (t, n) => Iz(e, r, n, t);
  },
  event(t, n) {
    const e = n.ast,
      r = t.functions;
    return t => Iz(e, r, void 0, void 0, t);
  },
  handler(t, n) {
    const e = n.ast,
      r = t.functions;
    return (t, n) => Iz(e, r, t, n.item && n.item.datum, n);
  },
  encode(t, n) {
    const { marktype: e, channels: r } = n,
      i = t.functions,
      o = 'group' === e || 'image' === e || 'rect' === e;
    return (t, n) => {
      const u = t.datum;
      let s,
        a = 0;
      for (const e in r) (s = Iz(r[e].ast, i, n, u, void 0, t)), t[e] !== s && ((t[e] = s), (a = 1));
      return (
        'rule' !== e &&
          (function (t, n, e) {
            let r;
            n.x2 &&
              (n.x
                ? (e && t.x > t.x2 && ((r = t.x), (t.x = t.x2), (t.x2 = r)), (t.width = t.x2 - t.x))
                : (t.x = t.x2 - (t.width || 0))),
              n.xc && (t.x = t.xc - (t.width || 0) / 2),
              n.y2 &&
                (n.y
                  ? (e && t.y > t.y2 && ((r = t.y), (t.y = t.y2), (t.y2 = r)), (t.height = t.y2 - t.y))
                  : (t.y = t.y2 - (t.height || 0))),
              n.yc && (t.y = t.yc - (t.height || 0) / 2);
          })(t, r, o),
        a
      );
    };
  },
};
Array.prototype.flat ||
  Object.defineProperty(Array.prototype, 'flat', {
    configurable: !0,
    value: function t() {
      var n = isNaN(arguments[0]) ? 1 : Number(arguments[0]);
      return n
        ? Array.prototype.reduce.call(
            this,
            function (e, r) {
              return Array.isArray(r) ? e.push.apply(e, t.call(r, n - 1)) : e.push(r), e;
            },
            [],
          )
        : Array.prototype.slice.call(this);
    },
    writable: !0,
  }),
  Array.prototype.flatMap ||
    Object.defineProperty(Array.prototype, 'flatMap', {
      configurable: !0,
      value: function (t) {
        return Array.prototype.map.apply(this, arguments).flat();
      },
      writable: !0,
    });
var Wz = i(function (t) {
    var n = (function () {
      function t(t, n) {
        return null != n && t instanceof n;
      }
      var n, e, r;
      try {
        n = Map;
      } catch (t) {
        n = function () {};
      }
      try {
        e = Set;
      } catch (t) {
        e = function () {};
      }
      try {
        r = Promise;
      } catch (t) {
        r = function () {};
      }
      function i(o, s, a, c, l) {
        'object' == typeof s && ((a = s.depth), (c = s.prototype), (l = s.includeNonEnumerable), (s = s.circular));
        var f = [],
          h = [],
          d = 'undefined' != typeof Buffer;
        return (
          void 0 === s && (s = !0),
          void 0 === a && (a = 1 / 0),
          (function o(a, p) {
            if (null === a) return null;
            if (0 === p) return a;
            var m, v;
            if ('object' != typeof a) return a;
            if (t(a, n)) m = new n();
            else if (t(a, e)) m = new e();
            else if (t(a, r))
              m = new r(function (t, n) {
                a.then(
                  function (n) {
                    t(o(n, p - 1));
                  },
                  function (t) {
                    n(o(t, p - 1));
                  },
                );
              });
            else if (i.__isArray(a)) m = [];
            else if (i.__isRegExp(a)) (m = new RegExp(a.source, u(a))), a.lastIndex && (m.lastIndex = a.lastIndex);
            else if (i.__isDate(a)) m = new Date(a.getTime());
            else {
              if (d && Buffer.isBuffer(a))
                return (m = Buffer.allocUnsafe ? Buffer.allocUnsafe(a.length) : new Buffer(a.length)), a.copy(m), m;
              t(a, Error)
                ? (m = Object.create(a))
                : void 0 === c
                ? ((v = Object.getPrototypeOf(a)), (m = Object.create(v)))
                : ((m = Object.create(c)), (v = c));
            }
            if (s) {
              var g = f.indexOf(a);
              if (-1 != g) return h[g];
              f.push(a), h.push(m);
            }
            for (var b in (t(a, n) &&
              a.forEach(function (t, n) {
                var e = o(n, p - 1),
                  r = o(t, p - 1);
                m.set(e, r);
              }),
            t(a, e) &&
              a.forEach(function (t) {
                var n = o(t, p - 1);
                m.add(n);
              }),
            a)) {
              var y;
              v && (y = Object.getOwnPropertyDescriptor(v, b)), (y && null == y.set) || (m[b] = o(a[b], p - 1));
            }
            if (Object.getOwnPropertySymbols) {
              var w = Object.getOwnPropertySymbols(a);
              for (b = 0; b < w.length; b++) {
                var x = w[b];
                (!(k = Object.getOwnPropertyDescriptor(a, x)) || k.enumerable || l) &&
                  ((m[x] = o(a[x], p - 1)), k.enumerable || Object.defineProperty(m, x, { enumerable: !1 }));
              }
            }
            if (l) {
              var O = Object.getOwnPropertyNames(a);
              for (b = 0; b < O.length; b++) {
                var k,
                  A = O[b];
                ((k = Object.getOwnPropertyDescriptor(a, A)) && k.enumerable) ||
                  ((m[A] = o(a[A], p - 1)), Object.defineProperty(m, A, { enumerable: !1 }));
              }
            }
            return m;
          })(o, a)
        );
      }
      function o(t) {
        return Object.prototype.toString.call(t);
      }
      function u(t) {
        var n = '';
        return t.global && (n += 'g'), t.ignoreCase && (n += 'i'), t.multiline && (n += 'm'), n;
      }
      return (
        (i.clonePrototype = function (t) {
          if (null === t) return null;
          var n = function () {};
          return (n.prototype = t), new n();
        }),
        (i.__objToStr = o),
        (i.__isDate = function (t) {
          return 'object' == typeof t && '[object Date]' === o(t);
        }),
        (i.__isArray = function (t) {
          return 'object' == typeof t && '[object Array]' === o(t);
        }),
        (i.__isRegExp = function (t) {
          return 'object' == typeof t && '[object RegExp]' === o(t);
        }),
        (i.__getRegExpFlags = u),
        i
      );
    })();
    t.exports && (t.exports = n);
  }),
  Hz = function (t, n) {
    n || (n = {}), 'function' == typeof n && (n = { cmp: n });
    var e,
      r = 'boolean' == typeof n.cycles && n.cycles,
      i =
        n.cmp &&
        ((e = n.cmp),
        function (t) {
          return function (n, r) {
            return e({ key: n, value: t[n] }, { key: r, value: t[r] });
          };
        }),
      o = [];
    return (function t(n) {
      if ((n && n.toJSON && 'function' == typeof n.toJSON && (n = n.toJSON()), void 0 !== n)) {
        if ('number' == typeof n) return isFinite(n) ? '' + n : 'null';
        if ('object' != typeof n) return JSON.stringify(n);
        var e, u;
        if (Array.isArray(n)) {
          for (u = '[', e = 0; e < n.length; e++) e && (u += ','), (u += t(n[e]) || 'null');
          return u + ']';
        }
        if (null === n) return 'null';
        if (-1 !== o.indexOf(n)) {
          if (r) return JSON.stringify('__cycle__');
          throw new TypeError('Converting circular structure to JSON');
        }
        var s = o.push(n) - 1,
          a = Object.keys(n).sort(i && i(n));
        for (u = '', e = 0; e < a.length; e++) {
          var c = a[e],
            l = t(n[c]);
          l && (u && (u += ','), (u += JSON.stringify(c) + ':' + l));
        }
        return o.splice(s, 1), '{' + u + '}';
      }
    })(t);
  };
function Gz(t) {
  return !!t.or;
}
function Vz(t) {
  return !!t.and;
}
function Yz(t) {
  return !!t.not;
}
function Xz(t, n) {
  if (Yz(t)) Xz(t.not, n);
  else if (Vz(t)) for (const e of t.and) Xz(e, n);
  else if (Gz(t)) for (const e of t.or) Xz(e, n);
  else n(t);
}
function Jz(t, n) {
  return Yz(t)
    ? { not: Jz(t.not, n) }
    : Vz(t)
    ? { and: t.and.map(t => Jz(t, n)) }
    : Gz(t)
    ? { or: t.or.map(t => Jz(t, n)) }
    : n(t);
}
const Qz = function t(n, e) {
    if (n === e) return !0;
    if (n && e && 'object' == typeof n && 'object' == typeof e) {
      if (n.constructor !== e.constructor) return !1;
      var r, i, o;
      if (Array.isArray(n)) {
        if ((r = n.length) != e.length) return !1;
        for (i = r; 0 != i--; ) if (!t(n[i], e[i])) return !1;
        return !0;
      }
      if (n.constructor === RegExp) return n.source === e.source && n.flags === e.flags;
      if (n.valueOf !== Object.prototype.valueOf) return n.valueOf() === e.valueOf();
      if (n.toString !== Object.prototype.toString) return n.toString() === e.toString();
      if ((r = (o = Object.keys(n)).length) !== Object.keys(e).length) return !1;
      for (i = r; 0 != i--; ) if (!Object.prototype.hasOwnProperty.call(e, o[i])) return !1;
      for (i = r; 0 != i--; ) {
        var u = o[i];
        if (!t(n[u], e[u])) return !1;
      }
      return !0;
    }
    return n != n && e != e;
  },
  Zz = Wz;
function Kz(t) {
  throw new Error(t);
}
function tT(t, n) {
  const e = {};
  for (const r of n) Pt(t, r) && (e[r] = t[r]);
  return e;
}
function nT(t, n) {
  const e = Object.assign({}, t);
  for (const t of n) delete e[t];
  return e;
}
Set.prototype.toJSON = function () {
  return `Set(${[...this].map(t => Hz(t)).join(',')})`;
};
const eT = Hz;
function rT(t) {
  if (Vt(t)) return t;
  const n = Xt(t) ? t : Hz(t);
  if (n.length < 250) return n;
  let e = 0;
  for (let t = 0; t < n.length; t++) (e = (e << 5) - e + n.charCodeAt(t)), (e &= e);
  return e;
}
function iT(t) {
  return !1 === t || null === t;
}
function oT(t, n) {
  return t.includes(n);
}
function uT(t, n) {
  let e = 0;
  for (const [r, i] of t.entries()) if (n(i, r, e++)) return !0;
  return !1;
}
function sT(t, n) {
  let e = 0;
  for (const [r, i] of t.entries()) if (!n(i, r, e++)) return !1;
  return !0;
}
function aT(t, ...n) {
  for (const e of n) cT(t, null != e ? e : {});
  return t;
}
function cT(t, n) {
  for (const e of vT(n)) rt(t, e, n[e], !0);
}
function lT(t, n) {
  const e = [],
    r = {};
  let i;
  for (const o of t) (i = n(o)), i in r || ((r[i] = 1), e.push(o));
  return e;
}
function fT(t, n) {
  if (t.size !== n.size) return !1;
  for (const e of t) if (!n.has(e)) return !1;
  return !0;
}
function hT(t, n) {
  for (const e of t) if (n.has(e)) return !0;
  return !1;
}
function dT(t) {
  const n = new Set();
  for (const e of t) {
    const t = U(e).map((t, n) => (0 === n ? t : `[${t}]`)),
      r = t.map((n, e) => t.slice(0, e + 1).join(''));
    for (const t of r) n.add(t);
  }
  return n;
}
function pT(t, n) {
  return void 0 === t || void 0 === n || hT(dT(t), dT(n));
}
function mT(t) {
  return 0 === vT(t).length;
}
const vT = Object.keys,
  gT = Object.values,
  bT = Object.entries;
function yT(t) {
  return !0 === t || !1 === t;
}
function wT(t) {
  const n = t.replace(/\W/g, '_');
  return (t.match(/^\d+/) ? '_' : '') + n;
}
function xT(t, n) {
  return Yz(t)
    ? `!(${xT(t.not, n)})`
    : Vz(t)
    ? `(${t.and.map(t => xT(t, n)).join(') && (')})`
    : Gz(t)
    ? `(${t.or.map(t => xT(t, n)).join(') || (')})`
    : n(t);
}
function OT(t, n) {
  if (0 === n.length) return !0;
  const e = n.shift();
  return e in t && OT(t[e], n) && delete t[e], mT(t);
}
function kT(t) {
  return t.charAt(0).toUpperCase() + t.substr(1);
}
function AT(t, n = 'datum') {
  const e = U(t),
    r = [];
  for (let t = 1; t <= e.length; t++) {
    const i = `[${e.slice(0, t).map(rn).join('][')}]`;
    r.push(`${n}${i}`);
  }
  return r.join(' && ');
}
function $T(t, n = 'datum') {
  return `${n}[${rn(U(t).join('.'))}]`;
}
function MT(t) {
  return t.replace(/(\[|\]|\.|'|")/g, '\\$1');
}
function jT(t) {
  return `${U(t).map(MT).join('\\.')}`;
}
function DT(t, n, e) {
  return t.replace(new RegExp(n.replace(/[-/\\^$*+?.()|[\]{}]/g, '\\$&'), 'g'), e);
}
function FT(t) {
  return `${U(t).join('.')}`;
}
function ET(t) {
  return t ? U(t).length : 0;
}
function ST(...t) {
  for (const n of t) if (void 0 !== n) return n;
}
let CT = 42;
function NT(t) {
  const n = ++CT;
  return t ? String(t) + n : n;
}
function BT(t) {
  return _T(t) ? t : `__${t}`;
}
function _T(t) {
  return t.startsWith('__');
}
function zT(t) {
  if (void 0 !== t) return ((t % 360) + 360) % 360;
}
function TT(t) {
  return !!Vt(t) || (!isNaN(t) && !isNaN(parseFloat(t)));
}
var PT = function (t, n) {
  var e = {};
  for (var r in t) Object.prototype.hasOwnProperty.call(t, r) && n.indexOf(r) < 0 && (e[r] = t[r]);
  if (null != t && 'function' == typeof Object.getOwnPropertySymbols) {
    var i = 0;
    for (r = Object.getOwnPropertySymbols(t); i < r.length; i++)
      n.indexOf(r[i]) < 0 && Object.prototype.propertyIsEnumerable.call(t, r[i]) && (e[r[i]] = t[r[i]]);
  }
  return e;
};
const RT = 'row',
  LT = 'column',
  qT = 'facet',
  IT = 'x',
  UT = 'y',
  WT = 'x2',
  HT = 'y2',
  GT = 'xOffset',
  VT = 'yOffset',
  YT = 'radius',
  XT = 'radius2',
  JT = 'theta',
  QT = 'theta2',
  ZT = 'latitude',
  KT = 'longitude',
  tP = 'latitude2',
  nP = 'longitude2',
  eP = 'color',
  rP = 'fill',
  iP = 'stroke',
  oP = 'shape',
  uP = 'size',
  sP = 'angle',
  aP = 'opacity',
  cP = 'fillOpacity',
  lP = 'strokeOpacity',
  fP = 'strokeWidth',
  hP = 'strokeDash',
  dP = 'text',
  pP = 'order',
  mP = 'detail',
  vP = 'key',
  gP = 'tooltip',
  bP = 'href',
  yP = 'url',
  wP = 'description',
  xP = { theta: 1, theta2: 1, radius: 1, radius2: 1 };
function OP(t) {
  return t in xP;
}
const kP = { longitude: 1, longitude2: 1, latitude: 1, latitude2: 1 },
  AP = vT(kP),
  $P = Object.assign(Object.assign(Object.assign(Object.assign({}, { x: 1, y: 1, x2: 1, y2: 1 }), xP), kP), {
    xOffset: 1,
    yOffset: 1,
    color: 1,
    fill: 1,
    stroke: 1,
    opacity: 1,
    fillOpacity: 1,
    strokeOpacity: 1,
    strokeWidth: 1,
    strokeDash: 1,
    size: 1,
    angle: 1,
    shape: 1,
    order: 1,
    text: 1,
    detail: 1,
    key: 1,
    tooltip: 1,
    href: 1,
    url: 1,
    description: 1,
  });
function MP(t) {
  return t === eP || t === rP || t === iP;
}
const jP = { row: 1, column: 1, facet: 1 },
  DP = vT(jP),
  FP = Object.assign(Object.assign({}, $P), jP),
  EP = vT(FP),
  SP = PT(FP, ['order', 'detail', 'tooltip']),
  CP = PT(SP, ['row', 'column', 'facet']);
function NP(t) {
  return !!FP[t];
}
const BP = [WT, HT, tP, nP, QT, XT];
function _P(t) {
  return zP(t) !== t;
}
function zP(t) {
  switch (t) {
    case WT:
      return IT;
    case HT:
      return UT;
    case tP:
      return ZT;
    case nP:
      return KT;
    case QT:
      return JT;
    case XT:
      return YT;
  }
  return t;
}
function TP(t) {
  if (OP(t))
    switch (t) {
      case JT:
        return 'startAngle';
      case QT:
        return 'endAngle';
      case YT:
        return 'outerRadius';
      case XT:
        return 'innerRadius';
    }
  return t;
}
function PP(t) {
  switch (t) {
    case IT:
      return WT;
    case UT:
      return HT;
    case ZT:
      return tP;
    case KT:
      return nP;
    case JT:
      return QT;
    case YT:
      return XT;
  }
}
function RP(t) {
  switch (t) {
    case IT:
    case WT:
      return 'width';
    case UT:
    case HT:
      return 'height';
  }
}
function LP(t) {
  switch (t) {
    case IT:
      return 'xOffset';
    case UT:
      return 'yOffset';
  }
}
function qP(t) {
  switch (t) {
    case 'xOffset':
      return 'x';
    case 'yOffset':
      return 'y';
  }
}
const IP = vT($P),
  UP = PT($P, [
    'x',
    'y',
    'x2',
    'y2',
    'xOffset',
    'yOffset',
    'latitude',
    'longitude',
    'latitude2',
    'longitude2',
    'theta',
    'theta2',
    'radius',
    'radius2',
  ]),
  WP = vT(UP),
  HP = { x: 1, y: 1 },
  GP = vT(HP);
function VP(t) {
  return t in HP;
}
const YP = { theta: 1, radius: 1 },
  XP = vT(YP);
function JP(t) {
  return 'width' === t ? IT : UT;
}
const QP = { xOffset: 1, yOffset: 1 };
function ZP(t) {
  return t in QP;
}
const KP = PT(UP, ['text', 'tooltip', 'href', 'url', 'description', 'detail', 'key', 'order']),
  tR = vT(KP),
  nR = Object.assign(Object.assign(Object.assign(Object.assign({}, HP), YP), QP), KP),
  eR = vT(nR);
function rR(t) {
  return !!nR[t];
}
const iR = {
    arc: 'always',
    area: 'always',
    bar: 'always',
    circle: 'always',
    geoshape: 'always',
    image: 'always',
    line: 'always',
    rule: 'always',
    point: 'always',
    rect: 'always',
    square: 'always',
    trail: 'always',
    text: 'always',
    tick: 'always',
  },
  oR = PT(iR, ['geoshape']);
function uR(t) {
  switch (t) {
    case IT:
    case UT:
    case JT:
    case YT:
    case GT:
    case VT:
    case uP:
    case sP:
    case fP:
    case aP:
    case cP:
    case lP:
    case WT:
    case HT:
    case QT:
    case XT:
      return;
    case qT:
    case RT:
    case LT:
    case oP:
    case hP:
    case dP:
    case gP:
    case bP:
    case yP:
    case wP:
      return 'discrete';
    case eP:
    case rP:
    case iP:
      return 'flexible';
    case ZT:
    case KT:
    case tP:
    case nP:
    case mP:
    case vP:
    case pP:
      return;
  }
}
const sR = {
    argmax: 1,
    argmin: 1,
    average: 1,
    count: 1,
    distinct: 1,
    product: 1,
    max: 1,
    mean: 1,
    median: 1,
    min: 1,
    missing: 1,
    q1: 1,
    q3: 1,
    ci0: 1,
    ci1: 1,
    stderr: 1,
    stdev: 1,
    stdevp: 1,
    sum: 1,
    valid: 1,
    values: 1,
    variance: 1,
    variancep: 1,
  },
  aR = { count: 1, min: 1, max: 1 };
function cR(t) {
  return !!t && !!t.argmin;
}
function lR(t) {
  return !!t && !!t.argmax;
}
function fR(t) {
  return Xt(t) && !!sR[t];
}
const hR = new Set(['count', 'valid', 'missing', 'distinct']);
function dR(t) {
  return Xt(t) && hR.has(t);
}
const pR = new Set(['count', 'sum', 'distinct', 'valid', 'missing']),
  mR = new Set(['mean', 'average', 'median', 'q1', 'q3', 'min', 'max']);
function vR(t) {
  return (
    Wt(t) && (t = lU(t, void 0)),
    'bin' +
      vT(t)
        .map(n => (wR(t[n]) ? wT(`_${n}_${bT(t[n])}`) : wT(`_${n}_${t[n]}`)))
        .join('')
  );
}
function gR(t) {
  return !0 === t || (yR(t) && !t.binned);
}
function bR(t) {
  return 'binned' === t || (yR(t) && !0 === t.binned);
}
function yR(t) {
  return tt(t);
}
function wR(t) {
  return null == t ? void 0 : t.param;
}
function xR(t) {
  switch (t) {
    case RT:
    case LT:
    case uP:
    case eP:
    case rP:
    case iP:
    case fP:
    case aP:
    case cP:
    case lP:
    case oP:
      return 6;
    case hP:
      return 4;
    default:
      return 10;
  }
}
function OR(t) {
  return !!(null == t ? void 0 : t.expr);
}
function kR(t) {
  const n = vT(t || {}),
    e = {};
  for (const r of n) e[r] = BR(t[r]);
  return e;
}
function AR(t) {
  const {
      anchor: n,
      frame: e,
      offset: r,
      orient: i,
      angle: o,
      limit: u,
      color: s,
      subtitleColor: a,
      subtitleFont: c,
      subtitleFontSize: l,
      subtitleFontStyle: f,
      subtitleFontWeight: h,
      subtitleLineHeight: d,
      subtitlePadding: p,
    } = t,
    m = (function (t, n) {
      var e = {};
      for (var r in t) Object.prototype.hasOwnProperty.call(t, r) && n.indexOf(r) < 0 && (e[r] = t[r]);
      if (null != t && 'function' == typeof Object.getOwnPropertySymbols) {
        var i = 0;
        for (r = Object.getOwnPropertySymbols(t); i < r.length; i++)
          n.indexOf(r[i]) < 0 && Object.prototype.propertyIsEnumerable.call(t, r[i]) && (e[r[i]] = t[r[i]]);
      }
      return e;
    })(t, [
      'anchor',
      'frame',
      'offset',
      'orient',
      'angle',
      'limit',
      'color',
      'subtitleColor',
      'subtitleFont',
      'subtitleFontSize',
      'subtitleFontStyle',
      'subtitleFontWeight',
      'subtitleLineHeight',
      'subtitlePadding',
    ]),
    v = Object.assign(Object.assign({}, m), s ? { fill: s } : {}),
    g = Object.assign(
      Object.assign(
        Object.assign(
          Object.assign(
            Object.assign(Object.assign({}, n ? { anchor: n } : {}), e ? { frame: e } : {}),
            r ? { offset: r } : {},
          ),
          i ? { orient: i } : {},
        ),
        void 0 !== o ? { angle: o } : {},
      ),
      void 0 !== u ? { limit: u } : {},
    ),
    b = Object.assign(
      Object.assign(
        Object.assign(
          Object.assign(
            Object.assign(
              Object.assign(Object.assign({}, a ? { subtitleColor: a } : {}), c ? { subtitleFont: c } : {}),
              l ? { subtitleFontSize: l } : {},
            ),
            f ? { subtitleFontStyle: f } : {},
          ),
          h ? { subtitleFontWeight: h } : {},
        ),
        d ? { subtitleLineHeight: d } : {},
      ),
      p ? { subtitlePadding: p } : {},
    );
  return {
    titleMarkConfig: v,
    subtitleMarkConfig: tT(t, ['align', 'baseline', 'dx', 'dy', 'limit']),
    nonMarkTitleProperties: g,
    subtitle: b,
  };
}
function $R(t) {
  return Xt(t) || (K(t) && Xt(t[0]));
}
function MR(t) {
  return !!(null == t ? void 0 : t.signal);
}
function jR(t) {
  return !!t.step;
}
function DR(t) {
  return !K(t) && 'field' in t && 'data' in t;
}
const FR = vT({
    aria: 1,
    description: 1,
    ariaRole: 1,
    ariaRoleDescription: 1,
    blend: 1,
    opacity: 1,
    fill: 1,
    fillOpacity: 1,
    stroke: 1,
    strokeCap: 1,
    strokeWidth: 1,
    strokeOpacity: 1,
    strokeDash: 1,
    strokeDashOffset: 1,
    strokeJoin: 1,
    strokeOffset: 1,
    strokeMiterLimit: 1,
    startAngle: 1,
    endAngle: 1,
    padAngle: 1,
    innerRadius: 1,
    outerRadius: 1,
    size: 1,
    shape: 1,
    interpolate: 1,
    tension: 1,
    orient: 1,
    align: 1,
    baseline: 1,
    text: 1,
    dir: 1,
    dx: 1,
    dy: 1,
    ellipsis: 1,
    limit: 1,
    radius: 1,
    theta: 1,
    angle: 1,
    font: 1,
    fontSize: 1,
    fontWeight: 1,
    fontStyle: 1,
    lineBreak: 1,
    lineHeight: 1,
    cursor: 1,
    href: 1,
    tooltip: 1,
    cornerRadius: 1,
    cornerRadiusTopLeft: 1,
    cornerRadiusTopRight: 1,
    cornerRadiusBottomLeft: 1,
    cornerRadiusBottomRight: 1,
    aspect: 1,
    width: 1,
    height: 1,
    url: 1,
    smooth: 1,
  }),
  ER = {
    arc: 1,
    area: 1,
    group: 1,
    image: 1,
    line: 1,
    path: 1,
    rect: 1,
    rule: 1,
    shape: 1,
    symbol: 1,
    text: 1,
    trail: 1,
  },
  SR = [
    'cornerRadius',
    'cornerRadiusTopLeft',
    'cornerRadiusTopRight',
    'cornerRadiusBottomLeft',
    'cornerRadiusBottomRight',
  ];
var CR = function (t, n) {
  var e = {};
  for (var r in t) Object.prototype.hasOwnProperty.call(t, r) && n.indexOf(r) < 0 && (e[r] = t[r]);
  if (null != t && 'function' == typeof Object.getOwnPropertySymbols) {
    var i = 0;
    for (r = Object.getOwnPropertySymbols(t); i < r.length; i++)
      n.indexOf(r[i]) < 0 && Object.prototype.propertyIsEnumerable.call(t, r[i]) && (e[r[i]] = t[r[i]]);
  }
  return e;
};
function NR(t) {
  const n = K(t.condition) ? t.condition.map(_R) : _R(t.condition);
  return Object.assign(Object.assign({}, BR(t)), { condition: n });
}
function BR(t) {
  if (OR(t)) {
    const { expr: n } = t,
      e = CR(t, ['expr']);
    return Object.assign({ signal: n }, e);
  }
  return t;
}
function _R(t) {
  if (OR(t)) {
    const { expr: n } = t,
      e = CR(t, ['expr']);
    return Object.assign({ signal: n }, e);
  }
  return t;
}
function zR(t) {
  if (OR(t)) {
    const { expr: n } = t,
      e = CR(t, ['expr']);
    return Object.assign({ signal: n }, e);
  }
  return MR(t) ? t : void 0 !== t ? { value: t } : void 0;
}
function TR(t) {
  return MR(t) ? t.signal : rn(t);
}
function PR(t) {
  return MR(t) ? t.signal : rn(t.value);
}
function RR(t) {
  return MR(t) ? t.signal : null == t ? null : rn(t);
}
function LR(t) {
  var n;
  return [].concat(t.type, null !== (n = t.style) && void 0 !== n ? n : []);
}
function qR(t, n, e, r = {}) {
  const { vgChannel: i, ignoreVgConfig: o } = r;
  return i && void 0 !== n[i] ? n[i] : void 0 !== n[t] ? n[t] : !o || (i && i !== t) ? IR(t, n, e, r) : void 0;
}
function IR(t, n, e, { vgChannel: r } = {}) {
  return ST(
    r ? UR(t, n, e.style) : void 0,
    UR(t, n, e.style),
    r ? e[n.type][r] : void 0,
    e[n.type][t],
    r ? e.mark[r] : e.mark[t],
  );
}
function UR(t, n, e) {
  return WR(t, LR(n), e);
}
function WR(t, n, e) {
  let r;
  n = At(n);
  for (const i of n) {
    const n = e[i];
    n && void 0 !== n[t] && (r = n[t]);
  }
  return r;
}
function HR(t, n) {
  return At(t).reduce(
    (t, e) => {
      var r;
      return t.field.push(JI(e, n)), t.order.push(null !== (r = e.sort) && void 0 !== r ? r : 'ascending'), t;
    },
    { field: [], order: [] },
  );
}
function GR(t, n) {
  const e = [...t];
  return (
    n.forEach(t => {
      for (const n of e) if (Qz(n, t)) return;
      e.push(t);
    }),
    e
  );
}
function VR(t, n) {
  return Qz(t, n) || !n ? t : t ? [...At(t), ...At(n)].join(', ') : n;
}
function YR(t, n) {
  const e = t.value,
    r = n.value;
  if (null == e || null === r) return { explicit: t.explicit, value: null };
  if (($R(e) || MR(e)) && ($R(r) || MR(r))) return { explicit: t.explicit, value: VR(e, r) };
  if ($R(e) || MR(e)) return { explicit: t.explicit, value: e };
  if ($R(r) || MR(r)) return { explicit: t.explicit, value: r };
  if (!($R(e) || MR(e) || $R(r) || MR(r))) return { explicit: t.explicit, value: GR(e, r) };
  throw new Error('It should never reach here');
}
function XR(t) {
  return `Invalid specification ${eT(
    t,
  )}. Make sure the specification includes at least one of the following properties: "mark", "layer", "facet", "hconcat", "vconcat", "concat", or "repeat".`;
}
function JR(t) {
  return ('width' == t ? 'Width' : 'Height') + ' "container" only works for single views and layered views.';
}
function QR(t) {
  return `${'width' == t ? 'Width' : 'Height'} "container" only works well with autosize "fit" or "fit-${
    'width' == t ? 'x' : 'y'
  }".`;
}
function ZR(t) {
  return t
    ? `Dropping "fit-${t}" because spec has discrete ${RP(t)}.`
    : 'Dropping "fit" because spec has discrete size.';
}
function KR(t) {
  return `Unknown field for ${t}. Cannot calculate view size.`;
}
function tL(t) {
  return `Cannot project a selection on encoding channel "${t}", which has no field.`;
}
function nL(t, n) {
  return `Cannot project a selection on encoding channel "${t}" as it uses an aggregate function ("${n}").`;
}
function eL(t) {
  return `Selection not supported for ${t} yet.`;
}
function rL(t) {
  return `The "columns" property cannot be used when "${t}" has nested row/column.`;
}
function iL(t, n, e) {
  return `An ancestor parsed field "${t}" as ${e} but a child wants to parse the field as ${n}.`;
}
function oL(t) {
  return `Ignoring an invalid transform: ${eT(t)}.`;
}
function uL(t) {
  return `Config.customFormatTypes is not true, thus custom format type and format for channel ${t} are dropped.`;
}
function sL(t) {
  return `${t}Offset dropped because ${t} is continuous`;
}
function aL(t) {
  return `There is no ${t} encoding. Replacing ${t}Offset encoding as ${t}.`;
}
function cL(t) {
  return `Invalid field type "${t}".`;
}
function lL(t, n) {
  const { fill: e, stroke: r } = n;
  return `Dropping color ${t} as the plot also has ${e && r ? 'fill and stroke' : e ? 'fill' : 'stroke'}.`;
}
function fL(t, n) {
  return `Dropping ${eT(t)} from channel "${n}" since it does not contain any data field, datum, value, or signal.`;
}
function hL(t, n, e) {
  return `${t} dropped as it is incompatible with "${n}"${e ? ` when ${e}` : ''}.`;
}
function dL(t) {
  return `${t} encoding has no scale, so specified scale is ignored.`;
}
function pL(t) {
  return `${t} encoding should be discrete (ordinal / nominal / binned).`;
}
function mL(t) {
  return `${t} encoding should be discrete (ordinal / nominal / binned) or use a discretizing scale (e.g. threshold).`;
}
function vL(t, n) {
  return `Using discrete channel "${t}" to encode "${n}" field can be misleading as it does not encode ${
    'ordinal' === n ? 'order' : 'magnitude'
  }.`;
}
function gL(t) {
  return `Using unaggregated domain with raw field has no effect (${eT(t)}).`;
}
function bL(t) {
  return `Unaggregated domain not applicable for "${t}" since it produces values outside the origin domain of the source data.`;
}
function yL(t) {
  return `Unaggregated domain is currently unsupported for log scale (${eT(t)}).`;
}
function wL(t, n, e) {
  return `${e}-scale's "${n}" is dropped as it does not work with ${t} scale.`;
}
function xL(t) {
  return `The step for "${t}" is dropped because the ${'width' === t ? 'x' : 'y'} is continuous.`;
}
const OL = 'Domains that should be unioned has conflicting sort properties. Sort will be set to true.';
function kL(t, n) {
  return `Invalid ${t}: ${eT(n)}.`;
}
function AL(t) {
  return `1D error band does not support ${t}.`;
}
function $L(t) {
  return `Channel ${t} is required for "binned" bin.`;
}
const ML = Z(2);
let jL = ML;
function DL(...t) {
  jL.warn(...t);
}
function FL(t) {
  if (t && tt(t)) for (const n of TL) if (n in t) return !0;
  return !1;
}
const EL = [
    'january',
    'february',
    'march',
    'april',
    'may',
    'june',
    'july',
    'august',
    'september',
    'october',
    'november',
    'december',
  ],
  SL = EL.map(t => t.substr(0, 3)),
  CL = ['sunday', 'monday', 'tuesday', 'wednesday', 'thursday', 'friday', 'saturday'],
  NL = CL.map(t => t.substr(0, 3));
function BL(t, n) {
  const e = [];
  if (
    (n &&
      void 0 !== t.day &&
      vT(t).length > 1 &&
      (DL(
        (function (t) {
          return `Dropping day from datetime ${eT(t)} as day cannot be combined with other units.`;
        })(t),
      ),
      delete (t = Zz(t)).day),
    e.push(void 0 !== t.year ? t.year : 2012),
    void 0 !== t.month)
  ) {
    const r = n
      ? (function (t) {
          if ((TT(t) && (t = +t), Vt(t))) return t - 1;
          {
            const n = t.toLowerCase(),
              e = EL.indexOf(n);
            if (-1 !== e) return e;
            const r = n.substr(0, 3),
              i = SL.indexOf(r);
            if (-1 !== i) return i;
            throw new Error(kL('month', t));
          }
        })(t.month)
      : t.month;
    e.push(r);
  } else if (void 0 !== t.quarter) {
    const r = n
      ? (function (t) {
          if ((TT(t) && (t = +t), Vt(t))) return t > 4 && DL(kL('quarter', t)), t - 1;
          throw new Error(kL('quarter', t));
        })(t.quarter)
      : t.quarter;
    e.push(Vt(r) ? 3 * r : `${r}*3`);
  } else e.push(0);
  if (void 0 !== t.date) e.push(t.date);
  else if (void 0 !== t.day) {
    const r = n
      ? (function (t) {
          if ((TT(t) && (t = +t), Vt(t))) return t % 7;
          {
            const n = t.toLowerCase(),
              e = CL.indexOf(n);
            if (-1 !== e) return e;
            const r = n.substr(0, 3),
              i = NL.indexOf(r);
            if (-1 !== i) return i;
            throw new Error(kL('day', t));
          }
        })(t.day)
      : t.day;
    e.push(Vt(r) ? r + 1 : `${r}+1`);
  } else e.push(1);
  for (const n of ['hours', 'minutes', 'seconds', 'milliseconds']) {
    const r = t[n];
    e.push(void 0 === r ? 0 : r);
  }
  return e;
}
function _L(t) {
  const n = BL(t, !0).join(', ');
  return t.utc ? `utc(${n})` : `datetime(${n})`;
}
const zL = {
    year: 1,
    quarter: 1,
    month: 1,
    week: 1,
    day: 1,
    dayofyear: 1,
    date: 1,
    hours: 1,
    minutes: 1,
    seconds: 1,
    milliseconds: 1,
  },
  TL = vT(zL);
function PL(t) {
  return t.startsWith('utc');
}
const RL = { 'year-month': '%b %Y ', 'year-month-date': '%b %d, %Y ' };
function LL(t) {
  return TL.filter(n => qL(t, n));
}
function qL(t, n) {
  const e = t.indexOf(n);
  return !(
    e < 0 ||
    (e > 0 && 'seconds' === n && 'i' === t.charAt(e - 1)) ||
    (t.length > e + 3 && 'day' === n && 'o' === t.charAt(e + 3)) ||
    (e > 0 && 'year' === n && 'f' === t.charAt(e - 1))
  );
}
function IL(t) {
  if (!t) return;
  const n = LL(t);
  return `timeUnitSpecifier(${eT(n)}, ${eT(RL)})`;
}
function UL(t) {
  if (!t) return;
  let n;
  return (
    Xt(t) ? (n = { unit: t }) : tt(t) && (n = Object.assign(Object.assign({}, t), t.unit ? { unit: t.unit } : {})),
    PL(n.unit) &&
      ((n.utc = !0),
      (n.unit = (function (t) {
        return t.substr(3);
      })(n.unit))),
    n
  );
}
function WL(t) {
  return !!(null == t ? void 0 : t.field) && void 0 !== t.equal;
}
function HL(t) {
  return !!(null == t ? void 0 : t.field) && void 0 !== t.lt;
}
function GL(t) {
  return !!(null == t ? void 0 : t.field) && void 0 !== t.lte;
}
function VL(t) {
  return !!(null == t ? void 0 : t.field) && void 0 !== t.gt;
}
function YL(t) {
  return !!(null == t ? void 0 : t.field) && void 0 !== t.gte;
}
function XL(t) {
  if (null == t ? void 0 : t.field) {
    if (K(t.range) && 2 === t.range.length) return !0;
    if (MR(t.range)) return !0;
  }
  return !1;
}
function JL(t) {
  return !!(null == t ? void 0 : t.field) && (K(t.oneOf) || K(t.in));
}
function QL(t) {
  return JL(t) || WL(t) || XL(t) || HL(t) || VL(t) || GL(t) || YL(t);
}
function ZL(t, n) {
  return dU(t, { timeUnit: n, wrapTime: !0 });
}
function KL(t, n = !0) {
  var e;
  const { field: r } = t,
    i = null === (e = UL(t.timeUnit)) || void 0 === e ? void 0 : e.unit,
    o = i
      ? `time(${(function (t, n, { end: e } = { end: !1 }) {
          const r = AT(n),
            i = PL(t) ? 'utc' : '';
          let o;
          const u = {};
          for (const n of TL)
            qL(t, n) && ((u[n] = 'quarter' === (s = n) ? `(${i}quarter(${r})-1)` : `${i}${s}(${r})`), (o = n));
          var s;
          return (
            e && (u[o] += '+1'),
            (function (t) {
              const n = BL(t, !1).join(', ');
              return t.utc ? `utc(${n})` : `datetime(${n})`;
            })(u)
          );
        })(i, r)})`
      : JI(t, { expr: 'datum' });
  if (WL(t)) return `${o}===${ZL(t.equal, i)}`;
  if (HL(t)) return `${o}<${ZL(t.lt, i)}`;
  if (VL(t)) return `${o}>${ZL(t.gt, i)}`;
  if (GL(t)) return `${o}<=${ZL(t.lte, i)}`;
  if (YL(t)) return `${o}>=${ZL(t.gte, i)}`;
  if (JL(t))
    return `indexof([${(function (t, n) {
      return t.map(t => ZL(t, n));
    })(t.oneOf, i).join(',')}], ${o}) !== -1`;
  if (
    (function (t) {
      return !!(null == t ? void 0 : t.field) && void 0 !== t.valid;
    })(t)
  )
    return tq(o, t.valid);
  if (XL(t)) {
    const { range: e } = t,
      r = MR(e) ? { signal: `${e.signal}[0]` } : e[0],
      u = MR(e) ? { signal: `${e.signal}[1]` } : e[1];
    if (null !== r && null !== u && n) return 'inrange(' + o + ', [' + ZL(r, i) + ', ' + ZL(u, i) + '])';
    const s = [];
    return (
      null !== r && s.push(`${o} >= ${ZL(r, i)}`),
      null !== u && s.push(`${o} <= ${ZL(u, i)}`),
      s.length > 0 ? s.join(' && ') : 'true'
    );
  }
  throw new Error(`Invalid field predicate: ${eT(t)}`);
}
function tq(t, n = !0) {
  return n ? `isValid(${t}) && isFinite(+${t})` : `!isValid(${t}) || !isFinite(+${t})`;
}
function nq(t) {
  var n;
  return QL(t) && t.timeUnit
    ? Object.assign(Object.assign({}, t), { timeUnit: null === (n = UL(t.timeUnit)) || void 0 === n ? void 0 : n.unit })
    : t;
}
function eq(t) {
  return 'ordinal' === t || 'nominal' === t;
}
const rq = 'quantitative',
  iq = 'ordinal',
  oq = 'temporal',
  uq = 'nominal',
  sq = 'geojson';
const aq = 'time',
  cq = 'utc',
  lq = 'point',
  fq = 'band',
  hq = {
    linear: 'numeric',
    log: 'numeric',
    pow: 'numeric',
    sqrt: 'numeric',
    symlog: 'numeric',
    identity: 'numeric',
    sequential: 'numeric',
    time: 'time',
    utc: 'time',
    ordinal: 'ordinal',
    'bin-ordinal': 'bin-ordinal',
    point: 'ordinal-position',
    band: 'ordinal-position',
    quantile: 'discretizing',
    quantize: 'discretizing',
    threshold: 'discretizing',
  };
function dq(t, n) {
  const e = hq[t],
    r = hq[n];
  return e === r || ('ordinal-position' === e && 'time' === r) || ('ordinal-position' === r && 'time' === e);
}
const pq = {
  linear: 0,
  log: 1,
  pow: 1,
  sqrt: 1,
  symlog: 1,
  identity: 1,
  sequential: 1,
  time: 0,
  utc: 0,
  point: 10,
  band: 11,
  ordinal: 0,
  'bin-ordinal': 0,
  quantile: 0,
  quantize: 0,
  threshold: 0,
};
function mq(t) {
  return pq[t];
}
const vq = new Set(['linear', 'log', 'pow', 'sqrt', 'symlog']),
  gq = new Set([...vq, 'time', 'utc']);
function bq(t) {
  return vq.has(t);
}
const yq = new Set(['quantile', 'quantize', 'threshold']),
  wq = new Set([...gq, ...yq, 'sequential', 'identity']),
  xq = new Set(['ordinal', 'bin-ordinal', 'point', 'band']);
function Oq(t) {
  return xq.has(t);
}
function kq(t) {
  return wq.has(t);
}
function Aq(t) {
  return gq.has(t);
}
function $q(t) {
  return yq.has(t);
}
function Mq(t) {
  return null == t ? void 0 : t.param;
}
const jq = (function (t, n) {
    var e = {};
    for (var r in t) Object.prototype.hasOwnProperty.call(t, r) && n.indexOf(r) < 0 && (e[r] = t[r]);
    if (null != t && 'function' == typeof Object.getOwnPropertySymbols) {
      var i = 0;
      for (r = Object.getOwnPropertySymbols(t); i < r.length; i++)
        n.indexOf(r[i]) < 0 && Object.prototype.propertyIsEnumerable.call(t, r[i]) && (e[r[i]] = t[r[i]]);
    }
    return e;
  })(
    {
      type: 1,
      domain: 1,
      domainMax: 1,
      domainMin: 1,
      domainMid: 1,
      align: 1,
      range: 1,
      rangeMax: 1,
      rangeMin: 1,
      scheme: 1,
      bins: 1,
      reverse: 1,
      round: 1,
      clamp: 1,
      nice: 1,
      base: 1,
      exponent: 1,
      constant: 1,
      interpolate: 1,
      zero: 1,
      padding: 1,
      paddingInner: 1,
      paddingOuter: 1,
    },
    ['type', 'domain', 'range', 'rangeMax', 'rangeMin', 'scheme'],
  ),
  Dq = vT(jq);
function Fq(t, n) {
  switch (n) {
    case 'type':
    case 'domain':
    case 'reverse':
    case 'range':
      return !0;
    case 'scheme':
    case 'interpolate':
      return !['point', 'band', 'identity'].includes(t);
    case 'bins':
      return !['point', 'band', 'identity', 'ordinal'].includes(t);
    case 'round':
      return Aq(t) || 'band' === t || 'point' === t;
    case 'padding':
    case 'rangeMin':
    case 'rangeMax':
      return Aq(t) || ['point', 'band'].includes(t);
    case 'paddingOuter':
    case 'align':
      return ['point', 'band'].includes(t);
    case 'paddingInner':
      return 'band' === t;
    case 'domainMax':
    case 'domainMid':
    case 'domainMin':
    case 'clamp':
      return Aq(t);
    case 'nice':
      return Aq(t) || 'quantize' === t || 'threshold' === t;
    case 'exponent':
      return 'pow' === t;
    case 'base':
      return 'log' === t;
    case 'constant':
      return 'symlog' === t;
    case 'zero':
      return kq(t) && !oT(['log', 'time', 'utc', 'threshold', 'quantile'], t);
  }
}
function Eq(t, n) {
  switch (n) {
    case 'interpolate':
    case 'scheme':
    case 'domainMid':
      return MP(t) ? void 0 : `Cannot use the scale property "${n}" with non-color channel.`;
    case 'align':
    case 'type':
    case 'bins':
    case 'domain':
    case 'domainMax':
    case 'domainMin':
    case 'range':
    case 'base':
    case 'exponent':
    case 'constant':
    case 'nice':
    case 'padding':
    case 'paddingInner':
    case 'paddingOuter':
    case 'rangeMax':
    case 'rangeMin':
    case 'reverse':
    case 'round':
    case 'clamp':
    case 'zero':
      return;
  }
}
const Sq = {
    arc: 'arc',
    area: 'area',
    bar: 'bar',
    image: 'image',
    line: 'line',
    point: 'point',
    rect: 'rect',
    rule: 'rule',
    text: 'text',
    tick: 'tick',
    trail: 'trail',
    circle: 'circle',
    square: 'square',
    geoshape: 'geoshape',
  },
  Cq = Sq.arc,
  Nq = Sq.area,
  Bq = Sq.bar,
  _q = Sq.image,
  zq = Sq.line,
  Tq = Sq.point,
  Pq = Sq.rect,
  Rq = Sq.rule,
  Lq = Sq.text,
  qq = Sq.tick,
  Iq = Sq.trail,
  Uq = Sq.circle,
  Wq = Sq.square,
  Hq = Sq.geoshape;
function Gq(t) {
  return ['line', 'area', 'trail'].includes(t);
}
function Vq(t) {
  return ['rect', 'bar', 'image', 'arc'].includes(t);
}
const Yq = new Set(vT(Sq));
function Xq(t) {
  return t.type;
}
const Jq = [
    'stroke',
    'strokeWidth',
    'strokeDash',
    'strokeDashOffset',
    'strokeOpacity',
    'strokeJoin',
    'strokeMiterLimit',
    'fill',
    'fillOpacity',
  ],
  Qq = vT({
    color: 1,
    filled: 1,
    invalid: 1,
    order: 1,
    radius2: 1,
    theta2: 1,
    timeUnitBandSize: 1,
    timeUnitBandPosition: 1,
  }),
  Zq = vT({
    mark: 1,
    arc: 1,
    area: 1,
    bar: 1,
    circle: 1,
    image: 1,
    line: 1,
    point: 1,
    rect: 1,
    rule: 1,
    square: 1,
    text: 1,
    tick: 1,
    trail: 1,
    geoshape: 1,
  });
function Kq(t) {
  return t && null != t.band;
}
const tI = {
  horizontal: ['cornerRadiusTopRight', 'cornerRadiusBottomRight'],
  vertical: ['cornerRadiusTopLeft', 'cornerRadiusTopRight'],
};
function nI(t) {
  const { channel: n, channelDef: e, markDef: r, scale: i, config: o } = t,
    u = uI(t);
  return TI(e) && !dR(e.aggregate) && i && Aq(i.get('type'))
    ? (function ({ fieldDef: t, channel: n, markDef: e, ref: r, config: i }) {
        if (Gq(e.type)) return r;
        return null === qR('invalid', e, i) ? [eI(t, n), r] : r;
      })({ fieldDef: e, channel: n, markDef: r, ref: u, config: o })
    : u;
}
function eI(t, n) {
  const e = rI(t, !0),
    r = zP(n);
  return Object.assign({ test: e }, 'y' === r ? { field: { group: 'height' } } : { value: 0 });
}
function rI(t, n = !0) {
  return tq(Xt(t) ? t : JI(t, { expr: 'datum' }), !n);
}
function iI(t, n, e, r) {
  const i = {};
  if ((n && (i.scale = n), RI(t))) {
    const { datum: n } = t;
    FL(n) ? (i.signal = _L(n)) : MR(n) ? (i.signal = n.signal) : OR(n) ? (i.signal = n.expr) : (i.value = n);
  } else i.field = JI(t, e);
  if (r) {
    const { offset: t, band: n } = r;
    t && (i.offset = t), n && (i.band = n);
  }
  return i;
}
function oI({
  scaleName: t,
  fieldOrDatumDef: n,
  fieldOrDatumDef2: e,
  offset: r,
  startSuffix: i,
  bandPosition: o = 0.5,
}) {
  const u = 0 < o && o < 1 ? 'datum' : void 0,
    s = JI(n, { expr: u, suffix: i }),
    a = void 0 !== e ? JI(e, { expr: u }) : JI(n, { suffix: 'end', expr: u }),
    c = {};
  if (0 === o || 1 === o) (c.scale = t), (c.field = 0 === o ? s : a);
  else {
    const n = MR(o) ? `${o.signal} * ${s} + (1-${o.signal}) * ${a}` : `${o} * ${s} + ${1 - o} * ${a}`;
    c.signal = `scale("${t}", ${n})`;
  }
  return r && (c.offset = r), c;
}
function uI({
  channel: t,
  channelDef: n,
  channel2Def: e,
  markDef: r,
  config: i,
  scaleName: o,
  scale: u,
  stack: s,
  offset: a,
  defaultRef: c,
  bandPosition: l,
}) {
  var f;
  if (n) {
    if (II(n)) {
      const c = null == u ? void 0 : u.get('type');
      if (UI(n)) {
        null != l || (l = SI({ fieldDef: n, fieldDef2: e, markDef: r, config: i }));
        const { bin: u, timeUnit: f, type: h } = n;
        if (gR(u) || (l && f && h === oq))
          return (null == s ? void 0 : s.impute)
            ? iI(n, o, { binSuffix: 'mid' }, { offset: a })
            : l && !Oq(c)
            ? oI({ scaleName: o, fieldOrDatumDef: n, bandPosition: l, offset: a })
            : iI(n, o, mU(n, t) ? { binSuffix: 'range' } : {}, { offset: a });
        if (bR(u)) {
          if (TI(e)) return oI({ scaleName: o, fieldOrDatumDef: n, fieldOrDatumDef2: e, bandPosition: l, offset: a });
          DL($L(t === IT ? WT : HT));
        }
      }
      return iI(n, o, Oq(c) ? { binSuffix: 'range' } : {}, {
        offset: a,
        band: 'band' === c ? (null !== (f = null != l ? l : n.bandPosition) && void 0 !== f ? f : 0.5) : void 0,
      });
    }
    if (WI(n)) {
      const e = a ? { offset: a } : {};
      return Object.assign(Object.assign({}, sI(t, n.value)), e);
    }
  }
  return Mt(c) && (c = c()), c ? Object.assign(Object.assign({}, c), a ? { offset: a } : {}) : c;
}
function sI(t, n) {
  return oT(['x', 'x2'], t) && 'width' === n
    ? { field: { group: 'width' } }
    : oT(['y', 'y2'], t) && 'height' === n
    ? { field: { group: 'height' } }
    : zR(n);
}
function aI(t) {
  return t && 'number' !== t && 'time' !== t;
}
function cI(t, n, e) {
  return `${t}(${n}${e ? `, ${eT(e)}` : ''})`;
}
function lI({ fieldOrDatumDef: t, format: n, formatType: e, expr: r, normalizeStack: i, config: o }) {
  var u, s;
  if (aI(e)) return hI({ fieldOrDatumDef: t, format: n, formatType: e, expr: r, config: o });
  const a = fI(t, r, i),
    c = PI(t);
  if (void 0 === n && void 0 === e && o.customFormatTypes) {
    if ('quantitative' === c) {
      if (i && o.normalizedNumberFormatType)
        return hI({
          fieldOrDatumDef: t,
          format: o.normalizedNumberFormat,
          formatType: o.normalizedNumberFormatType,
          expr: r,
          config: o,
        });
      if (o.numberFormatType)
        return hI({ fieldOrDatumDef: t, format: o.numberFormat, formatType: o.numberFormatType, expr: r, config: o });
    }
    if ('temporal' === c && o.timeFormatType && TI(t) && void 0 === t.timeUnit)
      return hI({ fieldOrDatumDef: t, format: o.timeFormat, formatType: o.timeFormatType, expr: r, config: o });
  }
  if (hU(t)) {
    const e = (function ({ field: t, timeUnit: n, format: e, formatType: r, rawTimeFormat: i, isUTCScale: o }) {
      return !n || e
        ? !n && r
          ? `${r}(${t}, '${e}')`
          : `${o ? 'utc' : 'time'}Format(${t}, '${(e = Xt(e) ? e : i)}')`
        : (function (t, n, e) {
            if (!t) return;
            const r = IL(t);
            return `${e || PL(t) ? 'utc' : 'time'}Format(${n}, ${r})`;
          })(n, t, o);
    })({
      field: a,
      timeUnit: TI(t) ? (null === (u = UL(t.timeUnit)) || void 0 === u ? void 0 : u.unit) : void 0,
      format: n,
      formatType: o.timeFormatType,
      rawTimeFormat: o.timeFormat,
      isUTCScale: HI(t) && (null === (s = t.scale) || void 0 === s ? void 0 : s.type) === cq,
    });
    return e ? { signal: e } : void 0;
  }
  return (
    (n = mI({ type: c, specifiedFormat: n, config: o, normalizeStack: i })),
    TI(t) && gR(t.bin)
      ? { signal: bI(a, JI(t, { expr: r, binSuffix: 'end' }), n, e, o) }
      : n || 'quantitative' === PI(t)
      ? { signal: `${vI(a, n)}` }
      : { signal: `isValid(${a}) ? ${a} : ""+${a}` }
  );
}
function fI(t, n, e) {
  return TI(t)
    ? e
      ? `${JI(t, { expr: n, suffix: 'end' })}-${JI(t, { expr: n, suffix: 'start' })}`
      : JI(t, { expr: n })
    : (function (t) {
        const { datum: n } = t;
        return FL(n) ? _L(n) : `${eT(n)}`;
      })(t);
}
function hI({ fieldOrDatumDef: t, format: n, formatType: e, expr: r, normalizeStack: i, config: o, field: u }) {
  return (
    null != u || (u = fI(t, r, i)),
    'datum.value' !== u && TI(t) && gR(t.bin)
      ? { signal: bI(u, JI(t, { expr: r, binSuffix: 'end' }), n, e, o) }
      : { signal: cI(e, u, n) }
  );
}
function dI(t, n, e, r, i, o) {
  var u;
  if (!aI(r)) {
    if (void 0 === e && void 0 === r && i.customFormatTypes && 'quantitative' === PI(t)) {
      if (i.normalizedNumberFormatType && GI(t) && 'normalize' === t.stack) return;
      if (i.numberFormatType) return;
    }
    if (GI(t) && 'normalize' === t.stack && i.normalizedNumberFormat)
      return mI({ type: 'quantitative', config: i, normalizeStack: !0 });
    if (hU(t)) {
      const n = TI(t) ? (null === (u = UL(t.timeUnit)) || void 0 === u ? void 0 : u.unit) : void 0;
      if (void 0 === n && i.customFormatTypes && i.timeFormatType) return;
      return (function ({ specifiedFormat: t, timeUnit: n, config: e, omitTimeFormatConfig: r }) {
        return t || (n ? { signal: IL(n) } : r ? void 0 : e.timeFormat);
      })({ specifiedFormat: e, timeUnit: n, config: i, omitTimeFormatConfig: o });
    }
    return mI({ type: n, specifiedFormat: e, config: i });
  }
}
function pI(t, n, e) {
  var r;
  return t && (MR(t) || 'number' === t || 'time' === t)
    ? t
    : hU(n) && 'time' !== e && 'utc' !== e
    ? TI(n) && (null === (r = UL(null == n ? void 0 : n.timeUnit)) || void 0 === r ? void 0 : r.utc)
      ? 'utc'
      : 'time'
    : void 0;
}
function mI({ type: t, specifiedFormat: n, config: e, normalizeStack: r }) {
  return Xt(n) ? n : t === rq ? (r ? e.normalizedNumberFormat : e.numberFormat) : void 0;
}
function vI(t, n) {
  return `format(${t}, "${n || ''}")`;
}
function gI(t, n, e, r) {
  var i;
  return aI(e) ? cI(e, t, n) : vI(t, null !== (i = Xt(n) ? n : void 0) && void 0 !== i ? i : r.numberFormat);
}
function bI(t, n, e, r, i) {
  if (void 0 === e && void 0 === r && i.customFormatTypes && i.numberFormatType)
    return bI(t, n, i.numberFormat, i.numberFormatType, i);
  const o = gI(t, e, r, i),
    u = gI(n, e, r, i);
  return `${tq(t, !1)} ? "null" : ${o} + " – " + ${u}`;
}
const yI = 'min',
  wI = {
    x: 1,
    y: 1,
    color: 1,
    fill: 1,
    stroke: 1,
    strokeWidth: 1,
    size: 1,
    shape: 1,
    fillOpacity: 1,
    strokeOpacity: 1,
    opacity: 1,
    text: 1,
  };
function xI(t) {
  return t in wI;
}
function OI(t) {
  return !!(null == t ? void 0 : t.encoding);
}
function kI(t) {
  return t && ('count' === t.op || !!t.field);
}
function AI(t) {
  return t && K(t);
}
function $I(t) {
  return 'row' in t || 'column' in t;
}
function MI(t) {
  return !!t && 'header' in t;
}
function jI(t) {
  return 'facet' in t;
}
var DI = function (t, n) {
  var e = {};
  for (var r in t) Object.prototype.hasOwnProperty.call(t, r) && n.indexOf(r) < 0 && (e[r] = t[r]);
  if (null != t && 'function' == typeof Object.getOwnPropertySymbols) {
    var i = 0;
    for (r = Object.getOwnPropertySymbols(t); i < r.length; i++)
      n.indexOf(r[i]) < 0 && Object.prototype.propertyIsEnumerable.call(t, r[i]) && (e[r[i]] = t[r[i]]);
  }
  return e;
};
function FI(t) {
  const { field: n, timeUnit: e, bin: r, aggregate: i } = t;
  return Object.assign(
    Object.assign(
      Object.assign(Object.assign({}, e ? { timeUnit: e } : {}), r ? { bin: r } : {}),
      i ? { aggregate: i } : {},
    ),
    { field: n },
  );
}
function EI(t) {
  return 'sort' in t;
}
function SI({ fieldDef: t, fieldDef2: n, markDef: e, config: r }) {
  if (II(t) && void 0 !== t.bandPosition) return t.bandPosition;
  if (TI(t)) {
    const { timeUnit: i, bin: o } = t;
    if (i && !n) return Vq(e.type) ? 0 : IR('timeUnitBandPosition', e, r);
    if (gR(o)) return 0.5;
  }
}
function CI({ channel: t, fieldDef: n, fieldDef2: e, markDef: r, config: i, scaleType: o, useVlSizeChannel: u }) {
  var s, a, c;
  const l = RP(t),
    f = qR(u ? 'size' : l, r, i, { vgChannel: l });
  if (void 0 !== f) return f;
  if (TI(n)) {
    const { timeUnit: t, bin: u } = n;
    if (t && !e) return { band: IR('timeUnitBandSize', r, i) };
    if (gR(u) && !Oq(o)) return { band: 1 };
  }
  return Vq(r.type)
    ? o
      ? Oq(o)
        ? (null === (s = i[r.type]) || void 0 === s ? void 0 : s.discreteBandSize) || { band: 1 }
        : null === (a = i[r.type]) || void 0 === a
        ? void 0
        : a.continuousBandSize
      : null === (c = i[r.type]) || void 0 === c
      ? void 0
      : c.discreteBandSize
    : void 0;
}
function NI(t, n, e, r) {
  return (
    !!(gR(t.bin) || (t.timeUnit && UI(t) && 'temporal' === t.type)) &&
    void 0 !== SI({ fieldDef: t, fieldDef2: n, markDef: e, config: r })
  );
}
function BI(t) {
  return t && 'condition' in t;
}
function _I(t) {
  const n = null == t ? void 0 : t.condition;
  return !!n && !K(n) && TI(n);
}
function zI(t) {
  const n = null == t ? void 0 : t.condition;
  return !!n && !K(n) && II(n);
}
function TI(t) {
  return t && (!!t.field || 'count' === t.aggregate);
}
function PI(t) {
  return null == t ? void 0 : t.type;
}
function RI(t) {
  return t && 'datum' in t;
}
function LI(t) {
  return (UI(t) && !QI(t)) || qI(t);
}
function qI(t) {
  return RI(t) && Vt(t.datum);
}
function II(t) {
  return TI(t) || RI(t);
}
function UI(t) {
  return t && ('field' in t || 'count' === t.aggregate) && 'type' in t;
}
function WI(t) {
  return t && 'value' in t && 'value' in t;
}
function HI(t) {
  return t && ('scale' in t || 'sort' in t);
}
function GI(t) {
  return t && ('axis' in t || 'stack' in t || 'impute' in t);
}
function VI(t) {
  return t && 'legend' in t;
}
function YI(t) {
  return t && ('format' in t || 'formatType' in t);
}
function XI(t) {
  return nT(t, ['legend', 'axis', 'header', 'scale']);
}
function JI(t, n = {}) {
  var e, r, i;
  let o = t.field;
  const u = n.prefix;
  let s = n.suffix,
    a = '';
  if (
    (function (t) {
      return 'count' === t.aggregate;
    })(t)
  )
    o = BT('count');
  else {
    let u;
    if (!n.nofn)
      if (
        (function (t) {
          return 'op' in t;
        })(t)
      )
        u = t.op;
      else {
        const { bin: c, aggregate: l, timeUnit: f } = t;
        gR(c)
          ? ((u = vR(c)),
            (s =
              (null !== (e = n.binSuffix) && void 0 !== e ? e : '') +
              (null !== (r = n.suffix) && void 0 !== r ? r : '')))
          : l
          ? lR(l)
            ? ((a = `["${o}"]`), (o = `argmax_${l.argmax}`))
            : cR(l)
            ? ((a = `["${o}"]`), (o = `argmin_${l.argmin}`))
            : (u = String(l))
          : f &&
            ((u = (function (t) {
              const n = UL(t),
                { utc: e } = n,
                r = (function (t, n) {
                  var e = {};
                  for (var r in t) Object.prototype.hasOwnProperty.call(t, r) && n.indexOf(r) < 0 && (e[r] = t[r]);
                  if (null != t && 'function' == typeof Object.getOwnPropertySymbols) {
                    var i = 0;
                    for (r = Object.getOwnPropertySymbols(t); i < r.length; i++)
                      n.indexOf(r[i]) < 0 && Object.prototype.propertyIsEnumerable.call(t, r[i]) && (e[r[i]] = t[r[i]]);
                  }
                  return e;
                })(n, ['utc']);
              return r.unit
                ? (e ? 'utc' : '') +
                    vT(r)
                      .map(t => wT(`${'unit' === t ? '' : `_${t}_`}${r[t]}`))
                      .join('')
                : (e ? 'utc' : '') +
                    'timeunit' +
                    vT(r)
                      .map(t => wT(`_${t}_${r[t]}`))
                      .join('');
            })(f)),
            (s =
              ((!['range', 'mid'].includes(n.binSuffix) && n.binSuffix) || '') +
              (null !== (i = n.suffix) && void 0 !== i ? i : '')));
      }
    u && (o = o ? `${u}_${o}` : u);
  }
  return s && (o = `${o}_${s}`), u && (o = `${u}_${o}`), n.forAs ? FT(o) : n.expr ? $T(o, n.expr) + a : jT(o) + a;
}
function QI(t) {
  switch (t.type) {
    case 'nominal':
    case 'ordinal':
    case 'geojson':
      return !0;
    case 'quantitative':
      return TI(t) && !!t.bin;
    case 'temporal':
      return !1;
  }
  throw new Error(cL(t.type));
}
const ZI = (t, n) => {
  switch (n.fieldTitle) {
    case 'plain':
      return t.field;
    case 'functional':
      return (function (t) {
        const { aggregate: n, bin: e, timeUnit: r, field: i } = t;
        if (lR(n)) return `${i} for argmax(${n.argmax})`;
        if (cR(n)) return `${i} for argmin(${n.argmin})`;
        const o = UL(r),
          u =
            n || (null == o ? void 0 : o.unit) || ((null == o ? void 0 : o.maxbins) && 'timeunit') || (gR(e) && 'bin');
        return u ? `${u.toUpperCase()}(${i})` : i;
      })(t);
    default:
      return (function (t, n) {
        var e;
        const { field: r, bin: i, timeUnit: o, aggregate: u } = t;
        if ('count' === u) return n.countTitle;
        if (gR(i)) return `${r} (binned)`;
        if (o) {
          const t = null === (e = UL(o)) || void 0 === e ? void 0 : e.unit;
          if (t) return `${r} (${LL(t).join('-')})`;
        } else if (u)
          return lR(u) ? `${r} for max ${u.argmax}` : cR(u) ? `${r} for min ${u.argmin}` : `${kT(u)} of ${r}`;
        return r;
      })(t, n);
  }
};
let KI = ZI;
function tU(t) {
  KI = t;
}
function nU(t, n, { allowDisabling: e, includeDefault: r = !0 }) {
  var i, o;
  const u = null === (i = eU(t)) || void 0 === i ? void 0 : i.title;
  if (!TI(t)) return null != u ? u : t.title;
  const s = t,
    a = r ? rU(s, n) : void 0;
  return e ? ST(u, s.title, a) : null !== (o = null != u ? u : s.title) && void 0 !== o ? o : a;
}
function eU(t) {
  return GI(t) && t.axis ? t.axis : VI(t) && t.legend ? t.legend : MI(t) && t.header ? t.header : void 0;
}
function rU(t, n) {
  return KI(t, n);
}
function iU(t) {
  var n;
  if (YI(t)) {
    const { format: n, formatType: e } = t;
    return { format: n, formatType: e };
  }
  {
    const e = null !== (n = eU(t)) && void 0 !== n ? n : {},
      { format: r, formatType: i } = e;
    return { format: r, formatType: i };
  }
}
function oU(t) {
  return TI(t) ? t : _I(t) ? t.condition : void 0;
}
function uU(t) {
  return II(t) ? t : zI(t) ? t.condition : void 0;
}
function sU(t, n, e, r = {}) {
  return Xt(t) || Vt(t) || Wt(t)
    ? (DL(
        (function (t, n, e) {
          return `Channel ${t} is a ${n}. Converted to {value: ${eT(e)}}.`;
        })(n, Xt(t) ? 'string' : Vt(t) ? 'number' : 'boolean', t),
      ),
      { value: t })
    : II(t)
    ? aU(t, n, e, r)
    : zI(t)
    ? Object.assign(Object.assign({}, t), { condition: aU(t.condition, n, e, r) })
    : t;
}
function aU(t, n, e, r) {
  if (YI(t)) {
    const { formatType: i } = t,
      o = DI(t, ['format', 'formatType']);
    if (aI(i) && !e.customFormatTypes) return DL(uL(n)), aU(o, n, e, r);
  } else {
    const i = GI(t) ? 'axis' : VI(t) ? 'legend' : MI(t) ? 'header' : null;
    if (i && t[i]) {
      const o = t[i],
        { formatType: u } = o,
        s = DI(o, ['format', 'formatType']);
      if (aI(u) && !e.customFormatTypes) return DL(uL(n)), aU(Object.assign(Object.assign({}, t), { [i]: s }), n, e, r);
    }
  }
  return TI(t)
    ? cU(t, n, r)
    : (function (t) {
        let n = t.type;
        if (n) return t;
        const { datum: e } = t;
        return (
          (n = Vt(e) ? 'quantitative' : Xt(e) ? 'nominal' : FL(e) ? 'temporal' : void 0),
          Object.assign(Object.assign({}, t), { type: n })
        );
      })(t);
}
function cU(t, n, { compositeMark: e = !1 } = {}) {
  const { aggregate: r, timeUnit: i, bin: o, field: u } = t,
    s = Object.assign({}, t);
  if (
    (e ||
      !r ||
      fR(r) ||
      lR(r) ||
      cR(r) ||
      (DL(
        (function (t) {
          return `Invalid aggregation operator "${t}".`;
        })(r),
      ),
      delete s.aggregate),
    i && (s.timeUnit = UL(i)),
    u && (s.field = `${u}`),
    gR(o) && (s.bin = lU(o, n)),
    bR(o) &&
      !VP(n) &&
      DL(
        (function (t) {
          return `Channel ${t} should not be used with "binned" bin.`;
        })(n),
      ),
    UI(s))
  ) {
    const { type: t } = s,
      n = (function (t) {
        if (t)
          switch ((t = t.toLowerCase())) {
            case 'q':
            case rq:
              return 'quantitative';
            case 't':
            case oq:
              return 'temporal';
            case 'o':
            case iq:
              return 'ordinal';
            case 'n':
            case uq:
              return 'nominal';
            case sq:
              return 'geojson';
          }
      })(t);
    t !== n && (s.type = n),
      'quantitative' !== t &&
        dR(r) &&
        (DL(
          (function (t, n) {
            return `Invalid field type "${t}" for aggregate: "${n}", using "quantitative" instead.`;
          })(t, r),
        ),
        (s.type = 'quantitative'));
  } else if (!_P(n)) {
    const t = (function (t, n) {
      var e;
      switch (n) {
        case 'latitude':
        case 'longitude':
          return 'quantitative';
        case 'row':
        case 'column':
        case 'facet':
        case 'shape':
        case 'strokeDash':
          return 'nominal';
        case 'order':
          return 'ordinal';
      }
      if (EI(t) && K(t.sort)) return 'ordinal';
      const { aggregate: r, bin: i, timeUnit: o } = t;
      if (o) return 'temporal';
      if (i || (r && !lR(r) && !cR(r))) return 'quantitative';
      if (HI(t) && (null === (e = t.scale) || void 0 === e ? void 0 : e.type))
        switch (hq[t.scale.type]) {
          case 'numeric':
          case 'discretizing':
            return 'quantitative';
          case 'time':
            return 'temporal';
        }
      return 'nominal';
    })(s, n);
    s.type = t;
  }
  if (UI(s)) {
    const { compatible: t, warning: e } =
      (function (t, n) {
        const e = t.type;
        if ('geojson' === e && 'shape' !== n)
          return { compatible: !1, warning: `Channel ${n} should not be used with a geojson data.` };
        switch (n) {
          case RT:
          case LT:
          case qT:
            return QI(t) ? fU : { compatible: !1, warning: pL(n) };
          case IT:
          case UT:
          case GT:
          case VT:
          case eP:
          case rP:
          case iP:
          case dP:
          case mP:
          case vP:
          case gP:
          case bP:
          case yP:
          case sP:
          case JT:
          case YT:
          case wP:
            return fU;
          case KT:
          case nP:
          case ZT:
          case tP:
            return e !== rq
              ? {
                  compatible: !1,
                  warning: `Channel ${n} should be used with a quantitative field only, not ${t.type} field.`,
                }
              : fU;
          case aP:
          case cP:
          case lP:
          case fP:
          case uP:
          case QT:
          case XT:
          case WT:
          case HT:
            return 'nominal' !== e || t.sort
              ? fU
              : { compatible: !1, warning: `Channel ${n} should not be used with an unsorted discrete field.` };
          case oP:
          case hP:
            return QI(t) ||
              (function (t) {
                var n;
                return HI(t) && $q(null === (n = t.scale) || void 0 === n ? void 0 : n.type);
              })(t)
              ? fU
              : { compatible: !1, warning: mL(n) };
          case pP:
            return 'nominal' !== t.type || 'sort' in t
              ? fU
              : {
                  compatible: !1,
                  warning: 'Channel order is inappropriate for nominal field, which has no inherent order.',
                };
        }
      })(s, n) || {};
    !1 === t && DL(e);
  }
  if (EI(s) && Xt(s.sort)) {
    const { sort: t } = s;
    if (xI(t)) return Object.assign(Object.assign({}, s), { sort: { encoding: t } });
    const n = t.substr(1);
    if ('-' === t.charAt(0) && xI(n))
      return Object.assign(Object.assign({}, s), { sort: { encoding: n, order: 'descending' } });
  }
  if (MI(s)) {
    const { header: t } = s;
    if (t) {
      const { orient: n } = t,
        e = DI(t, ['orient']);
      if (n)
        return Object.assign(Object.assign({}, s), {
          header: Object.assign(Object.assign({}, e), {
            labelOrient: t.labelOrient || n,
            titleOrient: t.titleOrient || n,
          }),
        });
    }
  }
  return s;
}
function lU(t, n) {
  return Wt(t)
    ? { maxbins: xR(n) }
    : 'binned' === t
    ? { binned: !0 }
    : t.maxbins || t.step
    ? t
    : Object.assign(Object.assign({}, t), { maxbins: xR(n) });
}
const fU = { compatible: !0 };
function hU(t) {
  const { formatType: n } = iU(t);
  return (
    'time' === n ||
    (!n &&
      (function (t) {
        return t && ('temporal' === t.type || (TI(t) && !!t.timeUnit));
      })(t))
  );
}
function dU(t, { timeUnit: n, type: e, wrapTime: r, undefinedIfExprNotRequired: i }) {
  var o;
  const u = n && (null === (o = UL(n)) || void 0 === o ? void 0 : o.unit);
  let s,
    a = u || 'temporal' === e;
  return (
    OR(t)
      ? (s = t.expr)
      : MR(t)
      ? (s = t.signal)
      : FL(t)
      ? ((a = !0), (s = _L(t)))
      : (Xt(t) || Vt(t)) &&
        a &&
        ((s = `datetime(${eT(t)})`),
        (function (t) {
          return !!zL[t];
        })(u) &&
          ((Vt(t) && t < 1e4) || (Xt(t) && isNaN(Date.parse(t)))) &&
          (s = _L({ [u]: t }))),
    s ? (r && a ? `time(${s})` : s) : i ? void 0 : eT(t)
  );
}
function pU(t, n) {
  const { type: e } = t;
  return n.map(n => {
    const r = dU(n, { timeUnit: TI(t) ? t.timeUnit : void 0, type: e, undefinedIfExprNotRequired: !0 });
    return void 0 !== r ? { signal: r } : n;
  });
}
function mU(t, n) {
  return gR(t.bin)
    ? rR(n) && ['ordinal', 'nominal'].includes(t.type)
    : (console.warn('Only call this method for binned field defs.'), !1);
}
const vU = {
  labelAlign: { part: 'labels', vgProp: 'align' },
  labelBaseline: { part: 'labels', vgProp: 'baseline' },
  labelColor: { part: 'labels', vgProp: 'fill' },
  labelFont: { part: 'labels', vgProp: 'font' },
  labelFontSize: { part: 'labels', vgProp: 'fontSize' },
  labelFontStyle: { part: 'labels', vgProp: 'fontStyle' },
  labelFontWeight: { part: 'labels', vgProp: 'fontWeight' },
  labelOpacity: { part: 'labels', vgProp: 'opacity' },
  labelOffset: null,
  labelPadding: null,
  gridColor: { part: 'grid', vgProp: 'stroke' },
  gridDash: { part: 'grid', vgProp: 'strokeDash' },
  gridDashOffset: { part: 'grid', vgProp: 'strokeDashOffset' },
  gridOpacity: { part: 'grid', vgProp: 'opacity' },
  gridWidth: { part: 'grid', vgProp: 'strokeWidth' },
  tickColor: { part: 'ticks', vgProp: 'stroke' },
  tickDash: { part: 'ticks', vgProp: 'strokeDash' },
  tickDashOffset: { part: 'ticks', vgProp: 'strokeDashOffset' },
  tickOpacity: { part: 'ticks', vgProp: 'opacity' },
  tickSize: null,
  tickWidth: { part: 'ticks', vgProp: 'strokeWidth' },
};
function gU(t) {
  return null == t ? void 0 : t.condition;
}
const bU = ['domain', 'grid', 'labels', 'ticks', 'title'],
  yU = {
    grid: 'grid',
    gridCap: 'grid',
    gridColor: 'grid',
    gridDash: 'grid',
    gridDashOffset: 'grid',
    gridOpacity: 'grid',
    gridScale: 'grid',
    gridWidth: 'grid',
    orient: 'main',
    bandPosition: 'both',
    aria: 'main',
    description: 'main',
    domain: 'main',
    domainCap: 'main',
    domainColor: 'main',
    domainDash: 'main',
    domainDashOffset: 'main',
    domainOpacity: 'main',
    domainWidth: 'main',
    format: 'main',
    formatType: 'main',
    labelAlign: 'main',
    labelAngle: 'main',
    labelBaseline: 'main',
    labelBound: 'main',
    labelColor: 'main',
    labelFlush: 'main',
    labelFlushOffset: 'main',
    labelFont: 'main',
    labelFontSize: 'main',
    labelFontStyle: 'main',
    labelFontWeight: 'main',
    labelLimit: 'main',
    labelLineHeight: 'main',
    labelOffset: 'main',
    labelOpacity: 'main',
    labelOverlap: 'main',
    labelPadding: 'main',
    labels: 'main',
    labelSeparation: 'main',
    maxExtent: 'main',
    minExtent: 'main',
    offset: 'both',
    position: 'main',
    tickCap: 'main',
    tickColor: 'main',
    tickDash: 'main',
    tickDashOffset: 'main',
    tickMinStep: 'both',
    tickOffset: 'both',
    tickOpacity: 'main',
    tickRound: 'both',
    ticks: 'main',
    tickSize: 'main',
    tickWidth: 'both',
    title: 'main',
    titleAlign: 'main',
    titleAnchor: 'main',
    titleAngle: 'main',
    titleBaseline: 'main',
    titleColor: 'main',
    titleFont: 'main',
    titleFontSize: 'main',
    titleFontStyle: 'main',
    titleFontWeight: 'main',
    titleLimit: 'main',
    titleLineHeight: 'main',
    titleOpacity: 'main',
    titlePadding: 'main',
    titleX: 'main',
    titleY: 'main',
    encode: 'both',
    scale: 'both',
    tickBand: 'both',
    tickCount: 'both',
    tickExtra: 'both',
    translate: 'both',
    values: 'both',
    zindex: 'both',
  },
  wU = {
    orient: 1,
    aria: 1,
    bandPosition: 1,
    description: 1,
    domain: 1,
    domainCap: 1,
    domainColor: 1,
    domainDash: 1,
    domainDashOffset: 1,
    domainOpacity: 1,
    domainWidth: 1,
    format: 1,
    formatType: 1,
    grid: 1,
    gridCap: 1,
    gridColor: 1,
    gridDash: 1,
    gridDashOffset: 1,
    gridOpacity: 1,
    gridWidth: 1,
    labelAlign: 1,
    labelAngle: 1,
    labelBaseline: 1,
    labelBound: 1,
    labelColor: 1,
    labelFlush: 1,
    labelFlushOffset: 1,
    labelFont: 1,
    labelFontSize: 1,
    labelFontStyle: 1,
    labelFontWeight: 1,
    labelLimit: 1,
    labelLineHeight: 1,
    labelOffset: 1,
    labelOpacity: 1,
    labelOverlap: 1,
    labelPadding: 1,
    labels: 1,
    labelSeparation: 1,
    maxExtent: 1,
    minExtent: 1,
    offset: 1,
    position: 1,
    tickBand: 1,
    tickCap: 1,
    tickColor: 1,
    tickCount: 1,
    tickDash: 1,
    tickDashOffset: 1,
    tickExtra: 1,
    tickMinStep: 1,
    tickOffset: 1,
    tickOpacity: 1,
    tickRound: 1,
    ticks: 1,
    tickSize: 1,
    tickWidth: 1,
    title: 1,
    titleAlign: 1,
    titleAnchor: 1,
    titleAngle: 1,
    titleBaseline: 1,
    titleColor: 1,
    titleFont: 1,
    titleFontSize: 1,
    titleFontStyle: 1,
    titleFontWeight: 1,
    titleLimit: 1,
    titleLineHeight: 1,
    titleOpacity: 1,
    titlePadding: 1,
    titleX: 1,
    titleY: 1,
    translate: 1,
    values: 1,
    zindex: 1,
  },
  xU = Object.assign(Object.assign({}, wU), { style: 1, labelExpr: 1, encoding: 1 });
function OU(t) {
  return !!xU[t];
}
const kU = vT({
  axis: 1,
  axisBand: 1,
  axisBottom: 1,
  axisDiscrete: 1,
  axisLeft: 1,
  axisPoint: 1,
  axisQuantitative: 1,
  axisRight: 1,
  axisTemporal: 1,
  axisTop: 1,
  axisX: 1,
  axisXBand: 1,
  axisXDiscrete: 1,
  axisXPoint: 1,
  axisXQuantitative: 1,
  axisXTemporal: 1,
  axisY: 1,
  axisYBand: 1,
  axisYDiscrete: 1,
  axisYPoint: 1,
  axisYQuantitative: 1,
  axisYTemporal: 1,
});
function AU(t) {
  return 'mark' in t;
}
class $U {
  constructor(t, n) {
    (this.name = t), (this.run = n);
  }
  hasMatchingType(t) {
    return (
      !!AU(t) &&
      (function (t) {
        return Xq(t) ? t.type : t;
      })(t.mark) === this.name
    );
  }
}
function MU(t, n) {
  const e = t && t[n];
  return !!e && (K(e) ? uT(e, t => !!t.field) : TI(e) || _I(e));
}
function jU(t, n) {
  const e = t && t[n];
  return !!e && (K(e) ? uT(e, t => !!t.field) : TI(e) || RI(e) || zI(e));
}
function DU(t, n) {
  if (VP(n)) {
    const e = t[n];
    if ((TI(e) || RI(e)) && eq(e.type)) return jU(t, LP(n));
  }
  return !1;
}
function FU(t) {
  return uT(EP, n => {
    if (MU(t, n)) {
      const e = t[n];
      if (K(e)) return uT(e, t => !!t.aggregate);
      {
        const t = oU(e);
        return t && !!t.aggregate;
      }
    }
    return !1;
  });
}
function EU(t, n) {
  const e = [],
    r = [],
    i = [],
    o = [],
    u = {};
  return (
    NU(t, (s, a) => {
      if (TI(s)) {
        const { field: c, aggregate: l, bin: f, timeUnit: h } = s,
          d = (function (t, n) {
            var e = {};
            for (var r in t) Object.prototype.hasOwnProperty.call(t, r) && n.indexOf(r) < 0 && (e[r] = t[r]);
            if (null != t && 'function' == typeof Object.getOwnPropertySymbols) {
              var i = 0;
              for (r = Object.getOwnPropertySymbols(t); i < r.length; i++)
                n.indexOf(r[i]) < 0 && Object.prototype.propertyIsEnumerable.call(t, r[i]) && (e[r[i]] = t[r[i]]);
            }
            return e;
          })(s, ['field', 'aggregate', 'bin', 'timeUnit']);
        if (l || h || f) {
          const t = eU(s),
            p = null == t ? void 0 : t.title;
          let m = JI(s, { forAs: !0 });
          const v = Object.assign(
            Object.assign(Object.assign({}, p ? [] : { title: nU(s, n, { allowDisabling: !0 }) }), d),
            { field: m },
          );
          if (l) {
            let t;
            if (
              (lR(l)
                ? ((t = 'argmax'), (m = JI({ op: 'argmax', field: l.argmax }, { forAs: !0 })), (v.field = `${m}.${c}`))
                : cR(l)
                ? ((t = 'argmin'), (m = JI({ op: 'argmin', field: l.argmin }, { forAs: !0 })), (v.field = `${m}.${c}`))
                : 'boxplot' !== l && 'errorbar' !== l && 'errorband' !== l && (t = l),
              t)
            ) {
              const n = { op: t, as: m };
              c && (n.field = c), o.push(n);
            }
          } else if ((e.push(m), UI(s) && gR(f)))
            r.push({ bin: f, field: c, as: m }),
              e.push(JI(s, { binSuffix: 'end' })),
              mU(s, a) && e.push(JI(s, { binSuffix: 'range' })),
              VP(a) && (u[`${a}2`] = { field: `${m}_end` }),
              (v.bin = 'binned'),
              _P(a) || (v.type = rq);
          else if (h) {
            i.push({ timeUnit: h, field: c, as: m });
            const t = UI(s) && s.type !== oq && 'time';
            t &&
              (a === dP || a === gP
                ? (v.formatType = t)
                : (function (t) {
                    return !!UP[t];
                  })(a)
                ? (v.legend = Object.assign({ formatType: t }, v.legend))
                : VP(a) && (v.axis = Object.assign({ formatType: t }, v.axis)));
          }
          u[a] = v;
        } else e.push(c), (u[a] = t[a]);
      } else u[a] = t[a];
    }),
    { bins: r, timeUnits: i, aggregate: o, groupby: e, encoding: u }
  );
}
function SU(t, n, e) {
  const r = (function (t, n) {
    return (function (t) {
      switch (t) {
        case eP:
        case rP:
        case iP:
        case wP:
        case mP:
        case vP:
        case gP:
        case bP:
        case pP:
        case aP:
        case cP:
        case lP:
        case fP:
        case qT:
        case RT:
        case LT:
          return iR;
        case IT:
        case UT:
        case GT:
        case VT:
        case ZT:
        case KT:
          return oR;
        case WT:
        case HT:
        case tP:
        case nP:
          return {
            area: 'always',
            bar: 'always',
            image: 'always',
            rect: 'always',
            rule: 'always',
            circle: 'binned',
            point: 'binned',
            square: 'binned',
            tick: 'binned',
            line: 'binned',
            trail: 'binned',
          };
        case uP:
          return {
            point: 'always',
            tick: 'always',
            rule: 'always',
            circle: 'always',
            square: 'always',
            bar: 'always',
            text: 'always',
            line: 'always',
            trail: 'always',
          };
        case hP:
          return {
            line: 'always',
            point: 'always',
            tick: 'always',
            rule: 'always',
            circle: 'always',
            square: 'always',
            bar: 'always',
            geoshape: 'always',
          };
        case oP:
          return { point: 'always', geoshape: 'always' };
        case dP:
          return { text: 'always' };
        case sP:
          return { point: 'always', square: 'always', text: 'always' };
        case yP:
          return { image: 'always' };
        case JT:
        case YT:
          return { text: 'always', arc: 'always' };
        case QT:
        case XT:
          return { arc: 'always' };
      }
    })(t)[n];
  })(n, e);
  if (!r) return !1;
  if ('binned' === r) {
    const e = t[n === WT ? IT : UT];
    return !!(TI(e) && TI(t[n]) && bR(e.bin));
  }
  return !0;
}
function CU(t, n) {
  const e = {};
  for (const r of vT(t)) {
    const i = sU(t[r], r, n, { compositeMark: !0 });
    e[r] = i;
  }
  return e;
}
function NU(t, n, e) {
  if (t)
    for (const r of vT(t)) {
      const i = t[r];
      if (K(i)) for (const t of i) n.call(e, t, r);
      else n.call(e, i, r);
    }
}
function BU(t, n) {
  return vT(n).reduce((e, r) => {
    switch (r) {
      case IT:
      case UT:
      case bP:
      case wP:
      case yP:
      case WT:
      case HT:
      case GT:
      case VT:
      case JT:
      case QT:
      case YT:
      case XT:
      case ZT:
      case KT:
      case tP:
      case nP:
      case dP:
      case oP:
      case sP:
      case gP:
        return e;
      case pP:
        if ('line' === t || 'trail' === t) return e;
      case mP:
      case vP: {
        const t = n[r];
        if (K(t) || TI(t)) for (const n of At(t)) n.aggregate || e.push(JI(n, {}));
        return e;
      }
      case uP:
        if ('trail' === t) return e;
      case eP:
      case rP:
      case iP:
      case aP:
      case cP:
      case lP:
      case hP:
      case fP: {
        const t = oU(n[r]);
        return t && !t.aggregate && e.push(JI(t, {})), e;
      }
    }
  }, []);
}
var _U = function (t, n) {
  var e = {};
  for (var r in t) Object.prototype.hasOwnProperty.call(t, r) && n.indexOf(r) < 0 && (e[r] = t[r]);
  if (null != t && 'function' == typeof Object.getOwnPropertySymbols) {
    var i = 0;
    for (r = Object.getOwnPropertySymbols(t); i < r.length; i++)
      n.indexOf(r[i]) < 0 && Object.prototype.propertyIsEnumerable.call(t, r[i]) && (e[r[i]] = t[r[i]]);
  }
  return e;
};
function zU(t, n, e, r = !0) {
  if ('tooltip' in e) return { tooltip: e.tooltip };
  const i = t.map(({ fieldPrefix: t, titlePrefix: e }) => {
      const i = r ? ` of ${TU(n)}` : '';
      return { field: t + n.field, type: n.type, title: MR(e) ? { signal: `${e}"${escape(i)}"` } : e + i };
    }),
    o = (function (t) {
      const n = [];
      for (const e of vT(t))
        if (MU(t, e)) {
          const r = At(t[e]);
          for (const t of r) TI(t) ? n.push(t) : _I(t) && n.push(t.condition);
        }
      return n;
    })(e).map(XI);
  return { tooltip: [...i, ...lT(o, rT)] };
}
function TU(t) {
  const { title: n, field: e } = t;
  return ST(n, e);
}
function PU(t, n, e, r, i) {
  const { scale: o, axis: u } = e;
  return ({ partName: s, mark: a, positionPrefix: c, endPositionPrefix: l, extraEncoding: f = {} }) => {
    const h = TU(e);
    return RU(t, s, i, {
      mark: a,
      encoding: Object.assign(
        Object.assign(
          Object.assign(
            {
              [n]: Object.assign(
                Object.assign(
                  Object.assign({ field: `${c}_${e.field}`, type: e.type }, void 0 !== h ? { title: h } : {}),
                  void 0 !== o ? { scale: o } : {},
                ),
                void 0 !== u ? { axis: u } : {},
              ),
            },
            Xt(l) ? { [`${n}2`]: { field: `${l}_${e.field}` } } : {},
          ),
          r,
        ),
        f,
      ),
    });
  };
}
function RU(t, n, e, r) {
  const { clip: i, color: o, opacity: u } = t,
    s = t.type;
  return t[n] || (void 0 === t[n] && e[n])
    ? [
        Object.assign(Object.assign({}, r), {
          mark: Object.assign(
            Object.assign(
              Object.assign(
                Object.assign(
                  Object.assign(Object.assign(Object.assign({}, e[n]), i ? { clip: i } : {}), o ? { color: o } : {}),
                  u ? { opacity: u } : {},
                ),
                Xq(r.mark) ? r.mark : { type: r.mark },
              ),
              { style: `${s}-${String(n)}` },
            ),
            Wt(t[n]) ? {} : t[n],
          ),
        }),
      ]
    : [];
}
function LU(t, n, e) {
  const { encoding: r } = t,
    i = 'vertical' === n ? 'y' : 'x',
    o = r[`${i}2`],
    u = r[`${i}Error`],
    s = r[`${i}Error2`];
  return {
    continuousAxisChannelDef: qU(r[i], e),
    continuousAxisChannelDef2: qU(o, e),
    continuousAxisChannelDefError: qU(u, e),
    continuousAxisChannelDefError2: qU(s, e),
    continuousAxis: i,
  };
}
function qU(t, n) {
  if (null == t ? void 0 : t.aggregate) {
    const { aggregate: e } = t,
      r = _U(t, ['aggregate']);
    return (
      e !== n &&
        DL(
          (function (t, n) {
            return `Continuous axis should not have customized aggregation function ${t}; ${n} already agregates the axis.`;
          })(e, n),
        ),
      r
    );
  }
  return t;
}
function IU(t, n) {
  const { mark: e, encoding: r } = t,
    { x: i, y: o } = r;
  if (Xq(e) && e.orient) return e.orient;
  if (LI(i)) {
    if (LI(o)) {
      const t = TI(i) && i.aggregate,
        e = TI(o) && o.aggregate;
      if (t || e !== n) {
        if (e || t !== n) {
          if (t === n && e === n) throw new Error('Both x and y cannot have aggregate');
          return hU(o) && !hU(i) ? 'horizontal' : 'vertical';
        }
        return 'horizontal';
      }
      return 'vertical';
    }
    return 'horizontal';
  }
  if (LI(o)) return 'vertical';
  throw new Error(`Need a valid continuous axis for ${n}s`);
}
var UU = function (t, n) {
  var e = {};
  for (var r in t) Object.prototype.hasOwnProperty.call(t, r) && n.indexOf(r) < 0 && (e[r] = t[r]);
  if (null != t && 'function' == typeof Object.getOwnPropertySymbols) {
    var i = 0;
    for (r = Object.getOwnPropertySymbols(t); i < r.length; i++)
      n.indexOf(r[i]) < 0 && Object.prototype.propertyIsEnumerable.call(t, r[i]) && (e[r[i]] = t[r[i]]);
  }
  return e;
};
const WU = 'boxplot',
  HU = new $U(WU, VU);
function GU(t) {
  return Vt(t) ? 'tukey' : t;
}
function VU(t, { config: n }) {
  var e, r;
  t = Object.assign(Object.assign({}, t), { encoding: CU(t.encoding, n) });
  const { mark: i, params: o } = t,
    u = UU(t, ['mark', 'encoding', 'params', 'projection']),
    s = Xq(i) ? i : { type: i };
  o && DL(eL('boxplot'));
  const a = null !== (e = s.extent) && void 0 !== e ? e : n.boxplot.extent,
    c = qR('size', s, n),
    l = GU(a),
    {
      bins: f,
      timeUnits: h,
      transform: d,
      continuousAxisChannelDef: p,
      continuousAxis: m,
      groupby: v,
      aggregate: g,
      encodingWithoutContinuousAxis: b,
      ticksOrient: y,
      boxOrient: w,
      customTooltipWithoutAggregatedField: x,
    } = (function (t, n, e) {
      const r = IU(t, WU),
        { continuousAxisChannelDef: i, continuousAxis: o } = LU(t, r, WU),
        u = i.field,
        s = GU(n),
        a = [
          ...YU(u),
          { op: 'median', field: u, as: `mid_box_${u}` },
          { op: 'min', field: u, as: ('min-max' === s ? 'lower_whisker_' : 'min_') + u },
          { op: 'max', field: u, as: ('min-max' === s ? 'upper_whisker_' : 'max_') + u },
        ],
        c =
          'min-max' === s || 'tukey' === s
            ? []
            : [
                { calculate: `datum["upper_box_${u}"] - datum["lower_box_${u}"]`, as: `iqr_${u}` },
                {
                  calculate: `min(datum["upper_box_${u}"] + datum["iqr_${u}"] * ${n}, datum["max_${u}"])`,
                  as: `upper_whisker_${u}`,
                },
                {
                  calculate: `max(datum["lower_box_${u}"] - datum["iqr_${u}"] * ${n}, datum["min_${u}"])`,
                  as: `lower_whisker_${u}`,
                },
              ],
        l = UU(t.encoding, ['symbol' == typeof o ? o : o + '']),
        { customTooltipWithoutAggregatedField: f, filteredEncoding: h } = (function (t) {
          const { tooltip: n } = t,
            e = _U(t, ['tooltip']);
          if (!n) return { filteredEncoding: e };
          let r, i;
          if (K(n)) {
            for (const t of n) t.aggregate ? (r || (r = []), r.push(t)) : (i || (i = []), i.push(t));
            r && (e.tooltip = r);
          } else n.aggregate ? (e.tooltip = n) : (i = n);
          return K(i) && 1 === i.length && (i = i[0]), { customTooltipWithoutAggregatedField: i, filteredEncoding: e };
        })(l),
        { bins: d, timeUnits: p, aggregate: m, groupby: v, encoding: g } = EU(h, e),
        b = 'vertical' === r ? 'horizontal' : 'vertical',
        y = r;
      return {
        bins: d,
        timeUnits: p,
        transform: [...d, ...p, { aggregate: [...m, ...a], groupby: v }, ...c],
        groupby: v,
        aggregate: m,
        continuousAxisChannelDef: i,
        continuousAxis: o,
        encodingWithoutContinuousAxis: g,
        ticksOrient: b,
        boxOrient: y,
        customTooltipWithoutAggregatedField: f,
      };
    })(t, a, n),
    { color: O, size: k } = b,
    A = UU(b, ['color', 'size']),
    $ = t => PU(s, m, p, t, n.boxplot),
    M = $(A),
    j = $(b),
    D = $(Object.assign(Object.assign({}, A), k ? { size: k } : {})),
    F = zU(
      [
        { fieldPrefix: 'min-max' === l ? 'upper_whisker_' : 'max_', titlePrefix: 'Max' },
        { fieldPrefix: 'upper_box_', titlePrefix: 'Q3' },
        { fieldPrefix: 'mid_box_', titlePrefix: 'Median' },
        { fieldPrefix: 'lower_box_', titlePrefix: 'Q1' },
        { fieldPrefix: 'min-max' === l ? 'lower_whisker_' : 'min_', titlePrefix: 'Min' },
      ],
      p,
      b,
    ),
    E = { type: 'tick', color: 'black', opacity: 1, orient: y, invalid: null, aria: !1 },
    S =
      'min-max' === l
        ? F
        : zU(
            [
              { fieldPrefix: 'upper_whisker_', titlePrefix: 'Upper Whisker' },
              { fieldPrefix: 'lower_whisker_', titlePrefix: 'Lower Whisker' },
            ],
            p,
            b,
          ),
    C = [
      ...M({
        partName: 'rule',
        mark: { type: 'rule', invalid: null, aria: !1 },
        positionPrefix: 'lower_whisker',
        endPositionPrefix: 'lower_box',
        extraEncoding: S,
      }),
      ...M({
        partName: 'rule',
        mark: { type: 'rule', invalid: null, aria: !1 },
        positionPrefix: 'upper_box',
        endPositionPrefix: 'upper_whisker',
        extraEncoding: S,
      }),
      ...M({ partName: 'ticks', mark: E, positionPrefix: 'lower_whisker', extraEncoding: S }),
      ...M({ partName: 'ticks', mark: E, positionPrefix: 'upper_whisker', extraEncoding: S }),
    ],
    N = [
      ...('tukey' !== l ? C : []),
      ...j({
        partName: 'box',
        mark: Object.assign(Object.assign({ type: 'bar' }, c ? { size: c } : {}), {
          orient: w,
          invalid: null,
          ariaRoleDescription: 'box',
        }),
        positionPrefix: 'lower_box',
        endPositionPrefix: 'upper_box',
        extraEncoding: F,
      }),
      ...D({
        partName: 'median',
        mark: Object.assign(
          Object.assign(
            Object.assign(
              { type: 'tick', invalid: null },
              tt(n.boxplot.median) && n.boxplot.median.color ? { color: n.boxplot.median.color } : {},
            ),
            c ? { size: c } : {},
          ),
          { orient: y, aria: !1 },
        ),
        positionPrefix: 'mid_box',
        extraEncoding: F,
      }),
    ];
  if ('min-max' === l)
    return Object.assign(Object.assign({}, u), {
      transform: (null !== (r = u.transform) && void 0 !== r ? r : []).concat(d),
      layer: N,
    });
  const B = `datum["lower_box_${p.field}"]`,
    _ = `datum["upper_box_${p.field}"]`,
    z = `(${_} - ${B})`,
    T = `${B} - ${a} * ${z}`,
    P = `${_} + ${a} * ${z}`,
    R = `datum["${p.field}"]`,
    L = { joinaggregate: YU(p.field), groupby: v },
    q = {
      transform: [
        { filter: `(${T} <= ${R}) && (${R} <= ${P})` },
        {
          aggregate: [
            { op: 'min', field: p.field, as: `lower_whisker_${p.field}` },
            { op: 'max', field: p.field, as: `upper_whisker_${p.field}` },
            { op: 'min', field: `lower_box_${p.field}`, as: `lower_box_${p.field}` },
            { op: 'max', field: `upper_box_${p.field}`, as: `upper_box_${p.field}` },
            ...g,
          ],
          groupby: v,
        },
      ],
      layer: C,
    },
    I = UU(A, ['tooltip']),
    { scale: U, axis: W } = p,
    H = TU(p),
    G = nT(W, ['title']),
    V = RU(s, 'outliers', n.boxplot, {
      transform: [{ filter: `(${R} < ${T}) || (${R} > ${P})` }],
      mark: 'point',
      encoding: Object.assign(
        Object.assign(
          Object.assign(
            {
              [m]: Object.assign(
                Object.assign(
                  Object.assign({ field: p.field, type: p.type }, void 0 !== H ? { title: H } : {}),
                  void 0 !== U ? { scale: U } : {},
                ),
                mT(G) ? {} : { axis: G },
              ),
            },
            I,
          ),
          O ? { color: O } : {},
        ),
        x ? { tooltip: x } : {},
      ),
    })[0];
  let Y;
  const X = [...f, ...h, L];
  return (
    V ? (Y = { transform: X, layer: [V, q] }) : ((Y = q), Y.transform.unshift(...X)),
    Object.assign(Object.assign({}, u), { layer: [Y, { transform: d, layer: N }] })
  );
}
function YU(t) {
  return [
    { op: 'q1', field: t, as: `lower_box_${t}` },
    { op: 'q3', field: t, as: `upper_box_${t}` },
  ];
}
var XU = function (t, n) {
  var e = {};
  for (var r in t) Object.prototype.hasOwnProperty.call(t, r) && n.indexOf(r) < 0 && (e[r] = t[r]);
  if (null != t && 'function' == typeof Object.getOwnPropertySymbols) {
    var i = 0;
    for (r = Object.getOwnPropertySymbols(t); i < r.length; i++)
      n.indexOf(r[i]) < 0 && Object.prototype.propertyIsEnumerable.call(t, r[i]) && (e[r[i]] = t[r[i]]);
  }
  return e;
};
const JU = 'errorbar',
  QU = new $U(JU, ZU);
function ZU(t, { config: n }) {
  t = Object.assign(Object.assign({}, t), { encoding: CU(t.encoding, n) });
  const {
    transform: e,
    continuousAxisChannelDef: r,
    continuousAxis: i,
    encodingWithoutContinuousAxis: o,
    ticksOrient: u,
    markDef: s,
    outerSpec: a,
    tooltipEncoding: c,
  } = KU(t, JU, n);
  delete o.size;
  const l = PU(s, i, r, o, n.errorbar),
    f = s.thickness,
    h = s.size,
    d = Object.assign(
      Object.assign({ type: 'tick', orient: u, aria: !1 }, void 0 !== f ? { thickness: f } : {}),
      void 0 !== h ? { size: h } : {},
    ),
    p = [
      ...l({ partName: 'ticks', mark: d, positionPrefix: 'lower', extraEncoding: c }),
      ...l({ partName: 'ticks', mark: d, positionPrefix: 'upper', extraEncoding: c }),
      ...l({
        partName: 'rule',
        mark: Object.assign({ type: 'rule', ariaRoleDescription: 'errorbar' }, void 0 !== f ? { size: f } : {}),
        positionPrefix: 'lower',
        endPositionPrefix: 'upper',
        extraEncoding: c,
      }),
    ];
  return Object.assign(
    Object.assign(Object.assign({}, a), { transform: e }),
    p.length > 1 ? { layer: p } : Object.assign({}, p[0]),
  );
}
function KU(t, n, e) {
  var r;
  const { mark: i, encoding: o, params: u } = t,
    s = XU(t, ['mark', 'encoding', 'params', 'projection']),
    a = Xq(i) ? i : { type: i };
  u && DL(eL(n));
  const { orient: c, inputType: l } = (function (t, n) {
      const { encoding: e } = t;
      if (
        (function (t) {
          return (
            (II(t.x) || II(t.y)) &&
            !II(t.x2) &&
            !II(t.y2) &&
            !II(t.xError) &&
            !II(t.xError2) &&
            !II(t.yError) &&
            !II(t.yError2)
          );
        })(e)
      )
        return { orient: IU(t, n), inputType: 'raw' };
      const r = (function (t) {
          return II(t.x2) || II(t.y2);
        })(e),
        i = (function (t) {
          return II(t.xError) || II(t.xError2) || II(t.yError) || II(t.yError2);
        })(e),
        o = e.x,
        u = e.y;
      if (r) {
        if (i) throw new Error(`${n} cannot be both type aggregated-upper-lower and aggregated-error`);
        const t = e.x2,
          r = e.y2;
        if (II(t) && II(r)) throw new Error(`${n} cannot have both x2 and y2`);
        if (II(t)) {
          if (LI(o)) return { orient: 'horizontal', inputType: 'aggregated-upper-lower' };
          throw new Error(`Both x and x2 have to be quantitative in ${n}`);
        }
        if (II(r)) {
          if (LI(u)) return { orient: 'vertical', inputType: 'aggregated-upper-lower' };
          throw new Error(`Both y and y2 have to be quantitative in ${n}`);
        }
        throw new Error('No ranged axis');
      }
      {
        const t = e.xError,
          r = e.yError,
          i = e.yError2;
        if (II(e.xError2) && !II(t)) throw new Error(`${n} cannot have xError2 without xError`);
        if (II(i) && !II(r)) throw new Error(`${n} cannot have yError2 without yError`);
        if (II(t) && II(r)) throw new Error(`${n} cannot have both xError and yError with both are quantiative`);
        if (II(t)) {
          if (LI(o)) return { orient: 'horizontal', inputType: 'aggregated-error' };
          throw new Error('All x, xError, and xError2 (if exist) have to be quantitative');
        }
        if (II(r)) {
          if (LI(u)) return { orient: 'vertical', inputType: 'aggregated-error' };
          throw new Error('All y, yError, and yError2 (if exist) have to be quantitative');
        }
        throw new Error('No ranged axis');
      }
    })(t, n),
    {
      continuousAxisChannelDef: f,
      continuousAxisChannelDef2: h,
      continuousAxisChannelDefError: d,
      continuousAxisChannelDefError2: p,
      continuousAxis: m,
    } = LU(t, c, n),
    {
      errorBarSpecificAggregate: v,
      postAggregateCalculates: g,
      tooltipSummary: b,
      tooltipTitleWithFieldName: y,
    } = (function (t, n, e, r, i, o, u, s) {
      let a = [],
        c = [];
      const l = n.field;
      let f,
        h = !1;
      if ('raw' === o) {
        const n = t.center ? t.center : t.extent ? ('iqr' === t.extent ? 'median' : 'mean') : s.errorbar.center,
          e = t.extent ? t.extent : 'mean' === n ? 'stderr' : 'iqr';
        if (
          (('median' === n) != ('iqr' === e) &&
            DL(
              (function (t, n, e) {
                return `${t} is not usually used with ${n} for ${e}.`;
              })(n, e, u),
            ),
          'stderr' === e || 'stdev' === e)
        )
          (a = [
            { op: e, field: l, as: `extent_${l}` },
            { op: n, field: l, as: `center_${l}` },
          ]),
            (c = [
              { calculate: `datum["center_${l}"] + datum["extent_${l}"]`, as: `upper_${l}` },
              { calculate: `datum["center_${l}"] - datum["extent_${l}"]`, as: `lower_${l}` },
            ]),
            (f = [
              { fieldPrefix: 'center_', titlePrefix: kT(n) },
              { fieldPrefix: 'upper_', titlePrefix: tW(n, e, '+') },
              { fieldPrefix: 'lower_', titlePrefix: tW(n, e, '-') },
            ]),
            (h = !0);
        else {
          let t, n, r;
          'ci' === e ? ((t = 'mean'), (n = 'ci0'), (r = 'ci1')) : ((t = 'median'), (n = 'q1'), (r = 'q3')),
            (a = [
              { op: n, field: l, as: `lower_${l}` },
              { op: r, field: l, as: `upper_${l}` },
              { op: t, field: l, as: `center_${l}` },
            ]),
            (f = [
              {
                fieldPrefix: 'upper_',
                titlePrefix: nU({ field: l, aggregate: r, type: 'quantitative' }, s, { allowDisabling: !1 }),
              },
              {
                fieldPrefix: 'lower_',
                titlePrefix: nU({ field: l, aggregate: n, type: 'quantitative' }, s, { allowDisabling: !1 }),
              },
              {
                fieldPrefix: 'center_',
                titlePrefix: nU({ field: l, aggregate: t, type: 'quantitative' }, s, { allowDisabling: !1 }),
              },
            ]);
        }
      } else {
        (t.center || t.extent) &&
          DL(
            (function (t, n) {
              return `${n ? 'extent ' : ''}${n && t ? 'and ' : ''}${t ? 'center ' : ''}${
                n && t ? 'are ' : 'is '
              }not needed when data are aggregated.`;
            })(t.center, t.extent),
          ),
          'aggregated-upper-lower' === o
            ? ((f = []),
              (c = [
                { calculate: `datum["${e.field}"]`, as: `upper_${l}` },
                { calculate: `datum["${l}"]`, as: `lower_${l}` },
              ]))
            : 'aggregated-error' === o &&
              ((f = [{ fieldPrefix: '', titlePrefix: l }]),
              (c = [{ calculate: `datum["${l}"] + datum["${r.field}"]`, as: `upper_${l}` }]),
              c.push(
                i
                  ? { calculate: `datum["${l}"] + datum["${i.field}"]`, as: `lower_${l}` }
                  : { calculate: `datum["${l}"] - datum["${r.field}"]`, as: `lower_${l}` },
              ));
        for (const t of c)
          f.push({ fieldPrefix: t.as.substring(0, 6), titlePrefix: DT(DT(t.calculate, 'datum["', ''), '"]', '') });
      }
      return {
        postAggregateCalculates: c,
        errorBarSpecificAggregate: a,
        tooltipSummary: f,
        tooltipTitleWithFieldName: h,
      };
    })(a, f, h, d, p, l, n, e),
    w = 'x' === m ? 'x2' : 'y2',
    x = 'x' === m ? 'xError' : 'yError',
    O = 'x' === m ? 'xError2' : 'yError2',
    k = XU(o, [
      'symbol' == typeof m ? m : m + '',
      'symbol' == typeof w ? w : w + '',
      'symbol' == typeof x ? x : x + '',
      'symbol' == typeof O ? O : O + '',
    ]),
    { bins: A, timeUnits: $, aggregate: M, groupby: j, encoding: D } = EU(k, e),
    F = [...M, ...v],
    E = 'raw' !== l ? [] : j,
    S = zU(b, f, D, y);
  return {
    transform: [
      ...(null !== (r = s.transform) && void 0 !== r ? r : []),
      ...A,
      ...$,
      ...(0 === F.length ? [] : [{ aggregate: F, groupby: E }]),
      ...g,
    ],
    groupby: E,
    continuousAxisChannelDef: f,
    continuousAxis: m,
    encodingWithoutContinuousAxis: D,
    ticksOrient: 'vertical' === c ? 'horizontal' : 'vertical',
    markDef: a,
    outerSpec: s,
    tooltipEncoding: S,
  };
}
function tW(t, n, e) {
  return `${kT(t)} ${e} ${n}`;
}
const nW = 'errorband',
  eW = new $U(nW, rW);
function rW(t, { config: n }) {
  t = Object.assign(Object.assign({}, t), { encoding: CU(t.encoding, n) });
  const {
      transform: e,
      continuousAxisChannelDef: r,
      continuousAxis: i,
      encodingWithoutContinuousAxis: o,
      markDef: u,
      outerSpec: s,
      tooltipEncoding: a,
    } = KU(t, nW, n),
    c = u,
    l = PU(c, i, r, o, n.errorband),
    f = void 0 !== t.encoding.x && void 0 !== t.encoding.y;
  let h = { type: f ? 'area' : 'rect' },
    d = { type: f ? 'line' : 'rule' };
  const p = Object.assign(
    Object.assign({}, c.interpolate ? { interpolate: c.interpolate } : {}),
    c.tension && c.interpolate ? { tension: c.tension } : {},
  );
  return (
    f
      ? ((h = Object.assign(Object.assign(Object.assign({}, h), p), { ariaRoleDescription: 'errorband' })),
        (d = Object.assign(Object.assign(Object.assign({}, d), p), { aria: !1 })))
      : c.interpolate
      ? DL(AL('interpolate'))
      : c.tension && DL(AL('tension')),
    Object.assign(Object.assign({}, s), {
      transform: e,
      layer: [
        ...l({ partName: 'band', mark: h, positionPrefix: 'lower', endPositionPrefix: 'upper', extraEncoding: a }),
        ...l({ partName: 'borders', mark: d, positionPrefix: 'lower', extraEncoding: a }),
        ...l({ partName: 'borders', mark: d, positionPrefix: 'upper', extraEncoding: a }),
      ],
    })
  );
}
const iW = {};
function oW(t, n, e) {
  const r = new $U(t, n);
  iW[t] = { normalizer: r, parts: e };
}
oW(WU, VU, ['box', 'median', 'outliers', 'rule', 'ticks']),
  oW(JU, ZU, ['ticks', 'rule']),
  oW(nW, rW, ['band', 'borders']);
const uW = [
    'gradientHorizontalMaxLength',
    'gradientHorizontalMinLength',
    'gradientVerticalMaxLength',
    'gradientVerticalMinLength',
    'unselectedOpacity',
  ],
  sW = {
    titleAlign: 'align',
    titleAnchor: 'anchor',
    titleAngle: 'angle',
    titleBaseline: 'baseline',
    titleColor: 'color',
    titleFont: 'font',
    titleFontSize: 'fontSize',
    titleFontStyle: 'fontStyle',
    titleFontWeight: 'fontWeight',
    titleLimit: 'limit',
    titleLineHeight: 'lineHeight',
    titleOrient: 'orient',
    titlePadding: 'offset',
  },
  aW = {
    labelAlign: 'align',
    labelAnchor: 'anchor',
    labelAngle: 'angle',
    labelBaseline: 'baseline',
    labelColor: 'color',
    labelFont: 'font',
    labelFontSize: 'fontSize',
    labelFontStyle: 'fontStyle',
    labelFontWeight: 'fontWeight',
    labelLimit: 'limit',
    labelLineHeight: 'lineHeight',
    labelOrient: 'orient',
    labelPadding: 'offset',
  },
  cW = vT(sW),
  lW = vT(aW),
  fW = vT({ header: 1, headerRow: 1, headerColumn: 1, headerFacet: 1 }),
  hW = ['size', 'shape', 'fill', 'stroke', 'strokeDash', 'strokeWidth', 'opacity'],
  dW = '_vgsid_',
  pW = {
    point: { on: 'click', fields: [dW], toggle: 'event.shiftKey', resolve: 'global', clear: 'dblclick' },
    interval: {
      on: '[mousedown, window:mouseup] > window:mousemove!',
      encodings: ['x', 'y'],
      translate: '[mousedown, window:mouseup] > window:mousemove!',
      zoom: 'wheel!',
      mark: { fill: '#333', fillOpacity: 0.125, stroke: 'white' },
      resolve: 'global',
      clear: 'dblclick',
    },
  };
function mW(t) {
  return 'legend' === t || !!(null == t ? void 0 : t.legend);
}
function vW(t) {
  return mW(t) && tt(t);
}
function gW(t) {
  return !!(null == t ? void 0 : t.select);
}
var bW = function (t, n) {
  var e = {};
  for (var r in t) Object.prototype.hasOwnProperty.call(t, r) && n.indexOf(r) < 0 && (e[r] = t[r]);
  if (null != t && 'function' == typeof Object.getOwnPropertySymbols) {
    var i = 0;
    for (r = Object.getOwnPropertySymbols(t); i < r.length; i++)
      n.indexOf(r[i]) < 0 && Object.prototype.propertyIsEnumerable.call(t, r[i]) && (e[r[i]] = t[r[i]]);
  }
  return e;
};
function yW(t) {
  const n = [];
  for (const e of t || []) {
    if (gW(e)) continue;
    const { expr: t, bind: r } = e,
      i = bW(e, ['expr', 'bind']);
    if (r && t) {
      const e = Object.assign(Object.assign({}, i), { bind: r, init: t });
      n.push(e);
    } else {
      const e = Object.assign(Object.assign(Object.assign({}, i), t ? { update: t } : {}), r ? { bind: r } : {});
      n.push(e);
    }
  }
  return n;
}
function wW(t) {
  return 'concat' in t;
}
function xW(t) {
  return 'vconcat' in t;
}
function OW(t) {
  return 'hconcat' in t;
}
function kW({ step: t, offsetIsDiscrete: n }) {
  var e;
  return n ? (null !== (e = t.for) && void 0 !== e ? e : 'offset') : 'position';
}
function AW(t) {
  return tt(t) && void 0 !== t.step;
}
function $W(t) {
  return t.view || t.width || t.height;
}
const MW = vT({ align: 1, bounds: 1, center: 1, columns: 1, spacing: 1 });
function jW(t, n) {
  var e;
  return null !== (e = t[n]) && void 0 !== e ? e : t['width' === n ? 'continuousWidth' : 'continuousHeight'];
}
function DW(t, n) {
  const e = FW(t, n);
  return AW(e) ? e.step : EW;
}
function FW(t, n) {
  var e;
  return ST(null !== (e = t[n]) && void 0 !== e ? e : t['width' === n ? 'discreteWidth' : 'discreteHeight'], {
    step: t.step,
  });
}
const EW = 20,
  SW = {
    background: 'white',
    padding: 5,
    timeFormat: '%b %d, %Y',
    countTitle: 'Count of Records',
    view: { continuousWidth: 200, continuousHeight: 200, step: EW },
    mark: { color: '#4c78a8', invalid: 'filter', timeUnitBandSize: 1 },
    arc: {},
    area: {},
    bar: { binSpacing: 1, continuousBandSize: 5, timeUnitBandPosition: 0.5 },
    circle: {},
    geoshape: {},
    image: {},
    line: {},
    point: {},
    rect: { binSpacing: 0, continuousBandSize: 5, timeUnitBandPosition: 0.5 },
    rule: { color: 'black' },
    square: {},
    text: { color: 'black' },
    tick: { thickness: 1 },
    trail: {},
    boxplot: { size: 14, extent: 1.5, box: {}, median: { color: 'white' }, outliers: {}, rule: {}, ticks: null },
    errorbar: { center: 'mean', rule: !0, ticks: !1 },
    errorband: { band: { opacity: 0.3 }, borders: !1 },
    scale: {
      pointPadding: 0.5,
      barBandPaddingInner: 0.1,
      rectBandPaddingInner: 0,
      bandWithNestedOffsetPaddingInner: 0.2,
      bandWithNestedOffsetPaddingOuter: 0.2,
      minBandSize: 2,
      minFontSize: 8,
      maxFontSize: 40,
      minOpacity: 0.3,
      maxOpacity: 0.8,
      minSize: 9,
      minStrokeWidth: 1,
      maxStrokeWidth: 4,
      quantileCount: 4,
      quantizeCount: 4,
    },
    projection: {},
    legend: {
      gradientHorizontalMaxLength: 200,
      gradientHorizontalMinLength: 100,
      gradientVerticalMaxLength: 200,
      gradientVerticalMinLength: 64,
      unselectedOpacity: 0.35,
    },
    header: { titlePadding: 10, labelPadding: 10 },
    headerColumn: {},
    headerRow: {},
    headerFacet: {},
    selection: pW,
    style: {},
    title: {},
    facet: { spacing: 20 },
    concat: { spacing: 20 },
    normalizedNumberFormat: '.0%',
  },
  CW = ['#4c78a8', '#f58518', '#e45756', '#72b7b2', '#54a24b', '#eeca3b', '#b279a2', '#ff9da6', '#9d755d', '#bab0ac'],
  NW = { text: 11, guideLabel: 10, guideTitle: 11, groupTitle: 13, groupSubtitle: 12 },
  BW = {
    blue: CW[0],
    orange: CW[1],
    red: CW[2],
    teal: CW[3],
    green: CW[4],
    yellow: CW[5],
    purple: CW[6],
    pink: CW[7],
    brown: CW[8],
    gray0: '#000',
    gray1: '#111',
    gray2: '#222',
    gray3: '#333',
    gray4: '#444',
    gray5: '#555',
    gray6: '#666',
    gray7: '#777',
    gray8: '#888',
    gray9: '#999',
    gray10: '#aaa',
    gray11: '#bbb',
    gray12: '#ccc',
    gray13: '#ddd',
    gray14: '#eee',
    gray15: '#fff',
  };
function _W(t) {
  const n = vT(t || {}),
    e = {};
  for (const r of n) {
    const n = t[r];
    e[r] = gU(n) ? NR(n) : BR(n);
  }
  return e;
}
const zW = [...Zq, ...kU, ...fW, 'background', 'padding', 'legend', 'lineBreak', 'scale', 'style', 'title', 'view'];
function TW(t = {}) {
  const { color: n, font: e, fontSize: r, selection: i } = t,
    o = (function (t, n) {
      var e = {};
      for (var r in t) Object.prototype.hasOwnProperty.call(t, r) && n.indexOf(r) < 0 && (e[r] = t[r]);
      if (null != t && 'function' == typeof Object.getOwnPropertySymbols) {
        var i = 0;
        for (r = Object.getOwnPropertySymbols(t); i < r.length; i++)
          n.indexOf(r[i]) < 0 && Object.prototype.propertyIsEnumerable.call(t, r[i]) && (e[r[i]] = t[r[i]]);
      }
      return e;
    })(t, ['color', 'font', 'fontSize', 'selection']),
    u = et(
      {},
      Zz(SW),
      e
        ? (function (t) {
            return {
              text: { font: t },
              style: {
                'guide-label': { font: t },
                'guide-title': { font: t },
                'group-title': { font: t },
                'group-subtitle': { font: t },
              },
            };
          })(e)
        : {},
      n
        ? (function (t = {}) {
            return {
              signals: [{ name: 'color', value: tt(t) ? Object.assign(Object.assign({}, BW), t) : BW }],
              mark: { color: { signal: 'color.blue' } },
              rule: { color: { signal: 'color.gray0' } },
              text: { color: { signal: 'color.gray0' } },
              style: {
                'guide-label': { fill: { signal: 'color.gray0' } },
                'guide-title': { fill: { signal: 'color.gray0' } },
                'group-title': { fill: { signal: 'color.gray0' } },
                'group-subtitle': { fill: { signal: 'color.gray0' } },
                cell: { stroke: { signal: 'color.gray8' } },
              },
              axis: {
                domainColor: { signal: 'color.gray13' },
                gridColor: { signal: 'color.gray8' },
                tickColor: { signal: 'color.gray13' },
              },
              range: {
                category: [
                  { signal: 'color.blue' },
                  { signal: 'color.orange' },
                  { signal: 'color.red' },
                  { signal: 'color.teal' },
                  { signal: 'color.green' },
                  { signal: 'color.yellow' },
                  { signal: 'color.purple' },
                  { signal: 'color.pink' },
                  { signal: 'color.brown' },
                  { signal: 'color.grey8' },
                ],
              },
            };
          })(n)
        : {},
      r
        ? (function (t) {
            return {
              signals: [{ name: 'fontSize', value: tt(t) ? Object.assign(Object.assign({}, NW), t) : NW }],
              text: { fontSize: { signal: 'fontSize.text' } },
              style: {
                'guide-label': { fontSize: { signal: 'fontSize.guideLabel' } },
                'guide-title': { fontSize: { signal: 'fontSize.guideTitle' } },
                'group-title': { fontSize: { signal: 'fontSize.groupTitle' } },
                'group-subtitle': { fontSize: { signal: 'fontSize.groupSubtitle' } },
              },
            };
          })(r)
        : {},
      o || {},
    );
  i && rt(u, 'selection', i, !0);
  const s = nT(u, zW);
  for (const t of ['background', 'lineBreak', 'padding']) u[t] && (s[t] = BR(u[t]));
  for (const t of Zq) u[t] && (s[t] = kR(u[t]));
  for (const t of kU) u[t] && (s[t] = _W(u[t]));
  for (const t of fW) u[t] && (s[t] = kR(u[t]));
  return (
    u.legend && (s.legend = kR(u.legend)),
    u.scale && (s.scale = kR(u.scale)),
    u.style &&
      (s.style = (function (t) {
        const n = vT(t),
          e = {};
        for (const r of n) e[r] = _W(t[r]);
        return e;
      })(u.style)),
    u.title && (s.title = kR(u.title)),
    u.view && (s.view = kR(u.view)),
    s
  );
}
const PW = new Set(['view', ...Yq]),
  RW = [
    'color',
    'fontSize',
    'background',
    'padding',
    'facet',
    'concat',
    'numberFormat',
    'numberFormatType',
    'normalizedNumberFormat',
    'normalizedNumberFormatType',
    'timeFormat',
    'countTitle',
    'header',
    'axisQuantitative',
    'axisTemporal',
    'axisDiscrete',
    'axisPoint',
    'axisXBand',
    'axisXPoint',
    'axisXDiscrete',
    'axisXQuantitative',
    'axisXTemporal',
    'axisYBand',
    'axisYPoint',
    'axisYDiscrete',
    'axisYQuantitative',
    'axisYTemporal',
    'scale',
    'selection',
    'overlay',
  ],
  LW = Object.assign(
    { view: ['continuousWidth', 'continuousHeight', 'discreteWidth', 'discreteHeight', 'step'] },
    {
      area: ['line', 'point'],
      bar: ['binSpacing', 'continuousBandSize', 'discreteBandSize'],
      rect: ['binSpacing', 'continuousBandSize', 'discreteBandSize'],
      line: ['point'],
      tick: ['bandSize', 'thickness'],
    },
  );
function qW(t, n, e, r) {
  'view' === n && (e = 'cell');
  const i = Object.assign(Object.assign({}, r ? t[n][r] : t[n]), t.style[null != e ? e : n]);
  mT(i) || (t.style[null != e ? e : n] = i), r || delete t[n];
}
function IW(t) {
  return 'layer' in t;
}
class UW {
  map(t, n) {
    return jI(t)
      ? this.mapFacet(t, n)
      : (function (t) {
          return 'repeat' in t;
        })(t)
      ? this.mapRepeat(t, n)
      : OW(t)
      ? this.mapHConcat(t, n)
      : xW(t)
      ? this.mapVConcat(t, n)
      : wW(t)
      ? this.mapConcat(t, n)
      : this.mapLayerOrUnit(t, n);
  }
  mapLayerOrUnit(t, n) {
    if (IW(t)) return this.mapLayer(t, n);
    if (AU(t)) return this.mapUnit(t, n);
    throw new Error(XR(t));
  }
  mapLayer(t, n) {
    return Object.assign(Object.assign({}, t), { layer: t.layer.map(t => this.mapLayerOrUnit(t, n)) });
  }
  mapHConcat(t, n) {
    return Object.assign(Object.assign({}, t), { hconcat: t.hconcat.map(t => this.map(t, n)) });
  }
  mapVConcat(t, n) {
    return Object.assign(Object.assign({}, t), { vconcat: t.vconcat.map(t => this.map(t, n)) });
  }
  mapConcat(t, n) {
    const { concat: e } = t,
      r = (function (t, n) {
        var e = {};
        for (var r in t) Object.prototype.hasOwnProperty.call(t, r) && n.indexOf(r) < 0 && (e[r] = t[r]);
        if (null != t && 'function' == typeof Object.getOwnPropertySymbols) {
          var i = 0;
          for (r = Object.getOwnPropertySymbols(t); i < r.length; i++)
            n.indexOf(r[i]) < 0 && Object.prototype.propertyIsEnumerable.call(t, r[i]) && (e[r[i]] = t[r[i]]);
        }
        return e;
      })(t, ['concat']);
    return Object.assign(Object.assign({}, r), { concat: e.map(t => this.map(t, n)) });
  }
  mapFacet(t, n) {
    return Object.assign(Object.assign({}, t), { spec: this.map(t.spec, n) });
  }
  mapRepeat(t, n) {
    return Object.assign(Object.assign({}, t), { spec: this.map(t.spec, n) });
  }
}
const WW = { zero: 1, center: 1, normalize: 1 },
  HW = new Set([Cq, Bq, Nq, Rq, Tq, Uq, Wq, zq, Lq, qq]),
  GW = new Set([Bq, Nq, Cq]);
function VW(t) {
  return TI(t) && 'quantitative' === PI(t) && !t.bin;
}
function YW(t, n) {
  var e, r;
  const i = 'x' === n ? 'y' : 'radius',
    o = t[n],
    u = t[i];
  if (TI(o) && TI(u))
    if (VW(o) && VW(u)) {
      if (o.stack) return n;
      if (u.stack) return i;
      const t = TI(o) && !!o.aggregate;
      if (t !== (TI(u) && !!u.aggregate)) return t ? n : i;
      {
        const t = null === (e = o.scale) || void 0 === e ? void 0 : e.type,
          s = null === (r = u.scale) || void 0 === r ? void 0 : r.type;
        if (t && 'linear' !== t) return i;
        if (s && 'linear' !== s) return n;
      }
    } else {
      if (VW(o)) return n;
      if (VW(u)) return i;
    }
  else {
    if (VW(o)) return n;
    if (VW(u)) return i;
  }
}
function XW(t, n) {
  var e, r;
  const i = Xq(t) ? t.type : t;
  if (!HW.has(i)) return null;
  const o = YW(n, 'x') || YW(n, 'theta');
  if (!o) return null;
  const u = n[o],
    s = TI(u) ? JI(u, {}) : void 0,
    a = (function (t) {
      switch (t) {
        case 'x':
          return 'y';
        case 'y':
          return 'x';
        case 'theta':
          return 'radius';
        case 'radius':
          return 'theta';
      }
    })(o),
    c = [],
    l = new Set();
  if (n[a]) {
    const t = n[a],
      e = TI(t) ? JI(t, {}) : void 0;
    e && e !== s && (c.push(a), l.add(e));
    const r = 'x' === a ? 'xOffset' : 'yOffset',
      i = n[r],
      o = TI(i) ? JI(i, {}) : void 0;
    o && o !== s && (c.push(r), l.add(o));
  }
  const f = WP.reduce((t, e) => {
    if ('tooltip' !== e && MU(n, e)) {
      const r = n[e];
      for (const n of At(r)) {
        const r = oU(n);
        if (r.aggregate) continue;
        const i = JI(r, {});
        (i && l.has(i)) || t.push({ channel: e, fieldDef: r });
      }
    }
    return t;
  }, []);
  let h;
  return (
    void 0 !== u.stack ? (h = Wt(u.stack) ? (u.stack ? 'zero' : null) : u.stack) : GW.has(i) && (h = 'zero'),
    h && h in WW
      ? FU(n) && 0 === f.length
        ? null
        : (null === (e = null == u ? void 0 : u.scale) || void 0 === e ? void 0 : e.type) &&
          'linear' !== (null === (r = null == u ? void 0 : u.scale) || void 0 === r ? void 0 : r.type)
        ? (DL(
            (function (t) {
              return `Cannot stack non-linear scale (${t}).`;
            })(u.scale.type),
          ),
          null)
        : II(n[PP(o)])
        ? (void 0 !== u.stack && DL(`Cannot stack "${(d = o)}" if there is already "${d}2".`), null)
        : (TI(u) &&
            u.aggregate &&
            !pR.has(u.aggregate) &&
            DL(`Stacking is applied even though the aggregate function is non-summative ("${u.aggregate}").`),
          {
            groupbyChannels: c,
            groupbyFields: l,
            fieldChannel: o,
            impute: null !== u.impute && Gq(i),
            stackBy: f,
            offset: h,
          })
      : null
  );
  var d;
}
var JW = function (t, n) {
  var e = {};
  for (var r in t) Object.prototype.hasOwnProperty.call(t, r) && n.indexOf(r) < 0 && (e[r] = t[r]);
  if (null != t && 'function' == typeof Object.getOwnPropertySymbols) {
    var i = 0;
    for (r = Object.getOwnPropertySymbols(t); i < r.length; i++)
      n.indexOf(r[i]) < 0 && Object.prototype.propertyIsEnumerable.call(t, r[i]) && (e[r[i]] = t[r[i]]);
  }
  return e;
};
function QW(t) {
  const n = JW(t, ['point', 'line']);
  return vT(n).length > 1 ? n : n.type;
}
function ZW(t) {
  for (const n of ['line', 'area', 'rule', 'trail'])
    t[n] && (t = Object.assign(Object.assign({}, t), { [n]: nT(t[n], ['point', 'line']) }));
  return t;
}
function KW(t, n = {}, e) {
  return 'transparent' === t.point
    ? { opacity: 0 }
    : t.point
    ? tt(t.point)
      ? t.point
      : {}
    : void 0 !== t.point
    ? null
    : n.point || e.shape
    ? tt(n.point)
      ? n.point
      : {}
    : void 0;
}
function tH(t, n = {}) {
  return t.line
    ? !0 === t.line
      ? {}
      : t.line
    : void 0 !== t.line
    ? null
    : n.line
    ? !0 === n.line
      ? {}
      : n.line
    : void 0;
}
class nH {
  constructor() {
    this.name = 'path-overlay';
  }
  hasMatchingType(t, n) {
    if (AU(t)) {
      const { mark: e, encoding: r } = t,
        i = Xq(e) ? e : { type: e };
      switch (i.type) {
        case 'line':
        case 'rule':
        case 'trail':
          return !!KW(i, n[i.type], r);
        case 'area':
          return !!KW(i, n[i.type], r) || !!tH(i, n[i.type]);
      }
    }
    return !1;
  }
  run(t, n, e) {
    const { config: r } = n,
      { params: i, projection: o, mark: u, encoding: s } = t,
      a = JW(t, ['params', 'projection', 'mark', 'encoding']),
      c = CU(s, r),
      l = Xq(u) ? u : { type: u },
      f = KW(l, r[l.type], c),
      h = 'area' === l.type && tH(l, r[l.type]),
      d = [
        Object.assign(Object.assign({}, i ? { params: i } : {}), {
          mark: QW(
            Object.assign(
              Object.assign(
                {},
                'area' === l.type && void 0 === l.opacity && void 0 === l.fillOpacity ? { opacity: 0.7 } : {},
              ),
              l,
            ),
          ),
          encoding: nT(c, ['shape']),
        }),
      ],
      p = XW(l, c);
    let m = c;
    if (p) {
      const { fieldChannel: t, offset: n } = p;
      m = Object.assign(Object.assign({}, c), { [t]: Object.assign(Object.assign({}, c[t]), n ? { stack: n } : {}) });
    }
    return (
      h &&
        d.push(
          Object.assign(Object.assign({}, o ? { projection: o } : {}), {
            mark: Object.assign(
              Object.assign({ type: 'line' }, tT(l, ['clip', 'interpolate', 'tension', 'tooltip'])),
              h,
            ),
            encoding: m,
          }),
        ),
      f &&
        d.push(
          Object.assign(Object.assign({}, o ? { projection: o } : {}), {
            mark: Object.assign(
              Object.assign({ type: 'point', opacity: 1, filled: !0 }, tT(l, ['clip', 'tooltip'])),
              f,
            ),
            encoding: m,
          }),
        ),
      e(Object.assign(Object.assign({}, a), { layer: d }), Object.assign(Object.assign({}, n), { config: ZW(r) }))
    );
  }
}
function eH(t, n) {
  return n ? ($I(t) ? aH(t, n) : oH(t, n)) : t;
}
function rH(t, n) {
  return n ? aH(t, n) : t;
}
function iH(t, n, e) {
  const r = n[t];
  return (function (t) {
    return t && !Xt(t) && 'repeat' in t;
  })(r)
    ? r.repeat in e
      ? Object.assign(Object.assign({}, n), { [t]: e[r.repeat] })
      : void DL(
          (function (t) {
            return `Unknown repeated value "${t}".`;
          })(r.repeat),
        )
    : n;
}
function oH(t, n) {
  if (void 0 !== (t = iH('field', t, n))) {
    if (null === t) return null;
    if (EI(t) && kI(t.sort)) {
      const e = iH('field', t.sort, n);
      t = Object.assign(Object.assign({}, t), e ? { sort: e } : {});
    }
    return t;
  }
}
function uH(t, n) {
  if (TI(t)) return oH(t, n);
  {
    const e = iH('datum', t, n);
    return e === t || e.type || (e.type = 'nominal'), e;
  }
}
function sH(t, n) {
  if (!II(t)) {
    if (zI(t)) {
      const e = uH(t.condition, n);
      return e
        ? Object.assign(Object.assign({}, t), { condition: e })
        : (function (t, n) {
            var e = {};
            for (var r in t) Object.prototype.hasOwnProperty.call(t, r) && n.indexOf(r) < 0 && (e[r] = t[r]);
            if (null != t && 'function' == typeof Object.getOwnPropertySymbols) {
              var i = 0;
              for (r = Object.getOwnPropertySymbols(t); i < r.length; i++)
                n.indexOf(r[i]) < 0 && Object.prototype.propertyIsEnumerable.call(t, r[i]) && (e[r[i]] = t[r[i]]);
            }
            return e;
          })(t, ['condition']);
    }
    return t;
  }
  {
    const e = uH(t, n);
    if (e) return e;
    if (BI(t)) return { condition: t.condition };
  }
}
function aH(t, n) {
  const e = {};
  for (const r in t)
    if (Pt(t, r)) {
      const i = t[r];
      if (K(i)) e[r] = i.map(t => sH(t, n)).filter(t => t);
      else {
        const t = sH(i, n);
        void 0 !== t && (e[r] = t);
      }
    }
  return e;
}
class cH {
  constructor() {
    this.name = 'RuleForRangedLine';
  }
  hasMatchingType(t) {
    if (AU(t)) {
      const { encoding: n, mark: e } = t;
      if ('line' === e || (Xq(e) && 'line' === e.type))
        for (const t of BP) {
          const e = n[zP(t)];
          if (n[t] && ((TI(e) && !bR(e.bin)) || RI(e))) return !0;
        }
    }
    return !1;
  }
  run(t, n, e) {
    const { encoding: r, mark: i } = t;
    var o;
    return (
      DL(
        `Line mark is for continuous lines and thus cannot be used with ${
          (o = !!r.x2) && !!r.y2 ? 'x2 and y2' : o ? 'x2' : 'y2'
        }. We will use the rule mark (line segments) instead.`,
      ),
      e(
        Object.assign(Object.assign({}, t), {
          mark: tt(i) ? Object.assign(Object.assign({}, i), { type: 'rule' }) : 'rule',
        }),
        n,
      )
    );
  }
}
var lH = function (t, n) {
  var e = {};
  for (var r in t) Object.prototype.hasOwnProperty.call(t, r) && n.indexOf(r) < 0 && (e[r] = t[r]);
  if (null != t && 'function' == typeof Object.getOwnPropertySymbols) {
    var i = 0;
    for (r = Object.getOwnPropertySymbols(t); i < r.length; i++)
      n.indexOf(r[i]) < 0 && Object.prototype.propertyIsEnumerable.call(t, r[i]) && (e[r[i]] = t[r[i]]);
  }
  return e;
};
function fH({ parentEncoding: t, encoding: n = {}, layer: e }) {
  let r = {};
  if (t) {
    const i = new Set([...vT(t), ...vT(n)]);
    for (const o of i) {
      const i = n[o],
        u = t[o];
      if (II(i)) {
        const t = Object.assign(Object.assign({}, u), i);
        r[o] = t;
      } else
        zI(i)
          ? (r[o] = Object.assign(Object.assign({}, i), {
              condition: Object.assign(Object.assign({}, u), i.condition),
            }))
          : i || null === i
          ? (r[o] = i)
          : (e || WI(u) || MR(u) || II(u) || K(u)) && (r[o] = u);
    }
  } else r = n;
  return !r || mT(r) ? void 0 : r;
}
function hH(t) {
  const { parentProjection: n, projection: e } = t;
  return (
    n &&
      e &&
      DL(
        (function (t) {
          const { parentProjection: n, projection: e } = t;
          return `Layer's shared projection ${eT(n)} is overridden by a child projection ${eT(e)}.`;
        })({ parentProjection: n, projection: e }),
      ),
    null != e ? e : n
  );
}
function dH(t) {
  return 'filter' in t;
}
function pH(t) {
  return void 0 !== (null == t ? void 0 : t.stop);
}
function mH(t) {
  return 'lookup' in t;
}
function vH(t) {
  return 'pivot' in t;
}
function gH(t) {
  return 'density' in t;
}
function bH(t) {
  return 'quantile' in t;
}
function yH(t) {
  return 'regression' in t;
}
function wH(t) {
  return 'loess' in t;
}
function xH(t) {
  return 'sample' in t;
}
function OH(t) {
  return 'window' in t;
}
function kH(t) {
  return 'joinaggregate' in t;
}
function AH(t) {
  return 'flatten' in t;
}
function $H(t) {
  return 'calculate' in t;
}
function MH(t) {
  return 'bin' in t;
}
function jH(t) {
  return 'impute' in t;
}
function DH(t) {
  return 'timeUnit' in t;
}
function FH(t) {
  return 'aggregate' in t;
}
function EH(t) {
  return 'stack' in t;
}
function SH(t) {
  return 'fold' in t;
}
var CH = function (t, n) {
  var e = {};
  for (var r in t) Object.prototype.hasOwnProperty.call(t, r) && n.indexOf(r) < 0 && (e[r] = t[r]);
  if (null != t && 'function' == typeof Object.getOwnPropertySymbols) {
    var i = 0;
    for (r = Object.getOwnPropertySymbols(t); i < r.length; i++)
      n.indexOf(r[i]) < 0 && Object.prototype.propertyIsEnumerable.call(t, r[i]) && (e[r[i]] = t[r[i]]);
  }
  return e;
};
function NH(t, n) {
  const { transform: e } = t,
    r = CH(t, ['transform']);
  if (e) {
    const t = e.map(t => {
      if (dH(t)) return { filter: zH(t, n) };
      if (MH(t) && yR(t.bin)) return Object.assign(Object.assign({}, t), { bin: _H(t.bin) });
      if (mH(t)) {
        const n = t.from,
          { selection: e } = n,
          r = CH(n, ['selection']);
        return e ? Object.assign(Object.assign({}, t), { from: Object.assign({ param: e }, r) }) : t;
      }
      return t;
    });
    return Object.assign(Object.assign({}, r), { transform: t });
  }
  return t;
}
function BH(t, n) {
  var e, r;
  const i = Zz(t);
  if (
    (TI(i) && yR(i.bin) && (i.bin = _H(i.bin)),
    HI(i) &&
      (null === (r = null === (e = i.scale) || void 0 === e ? void 0 : e.domain) || void 0 === r
        ? void 0
        : r.selection))
  ) {
    const t = i.scale.domain,
      { selection: n } = t,
      e = CH(t, ['selection']);
    i.scale.domain = Object.assign(Object.assign({}, e), n ? { param: n } : {});
  }
  if (BI(i))
    if (K(i.condition))
      i.condition = i.condition.map(t => {
        const { param: e } = t,
          r = CH(t, ['selection', 'param', 'test']);
        return e ? t : Object.assign(Object.assign({}, r), { test: zH(t, n) });
      });
    else {
      const t = BH(i.condition, n),
        { param: e } = t,
        r = CH(t, ['selection', 'param', 'test']);
      i.condition = e ? i.condition : Object.assign(Object.assign({}, r), { test: zH(i.condition, n) });
    }
  return i;
}
function _H(t) {
  const n = t.extent;
  if (null == n ? void 0 : n.selection) {
    const { selection: e } = n,
      r = CH(n, ['selection']);
    return Object.assign(Object.assign({}, t), { extent: Object.assign(Object.assign({}, r), { param: e }) });
  }
  return t;
}
function zH(t, n) {
  const e = t =>
    Jz(t, t => {
      var e, r, i;
      const o = { param: t, empty: null === (e = n.emptySelections[t]) || void 0 === e || e };
      return (
        (null !== (r = (i = n.selectionPredicates)[t]) && void 0 !== r) || (i[t] = []),
        n.selectionPredicates[t].push(o),
        o
      );
    });
  return t.selection ? e(t.selection) : Jz(t.test || t.filter, t => (t.selection ? e(t.selection) : t));
}
class TH extends UW {
  map(t, n) {
    var e;
    const r = null !== (e = n.selections) && void 0 !== e ? e : [];
    if (t.params && !AU(t)) {
      const n = [];
      for (const e of t.params) gW(e) ? r.push(e) : n.push(e);
      t.params = n;
    }
    return (n.selections = r), super.map(t, PH(t, n));
  }
  mapUnit(t, n) {
    var e;
    const r = n.selections;
    if (!r || !r.length) return t;
    const i = (null !== (e = n.path) && void 0 !== e ? e : []).concat(t.name),
      o = [];
    for (const n of r)
      if (n.views && n.views.length)
        for (const e of n.views)
          ((Xt(e) && (e === t.name || i.indexOf(e) >= 0)) ||
            (K(e) && e.map(t => i.indexOf(t)).every((t, n, e) => -1 !== t && (0 === n || t > e[n - 1])))) &&
            o.push(n);
      else o.push(n);
    return o.length && (t.params = o), t;
  }
}
for (const t of ['mapFacet', 'mapRepeat', 'mapHConcat', 'mapVConcat', 'mapLayer']) {
  const n = TH.prototype[t];
  TH.prototype[t] = function (t, e) {
    return n.call(this, t, PH(t, e));
  };
}
function PH(t, n) {
  var e;
  return t.name
    ? Object.assign(Object.assign({}, n), { path: (null !== (e = n.path) && void 0 !== e ? e : []).concat(t.name) })
    : n;
}
function RH(t, n) {
  void 0 === n && (n = TW(t.config));
  const e = (function (t, n = {}) {
      const e = { config: n };
      return IH.map(LH.map(qH.map(t, e), e), e);
    })(t, n),
    { width: r, height: i } = t,
    o = (function (t, n, e) {
      let { width: r, height: i } = n;
      const o = AU(t) || IW(t),
        u = {};
      o
        ? 'container' == r && 'container' == i
          ? ((u.type = 'fit'), (u.contains = 'padding'))
          : 'container' == r
          ? ((u.type = 'fit-x'), (u.contains = 'padding'))
          : 'container' == i && ((u.type = 'fit-y'), (u.contains = 'padding'))
        : ('container' == r && (DL(JR('width')), (r = void 0)), 'container' == i && (DL(JR('height')), (i = void 0)));
      const s = Object.assign(
        Object.assign(Object.assign({ type: 'pad' }, u), e ? UH(e.autosize) : {}),
        UH(t.autosize),
      );
      if (
        ('fit' !== s.type ||
          o ||
          (DL('Autosize "fit" only works for single views and layered views.'), (s.type = 'pad')),
        'container' == r && 'fit' != s.type && 'fit-x' != s.type && DL(QR('width')),
        'container' == i && 'fit' != s.type && 'fit-y' != s.type && DL(QR('height')),
        !Qz(s, { type: 'pad' }))
      )
        return s;
    })(e, { width: r, height: i, autosize: t.autosize }, n);
  return Object.assign(Object.assign({}, e), o ? { autosize: o } : {});
}
const LH = new (class extends UW {
    constructor() {
      super(...arguments), (this.nonFacetUnitNormalizers = [HU, QU, eW, new nH(), new cH()]);
    }
    map(t, n) {
      if (AU(t)) {
        const e = MU(t.encoding, RT),
          r = MU(t.encoding, LT),
          i = MU(t.encoding, qT);
        if (e || r || i) return this.mapFacetedUnit(t, n);
      }
      return super.map(t, n);
    }
    mapUnit(t, n) {
      const { parentEncoding: e, parentProjection: r } = n,
        i = rH(t.encoding, n.repeater),
        o = Object.assign(Object.assign({}, t), i ? { encoding: i } : {});
      if (e || r) return this.mapUnitWithParentEncodingOrProjection(o, n);
      const u = this.mapLayerOrUnit.bind(this);
      for (const t of this.nonFacetUnitNormalizers) if (t.hasMatchingType(o, n.config)) return t.run(o, n, u);
      return o;
    }
    mapRepeat(t, n) {
      return (function (t) {
        return !K(t.repeat) && t.repeat.layer;
      })(t)
        ? this.mapLayerRepeat(t, n)
        : this.mapNonLayerRepeat(t, n);
    }
    mapLayerRepeat(t, n) {
      const { repeat: e, spec: r } = t,
        i = lH(t, ['repeat', 'spec']),
        { row: o, column: u, layer: s } = e,
        { repeater: a = {}, repeaterPrefix: c = '' } = n;
      return o || u
        ? this.mapRepeat(
            Object.assign(Object.assign({}, t), {
              repeat: Object.assign(Object.assign({}, o ? { row: o } : {}), u ? { column: u } : {}),
              spec: { repeat: { layer: s }, spec: r },
            }),
            n,
          )
        : Object.assign(Object.assign({}, i), {
            layer: s.map(t => {
              const e = Object.assign(Object.assign({}, a), { layer: t }),
                i = `${(r.name || '') + c}child__layer_${wT(t)}`,
                o = this.mapLayerOrUnit(r, Object.assign(Object.assign({}, n), { repeater: e, repeaterPrefix: i }));
              return (o.name = i), o;
            }),
          });
    }
    mapNonLayerRepeat(t, n) {
      var e;
      const { repeat: r, spec: i, data: o } = t,
        u = lH(t, ['repeat', 'spec', 'data']);
      !K(r) && t.columns && ((t = nT(t, ['columns'])), DL(rL('repeat')));
      const s = [],
        { repeater: a = {}, repeaterPrefix: c = '' } = n,
        l = (!K(r) && r.row) || [a ? a.row : null],
        f = (!K(r) && r.column) || [a ? a.column : null],
        h = (K(r) && r) || [a ? a.repeat : null];
      for (const t of h)
        for (const e of l)
          for (const o of f) {
            const u = { repeat: t, row: e, column: o, layer: a.layer },
              l =
                (i.name || '') +
                c +
                'child__' +
                (K(r) ? `${wT(t)}` : (r.row ? `row_${wT(e)}` : '') + (r.column ? `column_${wT(o)}` : '')),
              f = this.map(i, Object.assign(Object.assign({}, n), { repeater: u, repeaterPrefix: l }));
            (f.name = l), s.push(nT(f, ['data']));
          }
      const d = K(r) ? t.columns : r.column ? r.column.length : 1;
      return Object.assign(Object.assign({ data: null !== (e = i.data) && void 0 !== e ? e : o, align: 'all' }, u), {
        columns: d,
        concat: s,
      });
    }
    mapFacet(t, n) {
      const { facet: e } = t;
      return $I(e) && t.columns && ((t = nT(t, ['columns'])), DL(rL('facet'))), super.mapFacet(t, n);
    }
    mapUnitWithParentEncodingOrProjection(t, n) {
      const { encoding: e, projection: r } = t,
        { parentEncoding: i, parentProjection: o, config: u } = n,
        s = hH({ parentProjection: o, projection: r }),
        a = fH({ parentEncoding: i, encoding: rH(e, n.repeater) });
      return this.mapUnit(
        Object.assign(Object.assign(Object.assign({}, t), s ? { projection: s } : {}), a ? { encoding: a } : {}),
        { config: u },
      );
    }
    mapFacetedUnit(t, n) {
      const e = t.encoding,
        { row: r, column: i, facet: o } = e,
        u = lH(e, ['row', 'column', 'facet']),
        { mark: s, width: a, projection: c, height: l, view: f, params: h } = t,
        d = lH(t, ['mark', 'width', 'projection', 'height', 'view', 'params', 'encoding']),
        { facetMapping: p, layout: m } = this.getFacetMappingAndLayout({ row: r, column: i, facet: o }, n),
        v = rH(u, n.repeater);
      return this.mapFacet(
        Object.assign(Object.assign(Object.assign({}, d), m), {
          facet: p,
          spec: Object.assign(
            Object.assign(
              Object.assign(
                Object.assign(
                  Object.assign(Object.assign({}, a ? { width: a } : {}), l ? { height: l } : {}),
                  f ? { view: f } : {},
                ),
                c ? { projection: c } : {},
              ),
              { mark: s, encoding: v },
            ),
            h ? { params: h } : {},
          ),
        }),
        n,
      );
    }
    getFacetMappingAndLayout(t, n) {
      var e;
      const { row: r, column: i, facet: o } = t;
      if (r || i) {
        o &&
          DL(
            `Facet encoding dropped as ${(u = [...(r ? [RT] : []), ...(i ? [LT] : [])]).join(' and ')} ${
              u.length > 1 ? 'are' : 'is'
            } also specified.`,
          );
        const n = {},
          s = {};
        for (const r of [RT, LT]) {
          const i = t[r];
          if (i) {
            const t = lH(i, ['align', 'center', 'spacing', 'columns']);
            n[r] = t;
            for (const t of ['align', 'center', 'spacing'])
              void 0 !== i[t] && ((null !== (e = s[t]) && void 0 !== e) || (s[t] = {}), (s[t][r] = i[t]));
          }
        }
        return { facetMapping: n, layout: s };
      }
      {
        const { align: t, center: e, spacing: r, columns: i } = o;
        return {
          facetMapping: eH(lH(o, ['align', 'center', 'spacing', 'columns']), n.repeater),
          layout: Object.assign(
            Object.assign(
              Object.assign(Object.assign({}, t ? { align: t } : {}), e ? { center: e } : {}),
              r ? { spacing: r } : {},
            ),
            i ? { columns: i } : {},
          ),
        };
      }
      var u;
    }
    mapLayer(t, n) {
      var { parentEncoding: e, parentProjection: r } = n,
        i = lH(n, ['parentEncoding', 'parentProjection']);
      const { encoding: o, projection: u } = t,
        s = lH(t, ['encoding', 'projection']),
        a = Object.assign(Object.assign({}, i), {
          parentEncoding: fH({ parentEncoding: e, encoding: o, layer: !0 }),
          parentProjection: hH({ parentProjection: r, projection: u }),
        });
      return super.mapLayer(s, a);
    }
  })(),
  qH = new (class extends UW {
    map(t, n) {
      var e, r;
      return (
        (null !== (e = n.emptySelections) && void 0 !== e) || (n.emptySelections = {}),
        (null !== (r = n.selectionPredicates) && void 0 !== r) || (n.selectionPredicates = {}),
        (t = NH(t, n)),
        super.map(t, n)
      );
    }
    mapLayerOrUnit(t, n) {
      if ((t = NH(t, n)).encoding) {
        const e = {};
        for (const [r, i] of bT(t.encoding)) e[r] = BH(i, n);
        t = Object.assign(Object.assign({}, t), { encoding: e });
      }
      return super.mapLayerOrUnit(t, n);
    }
    mapUnit(t, n) {
      const e = t,
        { selection: r } = e,
        i = CH(e, ['selection']);
      return r
        ? Object.assign(Object.assign({}, i), {
            params: bT(r).map(([t, e]) => {
              var r;
              const i = e,
                { init: o, bind: u, empty: s } = i,
                a = CH(i, ['init', 'bind', 'empty']);
              'single' === a.type ? ((a.type = 'point'), (a.toggle = !1)) : 'multi' === a.type && (a.type = 'point'),
                (n.emptySelections[t] = 'none' !== s);
              for (const e of gT(null !== (r = n.selectionPredicates[t]) && void 0 !== r ? r : {}))
                e.empty = 'none' !== s;
              return { name: t, value: o, select: a, bind: u };
            }),
          })
        : t;
    }
  })(),
  IH = new TH();
function UH(t) {
  return Xt(t) ? { type: t } : null != t ? t : {};
}
const WH = ['background', 'padding'];
function HH(t, n) {
  const e = {};
  for (const n of WH) t && void 0 !== t[n] && (e[n] = BR(t[n]));
  return n && (e.params = t.params), e;
}
class GH {
  constructor(t = {}, n = {}) {
    (this.explicit = t), (this.implicit = n);
  }
  clone() {
    return new GH(Zz(this.explicit), Zz(this.implicit));
  }
  combine() {
    return Object.assign(Object.assign({}, this.explicit), this.implicit);
  }
  get(t) {
    return ST(this.explicit[t], this.implicit[t]);
  }
  getWithExplicit(t) {
    return void 0 !== this.explicit[t]
      ? { explicit: !0, value: this.explicit[t] }
      : void 0 !== this.implicit[t]
      ? { explicit: !1, value: this.implicit[t] }
      : { explicit: !1, value: void 0 };
  }
  setWithExplicit(t, { value: n, explicit: e }) {
    void 0 !== n && this.set(t, n, e);
  }
  set(t, n, e) {
    return delete this[e ? 'implicit' : 'explicit'][t], (this[e ? 'explicit' : 'implicit'][t] = n), this;
  }
  copyKeyFromSplit(t, { explicit: n, implicit: e }) {
    void 0 !== n[t] ? this.set(t, n[t], !0) : void 0 !== e[t] && this.set(t, e[t], !1);
  }
  copyKeyFromObject(t, n) {
    void 0 !== n[t] && this.set(t, n[t], !0);
  }
  copyAll(t) {
    for (const n of vT(t.combine())) {
      const e = t.getWithExplicit(n);
      this.setWithExplicit(n, e);
    }
  }
}
function VH(t) {
  return { explicit: !0, value: t };
}
function YH(t) {
  return { explicit: !1, value: t };
}
function XH(t) {
  return (n, e, r, i) => {
    const o = t(n.value, e.value);
    return o > 0 ? n : o < 0 ? e : JH(n, e, r, i);
  };
}
function JH(t, n, e, r) {
  return (
    t.explicit &&
      n.explicit &&
      DL(
        (function (t, n, e, r) {
          return `Conflicting ${n.toString()} property "${t.toString()}" (${eT(e)} and ${eT(r)}). Using ${eT(e)}.`;
        })(e, r, t.value, n.value),
      ),
    t
  );
}
function QH(t, n, e, r, i = JH) {
  return void 0 === t || void 0 === t.value
    ? n
    : t.explicit && !n.explicit
    ? t
    : n.explicit && !t.explicit
    ? n
    : Qz(t.value, n.value)
    ? t
    : i(t, n, e, r);
}
class ZH extends GH {
  constructor(t = {}, n = {}, e = !1) {
    super(t, n), (this.explicit = t), (this.implicit = n), (this.parseNothing = e);
  }
  clone() {
    const t = super.clone();
    return (t.parseNothing = this.parseNothing), t;
  }
}
function KH(t) {
  return 'url' in t;
}
function tG(t) {
  return 'values' in t;
}
function nG(t) {
  return 'name' in t && !KH(t) && !tG(t) && !eG(t);
}
function eG(t) {
  return t && (rG(t) || iG(t) || oG(t));
}
function rG(t) {
  return 'sequence' in t;
}
function iG(t) {
  return 'sphere' in t;
}
function oG(t) {
  return 'graticule' in t;
}
var uG;
!(function (t) {
  (t[(t.Raw = 0)] = 'Raw'),
    (t[(t.Main = 1)] = 'Main'),
    (t[(t.Row = 2)] = 'Row'),
    (t[(t.Column = 3)] = 'Column'),
    (t[(t.Lookup = 4)] = 'Lookup');
})(uG || (uG = {}));
var sG = function (t, n) {
  var e = {};
  for (var r in t) Object.prototype.hasOwnProperty.call(t, r) && n.indexOf(r) < 0 && (e[r] = t[r]);
  if (null != t && 'function' == typeof Object.getOwnPropertySymbols) {
    var i = 0;
    for (r = Object.getOwnPropertySymbols(t); i < r.length; i++)
      n.indexOf(r[i]) < 0 && Object.prototype.propertyIsEnumerable.call(t, r[i]) && (e[r[i]] = t[r[i]]);
  }
  return e;
};
function aG(t, n = !0, e = G) {
  if (K(t)) {
    const r = t.map(t => aG(t, n, e));
    return n ? `[${r.join(', ')}]` : r;
  }
  return FL(t)
    ? e(
        n
          ? _L(t)
          : (function (t) {
              const n = BL(t, !0);
              return t.utc ? +new Date(Date.UTC(...n)) : +new Date(...n);
            })(t),
      )
    : n
    ? e(eT(t))
    : t;
}
function cG(t, n) {
  var e;
  for (const r of gT(null !== (e = t.component.selection) && void 0 !== e ? e : {})) {
    const e = r.name;
    let i = `${e}${mV}, ${'global' === r.resolve ? 'true' : `{unit: ${yV(t)}}`}`;
    for (const e of bV)
      e.defined(r) && (e.signals && (n = e.signals(t, r, n)), e.modifyExpr && (i = e.modifyExpr(t, r, i)));
    n.push({ name: e + vV, on: [{ events: { signal: r.name + mV }, update: `modify(${rn(r.name + pV)}, ${i})` }] });
  }
  return fG(n);
}
function lG(t, n) {
  var e;
  for (const r of gT(null !== (e = t.component.selection) && void 0 !== e ? e : {}))
    for (const e of bV) e.defined(r) && e.marks && (n = e.marks(t, r, n));
  return n;
}
function fG(t) {
  return t.map(t => (t.on && !t.on.length && delete t.on, t));
}
class hG {
  constructor(t, n) {
    (this.debugName = n), (this._children = []), (this._parent = null), t && (this.parent = t);
  }
  clone() {
    throw new Error('Cannot clone node');
  }
  get parent() {
    return this._parent;
  }
  set parent(t) {
    (this._parent = t), t && t.addChild(this);
  }
  get children() {
    return this._children;
  }
  numChildren() {
    return this._children.length;
  }
  addChild(t, n) {
    this._children.includes(t)
      ? DL('Attempt to add the same child twice.')
      : void 0 !== n
      ? this._children.splice(n, 0, t)
      : this._children.push(t);
  }
  removeChild(t) {
    const n = this._children.indexOf(t);
    return this._children.splice(n, 1), n;
  }
  remove() {
    let t = this._parent.removeChild(this);
    for (const n of this._children) (n._parent = this._parent), this._parent.addChild(n, t++);
  }
  insertAsParentOf(t) {
    const n = t.parent;
    n.removeChild(this), (this.parent = n), (t.parent = this);
  }
  swapWithParent() {
    const t = this._parent,
      n = t.parent;
    for (const n of this._children) n.parent = t;
    (this._children = []), t.removeChild(this);
    const e = t.parent.removeChild(t);
    (this._parent = n), n.addChild(this, e), (t.parent = this);
  }
}
class dG extends hG {
  constructor(t, n, e, r) {
    super(t, n),
      (this.type = e),
      (this.refCounts = r),
      (this._source = this._name = n),
      this.refCounts && !(this._name in this.refCounts) && (this.refCounts[this._name] = 0);
  }
  clone() {
    const t = new this.constructor();
    return (
      (t.debugName = `clone_${this.debugName}`),
      (t._source = this._source),
      (t._name = `clone_${this._name}`),
      (t.type = this.type),
      (t.refCounts = this.refCounts),
      (t.refCounts[t._name] = 0),
      t
    );
  }
  dependentFields() {
    return new Set();
  }
  producedFields() {
    return new Set();
  }
  hash() {
    return void 0 === this._hash && (this._hash = `Output ${NT()}`), this._hash;
  }
  getSource() {
    return this.refCounts[this._name]++, this._source;
  }
  isRequired() {
    return !!this.refCounts[this._name];
  }
  setSource(t) {
    this._source = t;
  }
}
var pG = function (t, n) {
  var e = {};
  for (var r in t) Object.prototype.hasOwnProperty.call(t, r) && n.indexOf(r) < 0 && (e[r] = t[r]);
  if (null != t && 'function' == typeof Object.getOwnPropertySymbols) {
    var i = 0;
    for (r = Object.getOwnPropertySymbols(t); i < r.length; i++)
      n.indexOf(r[i]) < 0 && Object.prototype.propertyIsEnumerable.call(t, r[i]) && (e[r[i]] = t[r[i]]);
  }
  return e;
};
class mG extends hG {
  constructor(t, n) {
    super(t), (this.formula = n);
  }
  clone() {
    return new mG(null, Zz(this.formula));
  }
  static makeFromEncoding(t, n) {
    const e = n.reduceFieldDef((t, n) => {
      const { field: e, timeUnit: r } = n;
      if (r) {
        const i = JI(n, { forAs: !0 });
        t[rT({ as: i, field: e, timeUnit: r })] = { as: i, field: e, timeUnit: r };
      }
      return t;
    }, {});
    return mT(e) ? null : new mG(t, e);
  }
  static makeFromTransform(t, n) {
    const e = Object.assign({}, n),
      { timeUnit: r } = e,
      i = pG(e, ['timeUnit']),
      o = UL(r),
      u = Object.assign(Object.assign({}, i), { timeUnit: o });
    return new mG(t, { [rT(u)]: u });
  }
  merge(t) {
    this.formula = Object.assign({}, this.formula);
    for (const n in t.formula) this.formula[n] || (this.formula[n] = t.formula[n]);
    for (const n of t.children) t.removeChild(n), (n.parent = this);
    t.remove();
  }
  removeFormulas(t) {
    const n = {};
    for (const [e, r] of bT(this.formula)) t.has(r.as) || (n[e] = r);
    this.formula = n;
  }
  producedFields() {
    return new Set(gT(this.formula).map(t => t.as));
  }
  dependentFields() {
    return new Set(gT(this.formula).map(t => t.field));
  }
  hash() {
    return `TimeUnit ${rT(this.formula)}`;
  }
  assemble() {
    const t = [];
    for (const n of gT(this.formula)) {
      const { field: e, as: r, timeUnit: i } = n,
        o = UL(i),
        { unit: u, utc: s } = o,
        a = pG(o, ['unit', 'utc']);
      t.push(
        Object.assign(
          Object.assign(
            Object.assign(
              Object.assign({ field: jT(e), type: 'timeunit' }, u ? { units: LL(u) } : {}),
              s ? { timezone: 'utc' } : {},
            ),
            a,
          ),
          { as: [r, `${r}_end`] },
        ),
      );
    }
    return t;
  }
}
const vG = '_tuple_fields';
class gG {
  constructor(...t) {
    (this.items = t), (this.hasChannel = {}), (this.hasField = {}), (this.hasSelectionId = !1);
  }
}
const bG = {
    defined: () => !0,
    parse: (t, n, e) => {
      var r;
      const i = n.name,
        o = null !== (r = n.project) && void 0 !== r ? r : (n.project = new gG()),
        u = {},
        s = {},
        a = new Set(),
        c = (t, n) => {
          const e = 'visual' === n ? t.channel : t.field;
          let r = wT(`${i}_${e}`);
          for (let t = 1; a.has(r); t++) r = wT(`${i}_${e}_${t}`);
          return a.add(r), { [n]: r };
        },
        l = n.type,
        f = t.config.selection[l],
        h = void 0 !== e.value ? At(e.value) : null;
      let { fields: d, encodings: p } = tt(e.select) ? e.select : {};
      if (!d && !p && h)
        for (const t of h)
          if (tt(t))
            for (const n of vT(t))
              CP[n]
                ? (p || (p = [])).push(n)
                : 'interval' === l
                ? (DL('Interval selections should be initialized using "x" and/or "y" keys.'), (p = f.encodings))
                : (d || (d = [])).push(n);
      d || p || ((p = f.encodings), 'fields' in f && (d = f.fields));
      for (const n of null != p ? p : []) {
        const e = t.fieldDef(n);
        if (e) {
          let r = e.field;
          if (e.aggregate) {
            DL(nL(n, e.aggregate));
            continue;
          }
          if (!r) {
            DL(tL(n));
            continue;
          }
          if (e.timeUnit) {
            r = t.vgField(n);
            const i = { timeUnit: e.timeUnit, as: r, field: e.field };
            s[rT(i)] = i;
          }
          if (!u[r]) {
            let i = 'E';
            'interval' === l ? kq(t.getScaleComponent(n).get('type')) && (i = 'R') : e.bin && (i = 'R-RE');
            const s = { field: r, channel: n, type: i };
            (s.signals = Object.assign(Object.assign({}, c(s, 'data')), c(s, 'visual'))),
              o.items.push((u[r] = s)),
              (o.hasField[r] = o.hasChannel[n] = u[r]),
              (o.hasSelectionId = o.hasSelectionId || r === dW);
          }
        } else DL(tL(n));
      }
      for (const t of null != d ? d : []) {
        if (o.hasField[t]) continue;
        const n = { type: 'E', field: t };
        (n.signals = Object.assign({}, c(n, 'data'))),
          o.items.push(n),
          (o.hasField[t] = n),
          (o.hasSelectionId = o.hasSelectionId || t === dW);
      }
      h && (n.init = h.map(t => o.items.map(n => (tt(t) ? (void 0 !== t[n.channel] ? t[n.channel] : t[n.field]) : t)))),
        mT(s) || (o.timeUnit = new mG(null, s));
    },
    signals: (t, n, e) => {
      const r = n.name + vG;
      return e.filter(t => t.name === r).length > 0 || n.project.hasSelectionId
        ? e
        : e.concat({
            name: r,
            value: n.project.items.map(t => {
              const n = (function (t, n) {
                var e = {};
                for (var r in t) Object.prototype.hasOwnProperty.call(t, r) && n.indexOf(r) < 0 && (e[r] = t[r]);
                if (null != t && 'function' == typeof Object.getOwnPropertySymbols) {
                  var i = 0;
                  for (r = Object.getOwnPropertySymbols(t); i < r.length; i++)
                    n.indexOf(r[i]) < 0 && Object.prototype.propertyIsEnumerable.call(t, r[i]) && (e[r[i]] = t[r[i]]);
                }
                return e;
              })(t, ['signals', 'hasLegend']);
              return (n.field = jT(n.field)), n;
            }),
          });
    },
  },
  yG = {
    defined: t => 'interval' === t.type && 'global' === t.resolve && t.bind && 'scales' === t.bind,
    parse: (t, n) => {
      const e = (n.scales = []);
      for (const r of n.project.items) {
        const i = r.channel;
        if (!rR(i)) continue;
        const o = t.getScaleComponent(i),
          u = o ? o.get('type') : void 0;
        o && kq(u)
          ? (o.set('selectionExtent', { param: n.name, field: r.field }, !0), e.push(r))
          : DL('Scale bindings are currently only supported for scales with unbinned, continuous domains.');
      }
    },
    topLevelSignals: (t, n, e) => {
      const r = n.scales.filter(t => 0 === e.filter(n => n.name === t.signals.data).length);
      if (!t.parent || xG(t) || 0 === r.length) return e;
      const i = e.filter(t => t.name === n.name)[0];
      let o = i.update;
      if (o.indexOf(gV) >= 0) i.update = `{${r.map(t => `${rn(jT(t.field))}: ${t.signals.data}`).join(', ')}}`;
      else {
        for (const t of r) {
          const n = `${rn(jT(t.field))}: ${t.signals.data}`;
          o.includes(n) || (o = `${o.substring(0, o.length - 1)}, ${n}}`);
        }
        i.update = o;
      }
      return e.concat(r.map(t => ({ name: t.signals.data })));
    },
    signals: (t, n, e) => {
      if (t.parent && !xG(t))
        for (const t of n.scales) {
          const n = e.filter(n => n.name === t.signals.data)[0];
          (n.push = 'outer'), delete n.value, delete n.update;
        }
      return e;
    },
  };
function wG(t, n) {
  return `domain(${rn(t.scaleName(n))})`;
}
function xG(t) {
  var n;
  return t.parent && tJ(t.parent) && (null !== (n = !t.parent.parent) && void 0 !== n ? n : xG(t.parent.parent));
}
const OG = '_brush',
  kG = '_scale_trigger',
  AG = {
    defined: t => 'interval' === t.type,
    signals: (t, n, e) => {
      const r = n.name,
        i = r + vG,
        o = yG.defined(n),
        u = n.init ? n.init[0] : null,
        s = [],
        a = [];
      if (n.translate && !o) {
        const t = `!event.item || event.item.mark.name !== ${rn(r + OG)}`;
        $G(n, (n, e) => {
          var r, i;
          const o = At(null !== (r = (i = e.between[0]).filter) && void 0 !== r ? r : (i.filter = []));
          return o.includes(t) || o.push(t), n;
        });
      }
      n.project.items.forEach((r, i) => {
        const o = r.channel;
        if (o !== IT && o !== UT) return void DL('Interval selections only support x and y encoding channels.');
        const c = (function (t, n, e, r) {
            const i = e.channel,
              o = e.signals.visual,
              u = e.signals.data,
              s = yG.defined(n),
              a = rn(t.scaleName(i)),
              c = t.getScaleComponent(i),
              l = c ? c.get('type') : void 0,
              f = t => `scale(${a}, ${t})`,
              h = t.getSizeSignalRef(i === IT ? 'width' : 'height').signal,
              d = `${i}(unit)`,
              p = $G(n, (t, n) => [
                ...t,
                { events: n.between[0], update: `[${d}, ${d}]` },
                { events: n, update: `[${o}[0], clamp(${d}, 0, ${h})]` },
              ]);
            return (
              p.push({
                events: { signal: n.name + kG },
                update: kq(l) ? `[${f(`${u}[0]`)}, ${f(`${u}[1]`)}]` : '[0, 0]',
              }),
              s
                ? [{ name: u, on: [] }]
                : [
                    Object.assign(Object.assign({ name: o }, r ? { init: aG(r, !0, f) } : { value: [] }), { on: p }),
                    Object.assign(Object.assign({ name: u }, r ? { init: aG(r) } : {}), {
                      on: [{ events: { signal: o }, update: `${o}[0] === ${o}[1] ? null : invert(${a}, ${o})` }],
                    }),
                  ]
            );
          })(t, n, r, u ? u[i] : null),
          l = r.signals.data,
          f = r.signals.visual,
          h = rn(t.scaleName(o)),
          d = kq(t.getScaleComponent(o).get('type')) ? '+' : '';
        e.push(...c),
          s.push(l),
          a.push({
            scaleName: t.scaleName(o),
            expr: `(!isArray(${l}) || (${d}invert(${h}, ${f})[0] === ${d}${l}[0] && ${d}invert(${h}, ${f})[1] === ${d}${l}[1]))`,
          });
      }),
        !o &&
          a.length &&
          e.push({
            name: r + kG,
            value: {},
            on: [
              {
                events: a.map(t => ({ scale: t.scaleName })),
                update: `${a.map(t => t.expr).join(' && ')} ? ${r + kG} : {}`,
              },
            ],
          });
      const c = `unit: ${yV(t)}, fields: ${i}, values`;
      return e.concat(
        Object.assign(
          Object.assign({ name: r + mV }, u ? { init: `{${c}: ${aG(u)}}` } : {}),
          s.length
            ? { on: [{ events: [{ signal: s.join(' || ') }], update: `${s.join(' && ')} ? {${c}: [${s}]} : null` }] }
            : {},
        ),
      );
    },
    marks: (t, n, e) => {
      const r = n.name,
        { x: i, y: o } = n.project.hasChannel,
        u = null == i ? void 0 : i.signals.visual,
        s = null == o ? void 0 : o.signals.visual,
        a = `data(${rn(n.name + pV)})`;
      if (yG.defined(n) || (!i && !o)) return e;
      const c = {
        x: void 0 !== i ? { signal: `${u}[0]` } : { value: 0 },
        y: void 0 !== o ? { signal: `${s}[0]` } : { value: 0 },
        x2: void 0 !== i ? { signal: `${u}[1]` } : { field: { group: 'width' } },
        y2: void 0 !== o ? { signal: `${s}[1]` } : { field: { group: 'height' } },
      };
      if ('global' === n.resolve)
        for (const n of vT(c))
          c[n] = [Object.assign({ test: `${a}.length && ${a}[0].unit === ${yV(t)}` }, c[n]), { value: 0 }];
      const l = n.mark,
        { fill: f, fillOpacity: h, cursor: d } = l,
        p = (function (t, n) {
          var e = {};
          for (var r in t) Object.prototype.hasOwnProperty.call(t, r) && n.indexOf(r) < 0 && (e[r] = t[r]);
          if (null != t && 'function' == typeof Object.getOwnPropertySymbols) {
            var i = 0;
            for (r = Object.getOwnPropertySymbols(t); i < r.length; i++)
              n.indexOf(r[i]) < 0 && Object.prototype.propertyIsEnumerable.call(t, r[i]) && (e[r[i]] = t[r[i]]);
          }
          return e;
        })(l, ['fill', 'fillOpacity', 'cursor']),
        m = vT(p).reduce(
          (t, n) => (
            (t[n] = [
              {
                test: [void 0 !== i && `${u}[0] !== ${u}[1]`, void 0 !== o && `${s}[0] !== ${s}[1]`]
                  .filter(t => t)
                  .join(' && '),
                value: p[n],
              },
              { value: null },
            ]),
            t
          ),
          {},
        );
      return [
        {
          name: `${r + OG}_bg`,
          type: 'rect',
          clip: !0,
          encode: { enter: { fill: { value: f }, fillOpacity: { value: h } }, update: c },
        },
        ...e,
        {
          name: r + OG,
          type: 'rect',
          clip: !0,
          encode: {
            enter: Object.assign(Object.assign({}, d ? { cursor: { value: d } } : {}), {
              fill: { value: 'transparent' },
            }),
            update: Object.assign(Object.assign({}, c), m),
          },
        },
      ];
    },
  };
function $G(t, n) {
  return t.events.reduce(
    (t, e) => (e.between ? n(t, e) : (DL(`${e} is not an ordered event stream for interval selections.`), t)),
    [],
  );
}
const MG = {
  defined: t => 'point' === t.type,
  signals: (t, n, e) => {
    var r;
    const i = n.name,
      o = i + vG,
      u = n.project,
      s = '(item().isVoronoi ? datum.datum : datum)',
      a = gT(null !== (r = t.component.selection) && void 0 !== r ? r : {})
        .reduce((t, n) => ('interval' === n.type ? t.concat(n.name + OG) : t), [])
        .map(t => `indexof(item().mark.name, '${t}') < 0`)
        .join(' && '),
      c =
        "datum && item().mark.marktype !== 'group' && indexof(item().mark.role, 'legend') < 0" + (a ? ` && ${a}` : '');
    let l = `unit: ${yV(t)}, `;
    l += n.project.hasSelectionId
      ? `${dW}: ${s}[${rn(dW)}]`
      : `fields: ${o}, values: [${u.items
          .map(n => {
            const e = t.fieldDef(n.channel);
            return (null == e ? void 0 : e.bin)
              ? `[${s}[${rn(t.vgField(n.channel, {}))}], ${s}[${rn(t.vgField(n.channel, { binSuffix: 'end' }))}]]`
              : `${s}[${rn(n.field)}]`;
          })
          .join(', ')}]`;
    const f = n.events;
    return e.concat([{ name: i + mV, on: f ? [{ events: f, update: `${c} ? {${l}} : null`, force: !0 }] : [] }]);
  },
};
function jG(t, n, e, r) {
  const i = BI(n) && n.condition,
    o = r(n);
  if (i) {
    const n = At(i).map(n => {
      const e = r(n);
      if (
        (function (t) {
          return t.param;
        })(n)
      ) {
        const { param: r, empty: i } = n,
          o = MV(t, { param: r, empty: i });
        return Object.assign({ test: o }, e);
      }
      {
        const r = DV(t, n.test);
        return Object.assign({ test: r }, e);
      }
    });
    return { [e]: [...n, ...(void 0 !== o ? [o] : [])] };
  }
  return void 0 !== o ? { [e]: o } : {};
}
function DG(t, n = 'text') {
  return jG(t, t.encoding[n], n, n => FG(n, t.config));
}
function FG(t, n, e = 'datum') {
  if (t) {
    if (WI(t)) return zR(t.value);
    if (II(t)) {
      const { format: r, formatType: i } = iU(t);
      return lI({ fieldOrDatumDef: t, format: r, formatType: i, expr: e, config: n });
    }
  }
}
function EG(t, n = {}) {
  const { encoding: e, markDef: r, config: i, stack: o } = t,
    u = e.tooltip;
  if (K(u)) return { tooltip: CG({ tooltip: u }, o, i, n) };
  {
    const s = n.reactiveGeom ? 'datum.datum' : 'datum';
    return jG(t, u, 'tooltip', t => {
      const u = FG(t, i, s);
      if (u) return u;
      if (null === t) return;
      let a = qR('tooltip', r, i);
      return (
        !0 === a && (a = { content: 'encoding' }),
        Xt(a) ? { value: a } : tt(a) ? (MR(a) ? a : 'encoding' === a.content ? CG(e, o, i, n) : { signal: s }) : void 0
      );
    });
  }
}
function SG(t, n, e, { reactiveGeom: r } = {}) {
  const i = {},
    o = r ? 'datum.datum' : 'datum',
    u = [];
  function s(r, s) {
    const a = zP(s),
      c = UI(r) ? r : Object.assign(Object.assign({}, r), { type: t[a].type }),
      l = At(c.title || rU(c, e)).join(', ');
    let f;
    if (VP(s)) {
      const n = 'x' === s ? 'x2' : 'y2',
        r = oU(t[n]);
      if (bR(c.bin) && r) {
        const t = JI(c, { expr: o }),
          u = JI(r, { expr: o }),
          { format: s, formatType: a } = iU(c);
        (f = bI(t, u, s, a, e)), (i[n] = !0);
      }
    }
    if ((VP(s) || s === JT || s === YT) && n && n.fieldChannel === s && 'normalize' === n.offset) {
      const { format: t, formatType: n } = iU(c);
      f = lI({ fieldOrDatumDef: c, format: t, formatType: n, expr: o, config: e, normalizeStack: !0 }).signal;
    }
    null != f || (f = FG(c, e, o).signal), u.push({ channel: s, key: l, value: f });
  }
  NU(t, (t, n) => {
    TI(t) ? s(t, n) : _I(t) && s(t.condition, n);
  });
  const a = {};
  for (const { channel: t, key: n, value: e } of u) i[t] || a[n] || (a[n] = e);
  return a;
}
function CG(t, n, e, { reactiveGeom: r } = {}) {
  const i = SG(t, n, e, { reactiveGeom: r }),
    o = bT(i).map(([t, n]) => `"${t}": ${n}`);
  return o.length > 0 ? { signal: `{${o.join(', ')}}` } : void 0;
}
function NG(t, n, e = {}) {
  const { markDef: r, encoding: i, config: o } = n,
    { vgChannel: u } = e;
  let { defaultRef: s, defaultValue: a } = e;
  return (
    void 0 === s && (null != a || (a = qR(t, r, o, { vgChannel: u, ignoreVgConfig: !0 })), void 0 !== a && (s = zR(a))),
    jG(n, i[t], null != u ? u : t, e =>
      uI({
        channel: t,
        channelDef: e,
        markDef: r,
        config: o,
        scaleName: n.scaleName(t),
        scale: n.getScaleComponent(t),
        stack: null,
        defaultRef: s,
      }),
    )
  );
}
function BG(t, n = { filled: void 0 }) {
  var e, r, i, o;
  const { markDef: u, encoding: s, config: a } = t,
    { type: c } = u,
    l = null !== (e = n.filled) && void 0 !== e ? e : qR('filled', u, a),
    f = oT(['bar', 'point', 'circle', 'square', 'geoshape'], c) ? 'transparent' : void 0,
    h =
      null !==
        (i =
          null !== (r = qR(!0 === l ? 'color' : void 0, u, a, { vgChannel: 'fill' })) && void 0 !== r
            ? r
            : a.mark[!0 === l && 'color']) && void 0 !== i
        ? i
        : f,
    d =
      null !== (o = qR(!1 === l ? 'color' : void 0, u, a, { vgChannel: 'stroke' })) && void 0 !== o
        ? o
        : a.mark[!1 === l && 'color'],
    p = l ? 'fill' : 'stroke',
    m = Object.assign(Object.assign({}, h ? { fill: zR(h) } : {}), d ? { stroke: zR(d) } : {});
  return (
    u.color && (l ? u.fill : u.stroke) && DL(lL('property', { fill: 'fill' in u, stroke: 'stroke' in u })),
    Object.assign(
      Object.assign(
        Object.assign(Object.assign({}, m), NG('color', t, { vgChannel: p, defaultValue: l ? h : d })),
        NG('fill', t, { defaultValue: s.fill ? h : void 0 }),
      ),
      NG('stroke', t, { defaultValue: s.stroke ? d : void 0 }),
    )
  );
}
function _G({ channel: t, markDef: n, encoding: e = {}, model: r, bandPosition: i }) {
  const o = `${t}Offset`,
    u = n[o],
    s = e[o];
  if (('xOffset' === o || 'yOffset' === o) && s)
    return {
      offsetType: 'encoding',
      offset: uI({
        channel: o,
        channelDef: s,
        markDef: n,
        config: null == r ? void 0 : r.config,
        scaleName: r.scaleName(o),
        scale: r.getScaleComponent(o),
        stack: null,
        defaultRef: zR(u),
        bandPosition: i,
      }),
    };
  const a = n[o];
  return a ? { offsetType: 'visual', offset: a } : {};
}
function zG(t, n, { defaultPos: e, vgChannel: r }) {
  const { encoding: i, markDef: o, config: u, stack: s } = n,
    a = i[t],
    c = i[PP(t)],
    l = n.scaleName(t),
    f = n.getScaleComponent(t),
    { offset: h, offsetType: d } = _G({ channel: t, markDef: o, encoding: i, model: n, bandPosition: 0.5 }),
    p = TG({ model: n, defaultPos: e, channel: t, scaleName: l, scale: f }),
    m =
      !a && VP(t) && (i.latitude || i.longitude)
        ? { field: n.getName(t) }
        : (function (t) {
            const { channel: n, channelDef: e, scaleName: r, stack: i, offset: o, markDef: u } = t;
            if (II(e) && i && n === i.fieldChannel) {
              if (TI(e)) {
                let t = e.bandPosition;
                if ((void 0 !== t || 'text' !== u.type || ('radius' !== n && 'theta' !== n) || (t = 0.5), void 0 !== t))
                  return oI({ scaleName: r, fieldOrDatumDef: e, startSuffix: 'start', bandPosition: t, offset: o });
              }
              return iI(e, r, { suffix: 'end' }, { offset: o });
            }
            return nI(t);
          })({
            channel: t,
            channelDef: a,
            channel2Def: c,
            markDef: o,
            config: u,
            scaleName: l,
            scale: f,
            stack: s,
            offset: h,
            defaultRef: p,
            bandPosition: 'encoding' === d ? 0 : void 0,
          });
  return m ? { [r || t]: m } : void 0;
}
function TG({ model: t, defaultPos: n, channel: e, scaleName: r, scale: i }) {
  const { markDef: o, config: u } = t;
  return () => {
    const s = zP(e),
      a = TP(e),
      c = qR(e, o, u, { vgChannel: a });
    if (void 0 !== c) return sI(e, c);
    switch (n) {
      case 'zeroOrMin':
      case 'zeroOrMax':
        if (r) {
          const t = i.get('type');
          if (oT(['log', aq, cq], t));
          else if (i.domainDefinitelyIncludesZero()) return { scale: r, value: 0 };
        }
        if ('zeroOrMin' === n) return 'y' === s ? { field: { group: 'height' } } : { value: 0 };
        switch (s) {
          case 'radius':
            return { signal: `min(${t.width.signal},${t.height.signal})/2` };
          case 'theta':
            return { signal: '2*PI' };
          case 'x':
            return { field: { group: 'width' } };
          case 'y':
            return { value: 0 };
        }
        break;
      case 'mid': {
        const n = t[RP(e)];
        return Object.assign(Object.assign({}, n), { mult: 0.5 });
      }
    }
  };
}
const PG = { left: 'x', center: 'xc', right: 'x2' },
  RG = { top: 'y', middle: 'yc', bottom: 'y2' };
function LG(t, n, e, r = 'middle') {
  if ('radius' === t || 'theta' === t) return TP(t);
  const i = 'x' === t ? 'align' : 'baseline',
    o = qR(i, n, e);
  let u;
  return (
    MR(o)
      ? (DL(
          (function (t) {
            return `The ${t} for range marks cannot be an expression`;
          })(i),
        ),
        (u = void 0))
      : (u = o),
    'x' === t ? PG[u || ('top' === r ? 'left' : 'center')] : RG[u || r]
  );
}
function qG(t, n, { defaultPos: e, defaultPos2: r, range: i }) {
  return i ? IG(t, n, { defaultPos: e, defaultPos2: r }) : zG(t, n, { defaultPos: e });
}
function IG(t, n, { defaultPos: e, defaultPos2: r }) {
  const { markDef: i, config: o } = n,
    u = PP(t),
    s = RP(t),
    a = (function (t, n, e) {
      const { encoding: r, mark: i, markDef: o, stack: u, config: s } = t,
        a = zP(e),
        c = RP(e),
        l = TP(e),
        f = r[a],
        h = t.scaleName(a),
        d = t.getScaleComponent(a),
        { offset: p } = _G(
          e in r || e in o
            ? { channel: e, markDef: o, encoding: r, model: t }
            : { channel: a, markDef: o, encoding: r, model: t },
        );
      if (!f && ('x2' === e || 'y2' === e) && (r.latitude || r.longitude)) {
        const n = RP(e),
          r = t.markDef[n];
        return null != r ? { [n]: { value: r } } : { [l]: { field: t.getName(e) } };
      }
      const m = (function ({
        channel: t,
        channelDef: n,
        channel2Def: e,
        markDef: r,
        config: i,
        scaleName: o,
        scale: u,
        stack: s,
        offset: a,
        defaultRef: c,
      }) {
        return II(n) && s && t.charAt(0) === s.fieldChannel.charAt(0)
          ? iI(n, o, { suffix: 'start' }, { offset: a })
          : nI({
              channel: t,
              channelDef: e,
              scaleName: o,
              scale: u,
              stack: s,
              markDef: r,
              config: i,
              offset: a,
              defaultRef: c,
            });
      })({
        channel: e,
        channelDef: f,
        channel2Def: r[e],
        markDef: o,
        config: s,
        scaleName: h,
        scale: d,
        stack: u,
        offset: p,
        defaultRef: void 0,
      });
      return void 0 !== m
        ? { [l]: m }
        : UG(e, o) ||
            UG(e, { [e]: UR(e, o, s.style), [c]: UR(c, o, s.style) }) ||
            UG(e, s[i]) ||
            UG(e, s.mark) || { [l]: TG({ model: t, defaultPos: n, channel: e, scaleName: h, scale: d })() };
    })(n, r, u),
    c = a[s] ? LG(t, i, o) : TP(t);
  return Object.assign(Object.assign({}, zG(t, n, { defaultPos: e, vgChannel: c })), a);
}
function UG(t, n) {
  const e = RP(t),
    r = TP(t);
  if (void 0 !== n[r]) return { [r]: sI(t, n[r]) };
  if (void 0 !== n[t]) return { [r]: sI(t, n[t]) };
  if (n[e]) {
    const r = n[e];
    if (!Kq(r)) return { [e]: sI(t, r) };
    DL(
      (function (t) {
        return `Position range does not support relative band size for ${t}.`;
      })(e),
    );
  }
}
function WG(t, n) {
  var e, r;
  const { config: i, encoding: o, markDef: u } = t,
    s = u.type,
    a = PP(n),
    c = RP(n),
    l = o[n],
    f = o[a],
    h = t.getScaleComponent(n),
    d = h ? h.get('type') : void 0,
    p = u.orient,
    m =
      null !== (r = null !== (e = o[c]) && void 0 !== e ? e : o.size) && void 0 !== r
        ? r
        : qR('size', u, i, { vgChannel: c }),
    v = 'bar' === s && ('x' === n ? 'vertical' === p : 'horizontal' === p);
  return !TI(l) || !(gR(l.bin) || bR(l.bin) || (l.timeUnit && !f)) || (m && !Kq(m)) || Oq(d)
    ? ((II(l) && Oq(d)) || v) && !f
      ? (function (t, n, e) {
          const { markDef: r, encoding: i, config: o, stack: u } = e,
            s = r.orient,
            a = e.scaleName(n),
            c = e.getScaleComponent(n),
            l = RP(n),
            f = PP(n),
            h = (function (t) {
              switch (t) {
                case IT:
                  return 'xOffset';
                case UT:
                  return 'yOffset';
                case WT:
                  return 'x2Offset';
                case HT:
                  return 'y2Offset';
                case JT:
                  return 'thetaOffset';
                case YT:
                  return 'radiusOffset';
                case QT:
                  return 'theta2Offset';
                case XT:
                  return 'radius2Offset';
              }
            })(n),
            d = e.scaleName(h),
            p = ('horizontal' === s && 'y' === n) || ('vertical' === s && 'x' === n);
          let m;
          (i.size || r.size) &&
            (p
              ? (m = NG('size', e, { vgChannel: l, defaultRef: zR(r.size) }))
              : DL(
                  (function (t) {
                    return `Cannot apply size to non-oriented mark "${t}".`;
                  })(r.type),
                ));
          const v = !!m,
            g = CI({
              channel: n,
              fieldDef: t,
              markDef: r,
              config: o,
              scaleType: null == c ? void 0 : c.get('type'),
              useVlSizeChannel: p,
            });
          m = m || { [l]: HG(l, d || a, c, o, g) };
          const b = LG(n, r, o, 'band' === (null == c ? void 0 : c.get('type')) && Kq(g) && !v ? 'top' : 'middle'),
            y = 'xc' === b || 'yc' === b,
            { offset: w, offsetType: x } = _G({
              channel: n,
              markDef: r,
              encoding: i,
              model: e,
              bandPosition: y ? 0.5 : 0,
            }),
            O = nI({
              channel: n,
              channelDef: t,
              markDef: r,
              config: o,
              scaleName: a,
              scale: c,
              stack: u,
              offset: w,
              defaultRef: TG({ model: e, defaultPos: 'mid', channel: n, scaleName: a, scale: c }),
              bandPosition: y
                ? 'encoding' === x
                  ? 0
                  : 0.5
                : MR(g)
                ? { signal: `(1-${g})/2` }
                : Kq(g)
                ? (1 - g.band) / 2
                : 0,
            });
          if (l) return Object.assign({ [b]: O }, m);
          {
            const t = TP(f),
              n = m[l],
              e = w ? Object.assign(Object.assign({}, n), { offset: w }) : n;
            return {
              [b]: O,
              [t]: K(O)
                ? [O[0], Object.assign(Object.assign({}, O[1]), { offset: e })]
                : Object.assign(Object.assign({}, O), { offset: e }),
            };
          }
        })(l, n, t)
      : IG(n, t, { defaultPos: 'zeroOrMax', defaultPos2: 'zeroOrMin' })
    : (function ({ fieldDef: t, fieldDef2: n, channel: e, model: r }) {
        var i, o, u;
        const { config: s, markDef: a, encoding: c } = r,
          l = r.getScaleComponent(e),
          f = r.scaleName(e),
          h = l ? l.get('type') : void 0,
          d = l.get('reverse'),
          p = CI({ channel: e, fieldDef: t, markDef: a, config: s, scaleType: h }),
          m = null === (i = r.component.axes[e]) || void 0 === i ? void 0 : i[0],
          v = null !== (o = null == m ? void 0 : m.get('translate')) && void 0 !== o ? o : 0.5,
          g = VP(e) && null !== (u = qR('binSpacing', a, s)) && void 0 !== u ? u : 0,
          b = PP(e),
          y = TP(e),
          w = TP(b),
          { offset: x } = _G({ channel: e, markDef: a, encoding: c, model: r, bandPosition: 0 }),
          O = MR(p) ? { signal: `(1-${p.signal})/2` } : Kq(p) ? (1 - p.band) / 2 : 0.5;
        if (gR(t.bin) || t.timeUnit)
          return {
            [w]: VG({ fieldDef: t, scaleName: f, bandPosition: O, offset: GG(b, g, d, v, x) }),
            [y]: VG({
              fieldDef: t,
              scaleName: f,
              bandPosition: MR(O) ? { signal: `1-${O.signal}` } : 1 - O,
              offset: GG(e, g, d, v, x),
            }),
          };
        if (bR(t.bin)) {
          const r = iI(t, f, {}, { offset: GG(b, g, d, v, x) });
          if (TI(n)) return { [w]: r, [y]: iI(n, f, {}, { offset: GG(e, g, d, v, x) }) };
          if (yR(t.bin) && t.bin.step)
            return {
              [w]: r,
              [y]: { signal: `scale("${f}", ${JI(t, { expr: 'datum' })} + ${t.bin.step})`, offset: GG(e, g, d, v, x) },
            };
        }
        DL($L(b));
      })({ fieldDef: l, fieldDef2: f, channel: n, model: t });
}
function HG(t, n, e, r, i) {
  if (Kq(i)) {
    if (!e) return { mult: i.band, field: { group: t } };
    {
      const t = e.get('type');
      if ('band' === t) {
        let t = `bandwidth('${n}')`;
        return 1 !== i.band && (t = `${i.band} * ${t}`), { signal: `max(0.25, ${t})` };
      }
      1 !== i.band &&
        (DL(
          (function (t) {
            return `Cannot use the relative band size with ${t} scale.`;
          })(t),
        ),
        (i = void 0));
    }
  } else {
    if (MR(i)) return i;
    if (i) return { value: i };
  }
  if (e) {
    const t = e.get('range');
    if (jR(t) && Vt(t.step)) return { value: t.step - 2 };
  }
  return { value: DW(r.view, t) - 2 };
}
function GG(t, n, e, r, i) {
  if (OP(t)) return 0;
  const o = 'x' === t || 'y2' === t ? -n / 2 : n / 2;
  if (MR(e) || MR(i) || MR(r)) {
    const t = RR(e),
      n = RR(i),
      u = RR(r);
    return { signal: (u ? `${u} + ` : '') + (t ? `(${t} ? -1 : 1) * ` : '') + (n ? `(${n} + ${o})` : o) };
  }
  return (i = i || 0), r + (e ? -i - o : +i + o);
}
function VG({ fieldDef: t, scaleName: n, bandPosition: e, offset: r }) {
  return oI({ scaleName: n, fieldOrDatumDef: t, bandPosition: e, offset: r });
}
const YG = new Set(['aria', 'width', 'height']);
function XG(t, n) {
  const { fill: e, stroke: r } = 'include' === n.color ? BG(t) : {};
  return Object.assign(
    Object.assign(
      Object.assign(
        Object.assign(
          Object.assign(
            Object.assign(
              Object.assign(
                Object.assign(
                  Object.assign(
                    Object.assign(
                      Object.assign(
                        Object.assign(
                          {},
                          (function (t, n) {
                            return FR.reduce(
                              (e, r) => (YG.has(r) || void 0 === t[r] || 'ignore' === n[r] || (e[r] = zR(t[r])), e),
                              {},
                            );
                          })(t.markDef, n),
                        ),
                        JG(t, 'fill', e),
                      ),
                      JG(t, 'stroke', r),
                    ),
                    NG('opacity', t),
                  ),
                  NG('fillOpacity', t),
                ),
                NG('strokeOpacity', t),
              ),
              NG('strokeWidth', t),
            ),
            NG('strokeDash', t),
          ),
          (function (t) {
            const { encoding: n, mark: e } = t,
              r = n.order;
            return !Gq(e) && WI(r) ? jG(t, r, 'zindex', t => zR(t.value)) : {};
          })(t),
        ),
        EG(t),
      ),
      DG(t, 'href'),
    ),
    (function (t) {
      const { markDef: n, config: e } = t,
        r = qR('aria', n, e);
      return !1 === r
        ? {}
        : Object.assign(
            Object.assign(
              Object.assign({}, r ? { aria: r } : {}),
              (function (t) {
                const { mark: n, markDef: e, config: r } = t;
                if (!1 === r.aria) return {};
                const i = qR('ariaRoleDescription', e, r);
                return null != i
                  ? { ariaRoleDescription: { value: i } }
                  : n in ER
                  ? {}
                  : { ariaRoleDescription: { value: n } };
              })(t),
            ),
            (function (t) {
              const { encoding: n, markDef: e, config: r, stack: i } = t,
                o = n.description;
              if (o) return jG(t, o, 'description', n => FG(n, t.config));
              const u = qR('description', e, r);
              if (null != u) return { description: zR(u) };
              if (!1 === r.aria) return {};
              const s = SG(n, i, r);
              return mT(s)
                ? void 0
                : {
                    description: {
                      signal: bT(s)
                        .map(([t, n], e) => `"${e > 0 ? '; ' : ''}${t}: " + (${n})`)
                        .join(' + '),
                    },
                  };
            })(t),
          );
    })(t),
  );
}
function JG(t, n, e) {
  const { config: r, mark: i, markDef: o } = t;
  if ('hide' === qR('invalid', o, r) && e && !Gq(i)) {
    const r = (function (t, { invalid: n = !1, channels: e }) {
      const r = e.reduce((n, e) => {
          const r = t.getScaleComponent(e);
          if (r) {
            const i = r.get('type'),
              o = t.vgField(e, { expr: 'datum' });
            o && kq(i) && (n[o] = !0);
          }
          return n;
        }, {}),
        i = vT(r);
      if (i.length > 0) {
        const t = n ? '||' : '&&';
        return i.map(t => rI(t, n)).join(` ${t} `);
      }
    })(t, { invalid: !0, channels: eR });
    if (r) return { [n]: [{ test: r, value: null }, ...At(e)] };
  }
  return e ? { [n]: e } : {};
}
function QG(t) {
  const { config: n, markDef: e } = t;
  if (qR('invalid', e, n)) {
    const n = (function (t, { invalid: n = !1, channels: e }) {
      const r = e.reduce((n, e) => {
          var r;
          const i = t.getScaleComponent(e);
          if (i) {
            const o = i.get('type'),
              u = t.vgField(e, {
                expr: 'datum',
                binSuffix: (null === (r = t.stack) || void 0 === r ? void 0 : r.impute) ? 'mid' : void 0,
              });
            u && kq(o) && (n[u] = !0);
          }
          return n;
        }, {}),
        i = vT(r);
      if (i.length > 0) {
        const t = n ? '||' : '&&';
        return i.map(t => rI(t, n)).join(` ${t} `);
      }
    })(t, { channels: GP });
    if (n) return { defined: { signal: n } };
  }
  return {};
}
function ZG(t, n) {
  if (void 0 !== n) return { [t]: zR(n) };
}
const KG = 'voronoi',
  tV = {
    defined: t => 'point' === t.type && t.nearest,
    parse: (t, n) => {
      if (n.events) for (const e of n.events) e.markname = t.getName(KG);
    },
    marks: (t, n, e) => {
      const { x: r, y: i } = n.project.hasChannel,
        o = t.mark;
      if (Gq(o)) return DL(`The "nearest" transform is not supported for ${o} marks.`), e;
      const u = {
        name: t.getName(KG),
        type: 'path',
        interactive: !0,
        from: { data: t.getName('marks') },
        encode: {
          update: Object.assign(
            {
              fill: { value: 'transparent' },
              strokeWidth: { value: 0.35 },
              stroke: { value: 'transparent' },
              isVoronoi: { value: !0 },
            },
            EG(t, { reactiveGeom: !0 }),
          ),
        },
        transform: [
          {
            type: 'voronoi',
            x: { expr: r || !i ? 'datum.datum.x || 0' : '0' },
            y: { expr: i || !r ? 'datum.datum.y || 0' : '0' },
            size: [t.getSizeSignalRef('width'), t.getSizeSignalRef('height')],
          },
        ],
      };
      let s = 0,
        a = !1;
      return (
        e.forEach((n, e) => {
          var r;
          const i = null !== (r = n.name) && void 0 !== r ? r : '';
          i === t.component.mark[0].name ? (s = e) : i.indexOf(KG) >= 0 && (a = !0);
        }),
        a || e.splice(s + 1, 0, u),
        e
      );
    },
  },
  nV = {
    defined: t => 'point' === t.type && 'global' === t.resolve && t.bind && 'scales' !== t.bind && !mW(t.bind),
    parse: (t, n, e) => xV(n, e),
    topLevelSignals: (t, n, e) => {
      const r = n.name,
        i = n.project,
        o = n.bind,
        u = n.init && n.init[0],
        s = tV.defined(n) ? '(item().isVoronoi ? datum.datum : datum)' : 'datum';
      return (
        i.items.forEach((t, i) => {
          var a, c;
          const l = wT(`${r}_${t.field}`);
          e.filter(t => t.name === l).length ||
            e.unshift(
              Object.assign(Object.assign({ name: l }, u ? { init: aG(u[i]) } : { value: null }), {
                on: n.events
                  ? [
                      {
                        events: n.events,
                        update: `datum && item().mark.marktype !== 'group' ? ${s}[${rn(t.field)}] : null`,
                      },
                    ]
                  : [],
                bind:
                  null !== (c = null !== (a = o[t.field]) && void 0 !== a ? a : o[t.channel]) && void 0 !== c ? c : o,
              }),
            );
        }),
        e
      );
    },
    signals: (t, n, e) => {
      const r = n.name,
        i = n.project,
        o = e.filter(t => t.name === r + mV)[0],
        u = r + vG,
        s = i.items.map(t => wT(`${r}_${t.field}`)),
        a = s.map(t => `${t} !== null`).join(' && ');
      return (
        s.length && (o.update = `${a} ? {fields: ${u}, values: [${s.join(', ')}]} : null`),
        delete o.value,
        delete o.on,
        e
      );
    },
  },
  eV = '_toggle',
  rV = {
    defined: t => 'point' === t.type && !!t.toggle,
    signals: (t, n, e) => e.concat({ name: n.name + eV, value: !1, on: [{ events: n.events, update: n.toggle }] }),
    modifyExpr: (t, n) => {
      const e = n.name + mV,
        r = n.name + eV;
      return (
        `${r} ? null : ${e}, ` +
        ('global' === n.resolve ? `${r} ? null : true, ` : `${r} ? null : {unit: ${yV(t)}}, `) +
        `${r} ? ${e} : null`
      );
    },
  },
  iV = {
    defined: t => void 0 !== t.clear && !1 !== t.clear,
    parse: (t, n) => {
      n.clear && (n.clear = Xt(n.clear) ? JC(n.clear, 'view') : n.clear);
    },
    topLevelSignals: (t, n, e) => {
      if (nV.defined(n))
        for (const t of n.project.items) {
          const r = e.findIndex(e => e.name === wT(`${n.name}_${t.field}`));
          -1 !== r && e[r].on.push({ events: n.clear, update: 'null' });
        }
      return e;
    },
    signals: (t, n, e) => {
      function r(t, r) {
        -1 !== t && e[t].on && e[t].on.push({ events: n.clear, update: r });
      }
      if ('interval' === n.type)
        for (const t of n.project.items) {
          const n = e.findIndex(n => n.name === t.signals.visual);
          r(n, '[0, 0]'),
            -1 === n &&
              r(
                e.findIndex(n => n.name === t.signals.data),
                'null',
              );
        }
      else {
        let t = e.findIndex(t => t.name === n.name + mV);
        r(t, 'null'), rV.defined(n) && ((t = e.findIndex(t => t.name === n.name + eV)), r(t, 'false'));
      }
      return e;
    },
  },
  oV = {
    defined: t => {
      const n = 'global' === t.resolve && t.bind && mW(t.bind),
        e = 1 === t.project.items.length && t.project.items[0].field !== dW;
      return (
        n &&
          !e &&
          DL('Legend bindings are only supported for selections over an individual field or encoding channel.'),
        n && e
      );
    },
    parse: (t, n, e) => {
      var r;
      const i = Zz(e);
      if (
        ((i.select = Xt(i.select)
          ? { type: i.select, toggle: n.toggle }
          : Object.assign(Object.assign({}, i.select), { toggle: n.toggle })),
        xV(n, i),
        tt(e.select) && (e.select.on || e.select.clear))
      ) {
        const t = 'event.item && indexof(event.item.mark.role, "legend") < 0';
        for (const e of n.events)
          (e.filter = At(null !== (r = e.filter) && void 0 !== r ? r : [])), e.filter.includes(t) || e.filter.push(t);
      }
      const o = vW(n.bind) ? n.bind.legend : 'click',
        u = Xt(o) ? JC(o, 'view') : At(o);
      n.bind = { legend: { merge: u } };
    },
    topLevelSignals: (t, n, e) => {
      const r = n.name,
        i = vW(n.bind) && n.bind.legend,
        o = t => n => {
          const e = Zz(n);
          return (e.markname = t), e;
        };
      for (const t of n.project.items) {
        if (!t.hasLegend) continue;
        const u = `${wT(t.field)}_legend`,
          s = `${r}_${u}`;
        if (0 === e.filter(t => t.name === s).length) {
          const t = i.merge
            .map(o(`${u}_symbols`))
            .concat(i.merge.map(o(`${u}_labels`)))
            .concat(i.merge.map(o(`${u}_entries`)));
          e.unshift(
            Object.assign(Object.assign({ name: s }, n.init ? {} : { value: null }), {
              on: [
                { events: t, update: 'datum.value || item().items[0].items[0].datum.value', force: !0 },
                { events: i.merge, update: `!event.item || !datum ? null : ${s}`, force: !0 },
              ],
            }),
          );
        }
      }
      return e;
    },
    signals: (t, n, e) => {
      const r = n.name,
        i = n.project,
        o = e.find(t => t.name === r + mV),
        u = r + vG,
        s = i.items.filter(t => t.hasLegend).map(t => wT(`${r}_${wT(t.field)}_legend`)),
        a = `${s.map(t => `${t} !== null`).join(' && ')} ? {fields: ${u}, values: [${s.join(', ')}]} : null`;
      n.events && s.length > 0
        ? o.on.push({ events: s.map(t => ({ signal: t })), update: a })
        : s.length > 0 && ((o.update = a), delete o.value, delete o.on);
      const c = e.find(t => t.name === r + eV),
        l = vW(n.bind) && n.bind.legend;
      return (
        c && (n.events ? c.on.push(Object.assign(Object.assign({}, c.on[0]), { events: l })) : (c.on[0].events = l)), e
      );
    },
  },
  uV = '_translate_anchor',
  sV = '_translate_delta',
  aV = {
    defined: t => 'interval' === t.type && t.translate,
    signals: (t, n, e) => {
      const r = n.name,
        i = yG.defined(n),
        o = r + uV,
        { x: u, y: s } = n.project.hasChannel;
      let a = JC(n.translate, 'scope');
      return (
        i || (a = a.map(t => ((t.between[0].markname = r + OG), t))),
        e.push(
          {
            name: o,
            value: {},
            on: [
              {
                events: a.map(t => t.between[0]),
                update:
                  '{x: x(unit), y: y(unit)' +
                  (void 0 !== u ? `, extent_x: ${i ? wG(t, IT) : `slice(${u.signals.visual})`}` : '') +
                  (void 0 !== s ? `, extent_y: ${i ? wG(t, UT) : `slice(${s.signals.visual})`}` : '') +
                  '}',
              },
            ],
          },
          { name: r + sV, value: {}, on: [{ events: a, update: `{x: ${o}.x - x(unit), y: ${o}.y - y(unit)}` }] },
        ),
        void 0 !== u && cV(t, n, u, 'width', e),
        void 0 !== s && cV(t, n, s, 'height', e),
        e
      );
    },
  };
function cV(t, n, e, r, i) {
  var o, u;
  const s = n.name,
    a = s + uV,
    c = s + sV,
    l = e.channel,
    f = yG.defined(n),
    h = i.filter(t => t.name === e.signals[f ? 'data' : 'visual'])[0],
    d = t.getSizeSignalRef(r).signal,
    p = t.getScaleComponent(l),
    m = p.get('type'),
    v = p.get('reverse'),
    g = `${a}.extent_${l}`,
    b = `${
      f ? ('log' === m ? 'panLog' : 'symlog' === m ? 'panSymlog' : 'pow' === m ? 'panPow' : 'panLinear') : 'panLinear'
    }(${g}, ${f ? (l === IT ? (v ? '' : '-') : v ? '-' : '') : ''}${c}.${l} / ${f ? `${d}` : `span(${g})`}${
      f
        ? 'pow' === m
          ? `, ${null !== (o = p.get('exponent')) && void 0 !== o ? o : 1}`
          : 'symlog' === m
          ? `, ${null !== (u = p.get('constant')) && void 0 !== u ? u : 1}`
          : ''
        : ''
    })`;
  h.on.push({ events: { signal: c }, update: f ? b : `clampRange(${b}, 0, ${d})` });
}
const lV = '_zoom_anchor',
  fV = '_zoom_delta',
  hV = {
    defined: t => 'interval' === t.type && t.zoom,
    signals: (t, n, e) => {
      const r = n.name,
        i = yG.defined(n),
        o = r + fV,
        { x: u, y: s } = n.project.hasChannel,
        a = rn(t.scaleName(IT)),
        c = rn(t.scaleName(UT));
      let l = JC(n.zoom, 'scope');
      return (
        i || (l = l.map(t => ((t.markname = r + OG), t))),
        e.push(
          {
            name: r + lV,
            on: [
              {
                events: l,
                update: i
                  ? '{' +
                    [a ? `x: invert(${a}, x(unit))` : '', c ? `y: invert(${c}, y(unit))` : '']
                      .filter(t => !!t)
                      .join(', ') +
                    '}'
                  : '{x: x(unit), y: y(unit)}',
              },
            ],
          },
          { name: o, on: [{ events: l, force: !0, update: 'pow(1.001, event.deltaY * pow(16, event.deltaMode))' }] },
        ),
        void 0 !== u && dV(t, n, u, 'width', e),
        void 0 !== s && dV(t, n, s, 'height', e),
        e
      );
    },
  };
function dV(t, n, e, r, i) {
  var o, u;
  const s = n.name,
    a = e.channel,
    c = yG.defined(n),
    l = i.filter(t => t.name === e.signals[c ? 'data' : 'visual'])[0],
    f = t.getSizeSignalRef(r).signal,
    h = t.getScaleComponent(a),
    d = h.get('type'),
    p = c ? wG(t, a) : l.name,
    m = s + fV,
    v = `${
      c
        ? 'log' === d
          ? 'zoomLog'
          : 'symlog' === d
          ? 'zoomSymlog'
          : 'pow' === d
          ? 'zoomPow'
          : 'zoomLinear'
        : 'zoomLinear'
    }(${p}, ${s}${lV}.${a}, ${m}${
      c
        ? 'pow' === d
          ? `, ${null !== (o = h.get('exponent')) && void 0 !== o ? o : 1}`
          : 'symlog' === d
          ? `, ${null !== (u = h.get('constant')) && void 0 !== u ? u : 1}`
          : ''
        : ''
    })`;
  l.on.push({ events: { signal: m }, update: c ? v : `clampRange(${v}, 0, ${f})` });
}
const pV = '_store',
  mV = '_tuple',
  vV = '_modify',
  gV = 'vlSelectionResolve',
  bV = [MG, AG, bG, rV, nV, yG, oV, iV, aV, hV, tV];
function yV(t, { escape: n } = { escape: !0 }) {
  let e = n ? rn(t.name) : t.name;
  const r = (function (t) {
    let n = t.parent;
    for (; n && !ZX(n); ) n = n.parent;
    return n;
  })(t);
  if (r) {
    const { facet: t } = r;
    for (const n of DP) t[n] && (e += ` + '__facet_${n}_' + (facet[${rn(r.vgField(n))}])`);
  }
  return e;
}
function wV(t) {
  var n;
  return gT(null !== (n = t.component.selection) && void 0 !== n ? n : {}).reduce(
    (t, n) => t || n.project.hasSelectionId,
    !1,
  );
}
function xV(t, n) {
  (!Xt(n.select) && n.select.on) || delete t.events,
    (!Xt(n.select) && n.select.clear) || delete t.clear,
    (!Xt(n.select) && n.select.toggle) || delete t.toggle;
}
function OV(t) {
  const n = [];
  return 'Identifier' === t.type
    ? [t.name]
    : 'Literal' === t.type
    ? [t.value]
    : ('MemberExpression' === t.type && (n.push(...OV(t.object)), n.push(...OV(t.property))), n);
}
function kV(t) {
  return 'MemberExpression' === t.object.type ? kV(t.object) : 'datum' === t.object.name;
}
function AV(t) {
  const n = IE(t),
    e = new Set();
  return (
    n.visit(t => {
      'MemberExpression' === t.type && kV(t) && e.add(OV(t).slice(1).join('.'));
    }),
    e
  );
}
class $V extends hG {
  constructor(t, n, e) {
    super(t),
      (this.model = n),
      (this.filter = e),
      (this.expr = DV(this.model, this.filter, this)),
      (this._dependentFields = AV(this.expr));
  }
  clone() {
    return new $V(null, this.model, Zz(this.filter));
  }
  dependentFields() {
    return this._dependentFields;
  }
  producedFields() {
    return new Set();
  }
  assemble() {
    return { type: 'filter', expr: this.expr };
  }
  hash() {
    return `Filter ${this.expr}`;
  }
}
function MV(t, n, e, r = 'datum') {
  const i = Xt(n) ? n : n.param,
    o = wT(i),
    u = rn(o + pV);
  let s;
  try {
    s = t.getSelectionComponent(o, i);
  } catch (t) {
    return `!!${o}`;
  }
  if (s.project.timeUnit) {
    const n = null != e ? e : t.component.data.raw,
      r = s.project.timeUnit.clone();
    n.parent ? r.insertAsParentOf(n) : (n.parent = r);
  }
  const a = `${s.project.hasSelectionId ? 'vlSelectionIdTest(' : 'vlSelectionTest('}${u}, ${r}${
      'global' === s.resolve ? ')' : `, ${rn(s.resolve)})`
    }`,
    c = `length(data(${u}))`;
  return !1 === n.empty ? `${c} && ${a}` : `!${c} || ${a}`;
}
function jV(t, n, e) {
  const r = wT(n),
    i = e.encoding;
  let o,
    u = e.field;
  try {
    o = t.getSelectionComponent(r, n);
  } catch (t) {
    return r;
  }
  if (i || u) {
    if (i && !u) {
      const t = o.project.items.filter(t => t.channel === i);
      !t.length || t.length > 1
        ? ((u = o.project.items[0].field),
          DL(
            (t.length ? 'Multiple ' : 'No ') +
              `matching ${rn(i)} encoding found for selection ${rn(e.param)}. ` +
              `Using "field": ${rn(u)}.`,
          ))
        : (u = t[0].field);
    }
  } else
    (u = o.project.items[0].field),
      o.project.items.length > 1 &&
        DL(
          `A "field" or "encoding" must be specified when using a selection as a scale domain. Using "field": ${rn(
            u,
          )}.`,
        );
  return `${o.name}[${rn(jT(u))}]`;
}
function DV(t, n, e) {
  return xT(n, n =>
    Xt(n)
      ? n
      : (function (t) {
          return null == t ? void 0 : t.param;
        })(n)
      ? MV(t, n, e)
      : KL(n),
  );
}
var FV = function (t, n) {
  var e = {};
  for (var r in t) Object.prototype.hasOwnProperty.call(t, r) && n.indexOf(r) < 0 && (e[r] = t[r]);
  if (null != t && 'function' == typeof Object.getOwnPropertySymbols) {
    var i = 0;
    for (r = Object.getOwnPropertySymbols(t); i < r.length; i++)
      n.indexOf(r[i]) < 0 && Object.prototype.propertyIsEnumerable.call(t, r[i]) && (e[r[i]] = t[r[i]]);
  }
  return e;
};
function EV(t, n, e, r) {
  var i, o, u, s, a;
  (null !== (i = t.encode) && void 0 !== i) || (t.encode = {}),
    (null !== (o = (s = t.encode)[n]) && void 0 !== o) || (s[n] = {}),
    (null !== (u = (a = t.encode[n]).update) && void 0 !== u) || (a.update = {}),
    (t.encode[n].update[e] = r);
}
function SV(t, n, e, r = { header: !1 }) {
  var i, o;
  const u = t.combine(),
    { disable: s, orient: a, scale: c, labelExpr: l, title: f, zindex: h } = u,
    d = FV(u, ['disable', 'orient', 'scale', 'labelExpr', 'title', 'zindex']);
  if (!s) {
    for (const t in d) {
      const e = yU[t],
        r = d[t];
      if (e && e !== n && 'both' !== e) delete d[t];
      else if (gU(r)) {
        const { condition: n } = r,
          e = FV(r, ['condition']),
          i = At(n),
          o = vU[t];
        if (o) {
          const { vgProp: n, part: r } = o,
            u = [
              ...i.map(t => {
                const { test: n } = t,
                  e = FV(t, ['test']);
                return Object.assign({ test: DV(null, n) }, e);
              }),
              e,
            ];
          EV(d, r, n, u), delete d[t];
        } else if (null === o) {
          const n = {
            signal:
              i
                .map(t => {
                  const { test: n } = t,
                    e = FV(t, ['test']);
                  return `${DV(null, n)} ? ${PR(e)} : `;
                })
                .join('') + PR(e),
          };
          d[t] = n;
        }
      } else if (MR(r)) {
        const n = vU[t];
        if (n) {
          const { vgProp: e, part: i } = n;
          EV(d, i, e, r), delete d[t];
        }
      }
      oT(['labelAlign', 'labelBaseline'], t) && null === d[t] && delete d[t];
    }
    if ('grid' === n) {
      if (!d.grid) return;
      if (d.encode) {
        const { grid: t } = d.encode;
        (d.encode = Object.assign({}, t ? { grid: t } : {})), mT(d.encode) && delete d.encode;
      }
      return Object.assign(Object.assign({ scale: c, orient: a }, d), {
        domain: !1,
        labels: !1,
        aria: !1,
        maxExtent: 0,
        minExtent: 0,
        ticks: !1,
        zindex: ST(h, 0),
      });
    }
    {
      if (!r.header && t.mainExtracted) return;
      if (void 0 !== l) {
        let t = l;
        (null === (o = null === (i = d.encode) || void 0 === i ? void 0 : i.labels) || void 0 === o
          ? void 0
          : o.update) &&
          MR(d.encode.labels.update.text) &&
          (t = DT(l, 'datum.label', d.encode.labels.update.text.signal)),
          EV(d, 'labels', 'text', { signal: t });
      }
      if ((null === d.labelAlign && delete d.labelAlign, d.encode)) {
        for (const n of bU) t.hasAxisPart(n) || delete d.encode[n];
        mT(d.encode) && delete d.encode;
      }
      const n = (function (t, n) {
        if (t) return K(t) && !$R(t) ? t.map(t => rU(t, n)).join(', ') : t;
      })(f, e);
      return Object.assign(
        Object.assign(
          Object.assign(Object.assign({ scale: c, orient: a, grid: !1 }, n ? { title: n } : {}), d),
          !1 === e.aria ? { aria: !1 } : {},
        ),
        { zindex: ST(h, 0) },
      );
    }
  }
}
function CV(t) {
  const { axes: n } = t.component,
    e = [];
  for (const r of GP)
    if (n[r])
      for (const i of n[r])
        if (!i.get('disable') && !i.get('gridScale')) {
          const n = 'x' === r ? 'height' : 'width',
            i = t.getSizeSignalRef(n).signal;
          n !== i && e.push({ name: n, update: i });
        }
  return e;
}
function NV(t, n, e, r) {
  return Object.assign.apply(null, [
    {},
    ...t.map(t => {
      if ('axisOrient' === t) {
        const t = 'x' === e ? 'bottom' : 'left',
          i = n['x' === e ? 'axisBottom' : 'axisLeft'] || {},
          o = n['x' === e ? 'axisTop' : 'axisRight'] || {},
          u = new Set([...vT(i), ...vT(o)]),
          s = {};
        for (const n of u.values()) s[n] = { signal: `${r.signal} === "${t}" ? ${RR(i[n])} : ${RR(o[n])}` };
        return s;
      }
      return n[t];
    }),
  ]);
}
function BV(t, n) {
  var e;
  const r = [{}];
  for (const i of t) {
    let t = null === (e = n[i]) || void 0 === e ? void 0 : e.style;
    if (t) {
      t = At(t);
      for (const e of t) r.push(n.style[e]);
    }
  }
  return Object.assign.apply(null, r);
}
function _V(t, n, e, r = {}) {
  var i;
  const o = WR(t, e, n);
  if (void 0 !== o) return { configFrom: 'style', configValue: o };
  for (const n of ['vlOnlyAxisConfig', 'vgAxisConfig', 'axisConfigStyle'])
    if (void 0 !== (null === (i = r[n]) || void 0 === i ? void 0 : i[t]))
      return { configFrom: n, configValue: r[n][t] };
  return {};
}
const zV = {
  scale: ({ model: t, channel: n }) => t.scaleName(n),
  format: ({ fieldOrDatumDef: t, config: n, axis: e }) => {
    const { format: r, formatType: i } = e;
    return dI(t, t.type, r, i, n, !0);
  },
  formatType: ({ axis: t, fieldOrDatumDef: n, scaleType: e }) => {
    const { formatType: r } = t;
    return pI(r, n, e);
  },
  grid: ({ fieldOrDatumDef: t, axis: n, scaleType: e }) => {
    var r;
    return null !== (r = n.grid) && void 0 !== r
      ? r
      : (function (t, n) {
          return !Oq(t) && TI(n) && !gR(null == n ? void 0 : n.bin) && !bR(null == n ? void 0 : n.bin);
        })(e, t);
  },
  gridScale: ({ model: t, channel: n }) =>
    (function (t, n) {
      const e = 'x' === n ? 'y' : 'x';
      if (t.getScaleComponent(e)) return t.scaleName(e);
    })(t, n),
  labelAlign: ({ axis: t, labelAngle: n, orient: e, channel: r }) => t.labelAlign || RV(n, e, r),
  labelAngle: ({ labelAngle: t }) => t,
  labelBaseline: ({ axis: t, labelAngle: n, orient: e, channel: r }) => t.labelBaseline || PV(n, e, r),
  labelFlush: ({ axis: t, fieldOrDatumDef: n, channel: e }) => {
    var r;
    return null !== (r = t.labelFlush) && void 0 !== r
      ? r
      : (function (t, n) {
          if ('x' === n && oT(['quantitative', 'temporal'], t)) return !0;
        })(n.type, e);
  },
  labelOverlap: ({ axis: t, fieldOrDatumDef: n, scaleType: e }) => {
    var r;
    return null !== (r = t.labelOverlap) && void 0 !== r
      ? r
      : (function (t, n, e, r) {
          if ((e && !tt(r)) || ('nominal' !== t && 'ordinal' !== t)) return ('log' !== n && 'symlog' !== n) || 'greedy';
        })(n.type, e, TI(n) && !!n.timeUnit, TI(n) ? n.sort : void 0);
  },
  orient: ({ orient: t }) => t,
  tickCount: ({ channel: t, model: n, axis: e, fieldOrDatumDef: r, scaleType: i }) => {
    var o;
    const u = 'x' === t ? 'width' : 'y' === t ? 'height' : void 0,
      s = u ? n.getSizeSignalRef(u) : void 0;
    return null !== (o = e.tickCount) && void 0 !== o
      ? o
      : (function ({ fieldOrDatumDef: t, scaleType: n, size: e, values: r }) {
          var i;
          if (!r && !Oq(n) && 'log' !== n) {
            if (TI(t)) {
              if (gR(t.bin)) return { signal: `ceil(${e.signal}/10)` };
              if (
                t.timeUnit &&
                oT(
                  ['month', 'hours', 'day', 'quarter'],
                  null === (i = UL(t.timeUnit)) || void 0 === i ? void 0 : i.unit,
                )
              )
                return;
            }
            return { signal: `ceil(${e.signal}/40)` };
          }
        })({ fieldOrDatumDef: r, scaleType: i, size: s, values: e.values });
  },
  title: ({ axis: t, model: n, channel: e }) => {
    if (void 0 !== t.title) return t.title;
    const r = LV(n, e);
    if (void 0 !== r) return r;
    const i = n.typedFieldDef(e),
      o = n.fieldDef('x' === e ? 'x2' : 'y2');
    return GR(i ? [FI(i)] : [], TI(o) ? [FI(o)] : []);
  },
  values: ({ axis: t, fieldOrDatumDef: n }) =>
    (function (t, n) {
      const e = t.values;
      return K(e) ? pU(n, e) : MR(e) ? e : void 0;
    })(t, n),
  zindex: ({ axis: t, fieldOrDatumDef: n, mark: e }) => {
    var r;
    return null !== (r = t.zindex) && void 0 !== r
      ? r
      : (function (t, n) {
          return 'rect' === t && QI(n) ? 1 : 0;
        })(e, n);
  },
};
function TV(t) {
  return `(((${t.signal} % 360) + 360) % 360)`;
}
function PV(t, n, e, r) {
  if (void 0 !== t) {
    if ('x' === e) {
      if (MR(t)) {
        const e = TV(t);
        return {
          signal: `(45 < ${e} && ${e} < 135) || (225 < ${e} && ${e} < 315) ? "middle" :(${e} <= 45 || 315 <= ${e}) === ${
            MR(n) ? `(${n.signal} === "top")` : 'top' === n
          } ? "bottom" : "top"`,
        };
      }
      return (45 < t && t < 135) || (225 < t && t < 315)
        ? 'middle'
        : MR(n)
        ? { signal: `${n.signal} ${t <= 45 || 315 <= t ? '===' : '!=='} "top" ? "bottom" : "top"` }
        : (t <= 45 || 315 <= t) == ('top' === n)
        ? 'bottom'
        : 'top';
    }
    if (MR(t)) {
      const e = TV(t);
      return {
        signal: `${e} <= 45 || 315 <= ${e} || (135 <= ${e} && ${e} <= 225) ? ${
          r ? '"middle"' : 'null'
        } : (45 <= ${e} && ${e} <= 135) === ${MR(n) ? `(${n.signal} === "left")` : 'left' === n} ? "top" : "bottom"`,
      };
    }
    return t <= 45 || 315 <= t || (135 <= t && t <= 225)
      ? r
        ? 'middle'
        : null
      : MR(n)
      ? { signal: `${n.signal} ${45 <= t && t <= 135 ? '===' : '!=='} "left" ? "top" : "bottom"` }
      : (45 <= t && t <= 135) == ('left' === n)
      ? 'top'
      : 'bottom';
  }
}
function RV(t, n, e) {
  if (void 0 === t) return;
  const r = 'x' === e,
    i = r ? 0 : 90,
    o = r ? 'bottom' : 'left';
  if (MR(t)) {
    const e = TV(t);
    return {
      signal: `(${i ? `(${e} + 90)` : e} % 180 === 0) ? ${r ? null : '"center"'} :(${i} < ${e} && ${e} < ${
        180 + i
      }) === ${MR(n) ? `(${n.signal} === "${o}")` : n === o} ? "left" : "right"`,
    };
  }
  return (t + i) % 180 == 0
    ? r
      ? null
      : 'center'
    : MR(n)
    ? { signal: `${n.signal} ${i < t && t < 180 + i ? '===' : '!=='} "${o}" ? "left" : "right"` }
    : (i < t && t < 180 + i) == (n === o)
    ? 'left'
    : 'right';
}
function LV(t, n) {
  const e = 'x' === n ? 'x2' : 'y2',
    r = t.fieldDef(n),
    i = t.fieldDef(e),
    o = r ? r.title : void 0,
    u = i ? i.title : void 0;
  return o && u ? VR(o, u) : o || u || (void 0 !== o ? o : void 0 !== u ? u : void 0);
}
class qV extends hG {
  constructor(t, n) {
    super(t), (this.transform = n), (this._dependentFields = AV(this.transform.calculate));
  }
  clone() {
    return new qV(null, Zz(this.transform));
  }
  static parseAllForSortIndex(t, n) {
    return (
      n.forEachFieldDef((n, e) => {
        if (HI(n) && AI(n.sort)) {
          const { field: r, timeUnit: i } = n,
            o = n.sort,
            u = o.map((t, n) => `${KL({ field: r, timeUnit: i, equal: t })} ? ${n} : `).join('') + o.length;
          t = new qV(t, { calculate: u, as: IV(n, e, { forAs: !0 }) });
        }
      }),
      t
    );
  }
  producedFields() {
    return new Set([this.transform.as]);
  }
  dependentFields() {
    return this._dependentFields;
  }
  assemble() {
    return { type: 'formula', expr: this.transform.calculate, as: this.transform.as };
  }
  hash() {
    return `Calculate ${rT(this.transform)}`;
  }
}
function IV(t, n, e) {
  return JI(t, Object.assign({ prefix: n, suffix: 'sort_index' }, null != e ? e : {}));
}
function UV(t, n) {
  return oT(['top', 'bottom'], n) ? 'column' : oT(['left', 'right'], n) || 'row' === t ? 'row' : 'column';
}
function WV(t, n, e, r) {
  return ST(
    (n || {})[t],
    ('row' === r ? e.headerRow : 'column' === r ? e.headerColumn : e.headerFacet)[t],
    e.header[t],
  );
}
function HV(t, n, e, r) {
  const i = {};
  for (const o of t) {
    const t = WV(o, n || {}, e, r);
    void 0 !== t && (i[o] = t);
  }
  return i;
}
const GV = ['row', 'column'],
  VV = ['header', 'footer'];
function YV(t, n) {
  const e = t.component.layoutHeaders[n].title,
    r = t.config ? t.config : void 0,
    i = t.component.layoutHeaders[n].facetFieldDef ? t.component.layoutHeaders[n].facetFieldDef : void 0,
    {
      titleAnchor: o,
      titleAngle: u,
      titleOrient: s,
    } = HV(['titleAnchor', 'titleAngle', 'titleOrient'], i.header, r, n),
    a = UV(n, s),
    c = zT(u);
  return {
    name: `${n}-title`,
    type: 'group',
    role: `${a}-title`,
    title: Object.assign(
      Object.assign(
        Object.assign(
          Object.assign(Object.assign({ text: e }, 'row' === n ? { orient: 'left' } : {}), { style: 'guide-title' }),
          JV(c, a),
        ),
        XV(a, c, o),
      ),
      rY(r, i, n, cW, sW),
    ),
  };
}
function XV(t, n, e = 'middle') {
  switch (e) {
    case 'start':
      return { align: 'left' };
    case 'end':
      return { align: 'right' };
  }
  const r = RV(n, 'row' === t ? 'left' : 'top', 'row' === t ? 'y' : 'x');
  return r ? { align: r } : {};
}
function JV(t, n) {
  const e = PV(t, 'row' === n ? 'left' : 'top', 'row' === n ? 'y' : 'x', !0);
  return e ? { baseline: e } : {};
}
function QV(t, n) {
  const e = t.component.layoutHeaders[n],
    r = [];
  for (const i of VV)
    if (e[i])
      for (const o of e[i]) {
        const u = tY(t, n, i, e, o);
        null != u && r.push(u);
      }
  return r;
}
function ZV(t, n) {
  var e;
  const { sort: r } = t;
  return kI(r)
    ? { field: JI(r, { expr: 'datum' }), order: null !== (e = r.order) && void 0 !== e ? e : 'ascending' }
    : K(r)
    ? { field: IV(t, n, { expr: 'datum' }), order: 'ascending' }
    : { field: JI(t, { expr: 'datum' }), order: null != r ? r : 'ascending' };
}
function KV(t, n, e) {
  const {
      format: r,
      formatType: i,
      labelAngle: o,
      labelAnchor: u,
      labelOrient: s,
      labelExpr: a,
    } = HV(['format', 'formatType', 'labelAngle', 'labelAnchor', 'labelOrient', 'labelExpr'], t.header, e, n),
    c = lI({ fieldOrDatumDef: t, format: r, formatType: i, expr: 'parent', config: e }).signal,
    l = UV(n, s);
  return Object.assign(
    Object.assign(
      Object.assign(
        Object.assign(
          Object.assign(
            { text: { signal: a ? DT(DT(a, 'datum.label', c), 'datum.value', JI(t, { expr: 'parent' })) : c } },
            'row' === n ? { orient: 'left' } : {},
          ),
          { style: 'guide-label', frame: 'group' },
        ),
        JV(o, l),
      ),
      XV(l, o, u),
    ),
    rY(e, t, n, lW, aW),
  );
}
function tY(t, n, e, r, i) {
  if (i) {
    let o = null;
    const { facetFieldDef: u } = r,
      s = t.config ? t.config : void 0;
    if (u && i.labels) {
      const { labelOrient: t } = HV(['labelOrient'], u.header, s, n);
      (('row' === n && !oT(['top', 'bottom'], t)) || ('column' === n && !oT(['left', 'right'], t))) &&
        (o = KV(u, n, s));
    }
    const a = ZX(t) && !$I(t.facet),
      c = i.axes,
      l = (null == c ? void 0 : c.length) > 0;
    if (o || l) {
      const s = 'row' === n ? 'height' : 'width';
      return Object.assign(
        Object.assign(
          Object.assign(
            Object.assign(
              Object.assign(
                { name: t.getName(`${n}_${e}`), type: 'group', role: `${n}-${e}` },
                r.facetFieldDef ? { from: { data: t.getName(`${n}_domain`) }, sort: ZV(u, n) } : {},
              ),
              l && a ? { from: { data: t.getName(`facet_domain_${n}`) } } : {},
            ),
            o ? { title: o } : {},
          ),
          i.sizeSignal ? { encode: { update: { [s]: i.sizeSignal } } } : {},
        ),
        l ? { axes: c } : {},
      );
    }
  }
  return null;
}
const nY = { column: { start: 0, end: 1 }, row: { start: 1, end: 0 } };
function eY(t, n) {
  return nY[n][t];
}
function rY(t, n, e, r, i) {
  const o = {};
  for (const u of r) {
    if (!i[u]) continue;
    const r = WV(u, null == n ? void 0 : n.header, t, e);
    void 0 !== r && (o[i[u]] = r);
  }
  return o;
}
function iY(t) {
  return [...oY(t, 'width'), ...oY(t, 'height'), ...oY(t, 'childWidth'), ...oY(t, 'childHeight')];
}
function oY(t, n) {
  const e = 'width' === n ? 'x' : 'y',
    r = t.component.layoutSize.get(n);
  if (!r || 'merged' === r) return [];
  const i = t.getSizeSignalRef(n).signal;
  if ('step' === r) {
    const n = t.getScaleComponent(e);
    if (n) {
      const r = n.get('type'),
        o = n.get('range');
      if (Oq(r) && jR(o)) {
        const r = t.scaleName(e);
        return ZX(t.parent) && 'independent' === t.parent.component.resolve.scale[e]
          ? [uY(r, o)]
          : [uY(r, o), { name: i, update: sY(r, n, `domain('${r}').length`) }];
      }
    }
    throw new Error('layout size is step although width/height is not step.');
  }
  if ('container' == r) {
    const n = i.endsWith('width'),
      e = n ? 'containerSize()[0]' : 'containerSize()[1]',
      r = `isFinite(${e}) ? ${e} : ${jW(t.config.view, n ? 'width' : 'height')}`;
    return [{ name: i, init: r, on: [{ update: r, events: 'window:resize' }] }];
  }
  return [{ name: i, value: r }];
}
function uY(t, n) {
  const e = `${t}_step`;
  return MR(n.step) ? { name: e, update: n.step.signal } : { name: e, value: n.step };
}
function sY(t, n, e) {
  const r = n.get('type'),
    i = n.get('padding'),
    o = ST(n.get('paddingOuter'), i);
  let u = n.get('paddingInner');
  return (u = 'band' === r ? (void 0 !== u ? u : i) : 1), `bandspace(${e}, ${RR(u)}, ${RR(o)}) * ${t}_step`;
}
function aY(t) {
  return 'childWidth' === t ? 'width' : 'childHeight' === t ? 'height' : t;
}
function cY(t, n) {
  return vT(t).reduce((e, r) => {
    const i = t[r];
    return Object.assign(
      Object.assign({}, e),
      jG(n, i, r, t => zR(t.value)),
    );
  }, {});
}
function lY(t, n) {
  if (ZX(n)) return 'theta' === t ? 'independent' : 'shared';
  if (tJ(n)) return 'shared';
  if (KX(n)) return VP(t) || 'theta' === t || 'radius' === t ? 'independent' : 'shared';
  throw new Error('invalid model type for resolve');
}
function fY(t, n) {
  const e = t.scale[n],
    r = VP(n) ? 'axis' : 'legend';
  return 'independent' === e
    ? ('shared' === t[r][n] &&
        DL(
          (function (t) {
            return `Setting the scale to be independent for "${t}" means we also have to set the guide (axis or legend) to be independent.`;
          })(n),
        ),
      'independent')
    : t[r][n] || 'shared';
}
const hY = Object.assign(
    Object.assign(
      {},
      {
        aria: 1,
        clipHeight: 1,
        columnPadding: 1,
        columns: 1,
        cornerRadius: 1,
        description: 1,
        direction: 1,
        fillColor: 1,
        format: 1,
        formatType: 1,
        gradientLength: 1,
        gradientOpacity: 1,
        gradientStrokeColor: 1,
        gradientStrokeWidth: 1,
        gradientThickness: 1,
        gridAlign: 1,
        labelAlign: 1,
        labelBaseline: 1,
        labelColor: 1,
        labelFont: 1,
        labelFontSize: 1,
        labelFontStyle: 1,
        labelFontWeight: 1,
        labelLimit: 1,
        labelOffset: 1,
        labelOpacity: 1,
        labelOverlap: 1,
        labelPadding: 1,
        labelSeparation: 1,
        legendX: 1,
        legendY: 1,
        offset: 1,
        orient: 1,
        padding: 1,
        rowPadding: 1,
        strokeColor: 1,
        symbolDash: 1,
        symbolDashOffset: 1,
        symbolFillColor: 1,
        symbolLimit: 1,
        symbolOffset: 1,
        symbolOpacity: 1,
        symbolSize: 1,
        symbolStrokeColor: 1,
        symbolStrokeWidth: 1,
        symbolType: 1,
        tickCount: 1,
        tickMinStep: 1,
        title: 1,
        titleAlign: 1,
        titleAnchor: 1,
        titleBaseline: 1,
        titleColor: 1,
        titleFont: 1,
        titleFontSize: 1,
        titleFontStyle: 1,
        titleFontWeight: 1,
        titleLimit: 1,
        titleLineHeight: 1,
        titleOpacity: 1,
        titleOrient: 1,
        titlePadding: 1,
        type: 1,
        values: 1,
        zindex: 1,
      },
    ),
    {
      disable: 1,
      labelExpr: 1,
      selections: 1,
      opacity: 1,
      shape: 1,
      stroke: 1,
      fill: 1,
      size: 1,
      strokeWidth: 1,
      strokeDash: 1,
      encode: 1,
    },
  ),
  dY = vT(hY);
class pY extends GH {}
const mY = {
  symbols: function (t, { fieldOrDatumDef: n, model: e, channel: r, legendCmpt: i, legendType: o }) {
    var u, s, a, c, l, f, h, d;
    if ('symbol' !== o) return;
    const { markDef: p, encoding: m, config: v, mark: g } = e,
      b = p.filled && 'trail' !== g;
    let y = Object.assign(
      Object.assign(
        {},
        (function (t, n, e) {
          for (const r of e) {
            const e = IR(r, n.markDef, n.config);
            void 0 !== e && (t[r] = zR(e));
          }
          return t;
        })({}, e, Jq),
      ),
      BG(e, { filled: b }),
    );
    const w = null !== (u = i.get('symbolOpacity')) && void 0 !== u ? u : v.legend.symbolOpacity,
      x = null !== (s = i.get('symbolFillColor')) && void 0 !== s ? s : v.legend.symbolFillColor,
      O = null !== (a = i.get('symbolStrokeColor')) && void 0 !== a ? a : v.legend.symbolStrokeColor,
      k = void 0 === w ? (null !== (c = vY(m.opacity)) && void 0 !== c ? c : p.opacity) : void 0;
    if (y.fill)
      if ('fill' === r || (b && r === eP)) delete y.fill;
      else if (y.fill.field)
        x
          ? delete y.fill
          : ((y.fill = zR(null !== (l = v.legend.symbolBaseFillColor) && void 0 !== l ? l : 'black')),
            (y.fillOpacity = zR(null != k ? k : 1)));
      else if (K(y.fill)) {
        const t =
          null !==
            (d = null !== (h = gY(null !== (f = m.fill) && void 0 !== f ? f : m.color)) && void 0 !== h ? h : p.fill) &&
          void 0 !== d
            ? d
            : b && p.color;
        t && (y.fill = zR(t));
      }
    if (y.stroke)
      if ('stroke' === r || (!b && r === eP)) delete y.stroke;
      else if (y.stroke.field || O) delete y.stroke;
      else if (K(y.stroke)) {
        const t = ST(gY(m.stroke || m.color), p.stroke, b ? p.color : void 0);
        t && (y.stroke = { value: t });
      }
    if (r !== aP) {
      const t = TI(n) && yY(0, i, n);
      t
        ? (y.opacity = [Object.assign({ test: t }, zR(null != k ? k : 1)), zR(v.legend.unselectedOpacity)])
        : k && (y.opacity = zR(k));
    }
    return (y = Object.assign(Object.assign({}, y), t)), mT(y) ? void 0 : y;
  },
  gradient: function (t, { model: n, legendType: e, legendCmpt: r }) {
    var i;
    if ('gradient' !== e) return;
    const { config: o, markDef: u, encoding: s } = n;
    let a = {};
    const c =
      void 0 === (null !== (i = r.get('gradientOpacity')) && void 0 !== i ? i : o.legend.gradientOpacity)
        ? vY(s.opacity) || u.opacity
        : void 0;
    return c && (a.opacity = zR(c)), (a = Object.assign(Object.assign({}, a), t)), mT(a) ? void 0 : a;
  },
  labels: function (t, { fieldOrDatumDef: n, model: e, channel: r, legendCmpt: i }) {
    const o = e.legend(r) || {},
      u = e.config,
      s = TI(n) ? yY(0, i, n) : void 0,
      a = s ? [{ test: s, value: 1 }, { value: u.legend.unselectedOpacity }] : void 0,
      { format: c, formatType: l } = o;
    let f;
    aI(l)
      ? (f = hI({ fieldOrDatumDef: n, field: 'datum.value', format: c, formatType: l, config: u }))
      : void 0 === c &&
        void 0 === l &&
        u.customFormatTypes &&
        ('quantitative' === n.type && u.numberFormatType
          ? (f = hI({
              fieldOrDatumDef: n,
              field: 'datum.value',
              format: u.numberFormat,
              formatType: u.numberFormatType,
              config: u,
            }))
          : 'temporal' === n.type &&
            u.timeFormatType &&
            TI(n) &&
            void 0 === n.timeUnit &&
            (f = hI({
              fieldOrDatumDef: n,
              field: 'datum.value',
              format: u.timeFormat,
              formatType: u.timeFormatType,
              config: u,
            })));
    const h = Object.assign(Object.assign(Object.assign({}, a ? { opacity: a } : {}), f ? { text: f } : {}), t);
    return mT(h) ? void 0 : h;
  },
  entries: function (t, { legendCmpt: n }) {
    const e = n.get('selections');
    return (null == e ? void 0 : e.length)
      ? Object.assign(Object.assign({}, t), { fill: { value: 'transparent' } })
      : t;
  },
};
function vY(t) {
  return bY(t, (t, n) => Math.max(t, n.value));
}
function gY(t) {
  return bY(t, (t, n) => ST(t, n.value));
}
function bY(t, n) {
  return (function (t) {
    const n = null == t ? void 0 : t.condition;
    return !!n && (K(n) || WI(n));
  })(t)
    ? At(t.condition).reduce(n, t.value)
    : WI(t)
    ? t.value
    : void 0;
}
function yY(t, n, e) {
  const r = n.get('selections');
  if (!(null == r ? void 0 : r.length)) return;
  const i = rn(e.field);
  return r
    .map(t => `(!length(data(${rn(wT(t) + pV)})) || (${t}[${i}] && indexof(${t}[${i}], datum.value) >= 0))`)
    .join(' || ');
}
const wY = {
  direction: ({ direction: t }) => t,
  format: ({ fieldOrDatumDef: t, legend: n, config: e }) => {
    const { format: r, formatType: i } = n;
    return dI(t, t.type, r, i, e, !1);
  },
  formatType: ({ legend: t, fieldOrDatumDef: n, scaleType: e }) => {
    const { formatType: r } = t;
    return pI(r, n, e);
  },
  gradientLength: t => {
    var n, e;
    const { legend: r, legendConfig: i } = t;
    return null !== (e = null !== (n = r.gradientLength) && void 0 !== n ? n : i.gradientLength) && void 0 !== e
      ? e
      : (function ({ legendConfig: t, model: n, direction: e, orient: r, scaleType: i }) {
          const {
            gradientHorizontalMaxLength: o,
            gradientHorizontalMinLength: u,
            gradientVerticalMaxLength: s,
            gradientVerticalMinLength: a,
          } = t;
          if (Aq(i))
            return 'horizontal' === e
              ? 'top' === r || 'bottom' === r
                ? OY(n, 'width', u, o)
                : u
              : OY(n, 'height', a, s);
        })(t);
  },
  labelOverlap: ({ legend: t, legendConfig: n, scaleType: e }) => {
    var r, i;
    return null !== (i = null !== (r = t.labelOverlap) && void 0 !== r ? r : n.labelOverlap) && void 0 !== i
      ? i
      : (function (t) {
          if (oT(['quantile', 'threshold', 'log', 'symlog'], t)) return 'greedy';
        })(e);
  },
  symbolType: ({ legend: t, markDef: n, channel: e, encoding: r }) => {
    var i;
    return null !== (i = t.symbolType) && void 0 !== i
      ? i
      : (function (t, n, e, r) {
          var i;
          if ('shape' !== n) {
            const t = null !== (i = gY(e)) && void 0 !== i ? i : r;
            if (t) return t;
          }
          switch (t) {
            case 'bar':
            case 'rect':
            case 'image':
            case 'square':
              return 'square';
            case 'line':
            case 'trail':
            case 'rule':
              return 'stroke';
            case 'arc':
            case 'point':
            case 'circle':
            case 'tick':
            case 'geoshape':
            case 'area':
            case 'text':
              return 'circle';
          }
        })(n.type, e, r.shape, n.shape);
  },
  title: ({ fieldOrDatumDef: t, config: n }) => nU(t, n, { allowDisabling: !0 }),
  type: ({ legendType: t, scaleType: n, channel: e }) => {
    if (MP(e) && Aq(n)) {
      if ('gradient' === t) return;
    } else if ('symbol' === t) return;
    return t;
  },
  values: ({ fieldOrDatumDef: t, legend: n }) =>
    (function (t, n) {
      const e = t.values;
      return K(e) ? pU(n, e) : MR(e) ? e : void 0;
    })(n, t),
};
function xY({ legendConfig: t, legendType: n, orient: e, legend: r }) {
  var i, o;
  return null !==
    (o = null !== (i = r.direction) && void 0 !== i ? i : t[n ? 'gradientDirection' : 'symbolDirection']) &&
    void 0 !== o
    ? o
    : (function (t, n) {
        switch (t) {
          case 'top':
          case 'bottom':
            return 'horizontal';
          case 'left':
          case 'right':
          case 'none':
          case void 0:
            return;
          default:
            return 'gradient' === n ? 'horizontal' : void 0;
        }
      })(e, n);
}
function OY(t, n, e, r) {
  return { signal: `clamp(${t.getSizeSignalRef(n).signal}, ${e}, ${r})` };
}
function kY(t) {
  const n = QX(t)
    ? (function (t) {
        const { encoding: n } = t,
          e = {};
        for (const r of [eP, ...hW]) {
          const i = uU(n[r]);
          i && t.getScaleComponent(r) && ((r === oP && TI(i) && i.type === sq) || (e[r] = $Y(t, r)));
        }
        return e;
      })(t)
    : (function (t) {
        const { legends: n, resolve: e } = t.component;
        for (const r of t.children) {
          kY(r);
          for (const i of vT(r.component.legends))
            (e.legend[i] = fY(t.component.resolve, i)),
              'shared' === e.legend[i] &&
                ((n[i] = MY(n[i], r.component.legends[i])), n[i] || ((e.legend[i] = 'independent'), delete n[i]));
        }
        for (const r of vT(n))
          for (const n of t.children)
            n.component.legends[r] && 'shared' === e.legend[r] && delete n.component.legends[r];
        return n;
      })(t);
  return (t.component.legends = n), n;
}
function AY(t, n, e, r) {
  switch (n) {
    case 'disable':
      return void 0 !== e;
    case 'values':
      return !!(null == e ? void 0 : e.values);
    case 'title':
      if ('title' === n && t === (null == r ? void 0 : r.title)) return !0;
  }
  return t === (e || {})[n];
}
function $Y(t, n) {
  var e, r, i;
  let o = t.legend(n);
  const { markDef: u, encoding: s, config: a } = t,
    c = a.legend,
    l = new pY(
      {},
      (function (t, n) {
        const e = t.scaleName(n);
        if ('trail' === t.mark) {
          if ('color' === n) return { stroke: e };
          if ('size' === n) return { strokeWidth: e };
        }
        return 'color' === n ? (t.markDef.filled ? { fill: e } : { stroke: e }) : { [n]: e };
      })(t, n),
    );
  !(function (t, n, e) {
    var r, i, o, u;
    const s = null === (r = t.fieldDef(n)) || void 0 === r ? void 0 : r.field;
    for (const r of gT(null !== (i = t.component.selection) && void 0 !== i ? i : {})) {
      const t = null !== (o = r.project.hasField[s]) && void 0 !== o ? o : r.project.hasChannel[n];
      if (t && oV.defined(r)) {
        const n = null !== (u = e.get('selections')) && void 0 !== u ? u : [];
        n.push(r.name), e.set('selections', n, !1), (t.hasLegend = !0);
      }
    }
  })(t, n, l);
  const f = void 0 !== o ? !o : c.disable;
  if ((l.set('disable', f, void 0 !== o), f)) return l;
  o = o || {};
  const h = t.getScaleComponent(n).get('type'),
    d = uU(s[n]),
    p = TI(d) ? (null === (e = UL(d.timeUnit)) || void 0 === e ? void 0 : e.unit) : void 0,
    m = o.orient || a.legend.orient || 'right',
    v = (function (t) {
      const { legend: n } = t;
      return ST(
        n.type,
        (function ({ channel: t, timeUnit: n, scaleType: e }) {
          if (MP(t)) {
            if (oT(['quarter', 'month', 'day'], n)) return 'symbol';
            if (Aq(e)) return 'gradient';
          }
          return 'symbol';
        })(t),
      );
    })({ legend: o, channel: n, timeUnit: p, scaleType: h }),
    g = {
      legend: o,
      channel: n,
      model: t,
      markDef: u,
      encoding: s,
      fieldOrDatumDef: d,
      legendConfig: c,
      config: a,
      scaleType: h,
      orient: m,
      legendType: v,
      direction: xY({ legend: o, legendType: v, orient: m, legendConfig: c }),
    };
  for (const e of dY) {
    if (('gradient' === v && e.startsWith('symbol')) || ('symbol' === v && e.startsWith('gradient'))) continue;
    const r = e in wY ? wY[e](g) : o[e];
    if (void 0 !== r) {
      const i = AY(r, e, o, t.fieldDef(n));
      (i || void 0 === a.legend[e]) && l.set(e, r, i);
    }
  }
  const b = null !== (r = null == o ? void 0 : o.encoding) && void 0 !== r ? r : {},
    y = l.get('selections'),
    w = {},
    x = { fieldOrDatumDef: d, model: t, channel: n, legendCmpt: l, legendType: v };
  for (const n of ['labels', 'legend', 'title', 'symbols', 'gradient', 'entries']) {
    const e = cY(null !== (i = b[n]) && void 0 !== i ? i : {}, t),
      r = n in mY ? mY[n](e, x) : e;
    void 0 === r ||
      mT(r) ||
      (w[n] = Object.assign(
        Object.assign(
          Object.assign({}, (null == y ? void 0 : y.length) && TI(d) ? { name: `${wT(d.field)}_legend_${n}` } : {}),
          (null == y ? void 0 : y.length) ? { interactive: !!y } : {},
        ),
        { update: r },
      ));
  }
  return mT(w) || l.set('encode', w, !!(null == o ? void 0 : o.encoding)), l;
}
function MY(t, n) {
  var e, r, i, o;
  if (!t) return n.clone();
  const u = t.getWithExplicit('orient'),
    s = n.getWithExplicit('orient');
  if (u.explicit && s.explicit && u.value !== s.value) return;
  let a = !1;
  for (const e of dY) {
    const r = QH(t.getWithExplicit(e), n.getWithExplicit(e), e, 'legend', (t, n) => {
      switch (e) {
        case 'symbolType':
          return (r = t), 'circle' === (i = n).value ? i : r;
        case 'title':
          return YR(t, n);
        case 'type':
          return (a = !0), YH('symbol');
      }
      var r, i;
      return JH(t, n, e, 'legend');
    });
    t.setWithExplicit(e, r);
  }
  return (
    a &&
      ((null === (r = null === (e = t.implicit) || void 0 === e ? void 0 : e.encode) || void 0 === r
        ? void 0
        : r.gradient) && OT(t.implicit, ['encode', 'gradient']),
      (null === (o = null === (i = t.explicit) || void 0 === i ? void 0 : i.encode) || void 0 === o
        ? void 0
        : o.gradient) && OT(t.explicit, ['encode', 'gradient'])),
    t
  );
}
function jY(t) {
  const n = t.component.legends,
    e = {};
  for (const r of vT(n)) {
    const i = t.getScaleComponent(r),
      o = eT(i.get('domains'));
    if (e[o]) for (const t of e[o]) MY(t, n[r]) || e[o].push(n[r]);
    else e[o] = [n[r].clone()];
  }
  const r = gT(e)
    .flat()
    .map(n =>
      (function (t, n) {
        var e, r, i;
        const o = t.combine(),
          { disable: u, labelExpr: s } = o,
          a = (function (t, n) {
            var e = {};
            for (var r in t) Object.prototype.hasOwnProperty.call(t, r) && n.indexOf(r) < 0 && (e[r] = t[r]);
            if (null != t && 'function' == typeof Object.getOwnPropertySymbols) {
              var i = 0;
              for (r = Object.getOwnPropertySymbols(t); i < r.length; i++)
                n.indexOf(r[i]) < 0 && Object.prototype.propertyIsEnumerable.call(t, r[i]) && (e[r[i]] = t[r[i]]);
            }
            return e;
          })(o, ['disable', 'labelExpr', 'selections']);
        if (!u) {
          if (
            (!1 === n.aria && null == a.aria && (a.aria = !1),
            null === (e = a.encode) || void 0 === e ? void 0 : e.symbols)
          ) {
            const t = a.encode.symbols.update;
            !t.fill || 'transparent' === t.fill.value || t.stroke || a.stroke || (t.stroke = { value: 'transparent' });
            for (const n of hW) a[n] && delete t[n];
          }
          if ((a.title || delete a.title, void 0 !== s)) {
            let t = s;
            (null === (i = null === (r = a.encode) || void 0 === r ? void 0 : r.labels) || void 0 === i
              ? void 0
              : i.update) &&
              MR(a.encode.labels.update.text) &&
              (t = DT(s, 'datum.label', a.encode.labels.update.text.signal)),
              (function (t, n, e, r) {
                var i, o, u, s, a;
                (null !== (i = t.encode) && void 0 !== i) || (t.encode = {}),
                  (null !== (o = (s = t.encode)[n]) && void 0 !== o) || (s[n] = {}),
                  (null !== (u = (a = t.encode[n]).update) && void 0 !== u) || (a.update = {}),
                  (t.encode[n].update.text = r);
              })(a, 'labels', 0, { signal: t });
          }
          return a;
        }
      })(n, t.config),
    )
    .filter(t => void 0 !== t);
  return r;
}
function DY(t) {
  const n = t.component.projection;
  if (!n || n.merged) return [];
  const e = n.combine(),
    { name: r } = e;
  if (n.data) {
    const i = { signal: `[${n.size.map(t => t.signal).join(', ')}]` },
      o = n.data.reduce((n, e) => {
        const r = MR(e) ? e.signal : `data('${t.lookupDataSource(e)}')`;
        return oT(n, r) || n.push(r), n;
      }, []);
    if (o.length <= 0) throw new Error("Projection's fit didn't find any data sources");
    return [Object.assign({ name: r, size: i, fit: { signal: o.length > 1 ? `[${o.join(', ')}]` : o[0] } }, e)];
  }
  return [Object.assign(Object.assign({ name: r }, { translate: { signal: '[width / 2, height / 2]' } }), e)];
}
const FY = [
  'type',
  'clipAngle',
  'clipExtent',
  'center',
  'rotate',
  'precision',
  'reflectX',
  'reflectY',
  'coefficient',
  'distance',
  'fraction',
  'lobes',
  'parallel',
  'radius',
  'ratio',
  'spacing',
  'tilt',
];
class EY extends GH {
  constructor(t, n, e, r) {
    super(Object.assign({}, n), { name: t }),
      (this.specifiedProjection = n),
      (this.size = e),
      (this.data = r),
      (this.merged = !1);
  }
  get isFit() {
    return !!this.data;
  }
}
function SY(t) {
  t.component.projection = QX(t)
    ? (function (t) {
        var n;
        if (t.hasProjection) {
          const e = kR(t.specifiedProjection),
            r = !(e && (null != e.scale || null != e.translate)),
            i = r ? [t.getSizeSignalRef('width'), t.getSizeSignalRef('height')] : void 0,
            o = r
              ? (function (t) {
                  const n = [],
                    { encoding: e } = t;
                  for (const r of [
                    [KT, ZT],
                    [nP, tP],
                  ])
                    (uU(e[r[0]]) || uU(e[r[1]])) && n.push({ signal: t.getName(`geojson_${n.length}`) });
                  return (
                    t.channelHasField(oP) &&
                      t.typedFieldDef(oP).type === sq &&
                      n.push({ signal: t.getName(`geojson_${n.length}`) }),
                    0 === n.length && n.push(t.requestDataName(uG.Main)),
                    n
                  );
                })(t)
              : void 0,
            u = new EY(
              t.projectionName(!0),
              Object.assign(
                Object.assign({}, null !== (n = kR(t.config.projection)) && void 0 !== n ? n : {}),
                null != e ? e : {},
              ),
              i,
              o,
            );
          return u.get('type') || u.set('type', 'equalEarth', !1), u;
        }
      })(t)
    : (function (t) {
        if (0 === t.children.length) return;
        let n;
        for (const n of t.children) SY(n);
        const e = sT(t.children, t => {
          const e = t.component.projection;
          if (e) {
            if (n) {
              const t = (function (t, n) {
                const e = sT(
                  FY,
                  e =>
                    (!Pt(t.explicit, e) && !Pt(n.explicit, e)) ||
                    !!(Pt(t.explicit, e) && Pt(n.explicit, e) && Qz(t.get(e), n.get(e))),
                );
                if (Qz(t.size, n.size)) {
                  if (e) return t;
                  if (Qz(t.explicit, {})) return n;
                  if (Qz(n.explicit, {})) return t;
                }
                return null;
              })(n, e);
              return t && (n = t), !!t;
            }
            return (n = e), !0;
          }
          return !0;
        });
        if (n && e) {
          const e = t.projectionName(!0),
            r = new EY(e, n.specifiedProjection, n.size, Zz(n.data));
          for (const n of t.children) {
            const t = n.component.projection;
            t &&
              (t.isFit && r.data.push(...n.component.projection.data),
              n.renameProjection(t.get('name'), e),
              (t.merged = !0));
          }
          return r;
        }
      })(t);
}
function CY(t, n) {
  return `${vR(t)}_${n}`;
}
function NY(t, n, e) {
  var r;
  const i = CY(null !== (r = lU(e, void 0)) && void 0 !== r ? r : {}, n);
  return t.getName(`${i}_bins`);
}
function BY(t, n, e) {
  let r, i;
  r = (function (t) {
    return 'as' in t;
  })(t)
    ? Xt(t.as)
      ? [t.as, `${t.as}_end`]
      : [t.as[0], t.as[1]]
    : [JI(t, { forAs: !0 }), JI(t, { binSuffix: 'end', forAs: !0 })];
  const o = Object.assign({}, lU(n, void 0)),
    u = CY(o, t.field),
    { signal: s, extentSignal: a } = (function (t, n) {
      return { signal: t.getName(`${n}_bins`), extentSignal: t.getName(`${n}_extent`) };
    })(e, u);
  if (wR(o.extent)) {
    const t = o.extent;
    (i = jV(e, t.param, t)), delete o.extent;
  }
  return {
    key: u,
    binComponent: Object.assign(
      Object.assign(
        Object.assign({ bin: o, field: t.field, as: [r] }, s ? { signal: s } : {}),
        a ? { extentSignal: a } : {},
      ),
      i ? { span: i } : {},
    ),
  };
}
class _Y extends hG {
  constructor(t, n) {
    super(t), (this.bins = n);
  }
  clone() {
    return new _Y(null, Zz(this.bins));
  }
  static makeFromEncoding(t, n) {
    const e = n.reduceFieldDef((t, e, r) => {
      if (UI(e) && gR(e.bin)) {
        const { key: i, binComponent: o } = BY(e, e.bin, n);
        t[i] = Object.assign(
          Object.assign(Object.assign({}, o), t[i]),
          (function (t, n, e, r) {
            var i, o;
            if (mU(n, e)) {
              const u =
                  QX(t) && null !== (o = null !== (i = t.axis(e)) && void 0 !== i ? i : t.legend(e)) && void 0 !== o
                    ? o
                    : {},
                s = JI(n, { expr: 'datum' }),
                a = JI(n, { expr: 'datum', binSuffix: 'end' });
              return {
                formulaAs: JI(n, { binSuffix: 'range', forAs: !0 }),
                formula: bI(s, a, u.format, u.formatType, r),
              };
            }
            return {};
          })(n, e, r, n.config),
        );
      }
      return t;
    }, {});
    return mT(e) ? null : new _Y(t, e);
  }
  static makeFromTransform(t, n, e) {
    const { key: r, binComponent: i } = BY(n, n.bin, e);
    return new _Y(t, { [r]: i });
  }
  merge(t, n) {
    for (const e of vT(t.bins))
      e in this.bins
        ? (n(t.bins[e].signal, this.bins[e].signal), (this.bins[e].as = lT([...this.bins[e].as, ...t.bins[e].as], rT)))
        : (this.bins[e] = t.bins[e]);
    for (const n of t.children) t.removeChild(n), (n.parent = this);
    t.remove();
  }
  producedFields() {
    return new Set(
      gT(this.bins)
        .map(t => t.as)
        .flat(2),
    );
  }
  dependentFields() {
    return new Set(gT(this.bins).map(t => t.field));
  }
  hash() {
    return `Bin ${rT(this.bins)}`;
  }
  assemble() {
    return gT(this.bins).flatMap(t => {
      const n = [],
        [e, ...r] = t.as,
        i = t.bin,
        { extent: o } = i,
        u = (function (t, n) {
          var e = {};
          for (var r in t) Object.prototype.hasOwnProperty.call(t, r) && n.indexOf(r) < 0 && (e[r] = t[r]);
          if (null != t && 'function' == typeof Object.getOwnPropertySymbols) {
            var i = 0;
            for (r = Object.getOwnPropertySymbols(t); i < r.length; i++)
              n.indexOf(r[i]) < 0 && Object.prototype.propertyIsEnumerable.call(t, r[i]) && (e[r[i]] = t[r[i]]);
          }
          return e;
        })(i, ['extent']),
        s = Object.assign(
          Object.assign(
            Object.assign(
              { type: 'bin', field: jT(t.field), as: e, signal: t.signal },
              wR(o) ? { extent: null } : { extent: o },
            ),
            t.span ? { span: { signal: `span(${t.span})` } } : {},
          ),
          u,
        );
      !o &&
        t.extentSignal &&
        (n.push({ type: 'extent', field: jT(t.field), signal: t.extentSignal }),
        (s.extent = { signal: t.extentSignal })),
        n.push(s);
      for (const t of r)
        for (let r = 0; r < 2; r++) n.push({ type: 'formula', expr: JI({ field: e[r] }, { expr: 'datum' }), as: t[r] });
      return t.formula && n.push({ type: 'formula', expr: t.formula, as: t.formulaAs }), n;
    });
  }
}
class zY extends hG {
  constructor(t, n, e) {
    super(t), (this.dimensions = n), (this.measures = e);
  }
  clone() {
    return new zY(null, new Set(this.dimensions), Zz(this.measures));
  }
  get groupBy() {
    return this.dimensions;
  }
  static makeFromEncoding(t, n) {
    let e = !1;
    n.forEachFieldDef(t => {
      t.aggregate && (e = !0);
    });
    const r = {},
      i = new Set();
    return e
      ? (n.forEachFieldDef((t, e) => {
          var o, u, s, a;
          const { aggregate: c, field: l } = t;
          if (c)
            if ('count' === c)
              (null !== (o = r['*']) && void 0 !== o) || (r['*'] = {}),
                (r['*'].count = new Set([JI(t, { forAs: !0 })]));
            else {
              if (cR(c) || lR(c)) {
                const t = cR(c) ? 'argmin' : 'argmax',
                  n = c[t];
                (null !== (u = r[n]) && void 0 !== u) || (r[n] = {}),
                  (r[n][t] = new Set([JI({ op: t, field: n }, { forAs: !0 })]));
              } else (null !== (s = r[l]) && void 0 !== s) || (r[l] = {}), (r[l][c] = new Set([JI(t, { forAs: !0 })]));
              rR(e) &&
                'unaggregated' === n.scaleDomain(e) &&
                ((null !== (a = r[l]) && void 0 !== a) || (r[l] = {}),
                (r[l].min = new Set([JI({ field: l, aggregate: 'min' }, { forAs: !0 })])),
                (r[l].max = new Set([JI({ field: l, aggregate: 'max' }, { forAs: !0 })])));
            }
          else
            !(function (t, n, e, r) {
              var i;
              const o = QX(r) ? r.encoding[PP(n)] : void 0;
              if (UI(e) && QX(r) && NI(e, o, r.markDef, r.config))
                t.add(JI(e, {})),
                  t.add(JI(e, { suffix: 'end' })),
                  e.bin && mU(e, n) && t.add(JI(e, { binSuffix: 'range' }));
              else if (n in kP) {
                const e = (function (t) {
                  switch (t) {
                    case ZT:
                      return 'y';
                    case tP:
                      return 'y2';
                    case KT:
                      return 'x';
                    case nP:
                      return 'x2';
                  }
                })(n);
                t.add(r.getName(e));
              } else t.add(JI(e));
              HI(e) &&
                (function (t) {
                  return tt(t) && 'field' in t;
                })(null === (i = e.scale) || void 0 === i ? void 0 : i.range) &&
                t.add(e.scale.range.field);
            })(i, e, t, n);
        }),
        i.size + vT(r).length === 0 ? null : new zY(t, i, r))
      : null;
  }
  static makeFromTransform(t, n) {
    var e, r, i;
    const o = new Set(),
      u = {};
    for (const t of n.aggregate) {
      const { op: n, field: i, as: o } = t;
      n &&
        ('count' === n
          ? ((null !== (e = u['*']) && void 0 !== e) || (u['*'] = {}),
            (u['*'].count = new Set([o || JI(t, { forAs: !0 })])))
          : ((null !== (r = u[i]) && void 0 !== r) || (u[i] = {}), (u[i][n] = new Set([o || JI(t, { forAs: !0 })]))));
    }
    for (const t of null !== (i = n.groupby) && void 0 !== i ? i : []) o.add(t);
    return o.size + vT(u).length === 0 ? null : new zY(t, o, u);
  }
  merge(t) {
    return fT(this.dimensions, t.dimensions)
      ? ((function (t, n) {
          var e;
          for (const r of vT(n)) {
            const i = n[r];
            for (const n of vT(i))
              r in t
                ? (t[r][n] = new Set([...(null !== (e = t[r][n]) && void 0 !== e ? e : []), ...i[n]]))
                : (t[r] = { [n]: i[n] });
          }
        })(this.measures, t.measures),
        !0)
      : (jL.debug('different dimensions, cannot merge'), !1);
  }
  addDimensions(t) {
    t.forEach(this.dimensions.add, this.dimensions);
  }
  dependentFields() {
    return new Set([...this.dimensions, ...vT(this.measures)]);
  }
  producedFields() {
    const t = new Set();
    for (const n of vT(this.measures))
      for (const e of vT(this.measures[n])) {
        const r = this.measures[n][e];
        0 === r.size ? t.add(`${e}_${n}`) : r.forEach(t.add, t);
      }
    return t;
  }
  hash() {
    return `Aggregate ${rT({ dimensions: this.dimensions, measures: this.measures })}`;
  }
  assemble() {
    const t = [],
      n = [],
      e = [];
    for (const r of vT(this.measures))
      for (const i of vT(this.measures[r]))
        for (const o of this.measures[r][i]) e.push(o), t.push(i), n.push('*' === r ? null : jT(r));
    return { type: 'aggregate', groupby: [...this.dimensions].map(jT), ops: t, fields: n, as: e };
  }
}
class TY extends hG {
  constructor(t, n, e, r) {
    super(t), (this.model = n), (this.name = e), (this.data = r);
    for (const t of DP) {
      const e = n.facet[t];
      if (e) {
        const { bin: r, sort: i } = e;
        this[t] = Object.assign(
          { name: n.getName(`${t}_domain`), fields: [JI(e), ...(gR(r) ? [JI(e, { binSuffix: 'end' })] : [])] },
          kI(i) ? { sortField: i } : K(i) ? { sortIndexField: IV(e, t) } : {},
        );
      }
    }
    this.childModel = n.child;
  }
  hash() {
    let t = 'Facet';
    for (const n of DP) this[n] && (t += ` ${n.charAt(0)}:${rT(this[n])}`);
    return t;
  }
  get fields() {
    var t;
    const n = [];
    for (const e of DP) (null === (t = this[e]) || void 0 === t ? void 0 : t.fields) && n.push(...this[e].fields);
    return n;
  }
  dependentFields() {
    const t = new Set(this.fields);
    for (const n of DP)
      this[n] &&
        (this[n].sortField && t.add(this[n].sortField.field), this[n].sortIndexField && t.add(this[n].sortIndexField));
    return t;
  }
  producedFields() {
    return new Set();
  }
  getSource() {
    return this.name;
  }
  getChildIndependentFieldsWithStep() {
    const t = {};
    for (const n of GP) {
      const e = this.childModel.component.scales[n];
      if (e && !e.merged) {
        const r = e.get('type'),
          i = e.get('range');
        if (Oq(r) && jR(i)) {
          const e = jX(DX(this.childModel, n));
          e ? (t[n] = e) : DL(KR(n));
        }
      }
    }
    return t;
  }
  assembleRowColumnHeaderData(t, n, e) {
    const r = { row: 'y', column: 'x', facet: void 0 }[t],
      i = [],
      o = [],
      u = [];
    r &&
      e &&
      e[r] &&
      (n ? (i.push(`distinct_${e[r]}`), o.push('max')) : (i.push(e[r]), o.push('distinct')),
      u.push(`distinct_${e[r]}`));
    const { sortField: s, sortIndexField: a } = this[t];
    if (s) {
      const { op: t = yI, field: n } = s;
      i.push(n), o.push(t), u.push(JI(s, { forAs: !0 }));
    } else a && (i.push(a), o.push('max'), u.push(a));
    return {
      name: this[t].name,
      source: null != n ? n : this.data,
      transform: [
        Object.assign({ type: 'aggregate', groupby: this[t].fields }, i.length ? { fields: i, ops: o, as: u } : {}),
      ],
    };
  }
  assembleFacetHeaderData(t) {
    var n, e;
    const { columns: r } = this.model.layout,
      { layoutHeaders: i } = this.model.component,
      o = [],
      u = {};
    for (const t of GV) {
      for (const r of VV) {
        const o = null !== (n = i[t] && i[t][r]) && void 0 !== n ? n : [];
        for (const n of o)
          if ((null === (e = n.axes) || void 0 === e ? void 0 : e.length) > 0) {
            u[t] = !0;
            break;
          }
      }
      if (u[t]) {
        const n = `length(data("${this.facet.name}"))`;
        o.push({
          name: `${this.facet.name}_${t}`,
          transform: [
            {
              type: 'sequence',
              start: 0,
              stop:
                'row' === t
                  ? r
                    ? { signal: `ceil(${n} / ${r})` }
                    : 1
                  : r
                  ? { signal: `min(${n}, ${r})` }
                  : { signal: n },
            },
          ],
        });
      }
    }
    const { row: s, column: a } = u;
    return (s || a) && o.unshift(this.assembleRowColumnHeaderData('facet', null, t)), o;
  }
  assemble() {
    var t, n;
    const e = [];
    let r = null;
    const i = this.getChildIndependentFieldsWithStep(),
      { column: o, row: u, facet: s } = this;
    if (o && u && (i.x || i.y)) {
      r = `cross_${this.column.name}_${this.row.name}`;
      const o = [].concat(null !== (t = i.x) && void 0 !== t ? t : [], null !== (n = i.y) && void 0 !== n ? n : []),
        u = o.map(() => 'distinct');
      e.push({
        name: r,
        source: this.data,
        transform: [{ type: 'aggregate', groupby: this.fields, fields: o, ops: u }],
      });
    }
    for (const t of [LT, RT]) this[t] && e.push(this.assembleRowColumnHeaderData(t, r, i));
    if (s) {
      const t = this.assembleFacetHeaderData(i);
      t && e.push(...t);
    }
    return e;
  }
}
function PY(t) {
  return (t.startsWith("'") && t.endsWith("'")) || (t.startsWith('"') && t.endsWith('"')) ? t.slice(1, -1) : t;
}
function RY(t) {
  const n = {};
  return (
    Xz(t.filter, t => {
      var e;
      if (QL(t)) {
        let r = null;
        WL(t)
          ? (r = BR(t.equal))
          : GL(t)
          ? (r = BR(t.lte))
          : HL(t)
          ? (r = BR(t.lt))
          : VL(t)
          ? (r = BR(t.gt))
          : YL(t)
          ? (r = BR(t.gte))
          : XL(t)
          ? (r = t.range[0])
          : JL(t) && (r = (null !== (e = t.oneOf) && void 0 !== e ? e : t.in)[0]),
          r && (FL(r) ? (n[t.field] = 'date') : Vt(r) ? (n[t.field] = 'number') : Xt(r) && (n[t.field] = 'string')),
          t.timeUnit && (n[t.field] = 'date');
      }
    }),
    n
  );
}
class LY extends hG {
  constructor(t, n) {
    super(t), (this._parse = n);
  }
  clone() {
    return new LY(null, Zz(this._parse));
  }
  hash() {
    return `Parse ${rT(this._parse)}`;
  }
  static makeExplicit(t, n, e) {
    var r;
    let i = {};
    const o = n.data;
    return (
      !eG(o) &&
        (null === (r = null == o ? void 0 : o.format) || void 0 === r ? void 0 : r.parse) &&
        (i = o.format.parse),
      this.makeWithAncestors(t, i, {}, e)
    );
  }
  static makeWithAncestors(t, n, e, r) {
    for (const t of vT(e)) {
      const n = r.getWithExplicit(t);
      void 0 !== n.value &&
        (n.explicit || n.value === e[t] || 'derived' === n.value || 'flatten' === e[t]
          ? delete e[t]
          : DL(iL(t, e[t], n.value)));
    }
    for (const t of vT(n)) {
      const e = r.get(t);
      void 0 !== e && (e === n[t] ? delete n[t] : DL(iL(t, n[t], e)));
    }
    const i = new GH(n, e);
    r.copyAll(i);
    const o = {};
    for (const t of vT(i.combine())) {
      const n = i.get(t);
      null !== n && (o[t] = n);
    }
    return 0 === vT(o).length || r.parseNothing ? null : new LY(t, o);
  }
  get parse() {
    return this._parse;
  }
  merge(t) {
    (this._parse = Object.assign(Object.assign({}, this._parse), t.parse)), t.remove();
  }
  assembleFormatParse() {
    const t = {};
    for (const n of vT(this._parse)) {
      const e = this._parse[n];
      1 === ET(n) && (t[n] = e);
    }
    return t;
  }
  producedFields() {
    return new Set(vT(this._parse));
  }
  dependentFields() {
    return new Set(vT(this._parse));
  }
  assembleTransforms(t = !1) {
    return vT(this._parse)
      .filter(n => !t || ET(n) > 1)
      .map(t => {
        const n = (function (t, n) {
          const e = AT(t);
          return 'number' === n
            ? `toNumber(${e})`
            : 'boolean' === n
            ? `toBoolean(${e})`
            : 'string' === n
            ? `toString(${e})`
            : 'date' === n
            ? `toDate(${e})`
            : 'flatten' === n
            ? e
            : n.startsWith('date:')
            ? `timeParse(${e},'${PY(n.slice(5, n.length))}')`
            : n.startsWith('utc:')
            ? `utcParse(${e},'${PY(n.slice(4, n.length))}')`
            : (DL(`Unrecognized parse "${n}".`), null);
        })(t, this._parse[t]);
        return n ? { type: 'formula', expr: n, as: FT(t) } : null;
      })
      .filter(t => null !== t);
  }
}
class qY extends hG {
  clone() {
    return new qY(null);
  }
  constructor(t) {
    super(t);
  }
  dependentFields() {
    return new Set();
  }
  producedFields() {
    return new Set([dW]);
  }
  hash() {
    return 'Identifier';
  }
  assemble() {
    return { type: 'identifier', as: dW };
  }
}
class IY extends hG {
  constructor(t, n) {
    super(t), (this.params = n);
  }
  clone() {
    return new IY(null, this.params);
  }
  dependentFields() {
    return new Set();
  }
  producedFields() {}
  hash() {
    return `Graticule ${rT(this.params)}`;
  }
  assemble() {
    return Object.assign({ type: 'graticule' }, !0 === this.params ? {} : this.params);
  }
}
class UY extends hG {
  constructor(t, n) {
    super(t), (this.params = n);
  }
  clone() {
    return new UY(null, this.params);
  }
  dependentFields() {
    return new Set();
  }
  producedFields() {
    var t;
    return new Set([null !== (t = this.params.as) && void 0 !== t ? t : 'data']);
  }
  hash() {
    return `Hash ${rT(this.params)}`;
  }
  assemble() {
    return Object.assign({ type: 'sequence' }, this.params);
  }
}
class WY extends hG {
  constructor(t) {
    let n;
    if (
      (super(null),
      null != t || (t = { name: 'source' }),
      eG(t) || (n = t.format ? Object.assign({}, nT(t.format, ['parse'])) : {}),
      tG(t))
    )
      this._data = { values: t.values };
    else if (KH(t)) {
      if (((this._data = { url: t.url }), !n.type)) {
        let e = /(?:\.([^.]+))?$/.exec(t.url)[1];
        oT(['json', 'csv', 'tsv', 'dsv', 'topojson'], e) || (e = 'json'), (n.type = e);
      }
    } else iG(t) ? (this._data = { values: [{ type: 'Sphere' }] }) : (nG(t) || eG(t)) && (this._data = {});
    (this._generator = eG(t)), t.name && (this._name = t.name), n && !mT(n) && (this._data.format = n);
  }
  dependentFields() {
    return new Set();
  }
  producedFields() {}
  get data() {
    return this._data;
  }
  hasName() {
    return !!this._name;
  }
  get isGenerator() {
    return this._generator;
  }
  get dataName() {
    return this._name;
  }
  set dataName(t) {
    this._name = t;
  }
  set parent(t) {
    throw new Error('Source nodes have to be roots.');
  }
  remove() {
    throw new Error('Source nodes are roots and cannot be removed.');
  }
  hash() {
    throw new Error('Cannot hash sources');
  }
  assemble() {
    return Object.assign(Object.assign({ name: this._name }, this._data), { transform: [] });
  }
}
var HY,
  GY = function (t, n, e, r, i) {
    if ('m' === r) throw new TypeError('Private method is not writable');
    if ('a' === r && !i) throw new TypeError('Private accessor was defined without a setter');
    if ('function' == typeof n ? t !== n || !i : !n.has(t))
      throw new TypeError('Cannot write private member to an object whose class did not declare it');
    return 'a' === r ? i.call(t, e) : i ? (i.value = e) : n.set(t, e), e;
  };
function VY(t) {
  return t instanceof WY || t instanceof IY || t instanceof UY;
}
class YY {
  constructor() {
    HY.set(this, void 0), GY(this, HY, !1, 'f');
  }
  setModified() {
    GY(this, HY, !0, 'f');
  }
  get modifiedFlag() {
    return (function (t, n, e, r) {
      if ('a' === e && !r) throw new TypeError('Private accessor was defined without a getter');
      if ('function' == typeof n ? t !== n || !r : !n.has(t))
        throw new TypeError('Cannot read private member from an object whose class did not declare it');
      return 'm' === e ? r : 'a' === e ? r.call(t) : r ? r.value : n.get(t);
    })(this, HY, 'f');
  }
}
HY = new WeakMap();
class XY extends YY {
  getNodeDepths(t, n, e) {
    e.set(t, n);
    for (const r of t.children) this.getNodeDepths(r, n + 1, e);
    return e;
  }
  optimize(t) {
    const n = [...this.getNodeDepths(t, 0, new Map()).entries()].sort((t, n) => n[1] - t[1]);
    for (const t of n) this.run(t[0]);
    return this.modifiedFlag;
  }
}
class JY extends YY {
  optimize(t) {
    this.run(t);
    for (const n of t.children) this.optimize(n);
    return this.modifiedFlag;
  }
}
class QY extends JY {
  mergeNodes(t, n) {
    const e = n.shift();
    for (const r of n) t.removeChild(r), (r.parent = e), r.remove();
  }
  run(t) {
    const n = t.children.map(t => t.hash()),
      e = {};
    for (let r = 0; r < n.length; r++) void 0 === e[n[r]] ? (e[n[r]] = [t.children[r]]) : e[n[r]].push(t.children[r]);
    for (const n of vT(e)) e[n].length > 1 && (this.setModified(), this.mergeNodes(t, e[n]));
  }
}
class ZY extends JY {
  constructor(t) {
    super(), (this.requiresSelectionId = t && wV(t));
  }
  run(t) {
    t instanceof qY &&
      ((this.requiresSelectionId && (VY(t.parent) || t.parent instanceof zY || t.parent instanceof LY)) ||
        (this.setModified(), t.remove()));
  }
}
class KY extends YY {
  optimize(t) {
    return this.run(t, new Set()), this.modifiedFlag;
  }
  run(t, n) {
    let e = new Set();
    t instanceof mG &&
      ((e = t.producedFields()),
      hT(e, n) && (this.setModified(), t.removeFormulas(n), 0 === t.producedFields.length && t.remove()));
    for (const r of t.children) this.run(r, new Set([...n, ...e]));
  }
}
class tX extends JY {
  constructor() {
    super();
  }
  run(t) {
    t instanceof dG && !t.isRequired() && (this.setModified(), t.remove());
  }
}
class nX extends XY {
  run(t) {
    if (!(VY(t) || t.numChildren() > 1))
      for (const n of t.children)
        if (n instanceof LY)
          if (t instanceof LY) this.setModified(), t.merge(n);
          else {
            if (pT(t.producedFields(), n.dependentFields())) continue;
            this.setModified(), n.swapWithParent();
          }
  }
}
class eX extends XY {
  run(t) {
    const n = [...t.children],
      e = t.children.filter(t => t instanceof LY);
    if (t.numChildren() > 1 && e.length >= 1) {
      const r = {},
        i = new Set();
      for (const t of e) {
        const n = t.parse;
        for (const t of vT(n)) t in r ? r[t] !== n[t] && i.add(t) : (r[t] = n[t]);
      }
      for (const t of i) delete r[t];
      if (!mT(r)) {
        this.setModified();
        const e = new LY(t, r);
        for (const i of n) {
          if (i instanceof LY) for (const t of vT(r)) delete i.parse[t];
          t.removeChild(i), (i.parent = e), i instanceof LY && 0 === vT(i.parse).length && i.remove();
        }
      }
    }
  }
}
class rX extends XY {
  run(t) {
    t instanceof dG || t.numChildren() > 0 || t instanceof TY || t instanceof WY || (this.setModified(), t.remove());
  }
}
class iX extends XY {
  run(t) {
    const n = t.children.filter(t => t instanceof mG),
      e = n.pop();
    for (const t of n) this.setModified(), e.merge(t);
  }
}
class oX extends XY {
  run(t) {
    const n = t.children.filter(t => t instanceof zY),
      e = {};
    for (const t of n) {
      const n = rT(t.groupBy);
      n in e || (e[n] = []), e[n].push(t);
    }
    for (const n of vT(e)) {
      const r = e[n];
      if (r.length > 1) {
        const n = r.pop();
        for (const e of r) n.merge(e) && (t.removeChild(e), (e.parent = n), e.remove(), this.setModified());
      }
    }
  }
}
class uX extends XY {
  constructor(t) {
    super(), (this.model = t);
  }
  run(t) {
    const n = !(VY(t) || t instanceof $V || t instanceof LY || t instanceof qY),
      e = [],
      r = [];
    for (const i of t.children)
      i instanceof _Y && (n && !pT(t.producedFields(), i.dependentFields()) ? e.push(i) : r.push(i));
    if (e.length > 0) {
      const n = e.pop();
      for (const t of e) n.merge(t, this.model.renameSignal.bind(this.model));
      this.setModified(), t instanceof _Y ? t.merge(n, this.model.renameSignal.bind(this.model)) : n.swapWithParent();
    }
    if (r.length > 1) {
      const t = r.pop();
      for (const n of r) t.merge(n, this.model.renameSignal.bind(this.model));
      this.setModified();
    }
  }
}
class sX extends XY {
  run(t) {
    const n = [...t.children];
    if (!uT(n, t => t instanceof dG) || t.numChildren() <= 1) return;
    const e = [];
    let r;
    for (const i of n)
      if (i instanceof dG) {
        let n = i;
        for (; 1 === n.numChildren(); ) {
          const [t] = n.children;
          if (!(t instanceof dG)) break;
          n = t;
        }
        e.push(...n.children),
          r
            ? (t.removeChild(i), (i.parent = r.parent), r.parent.removeChild(r), (r.parent = n), this.setModified())
            : (r = n);
      } else e.push(i);
    if (e.length) {
      this.setModified();
      for (const t of e) t.parent.removeChild(t), (t.parent = r);
    }
  }
}
class aX extends hG {
  constructor(t, n) {
    super(t), (this.transform = n);
  }
  clone() {
    return new aX(null, Zz(this.transform));
  }
  addDimensions(t) {
    this.transform.groupby = lT(this.transform.groupby.concat(t), t => t);
  }
  dependentFields() {
    const t = new Set();
    return (
      this.transform.groupby && this.transform.groupby.forEach(t.add, t),
      this.transform.joinaggregate
        .map(t => t.field)
        .filter(t => void 0 !== t)
        .forEach(t.add, t),
      t
    );
  }
  producedFields() {
    return new Set(this.transform.joinaggregate.map(this.getDefaultName));
  }
  getDefaultName(t) {
    var n;
    return null !== (n = t.as) && void 0 !== n ? n : JI(t);
  }
  hash() {
    return `JoinAggregateTransform ${rT(this.transform)}`;
  }
  assemble() {
    const t = [],
      n = [],
      e = [];
    for (const r of this.transform.joinaggregate)
      n.push(r.op), e.push(this.getDefaultName(r)), t.push(void 0 === r.field ? null : r.field);
    const r = this.transform.groupby;
    return Object.assign({ type: 'joinaggregate', as: e, ops: n, fields: t }, void 0 !== r ? { groupby: r } : {});
  }
}
class cX extends hG {
  constructor(t, n) {
    super(t), (this._stack = n);
  }
  clone() {
    return new cX(null, Zz(this._stack));
  }
  static makeFromTransform(t, n) {
    const { stack: e, groupby: r, as: i, offset: o = 'zero' } = n,
      u = [],
      s = [];
    if (void 0 !== n.sort) for (const t of n.sort) u.push(t.field), s.push(ST(t.order, 'ascending'));
    const a = { field: u, order: s };
    let c;
    return (
      (c = (function (t) {
        return K(t) && t.every(t => Xt(t)) && t.length > 1;
      })(i)
        ? i
        : Xt(i)
        ? [i, `${i}_end`]
        : [`${n.stack}_start`, `${n.stack}_end`]),
      new cX(t, { dimensionFieldDefs: [], stackField: e, groupby: r, offset: o, sort: a, facetby: [], as: c })
    );
  }
  static makeFromEncoding(t, n) {
    const e = n.stack,
      { encoding: r } = n;
    if (!e) return null;
    const { groupbyChannels: i, fieldChannel: o, offset: u, impute: s } = e,
      a = i.map(t => oU(r[t])).filter(t => !!t),
      c = (function (t) {
        return t.stack.stackBy.reduce((t, n) => {
          const e = JI(n.fieldDef);
          return e && t.push(e), t;
        }, []);
      })(n),
      l = n.encoding.order;
    let f;
    return (
      (f =
        K(l) || TI(l)
          ? HR(l)
          : c.reduce((t, n) => (t.field.push(n), t.order.push('y' === o ? 'descending' : 'ascending'), t), {
              field: [],
              order: [],
            })),
      new cX(t, {
        dimensionFieldDefs: a,
        stackField: n.vgField(o),
        facetby: [],
        stackby: c,
        sort: f,
        offset: u,
        impute: s,
        as: [n.vgField(o, { suffix: 'start', forAs: !0 }), n.vgField(o, { suffix: 'end', forAs: !0 })],
      })
    );
  }
  get stack() {
    return this._stack;
  }
  addDimensions(t) {
    this._stack.facetby.push(...t);
  }
  dependentFields() {
    const t = new Set();
    return (
      t.add(this._stack.stackField),
      this.getGroupbyFields().forEach(t.add, t),
      this._stack.facetby.forEach(t.add, t),
      this._stack.sort.field.forEach(t.add, t),
      t
    );
  }
  producedFields() {
    return new Set(this._stack.as);
  }
  hash() {
    return `Stack ${rT(this._stack)}`;
  }
  getGroupbyFields() {
    const { dimensionFieldDefs: t, impute: n, groupby: e } = this._stack;
    return t.length > 0
      ? t
          .map(t => (t.bin ? (n ? [JI(t, { binSuffix: 'mid' })] : [JI(t, {}), JI(t, { binSuffix: 'end' })]) : [JI(t)]))
          .flat()
      : null != e
      ? e
      : [];
  }
  assemble() {
    const t = [],
      {
        facetby: n,
        dimensionFieldDefs: e,
        stackField: r,
        stackby: i,
        sort: o,
        offset: u,
        impute: s,
        as: a,
      } = this._stack;
    if (s)
      for (const o of e) {
        const { bandPosition: e = 0.5, bin: u } = o;
        if (u) {
          const n = JI(o, { expr: 'datum' }),
            r = JI(o, { expr: 'datum', binSuffix: 'end' });
          t.push({ type: 'formula', expr: `${e}*${n}+${1 - e}*${r}`, as: JI(o, { binSuffix: 'mid', forAs: !0 }) });
        }
        t.push({
          type: 'impute',
          field: r,
          groupby: [...i, ...n],
          key: JI(o, { binSuffix: 'mid' }),
          method: 'value',
          value: 0,
        });
      }
    return (
      t.push({ type: 'stack', groupby: [...this.getGroupbyFields(), ...n], field: r, sort: o, as: a, offset: u }), t
    );
  }
}
class lX extends hG {
  constructor(t, n) {
    super(t), (this.transform = n);
  }
  clone() {
    return new lX(null, Zz(this.transform));
  }
  addDimensions(t) {
    this.transform.groupby = lT(this.transform.groupby.concat(t), t => t);
  }
  dependentFields() {
    var t, n;
    const e = new Set();
    return (
      (null !== (t = this.transform.groupby) && void 0 !== t ? t : []).forEach(e.add, e),
      (null !== (n = this.transform.sort) && void 0 !== n ? n : []).forEach(t => e.add(t.field)),
      this.transform.window
        .map(t => t.field)
        .filter(t => void 0 !== t)
        .forEach(e.add, e),
      e
    );
  }
  producedFields() {
    return new Set(this.transform.window.map(this.getDefaultName));
  }
  getDefaultName(t) {
    var n;
    return null !== (n = t.as) && void 0 !== n ? n : JI(t);
  }
  hash() {
    return `WindowTransform ${rT(this.transform)}`;
  }
  assemble() {
    var t;
    const n = [],
      e = [],
      r = [],
      i = [];
    for (const t of this.transform.window)
      e.push(t.op),
        r.push(this.getDefaultName(t)),
        i.push(void 0 === t.param ? null : t.param),
        n.push(void 0 === t.field ? null : t.field);
    const o = this.transform.frame,
      u = this.transform.groupby;
    if (o && null === o[0] && null === o[1] && e.every(t => fR(t)))
      return Object.assign({ type: 'joinaggregate', as: r, ops: e, fields: n }, void 0 !== u ? { groupby: u } : {});
    const s = [],
      a = [];
    if (void 0 !== this.transform.sort)
      for (const n of this.transform.sort)
        s.push(n.field), a.push(null !== (t = n.order) && void 0 !== t ? t : 'ascending');
    const c = this.transform.ignorePeers;
    return Object.assign(
      Object.assign(
        Object.assign(
          { type: 'window', params: i, as: r, ops: e, fields: n, sort: { field: s, order: a } },
          void 0 !== c ? { ignorePeers: c } : {},
        ),
        void 0 !== u ? { groupby: u } : {},
      ),
      void 0 !== o ? { frame: o } : {},
    );
  }
}
function fX(t) {
  if (t instanceof TY)
    if (1 !== t.numChildren() || t.children[0] instanceof dG) {
      const e = t.model.component.data.main;
      hX(e);
      const r =
          ((n = t),
          function t(e) {
            if (!(e instanceof TY)) {
              const r = e.clone();
              if (r instanceof dG) {
                const t = dX + r.getSource();
                r.setSource(t), (n.model.component.data.outputNodes[t] = r);
              } else
                (r instanceof zY || r instanceof cX || r instanceof lX || r instanceof aX) && r.addDimensions(n.fields);
              for (const n of e.children.flatMap(t)) n.parent = r;
              return [r];
            }
            return e.children.flatMap(t);
          }),
        i = t.children.map(r).flat();
      for (const t of i) t.parent = e;
    } else {
      const n = t.children[0];
      (n instanceof zY || n instanceof cX || n instanceof lX || n instanceof aX) && n.addDimensions(t.fields),
        n.swapWithParent(),
        fX(t);
    }
  else t.children.map(fX);
  var n;
}
function hX(t) {
  if (t instanceof dG && t.type === uG.Main && 1 === t.numChildren()) {
    const n = t.children[0];
    n instanceof TY || (n.swapWithParent(), hX(t));
  }
}
const dX = 'scale_';
function pX(t) {
  for (const n of t) {
    for (const t of n.children) if (t.parent !== n) return !1;
    if (!pX(n.children)) return !1;
  }
  return !0;
}
function mX(t, n) {
  let e = !1;
  for (const r of n) e = t.optimize(r) || e;
  return e;
}
function vX(t, n, e) {
  let r = t.sources,
    i = !1;
  return (
    (i = mX(new tX(), r) || i),
    (i = mX(new ZY(n), r) || i),
    (r = r.filter(t => t.numChildren() > 0)),
    (i = mX(new rX(), r) || i),
    (r = r.filter(t => t.numChildren() > 0)),
    e ||
      ((i = mX(new nX(), r) || i),
      (i = mX(new uX(n), r) || i),
      (i = mX(new KY(), r) || i),
      (i = mX(new eX(), r) || i),
      (i = mX(new oX(), r) || i),
      (i = mX(new iX(), r) || i),
      (i = mX(new QY(), r) || i),
      (i = mX(new sX(), r) || i)),
    (t.sources = r),
    i
  );
}
class gX {
  constructor(t) {
    Object.defineProperty(this, 'signal', { enumerable: !0, get: t });
  }
  static fromName(t, n) {
    return new gX(() => t(n));
  }
}
function bX(t) {
  QX(t)
    ? (function (t) {
        const n = t.component.scales;
        for (const e of vT(n)) {
          const r = yX(t, e);
          if ((n[e].setWithExplicit('domains', r), kX(t, e), t.component.data.isFaceted)) {
            let n = t;
            for (; !ZX(n) && n.parent; ) n = n.parent;
            if ('shared' === n.component.resolve.scale[e])
              for (const t of r.value) DR(t) && (t.data = dX + t.data.replace(dX, ''));
          }
        }
      })(t)
    : (function (t) {
        for (const n of t.children) bX(n);
        const n = t.component.scales;
        for (const e of vT(n)) {
          let r,
            i = null;
          for (const n of t.children) {
            const t = n.component.scales[e];
            if (t) {
              r =
                void 0 === r
                  ? t.getWithExplicit('domains')
                  : QH(r, t.getWithExplicit('domains'), 'domains', 'scale', $X);
              const n = t.get('selectionExtent');
              i &&
                n &&
                i.param !== n.param &&
                DL('The same selection must be used to override scale domains in a layered view.'),
                (i = n);
            }
          }
          n[e].setWithExplicit('domains', r), i && n[e].set('selectionExtent', i, !0);
        }
      })(t);
}
function yX(t, n) {
  const e = t.getScaleComponent(n).get('type'),
    { encoding: r } = t,
    i = (function (t, n, e, r) {
      if ('unaggregated' === t) {
        const { valid: t, reason: r } = AX(n, e);
        if (!t) return void DL(r);
      } else if (void 0 === t && r.useUnaggregatedDomain) {
        const { valid: t } = AX(n, e);
        if (t) return 'unaggregated';
      }
      return t;
    })(t.scaleDomain(n), t.typedFieldDef(n), e, t.config.scale);
  return (
    i !== t.scaleDomain(n) &&
      (t.specifiedScales[n] = Object.assign(Object.assign({}, t.specifiedScales[n]), { domain: i })),
    'x' === n && uU(r.x2)
      ? uU(r.x)
        ? QH(xX(e, i, t, 'x'), xX(e, i, t, 'x2'), 'domain', 'scale', $X)
        : xX(e, i, t, 'x2')
      : 'y' === n && uU(r.y2)
      ? uU(r.y)
        ? QH(xX(e, i, t, 'y'), xX(e, i, t, 'y2'), 'domain', 'scale', $X)
        : xX(e, i, t, 'y2')
      : xX(e, i, t, n)
  );
}
function wX(t, n, e) {
  var r;
  const i = null === (r = UL(e)) || void 0 === r ? void 0 : r.unit;
  return 'temporal' === n || i
    ? (function (t, n, e) {
        return t.map(t => ({ signal: `{data: ${dU(t, { timeUnit: e, type: n })}}` }));
      })(t, n, i)
    : [t];
}
function xX(t, n, e, r) {
  const { encoding: i } = e,
    o = uU(i[r]),
    { type: u } = o,
    s = o.timeUnit;
  if (
    (function (t) {
      return null == t ? void 0 : t.unionWith;
    })(n)
  ) {
    const i = xX(t, void 0, e, r),
      o = wX(n.unionWith, u, s);
    return VH([...i.value, ...o]);
  }
  if (MR(n)) return VH([n]);
  if (n && 'unaggregated' !== n && !Mq(n)) return VH(wX(n, u, s));
  const a = e.stack;
  if (a && r === a.fieldChannel) {
    if ('normalize' === a.offset) return YH([[0, 1]]);
    const t = e.requestDataName(uG.Main);
    return YH([
      { data: t, field: e.vgField(r, { suffix: 'start' }) },
      { data: t, field: e.vgField(r, { suffix: 'end' }) },
    ]);
  }
  const c =
    rR(r) && TI(o)
      ? (function (t, n, e) {
          if (!Oq(e)) return;
          const r = t.fieldDef(n),
            i = r.sort;
          if (AI(i)) return { op: 'min', field: IV(r, n), order: 'ascending' };
          const { stack: o } = t,
            u = o ? new Set([...o.groupbyFields, ...o.stackBy.map(t => t.fieldDef.field)]) : void 0;
          if (kI(i)) return OX(i, o && !u.has(i.field));
          if (OI(i)) {
            const { encoding: n, order: e } = i,
              r = t.fieldDef(n),
              { aggregate: s, field: a } = r,
              c = o && !u.has(a);
            if (cR(s) || lR(s)) return OX({ field: JI(r), order: e }, c);
            if (fR(s) || !s) return OX({ op: s, field: a, order: e }, c);
          } else {
            if ('descending' === i) return { op: 'min', field: t.vgField(n), order: 'descending' };
            if (oT(['ascending', void 0], i)) return !0;
          }
        })(e, r, t)
      : void 0;
  if (RI(o)) return YH(wX([o.datum], u, s));
  const l = o;
  if ('unaggregated' === n) {
    const t = e.requestDataName(uG.Main),
      { field: n } = o;
    return YH([
      { data: t, field: JI({ field: n, aggregate: 'min' }) },
      { data: t, field: JI({ field: n, aggregate: 'max' }) },
    ]);
  }
  if (gR(l.bin)) {
    if (Oq(t))
      return YH(
        'bin-ordinal' === t
          ? []
          : [
              {
                data: yT(c) ? e.requestDataName(uG.Main) : e.requestDataName(uG.Raw),
                field: e.vgField(r, mU(l, r) ? { binSuffix: 'range' } : {}),
                sort: !0 !== c && tt(c) ? c : { field: e.vgField(r, {}), op: 'min' },
              },
            ],
      );
    {
      const { bin: t } = l;
      if (gR(t)) {
        const n = NY(e, l.field, t);
        return YH([
          new gX(() => {
            const t = e.getSignalName(n);
            return `[${t}.start, ${t}.stop]`;
          }),
        ]);
      }
      return YH([{ data: e.requestDataName(uG.Main), field: e.vgField(r, {}) }]);
    }
  }
  if (l.timeUnit && oT(['time', 'utc'], t) && NI(l, QX(e) ? e.encoding[PP(r)] : void 0, e.markDef, e.config)) {
    const t = e.requestDataName(uG.Main);
    return YH([
      { data: t, field: e.vgField(r) },
      { data: t, field: e.vgField(r, { suffix: 'end' }) },
    ]);
  }
  return YH(
    c
      ? [{ data: yT(c) ? e.requestDataName(uG.Main) : e.requestDataName(uG.Raw), field: e.vgField(r), sort: c }]
      : [{ data: e.requestDataName(uG.Main), field: e.vgField(r) }],
  );
}
function OX(t, n) {
  const { op: e, field: r, order: i } = t;
  return Object.assign(
    Object.assign({ op: null != e ? e : n ? 'sum' : yI }, r ? { field: jT(r) } : {}),
    i ? { order: i } : {},
  );
}
function kX(t, n) {
  var e;
  const r = t.component.scales[n],
    i = t.specifiedScales[n].domain,
    o = null === (e = t.fieldDef(n)) || void 0 === e ? void 0 : e.bin,
    u = Mq(i) && i,
    s = yR(o) && wR(o.extent) && o.extent;
  (u || s) && r.set('selectionExtent', null != u ? u : s, !0);
}
function AX(t, n) {
  const { aggregate: e, type: r } = t;
  return e
    ? Xt(e) && !mR.has(e)
      ? { valid: !1, reason: bL(e) }
      : 'quantitative' === r && 'log' === n
      ? { valid: !1, reason: yL(t) }
      : { valid: !0 }
    : { valid: !1, reason: gL(t) };
}
function $X(t, n, e, r) {
  return (
    t.explicit &&
      n.explicit &&
      DL(
        (function (t, n, e, r) {
          return `Conflicting ${n.toString()} property "${t.toString()}" (${eT(e)} and ${eT(
            r,
          )}). Using the union of the two domains.`;
        })(e, r, t.value, n.value),
      ),
    { explicit: t.explicit, value: [...t.value, ...n.value] }
  );
}
function MX(t) {
  const n = lT(
      t.map(t =>
        DR(t)
          ? (function (t, n) {
              var e = {};
              for (var r in t) Object.prototype.hasOwnProperty.call(t, r) && n.indexOf(r) < 0 && (e[r] = t[r]);
              if (null != t && 'function' == typeof Object.getOwnPropertySymbols) {
                var i = 0;
                for (r = Object.getOwnPropertySymbols(t); i < r.length; i++)
                  n.indexOf(r[i]) < 0 && Object.prototype.propertyIsEnumerable.call(t, r[i]) && (e[r[i]] = t[r[i]]);
              }
              return e;
            })(t, ['sort'])
          : t,
      ),
      rT,
    ),
    e = lT(
      t
        .map(t => {
          if (DR(t)) {
            const n = t.sort;
            return (
              void 0 === n ||
                yT(n) ||
                ('op' in n && 'count' === n.op && delete n.field, 'ascending' === n.order && delete n.order),
              n
            );
          }
        })
        .filter(t => void 0 !== t),
      rT,
    );
  if (0 === n.length) return;
  if (1 === n.length) {
    const n = t[0];
    if (DR(n) && e.length > 0) {
      let t = e[0];
      return (
        e.length > 1
          ? (DL(OL), (t = !0))
          : tt(t) && 'field' in t && n.field === t.field && (t = !t.order || { order: t.order }),
        Object.assign(Object.assign({}, n), { sort: t })
      );
    }
    return n;
  }
  const r = lT(
    e.map(t =>
      yT(t) || !('op' in t) || (Xt(t.op) && t.op in aR)
        ? t
        : (DL(
            (function (t) {
              return `Dropping sort property ${eT(
                t,
              )} as unioned domains only support boolean or op "count", "min", and "max".`;
            })(t),
          ),
          !0),
    ),
    rT,
  );
  let i;
  1 === r.length ? (i = r[0]) : r.length > 1 && (DL(OL), (i = !0));
  const o = lT(
    t.map(t => (DR(t) ? t.data : null)),
    t => t,
  );
  return Object.assign(
    1 === o.length && null !== o[0] ? { data: o[0], fields: n.map(t => t.field) } : { fields: n },
    i ? { sort: i } : {},
  );
}
function jX(t) {
  if (DR(t) && Xt(t.field)) return t.field;
  if (
    (function (t) {
      return !K(t) && 'fields' in t && !('data' in t);
    })(t)
  ) {
    let n;
    for (const e of t.fields)
      if (DR(e) && Xt(e.field))
        if (n) {
          if (n !== e.field)
            return (
              DL(
                'Detected faceted independent scales that union domain of multiple fields from different data sources. We will use the first field. The result view size may be incorrect.',
              ),
              n
            );
        } else n = e.field;
    return (
      DL(
        'Detected faceted independent scales that union domain of the same fields from different source. We will assume that this is the same field from a different fork of the same data source. However, if this is not the case, the result view size may be incorrect.',
      ),
      n
    );
  }
  if (
    (function (t) {
      return !K(t) && 'fields' in t && 'data' in t;
    })(t)
  ) {
    DL(
      'Detected faceted independent scales that union domain of multiple fields from the same data source. We will use the first field. The result view size may be incorrect.',
    );
    const n = t.fields[0];
    return Xt(n) ? n : void 0;
  }
}
function DX(t, n) {
  const e = t.component.scales[n].get('domains').map(n => (DR(n) && (n.data = t.lookupDataSource(n.data)), n));
  return MX(e);
}
function FX(t) {
  return tJ(t) || KX(t) ? t.children.reduce((t, n) => t.concat(FX(n)), EX(t)) : EX(t);
}
function EX(t) {
  return vT(t.component.scales).reduce((n, e) => {
    const r = t.component.scales[e];
    if (r.merged) return n;
    const i = r.combine(),
      { name: o, type: u, selectionExtent: s, reverse: a } = i,
      c = (function (t, n) {
        var e = {};
        for (var r in t) Object.prototype.hasOwnProperty.call(t, r) && n.indexOf(r) < 0 && (e[r] = t[r]);
        if (null != t && 'function' == typeof Object.getOwnPropertySymbols) {
          var i = 0;
          for (r = Object.getOwnPropertySymbols(t); i < r.length; i++)
            n.indexOf(r[i]) < 0 && Object.prototype.propertyIsEnumerable.call(t, r[i]) && (e[r[i]] = t[r[i]]);
        }
        return e;
      })(i, ['name', 'type', 'selectionExtent', 'domains', 'range', 'reverse']),
      l = (function (t, n, e, r) {
        if (VP(e)) {
          if (jR(t)) return { step: { signal: `${n}_step` } };
        } else if (tt(t) && DR(t)) return Object.assign(Object.assign({}, t), { data: r.lookupDataSource(t.data) });
        return t;
      })(i.range, o, e, t),
      f = DX(t, e),
      h = s
        ? (function (t, n, e, r) {
            const i = jV(t, n.param, n);
            return { signal: kq(e.get('type')) && K(r) && r[0] > r[1] ? `isValid(${i}) && reverse(${i})` : i };
          })(t, s, r, f)
        : null;
    return (
      n.push(
        Object.assign(
          Object.assign(
            Object.assign(
              Object.assign(Object.assign({ name: o, type: u }, f ? { domain: f } : {}), h ? { domainRaw: h } : {}),
              { range: l },
            ),
            void 0 !== a ? { reverse: a } : {},
          ),
          c,
        ),
      ),
      n
    );
  }, []);
}
class SX extends GH {
  constructor(t, n) {
    super({}, { name: t }), (this.merged = !1), this.setWithExplicit('type', n);
  }
  domainDefinitelyIncludesZero() {
    return !1 !== this.get('zero') || uT(this.get('domains'), t => K(t) && 2 === t.length && t[0] <= 0 && t[1] >= 0);
  }
}
const CX = ['range', 'scheme'];
function NX(t, n) {
  const e = t.fieldDef(n);
  if (null == e ? void 0 : e.bin) {
    const { bin: r, field: i } = e,
      o = RP(n),
      u = t.getName(o);
    if (tt(r) && r.binned && void 0 !== r.step)
      return new gX(() => {
        const e = t.scaleName(n),
          i = `(domain("${e}")[1] - domain("${e}")[0]) / ${r.step}`;
        return `${t.getSignalName(u)} / (${i})`;
      });
    if (gR(r)) {
      const n = NY(t, i, r);
      return new gX(() => {
        const e = t.getSignalName(n),
          r = `(${e}.stop - ${e}.start) / ${e}.step`;
        return `${t.getSignalName(u)} / (${r})`;
      });
    }
  }
}
function BX(t, n) {
  const e = n.specifiedScales[t],
    { size: r } = n,
    i = n.getScaleComponent(t).get('type');
  for (const r of CX)
    if (void 0 !== e[r]) {
      const o = Fq(i, r),
        u = Eq(t, r);
      if (o)
        if (u) DL(u);
        else
          switch (r) {
            case 'range': {
              const r = e.range;
              if (K(r)) {
                if (VP(t))
                  return VH(
                    r.map(t => {
                      if ('width' === t || 'height' === t) {
                        const e = n.getName(t),
                          r = n.getSignalName.bind(n);
                        return gX.fromName(r, e);
                      }
                      return t;
                    }),
                  );
              } else if (tt(r))
                return VH({
                  data: n.requestDataName(uG.Main),
                  field: r.field,
                  sort: { op: 'min', field: n.vgField(t) },
                });
              return VH(r);
            }
            case 'scheme':
              return VH(_X(e[r]));
          }
      else DL(wL(i, r, t));
    }
  const o = t === IT || 'xOffset' === t ? 'width' : 'height',
    u = r[o];
  if (AW(u))
    if (VP(t))
      if (Oq(i)) {
        const e = zX(u, n, t);
        if (e) return VH({ step: e });
      } else DL(xL(o));
    else if (ZP(t) && 'band' === n.getScaleComponent(t === GT ? 'x' : 'y').get('type')) {
      const t = TX(u, i);
      if (t) return VH(t);
    }
  const { rangeMin: s, rangeMax: a } = e,
    c = (function (t, n) {
      const { size: e, config: r, mark: i, encoding: o } = n,
        u = n.getSignalName.bind(n),
        { type: s } = uU(o[t]),
        a = n.getScaleComponent(t).get('type'),
        { domain: c, domainMid: l } = n.specifiedScales[t];
      switch (t) {
        case IT:
        case UT: {
          if (oT(['point', 'band'], a)) {
            const i = PX(t, e, r.view);
            if (AW(i)) return { step: zX(i, n, t) };
          }
          const i = RP(t),
            o = n.getName(i);
          return t === UT && kq(a) ? [gX.fromName(u, o), 0] : [0, gX.fromName(u, o)];
        }
        case GT:
        case VT:
          return (function (t, n, e) {
            const r = t === GT ? 'x' : 'y',
              i = n.getScaleComponent(r).get('type'),
              o = n.scaleName(r);
            if ('band' === i) {
              const t = PX(r, n.size, n.config.view);
              if (AW(t)) {
                const n = TX(t, e);
                if (n) return n;
              }
              return [0, { signal: `bandwidth('${o}')` }];
            }
            return Kz(`Cannot use ${t} scale if ${r} scale is not discrete.`);
          })(t, n, a);
        case uP: {
          const o = RX(i, n.component.scales[t].get('zero'), r),
            u = (function (t, n, e, r) {
              const i = { x: NX(e, 'x'), y: NX(e, 'y') };
              switch (t) {
                case 'bar':
                case 'tick': {
                  if (void 0 !== r.scale.maxBandSize) return r.scale.maxBandSize;
                  const t = qX(n, i, r.view);
                  return Vt(t) ? t - 1 : new gX(() => `${t.signal} - 1`);
                }
                case 'line':
                case 'trail':
                case 'rule':
                  return r.scale.maxStrokeWidth;
                case 'text':
                  return r.scale.maxFontSize;
                case 'point':
                case 'square':
                case 'circle': {
                  if (r.scale.maxSize) return r.scale.maxSize;
                  const t = qX(n, i, r.view);
                  return Vt(t) ? Math.pow(LX * t, 2) : new gX(() => `pow(0.95 * ${t.signal}, 2)`);
                }
              }
              throw new Error(hL('size', t));
            })(i, e, n, r);
          return $q(a)
            ? (function (t, n, e) {
                const r = () => {
                  const r = RR(n),
                    i = RR(t),
                    o = `(${r} - ${i}) / (${e} - 1)`;
                  return `sequence(${i}, ${r} + ${o}, ${o})`;
                };
                return MR(n) ? new gX(r) : { signal: r() };
              })(
                o,
                u,
                (function (t, n, e, r) {
                  switch (t) {
                    case 'quantile':
                      return n.scale.quantileCount;
                    case 'quantize':
                      return n.scale.quantizeCount;
                    case 'threshold':
                      return void 0 !== e && K(e)
                        ? e.length + 1
                        : (DL(
                            (function (t) {
                              return `Domain for ${t} is required for threshold scale.`;
                            })(r),
                          ),
                          3);
                  }
                })(a, r, c, t),
              )
            : [o, u];
        }
        case JT:
          return [0, 2 * Math.PI];
        case sP:
          return [0, 360];
        case YT:
          return [0, new gX(() => `min(${n.getSignalName('width')},${n.getSignalName('height')})/2`)];
        case fP:
          return [r.scale.minStrokeWidth, r.scale.maxStrokeWidth];
        case hP:
          return [
            [1, 0],
            [4, 2],
            [2, 1],
            [1, 1],
            [1, 2, 4, 2],
          ];
        case oP:
          return 'symbol';
        case eP:
        case rP:
        case iP:
          return 'ordinal' === a
            ? 'nominal' === s
              ? 'category'
              : 'ordinal'
            : void 0 !== l
            ? 'diverging'
            : 'rect' === i || 'geoshape' === i
            ? 'heatmap'
            : 'ramp';
        case aP:
        case cP:
        case lP:
          return [r.scale.minOpacity, r.scale.maxOpacity];
      }
    })(t, n);
  return (void 0 !== s || void 0 !== a) && Fq(i, 'rangeMin') && K(c) && 2 === c.length
    ? VH([null != s ? s : c[0], null != a ? a : c[1]])
    : YH(c);
}
function _X(t) {
  return (function (t) {
    return !Xt(t) && !!t.name;
  })(t)
    ? Object.assign({ scheme: t.name }, nT(t, ['name']))
    : { scheme: t };
}
function zX(t, n, e) {
  var r, i, o, u, s;
  const { encoding: a } = n,
    c = n.getScaleComponent(e),
    l = LP(e),
    f = a[l];
  if ('offset' === kW({ step: t, offsetIsDiscrete: II(f) && eq(f.type) }) && jU(a, l)) {
    const e = n.getScaleComponent(l);
    let a = `domain('${n.scaleName(l)}').length`;
    'band' === e.get('type') &&
      (a = `bandspace(${a}, ${
        null !== (i = null !== (r = e.get('paddingInner')) && void 0 !== r ? r : e.get('padding')) && void 0 !== i
          ? i
          : 0
      }, ${
        null !== (u = null !== (o = e.get('paddingOuter')) && void 0 !== o ? o : e.get('padding')) && void 0 !== u
          ? u
          : 0
      })`);
    const f = null !== (s = c.get('paddingInner')) && void 0 !== s ? s : c.get('padding');
    return { signal: `${t.step} * ${a} / (1-${TR(f)})` };
  }
  return t.step;
}
function TX(t, n) {
  if ('offset' === kW({ step: t, offsetIsDiscrete: Oq(n) })) return { step: t.step };
}
function PX(t, n, e) {
  const r = t === IT ? 'width' : 'height';
  return n[r] || FW(e, r);
}
function RX(t, n, e) {
  if (n) return MR(n) ? { signal: `${n.signal} ? 0 : ${RX(t, !1, e)}` } : 0;
  switch (t) {
    case 'bar':
    case 'tick':
      return e.scale.minBandSize;
    case 'line':
    case 'trail':
    case 'rule':
      return e.scale.minStrokeWidth;
    case 'text':
      return e.scale.minFontSize;
    case 'point':
    case 'square':
    case 'circle':
      return e.scale.minSize;
  }
  throw new Error(hL('size', t));
}
const LX = 0.95;
function qX(t, n, e) {
  const r = AW(t.width) ? t.width.step : DW(e, 'width'),
    i = AW(t.height) ? t.height.step : DW(e, 'height');
  return n.x || n.y ? new gX(() => `min(${[n.x ? n.x.signal : r, n.y ? n.y.signal : i].join(', ')})`) : Math.min(r, i);
}
function IX(t, n) {
  QX(t)
    ? (function (t, n) {
        const e = t.component.scales,
          { config: r, encoding: i, markDef: o, specifiedScales: u } = t;
        for (const s of vT(e)) {
          const a = u[s],
            c = e[s],
            l = t.getScaleComponent(s),
            f = uU(i[s]),
            h = a[n],
            d = l.get('type'),
            p = l.get('padding'),
            m = l.get('paddingInner'),
            v = Fq(d, n),
            g = Eq(s, n);
          if ((void 0 !== h && (v ? g && DL(g) : DL(wL(d, n, s))), v && void 0 === g))
            if (void 0 !== h) {
              const t = f.timeUnit,
                e = f.type;
              switch (n) {
                case 'domainMax':
                case 'domainMin':
                  FL(a[n]) || 'temporal' === e || t
                    ? c.set(n, { signal: dU(a[n], { type: e, timeUnit: t }) }, !0)
                    : c.set(n, a[n], !0);
                  break;
                default:
                  c.copyKeyFromObject(n, a);
              }
            } else {
              const e =
                n in UX
                  ? UX[n]({
                      model: t,
                      channel: s,
                      fieldOrDatumDef: f,
                      scaleType: d,
                      scalePadding: p,
                      scalePaddingInner: m,
                      domain: a.domain,
                      domainMin: a.domainMin,
                      domainMax: a.domainMax,
                      markDef: o,
                      config: r,
                      hasNestedOffsetScale: DU(i, s),
                    })
                  : r.scale[n];
              void 0 !== e && c.set(n, e, !1);
            }
        }
      })(t, n)
    : HX(t, n);
}
const UX = {
  bins: ({ model: t, fieldOrDatumDef: n }) =>
    TI(n)
      ? (function (t, n) {
          const e = n.bin;
          if (gR(e)) {
            const r = NY(t, n.field, e);
            return new gX(() => t.getSignalName(r));
          }
          if (bR(e) && yR(e) && void 0 !== e.step) return { step: e.step };
        })(t, n)
      : void 0,
  interpolate: ({ channel: t, fieldOrDatumDef: n }) =>
    (function (t, n) {
      if (oT([eP, rP, iP], t) && 'nominal' !== n) return 'hcl';
    })(t, n.type),
  nice: ({ scaleType: t, channel: n, domain: e, domainMin: r, domainMax: i, fieldOrDatumDef: o }) =>
    (function (t, n, e, r, i, o) {
      var u;
      if (
        !((null === (u = oU(o)) || void 0 === u ? void 0 : u.bin) || K(e) || null != i || null != r || oT([aq, cq], t))
      )
        return !!VP(n) || void 0;
    })(t, n, e, r, i, o),
  padding: ({ channel: t, scaleType: n, fieldOrDatumDef: e, markDef: r, config: i }) =>
    (function (t, n, e, r, i, o) {
      if (VP(t)) {
        if (Aq(n)) {
          if (void 0 !== e.continuousPadding) return e.continuousPadding;
          const { type: n, orient: u } = i;
          if (
            'bar' === n &&
            (!TI(r) || (!r.bin && !r.timeUnit)) &&
            (('vertical' === u && 'x' === t) || ('horizontal' === u && 'y' === t))
          )
            return o.continuousBandSize;
        }
        if (n === lq) return e.pointPadding;
      }
    })(t, n, i.scale, e, r, i.bar),
  paddingInner: ({ scalePadding: t, channel: n, markDef: e, scaleType: r, config: i, hasNestedOffsetScale: o }) =>
    (function (t, n, e, r, i, o = !1) {
      if (void 0 === t) {
        if (VP(n)) {
          const {
            bandPaddingInner: t,
            barBandPaddingInner: n,
            rectBandPaddingInner: r,
            bandWithNestedOffsetPaddingInner: u,
          } = i;
          return o ? u : ST(t, 'bar' === e ? n : r);
        }
        return ZP(n) && r === fq ? i.offsetBandPaddingInner : void 0;
      }
    })(t, n, e.type, r, i.scale, o),
  paddingOuter: ({
    scalePadding: t,
    channel: n,
    scaleType: e,
    scalePaddingInner: r,
    config: i,
    hasNestedOffsetScale: o,
  }) =>
    (function (t, n, e, r, i, o = !1) {
      if (void 0 === t)
        if (VP(n)) {
          const { bandPaddingOuter: t, bandWithNestedOffsetPaddingOuter: n } = i;
          if (o) return n;
          if (e === fq) return ST(t, MR(r) ? { signal: `${r.signal}/2` } : r / 2);
        } else if (ZP(n)) {
          if (e === lq) return 0.5;
          if (e === fq) return i.offsetBandPaddingOuter;
        }
    })(t, n, e, r, i.scale, o),
  reverse: ({ fieldOrDatumDef: t, scaleType: n, channel: e, config: r }) =>
    (function (t, n, e, r) {
      return 'x' === e && void 0 !== r.xReverse
        ? kq(t) && 'descending' === n
          ? MR(r.xReverse)
            ? { signal: `!${r.xReverse.signal}` }
            : !r.xReverse
          : r.xReverse
        : !(!kq(t) || 'descending' !== n) || void 0;
    })(n, TI(t) ? t.sort : void 0, e, r.scale),
  zero: ({ channel: t, fieldOrDatumDef: n, domain: e, markDef: r, scaleType: i }) =>
    (function (t, n, e, r, i) {
      if (e && 'unaggregated' !== e && kq(i)) return !!(K(e) && e[0] <= 0 && e[e.length - 1] >= 0);
      if ('size' === t && 'quantitative' === n.type && !$q(i)) return !0;
      if ((!TI(n) || !n.bin) && oT([...GP, ...XP], t)) {
        const { orient: n, type: e } = r;
        return (
          !oT(['bar', 'area', 'line', 'trail'], e) ||
          !(('horizontal' === n && 'y' === t) || ('vertical' === n && 'x' === t))
        );
      }
      return !1;
    })(t, n, e, r, i),
};
function WX(t) {
  QX(t)
    ? (function (t) {
        const n = t.component.scales;
        for (const e of eR) {
          const r = n[e];
          if (!r) continue;
          const i = BX(e, t);
          r.setWithExplicit('range', i);
        }
      })(t)
    : HX(t, 'range');
}
function HX(t, n) {
  const e = t.component.scales;
  for (const e of t.children) 'range' === n ? WX(e) : IX(e, n);
  for (const r of vT(e)) {
    let i;
    for (const e of t.children) {
      const t = e.component.scales[r];
      t &&
        (i = QH(
          i,
          t.getWithExplicit(n),
          n,
          'scale',
          XH((t, e) => ('range' === n && t.step && e.step ? t.step - e.step : 0)),
        ));
    }
    e[r].setWithExplicit(n, i);
  }
}
function GX(t, n, e, r, i = !1) {
  const o = (function (t, n, e, r) {
      var i;
      switch (n.type) {
        case 'nominal':
        case 'ordinal':
          if (MP(t) || 'discrete' === uR(t))
            return 'shape' === t && 'ordinal' === n.type && DL(vL(t, 'ordinal')), 'ordinal';
          if (VP(t) || ZP(t)) {
            if (oT(['rect', 'bar', 'image', 'rule'], e.type)) return 'band';
            if (r) return 'band';
          } else if ('arc' === e.type && t in YP) return 'band';
          return Kq(e[RP(t)]) || (GI(n) && (null === (i = n.axis) || void 0 === i ? void 0 : i.tickBand))
            ? 'band'
            : 'point';
        case 'temporal':
          return MP(t)
            ? 'time'
            : 'discrete' === uR(t)
            ? (DL(vL(t, 'temporal')), 'ordinal')
            : TI(n) && n.timeUnit && UL(n.timeUnit).utc
            ? 'utc'
            : 'time';
        case 'quantitative':
          return MP(t)
            ? TI(n) && gR(n.bin)
              ? 'bin-ordinal'
              : 'linear'
            : 'discrete' === uR(t)
            ? (DL(vL(t, 'quantitative')), 'ordinal')
            : 'linear';
        case 'geojson':
          return;
      }
      throw new Error(cL(n.type));
    })(n, e, r, i),
    { type: u } = t;
  return rR(n)
    ? void 0 !== u
      ? (function (t, n, e = !1) {
          if (!rR(t)) return !1;
          switch (t) {
            case IT:
            case UT:
            case GT:
            case VT:
            case JT:
            case YT:
              return !!Aq(n) || 'band' === n || ('point' === n && !e);
            case uP:
            case fP:
            case aP:
            case cP:
            case lP:
            case sP:
              return Aq(n) || $q(n) || oT(['band', 'point', 'ordinal'], n);
            case eP:
            case rP:
            case iP:
              return 'band' !== n;
            case hP:
            case oP:
              return 'ordinal' === n || $q(n);
          }
        })(n, u)
        ? TI(e) &&
          ((s = u),
          !(oT([iq, uq], (a = e.type))
            ? void 0 === s || Oq(s)
            : a === oq
            ? oT([aq, cq, void 0], s)
            : a !== rq || bq(s) || $q(s) || void 0 === s))
          ? (DL(
              (function (t, n) {
                return `FieldDef does not work with "${t}" scale. We are using "${n}" scale instead.`;
              })(u, o),
            ),
            o)
          : u
        : (DL(
            (function (t, n, e) {
              return `Channel "${t}" does not work with "${n}" scale. We are using "${e}" scale instead.`;
            })(n, u, o),
          ),
          o)
      : o
    : null;
  var s, a;
}
function VX(t) {
  t.component.scales = QX(t)
    ? (function (t) {
        const { encoding: n, mark: e, markDef: r } = t,
          i = {};
        for (const o of eR) {
          const u = uU(n[o]);
          if (u && e === Hq && o === oP && u.type === sq) continue;
          let s = u && u.scale;
          if (!ZP(o) || DU(n, qP(o))) {
            if (u && null !== s && !1 !== s) {
              null != s || (s = {});
              const e = GX(s, o, u, r, DU(n, o));
              i[o] = new SX(t.scaleName(`${o}`, !0), { value: e, explicit: s.type === e });
            }
          } else s && DL(dL(o));
        }
        return i;
      })(t)
    : (function (t) {
        var n, e;
        const r = (t.component.scales = {}),
          i = {},
          o = t.component.resolve;
        for (const r of t.children) {
          VX(r);
          for (const u of vT(r.component.scales))
            if (((null !== (n = (e = o.scale)[u]) && void 0 !== n) || (e[u] = lY(u, t)), 'shared' === o.scale[u])) {
              const t = i[u],
                n = r.component.scales[u].getWithExplicit('type');
              t
                ? dq(t.value, n.value)
                  ? (i[u] = QH(t, n, 'type', 'scale', YX))
                  : ((o.scale[u] = 'independent'), delete i[u])
                : (i[u] = n);
            }
        }
        for (const n of vT(i)) {
          const e = t.scaleName(n, !0);
          r[n] = new SX(e, i[n]);
          for (const r of t.children) {
            const t = r.component.scales[n];
            t && (r.renameScale(t.get('name'), e), (t.merged = !0));
          }
        }
        return r;
      })(t);
}
const YX = XH((t, n) => mq(t) - mq(n));
var XX = function (t, n) {
  var e = {};
  for (var r in t) Object.prototype.hasOwnProperty.call(t, r) && n.indexOf(r) < 0 && (e[r] = t[r]);
  if (null != t && 'function' == typeof Object.getOwnPropertySymbols) {
    var i = 0;
    for (r = Object.getOwnPropertySymbols(t); i < r.length; i++)
      n.indexOf(r[i]) < 0 && Object.prototype.propertyIsEnumerable.call(t, r[i]) && (e[r[i]] = t[r[i]]);
  }
  return e;
};
class JX {
  constructor() {
    this.nameMap = {};
  }
  rename(t, n) {
    this.nameMap[t] = n;
  }
  has(t) {
    return void 0 !== this.nameMap[t];
  }
  get(t) {
    for (; this.nameMap[t] && t !== this.nameMap[t]; ) t = this.nameMap[t];
    return t;
  }
}
function QX(t) {
  return 'unit' === (null == t ? void 0 : t.type);
}
function ZX(t) {
  return 'facet' === (null == t ? void 0 : t.type);
}
function KX(t) {
  return 'concat' === (null == t ? void 0 : t.type);
}
function tJ(t) {
  return 'layer' === (null == t ? void 0 : t.type);
}
class nJ {
  constructor(t, n, e, r, i, o, u) {
    var s, a;
    (this.type = n),
      (this.parent = e),
      (this.config = i),
      (this.correctDataNames = t => {
        var n, e, r;
        return (
          (null === (n = t.from) || void 0 === n ? void 0 : n.data) &&
            (t.from.data = this.lookupDataSource(t.from.data)),
          (null === (r = null === (e = t.from) || void 0 === e ? void 0 : e.facet) || void 0 === r ? void 0 : r.data) &&
            (t.from.facet.data = this.lookupDataSource(t.from.facet.data)),
          t
        );
      }),
      (this.parent = e),
      (this.config = i),
      (this.view = kR(u)),
      (this.name = null !== (s = t.name) && void 0 !== s ? s : r),
      (this.title = $R(t.title) ? { text: t.title } : t.title ? kR(t.title) : void 0),
      (this.scaleNameMap = e ? e.scaleNameMap : new JX()),
      (this.projectionNameMap = e ? e.projectionNameMap : new JX()),
      (this.signalNameMap = e ? e.signalNameMap : new JX()),
      (this.data = t.data),
      (this.description = t.description),
      (this.transforms = (function (t) {
        return t.map(t => (dH(t) ? { filter: Jz(t.filter, nq) } : t));
      })(null !== (a = t.transform) && void 0 !== a ? a : [])),
      (this.layout =
        'layer' === n || 'unit' === n
          ? {}
          : (function (t, n, e) {
              var r, i;
              const o = e[n],
                u = {},
                { spacing: s, columns: a } = o;
              void 0 !== s && (u.spacing = s),
                void 0 !== a && ((jI(t) && !$I(t.facet)) || wW(t)) && (u.columns = a),
                xW(t) && (u.columns = 1);
              for (const n of MW)
                if (void 0 !== t[n])
                  if ('spacing' === n) {
                    const e = t[n];
                    u[n] = Vt(e)
                      ? e
                      : {
                          row: null !== (r = e.row) && void 0 !== r ? r : s,
                          column: null !== (i = e.column) && void 0 !== i ? i : s,
                        };
                  } else u[n] = t[n];
              return u;
            })(t, n, i)),
      (this.component = {
        data: {
          sources: e ? e.component.data.sources : [],
          outputNodes: e ? e.component.data.outputNodes : {},
          outputNodeRefCounts: e ? e.component.data.outputNodeRefCounts : {},
          isFaceted: jI(t) || ((null == e ? void 0 : e.component.data.isFaceted) && void 0 === t.data),
        },
        layoutSize: new GH(),
        layoutHeaders: { row: {}, column: {}, facet: {} },
        mark: null,
        resolve: Object.assign({ scale: {}, axis: {}, legend: {} }, o ? Zz(o) : {}),
        selection: null,
        scales: null,
        projection: null,
        axes: {},
        legends: {},
      });
  }
  get width() {
    return this.getSizeSignalRef('width');
  }
  get height() {
    return this.getSizeSignalRef('height');
  }
  parse() {
    this.parseScale(),
      this.parseLayoutSize(),
      this.renameTopLevelLayoutSizeSignal(),
      this.parseSelections(),
      this.parseProjection(),
      this.parseData(),
      this.parseAxesAndHeaders(),
      this.parseLegends(),
      this.parseMarkGroup();
  }
  parseScale() {
    !(function (t, { ignoreRange: n } = {}) {
      VX(t), bX(t);
      for (const n of Dq) IX(t, n);
      n || WX(t);
    })(this);
  }
  parseProjection() {
    SY(this);
  }
  renameTopLevelLayoutSizeSignal() {
    'width' !== this.getName('width') && this.renameSignal(this.getName('width'), 'width'),
      'height' !== this.getName('height') && this.renameSignal(this.getName('height'), 'height');
  }
  parseLegends() {
    kY(this);
  }
  assembleEncodeFromView(t) {
    const n = XX(t, ['style']),
      e = {};
    for (const t of vT(n)) {
      const r = n[t];
      void 0 !== r && (e[t] = zR(r));
    }
    return e;
  }
  assembleGroupEncodeEntry(t) {
    let n = {};
    return (
      this.view && (n = this.assembleEncodeFromView(this.view)),
      t || (this.description && (n.description = zR(this.description)), 'unit' !== this.type && 'layer' !== this.type)
        ? mT(n)
          ? void 0
          : n
        : Object.assign(
            { width: this.getSizeSignalRef('width'), height: this.getSizeSignalRef('height') },
            null != n ? n : {},
          )
    );
  }
  assembleLayout() {
    if (!this.layout) return;
    const t = this.layout,
      { spacing: n } = t,
      e = XX(t, ['spacing']),
      { component: r, config: i } = this,
      o = (function (t, n) {
        const e = {};
        for (const r of DP) {
          const i = t[r];
          if (null == i ? void 0 : i.facetFieldDef) {
            const { titleAnchor: t, titleOrient: o } = HV(['titleAnchor', 'titleOrient'], i.facetFieldDef.header, n, r),
              u = UV(r, o),
              s = eY(t, u);
            void 0 !== s && (e[u] = s);
          }
        }
        return mT(e) ? void 0 : e;
      })(r.layoutHeaders, i);
    return Object.assign(
      Object.assign(Object.assign({ padding: n }, this.assembleDefaultLayout()), e),
      o ? { titleBand: o } : {},
    );
  }
  assembleDefaultLayout() {
    return {};
  }
  assembleHeaderMarks() {
    const { layoutHeaders: t } = this.component;
    let n = [];
    for (const e of DP) t[e].title && n.push(YV(this, e));
    for (const t of GV) n = n.concat(QV(this, t));
    return n;
  }
  assembleAxes() {
    return (function (t, n) {
      const { x: e = [], y: r = [] } = t;
      return [
        ...e.map(t => SV(t, 'grid', n)),
        ...r.map(t => SV(t, 'grid', n)),
        ...e.map(t => SV(t, 'main', n)),
        ...r.map(t => SV(t, 'main', n)),
      ].filter(t => t);
    })(this.component.axes, this.config);
  }
  assembleLegends() {
    return jY(this);
  }
  assembleProjections() {
    return tJ((t = this)) || KX(t)
      ? (function (t) {
          return t.children.reduce((t, n) => t.concat(n.assembleProjections()), DY(t));
        })(t)
      : DY(t);
    var t;
  }
  assembleTitle() {
    var t, n, e;
    const r = null !== (t = this.title) && void 0 !== t ? t : {},
      { encoding: i } = r,
      o = XX(r, ['encoding']),
      u = Object.assign(
        Object.assign(Object.assign({}, AR(this.config.title).nonMarkTitleProperties), o),
        i ? { encode: { update: i } } : {},
      );
    if (u.text)
      return (
        oT(['unit', 'layer'], this.type)
          ? oT(['middle', void 0], u.anchor) && ((null !== (n = u.frame) && void 0 !== n) || (u.frame = 'group'))
          : (null !== (e = u.anchor) && void 0 !== e) || (u.anchor = 'start'),
        mT(u) ? void 0 : u
      );
  }
  assembleGroup(t = []) {
    const n = {};
    (t = t.concat(this.assembleSignals())).length > 0 && (n.signals = t);
    const e = this.assembleLayout();
    e && (n.layout = e), (n.marks = [].concat(this.assembleHeaderMarks(), this.assembleMarks()));
    const r = !this.parent || ZX(this.parent) ? FX(this) : [];
    r.length > 0 && (n.scales = r);
    const i = this.assembleAxes();
    i.length > 0 && (n.axes = i);
    const o = this.assembleLegends();
    return o.length > 0 && (n.legends = o), n;
  }
  getName(t) {
    return wT((this.name ? `${this.name}_` : '') + t);
  }
  getDataName(t) {
    return this.getName(uG[t].toLowerCase());
  }
  requestDataName(t) {
    const n = this.getDataName(t),
      e = this.component.data.outputNodeRefCounts;
    return (e[n] = (e[n] || 0) + 1), n;
  }
  getSizeSignalRef(t) {
    if (ZX(this.parent)) {
      const n = JP(aY(t)),
        e = this.component.scales[n];
      if (e && !e.merged) {
        const t = e.get('type'),
          r = e.get('range');
        if (Oq(t) && jR(r)) {
          const t = e.get('name'),
            r = jX(DX(this, n));
          return r
            ? { signal: sY(t, e, JI({ aggregate: 'distinct', field: r }, { expr: 'datum' })) }
            : (DL(KR(n)), null);
        }
      }
    }
    return { signal: this.signalNameMap.get(this.getName(t)) };
  }
  lookupDataSource(t) {
    const n = this.component.data.outputNodes[t];
    return n ? n.getSource() : t;
  }
  getSignalName(t) {
    return this.signalNameMap.get(t);
  }
  renameSignal(t, n) {
    this.signalNameMap.rename(t, n);
  }
  renameScale(t, n) {
    this.scaleNameMap.rename(t, n);
  }
  renameProjection(t, n) {
    this.projectionNameMap.rename(t, n);
  }
  scaleName(t, n) {
    return n
      ? this.getName(t)
      : (NP(t) && rR(t) && this.component.scales[t]) || this.scaleNameMap.has(this.getName(t))
      ? this.scaleNameMap.get(this.getName(t))
      : void 0;
  }
  projectionName(t) {
    return t
      ? this.getName('projection')
      : (this.component.projection && !this.component.projection.merged) ||
        this.projectionNameMap.has(this.getName('projection'))
      ? this.projectionNameMap.get(this.getName('projection'))
      : void 0;
  }
  getScaleComponent(t) {
    if (!this.component.scales)
      throw new Error(
        'getScaleComponent cannot be called before parseScale(). Make sure you have called parseScale or use parseUnitModelWithScale().',
      );
    const n = this.component.scales[t];
    return n && !n.merged ? n : this.parent ? this.parent.getScaleComponent(t) : void 0;
  }
  getSelectionComponent(t, n) {
    let e = this.component.selection[t];
    if ((!e && this.parent && (e = this.parent.getSelectionComponent(t, n)), !e))
      throw new Error(`Cannot find a selection named "${n}".`);
    return e;
  }
  hasAxisOrientSignalRef() {
    var t, n;
    return (
      (null === (t = this.component.axes.x) || void 0 === t ? void 0 : t.some(t => t.hasOrientSignalRef())) ||
      (null === (n = this.component.axes.y) || void 0 === n ? void 0 : n.some(t => t.hasOrientSignalRef()))
    );
  }
}
class eJ extends nJ {
  vgField(t, n = {}) {
    const e = this.fieldDef(t);
    if (e) return JI(e, n);
  }
  reduceFieldDef(t, n) {
    return (function (t, n, e, r) {
      return t
        ? vT(t).reduce((e, i) => {
            const o = t[i];
            return K(o) ? o.reduce((t, e) => n.call(r, t, e, i), e) : n.call(r, e, o, i);
          }, e)
        : e;
    })(
      this.getMapping(),
      (n, e, r) => {
        const i = oU(e);
        return i ? t(n, i, r) : n;
      },
      n,
    );
  }
  forEachFieldDef(t, n) {
    NU(
      this.getMapping(),
      (n, e) => {
        const r = oU(n);
        r && t(r, e);
      },
      n,
    );
  }
}
class rJ extends hG {
  constructor(t, n) {
    var e, r, i;
    super(t), (this.transform = n), (this.transform = Zz(n));
    const o = null !== (e = this.transform.as) && void 0 !== e ? e : [void 0, void 0];
    (this.transform.as = [
      null !== (r = o[0]) && void 0 !== r ? r : 'value',
      null !== (i = o[1]) && void 0 !== i ? i : 'density',
    ]),
      n.groupby && null == n.minsteps && null == n.maxsteps && null == n.steps && (this.transform.steps = 200);
  }
  clone() {
    return new rJ(null, Zz(this.transform));
  }
  dependentFields() {
    var t;
    return new Set([this.transform.density, ...(null !== (t = this.transform.groupby) && void 0 !== t ? t : [])]);
  }
  producedFields() {
    return new Set(this.transform.as);
  }
  hash() {
    return `DensityTransform ${rT(this.transform)}`;
  }
  assemble() {
    const t = this.transform,
      { density: n } = t,
      e = (function (t, n) {
        var e = {};
        for (var r in t) Object.prototype.hasOwnProperty.call(t, r) && n.indexOf(r) < 0 && (e[r] = t[r]);
        if (null != t && 'function' == typeof Object.getOwnPropertySymbols) {
          var i = 0;
          for (r = Object.getOwnPropertySymbols(t); i < r.length; i++)
            n.indexOf(r[i]) < 0 && Object.prototype.propertyIsEnumerable.call(t, r[i]) && (e[r[i]] = t[r[i]]);
        }
        return e;
      })(t, ['density']);
    return Object.assign({ type: 'kde', field: n }, e);
  }
}
class iJ extends hG {
  constructor(t, n) {
    super(t), (this.filter = n);
  }
  clone() {
    return new iJ(null, Object.assign({}, this.filter));
  }
  static make(t, n) {
    const { config: e, mark: r, markDef: i } = n;
    if ('filter' !== qR('invalid', i, e)) return null;
    const o = n.reduceFieldDef((t, e, i) => {
      const o = rR(i) && n.getScaleComponent(i);
      return o && kq(o.get('type')) && 'count' !== e.aggregate && !Gq(r) && (t[e.field] = e), t;
    }, {});
    return vT(o).length ? new iJ(t, o) : null;
  }
  dependentFields() {
    return new Set(vT(this.filter));
  }
  producedFields() {
    return new Set();
  }
  hash() {
    return `FilterInvalid ${rT(this.filter)}`;
  }
  assemble() {
    const t = vT(this.filter).reduce((t, n) => {
      const e = this.filter[n],
        r = JI(e, { expr: 'datum' });
      return (
        null !== e &&
          ('temporal' === e.type
            ? t.push(`(isDate(${r}) || (isValid(${r}) && isFinite(+${r})))`)
            : 'quantitative' === e.type && (t.push(`isValid(${r})`), t.push(`isFinite(+${r})`))),
        t
      );
    }, []);
    return t.length > 0 ? { type: 'filter', expr: t.join(' && ') } : null;
  }
}
class oJ extends hG {
  constructor(t, n) {
    super(t), (this.transform = n), (this.transform = Zz(n));
    const { flatten: e, as: r = [] } = this.transform;
    this.transform.as = e.map((t, n) => {
      var e;
      return null !== (e = r[n]) && void 0 !== e ? e : t;
    });
  }
  clone() {
    return new oJ(this.parent, Zz(this.transform));
  }
  dependentFields() {
    return new Set(this.transform.flatten);
  }
  producedFields() {
    return new Set(this.transform.as);
  }
  hash() {
    return `FlattenTransform ${rT(this.transform)}`;
  }
  assemble() {
    const { flatten: t, as: n } = this.transform;
    return { type: 'flatten', fields: t, as: n };
  }
}
class uJ extends hG {
  constructor(t, n) {
    var e, r, i;
    super(t), (this.transform = n), (this.transform = Zz(n));
    const o = null !== (e = this.transform.as) && void 0 !== e ? e : [void 0, void 0];
    this.transform.as = [
      null !== (r = o[0]) && void 0 !== r ? r : 'key',
      null !== (i = o[1]) && void 0 !== i ? i : 'value',
    ];
  }
  clone() {
    return new uJ(null, Zz(this.transform));
  }
  dependentFields() {
    return new Set(this.transform.fold);
  }
  producedFields() {
    return new Set(this.transform.as);
  }
  hash() {
    return `FoldTransform ${rT(this.transform)}`;
  }
  assemble() {
    const { fold: t, as: n } = this.transform;
    return { type: 'fold', fields: t, as: n };
  }
}
class sJ extends hG {
  constructor(t, n, e, r) {
    super(t), (this.fields = n), (this.geojson = e), (this.signal = r);
  }
  clone() {
    return new sJ(null, Zz(this.fields), this.geojson, this.signal);
  }
  static parseAll(t, n) {
    if (n.component.projection && !n.component.projection.isFit) return t;
    let e = 0;
    for (const r of [
      [KT, ZT],
      [nP, tP],
    ]) {
      const i = r.map(t => {
        const e = uU(n.encoding[t]);
        return TI(e) ? e.field : RI(e) ? { expr: `${e.datum}` } : WI(e) ? { expr: `${e.value}` } : void 0;
      });
      (i[0] || i[1]) && (t = new sJ(t, i, null, n.getName('geojson_' + e++)));
    }
    if (n.channelHasField(oP)) {
      const r = n.typedFieldDef(oP);
      r.type === sq && (t = new sJ(t, null, r.field, n.getName('geojson_' + e++)));
    }
    return t;
  }
  dependentFields() {
    var t;
    const n = (null !== (t = this.fields) && void 0 !== t ? t : []).filter(Xt);
    return new Set([...(this.geojson ? [this.geojson] : []), ...n]);
  }
  producedFields() {
    return new Set();
  }
  hash() {
    return `GeoJSON ${this.geojson} ${this.signal} ${rT(this.fields)}`;
  }
  assemble() {
    return [
      ...(this.geojson ? [{ type: 'filter', expr: `isValid(datum["${this.geojson}"])` }] : []),
      Object.assign(
        Object.assign(
          Object.assign({ type: 'geojson' }, this.fields ? { fields: this.fields } : {}),
          this.geojson ? { geojson: this.geojson } : {},
        ),
        { signal: this.signal },
      ),
    ];
  }
}
class aJ extends hG {
  constructor(t, n, e, r) {
    super(t), (this.projection = n), (this.fields = e), (this.as = r);
  }
  clone() {
    return new aJ(null, this.projection, Zz(this.fields), Zz(this.as));
  }
  static parseAll(t, n) {
    if (!n.projectionName()) return t;
    for (const e of [
      [KT, ZT],
      [nP, tP],
    ]) {
      const r = e.map(t => {
          const e = uU(n.encoding[t]);
          return TI(e) ? e.field : RI(e) ? { expr: `${e.datum}` } : WI(e) ? { expr: `${e.value}` } : void 0;
        }),
        i = e[0] === nP ? '2' : '';
      (r[0] || r[1]) && (t = new aJ(t, n.projectionName(), r, [n.getName(`x${i}`), n.getName(`y${i}`)]));
    }
    return t;
  }
  dependentFields() {
    return new Set(this.fields.filter(Xt));
  }
  producedFields() {
    return new Set(this.as);
  }
  hash() {
    return `Geopoint ${this.projection} ${rT(this.fields)} ${rT(this.as)}`;
  }
  assemble() {
    return { type: 'geopoint', projection: this.projection, fields: this.fields, as: this.as };
  }
}
class cJ extends hG {
  constructor(t, n) {
    super(t), (this.transform = n);
  }
  clone() {
    return new cJ(null, Zz(this.transform));
  }
  dependentFields() {
    var t;
    return new Set([
      this.transform.impute,
      this.transform.key,
      ...(null !== (t = this.transform.groupby) && void 0 !== t ? t : []),
    ]);
  }
  producedFields() {
    return new Set([this.transform.impute]);
  }
  processSequence(t) {
    const { start: n = 0, stop: e, step: r } = t;
    return { signal: `sequence(${[n, e, ...(r ? [r] : [])].join(',')})` };
  }
  static makeFromTransform(t, n) {
    return new cJ(t, n);
  }
  static makeFromEncoding(t, n) {
    const e = n.encoding,
      r = e.x,
      i = e.y;
    if (TI(r) && TI(i)) {
      const o = r.impute ? r : i.impute ? i : void 0;
      if (void 0 === o) return;
      const u = r.impute ? i : i.impute ? r : void 0,
        { method: s, value: a, frame: c, keyvals: l } = o.impute,
        f = BU(n.mark, e);
      return new cJ(
        t,
        Object.assign(
          Object.assign(
            Object.assign(
              Object.assign(
                Object.assign({ impute: o.field, key: u.field }, s ? { method: s } : {}),
                void 0 !== a ? { value: a } : {},
              ),
              c ? { frame: c } : {},
            ),
            void 0 !== l ? { keyvals: l } : {},
          ),
          f.length ? { groupby: f } : {},
        ),
      );
    }
    return null;
  }
  hash() {
    return `Impute ${rT(this.transform)}`;
  }
  assemble() {
    const { impute: t, key: n, keyvals: e, method: r, groupby: i, value: o, frame: u = [null, null] } = this.transform,
      s = Object.assign(
        Object.assign(
          Object.assign(
            Object.assign(
              { type: 'impute', field: t, key: n },
              e ? { keyvals: pH(e) ? this.processSequence(e) : e } : {},
            ),
            { method: 'value' },
          ),
          i ? { groupby: i } : {},
        ),
        { value: r && 'value' !== r ? null : o },
      );
    return r && 'value' !== r
      ? [
          s,
          Object.assign(
            { type: 'window', as: [`imputed_${t}_value`], ops: [r], fields: [t], frame: u, ignorePeers: !1 },
            i ? { groupby: i } : {},
          ),
          { type: 'formula', expr: `datum.${t} === null ? datum.imputed_${t}_value : datum.${t}`, as: t },
        ]
      : [s];
  }
}
class lJ extends hG {
  constructor(t, n) {
    var e, r, i;
    super(t), (this.transform = n), (this.transform = Zz(n));
    const o = null !== (e = this.transform.as) && void 0 !== e ? e : [void 0, void 0];
    this.transform.as = [
      null !== (r = o[0]) && void 0 !== r ? r : n.on,
      null !== (i = o[1]) && void 0 !== i ? i : n.loess,
    ];
  }
  clone() {
    return new lJ(null, Zz(this.transform));
  }
  dependentFields() {
    var t;
    return new Set([
      this.transform.loess,
      this.transform.on,
      ...(null !== (t = this.transform.groupby) && void 0 !== t ? t : []),
    ]);
  }
  producedFields() {
    return new Set(this.transform.as);
  }
  hash() {
    return `LoessTransform ${rT(this.transform)}`;
  }
  assemble() {
    const t = this.transform,
      { loess: n, on: e } = t,
      r = (function (t, n) {
        var e = {};
        for (var r in t) Object.prototype.hasOwnProperty.call(t, r) && n.indexOf(r) < 0 && (e[r] = t[r]);
        if (null != t && 'function' == typeof Object.getOwnPropertySymbols) {
          var i = 0;
          for (r = Object.getOwnPropertySymbols(t); i < r.length; i++)
            n.indexOf(r[i]) < 0 && Object.prototype.propertyIsEnumerable.call(t, r[i]) && (e[r[i]] = t[r[i]]);
        }
        return e;
      })(t, ['loess', 'on']);
    return Object.assign({ type: 'loess', x: e, y: n }, r);
  }
}
class fJ extends hG {
  constructor(t, n, e) {
    super(t), (this.transform = n), (this.secondary = e);
  }
  clone() {
    return new fJ(null, Zz(this.transform), this.secondary);
  }
  static make(t, n, e, r) {
    const i = n.component.data.sources,
      { from: o } = e;
    let u = null;
    if (
      (function (t) {
        return 'data' in t;
      })(o)
    ) {
      let t = $J(o.data, i);
      t || ((t = new WY(o.data)), i.push(t));
      const e = n.getName(`lookup_${r}`);
      (u = new dG(t, e, uG.Lookup, n.component.data.outputNodeRefCounts)), (n.component.data.outputNodes[e] = u);
    } else if (
      (function (t) {
        return 'param' in t;
      })(o)
    ) {
      const t = o.param;
      let r;
      e = Object.assign({ as: t }, e);
      try {
        r = n.getSelectionComponent(wT(t), t);
      } catch (n) {
        throw new Error(`Lookups can only be performed on selection parameters. "${t}" is a variable parameter.`);
      }
      if (((u = r.materialized), !u))
        throw new Error(
          (function (t) {
            return `Cannot define and lookup the "${t}" selection in the same view. Try moving the lookup into a second, layered view?`;
          })(t),
        );
    }
    return new fJ(t, e, u.getSource());
  }
  dependentFields() {
    return new Set([this.transform.lookup]);
  }
  producedFields() {
    return new Set(this.transform.as ? At(this.transform.as) : this.transform.from.fields);
  }
  hash() {
    return `Lookup ${rT({ transform: this.transform, secondary: this.secondary })}`;
  }
  assemble() {
    let t;
    if (this.transform.from.fields)
      t = Object.assign({ values: this.transform.from.fields }, this.transform.as ? { as: At(this.transform.as) } : {});
    else {
      let n = this.transform.as;
      Xt(n) ||
        (DL(
          'If "from.fields" is not specified, "as" has to be a string that specifies the key to be used for the data from the secondary source.',
        ),
        (n = '_lookup')),
        (t = { as: [n] });
    }
    return Object.assign(
      Object.assign(
        { type: 'lookup', from: this.secondary, key: this.transform.from.key, fields: [this.transform.lookup] },
        t,
      ),
      this.transform.default ? { default: this.transform.default } : {},
    );
  }
}
class hJ extends hG {
  constructor(t, n) {
    var e, r, i;
    super(t), (this.transform = n), (this.transform = Zz(n));
    const o = null !== (e = this.transform.as) && void 0 !== e ? e : [void 0, void 0];
    this.transform.as = [
      null !== (r = o[0]) && void 0 !== r ? r : 'prob',
      null !== (i = o[1]) && void 0 !== i ? i : 'value',
    ];
  }
  clone() {
    return new hJ(null, Zz(this.transform));
  }
  dependentFields() {
    var t;
    return new Set([this.transform.quantile, ...(null !== (t = this.transform.groupby) && void 0 !== t ? t : [])]);
  }
  producedFields() {
    return new Set(this.transform.as);
  }
  hash() {
    return `QuantileTransform ${rT(this.transform)}`;
  }
  assemble() {
    const t = this.transform,
      { quantile: n } = t,
      e = (function (t, n) {
        var e = {};
        for (var r in t) Object.prototype.hasOwnProperty.call(t, r) && n.indexOf(r) < 0 && (e[r] = t[r]);
        if (null != t && 'function' == typeof Object.getOwnPropertySymbols) {
          var i = 0;
          for (r = Object.getOwnPropertySymbols(t); i < r.length; i++)
            n.indexOf(r[i]) < 0 && Object.prototype.propertyIsEnumerable.call(t, r[i]) && (e[r[i]] = t[r[i]]);
        }
        return e;
      })(t, ['quantile']);
    return Object.assign({ type: 'quantile', field: n }, e);
  }
}
class dJ extends hG {
  constructor(t, n) {
    var e, r, i;
    super(t), (this.transform = n), (this.transform = Zz(n));
    const o = null !== (e = this.transform.as) && void 0 !== e ? e : [void 0, void 0];
    this.transform.as = [
      null !== (r = o[0]) && void 0 !== r ? r : n.on,
      null !== (i = o[1]) && void 0 !== i ? i : n.regression,
    ];
  }
  clone() {
    return new dJ(null, Zz(this.transform));
  }
  dependentFields() {
    var t;
    return new Set([
      this.transform.regression,
      this.transform.on,
      ...(null !== (t = this.transform.groupby) && void 0 !== t ? t : []),
    ]);
  }
  producedFields() {
    return new Set(this.transform.as);
  }
  hash() {
    return `RegressionTransform ${rT(this.transform)}`;
  }
  assemble() {
    const t = this.transform,
      { regression: n, on: e } = t,
      r = (function (t, n) {
        var e = {};
        for (var r in t) Object.prototype.hasOwnProperty.call(t, r) && n.indexOf(r) < 0 && (e[r] = t[r]);
        if (null != t && 'function' == typeof Object.getOwnPropertySymbols) {
          var i = 0;
          for (r = Object.getOwnPropertySymbols(t); i < r.length; i++)
            n.indexOf(r[i]) < 0 && Object.prototype.propertyIsEnumerable.call(t, r[i]) && (e[r[i]] = t[r[i]]);
        }
        return e;
      })(t, ['regression', 'on']);
    return Object.assign({ type: 'regression', x: e, y: n }, r);
  }
}
class pJ extends hG {
  constructor(t, n) {
    super(t), (this.transform = n);
  }
  clone() {
    return new pJ(null, Zz(this.transform));
  }
  addDimensions(t) {
    var n;
    this.transform.groupby = lT((null !== (n = this.transform.groupby) && void 0 !== n ? n : []).concat(t), t => t);
  }
  producedFields() {}
  dependentFields() {
    var t;
    return new Set([
      this.transform.pivot,
      this.transform.value,
      ...(null !== (t = this.transform.groupby) && void 0 !== t ? t : []),
    ]);
  }
  hash() {
    return `PivotTransform ${rT(this.transform)}`;
  }
  assemble() {
    const { pivot: t, value: n, groupby: e, limit: r, op: i } = this.transform;
    return Object.assign(
      Object.assign(
        Object.assign({ type: 'pivot', field: t, value: n }, void 0 !== r ? { limit: r } : {}),
        void 0 !== i ? { op: i } : {},
      ),
      void 0 !== e ? { groupby: e } : {},
    );
  }
}
class mJ extends hG {
  constructor(t, n) {
    super(t), (this.transform = n);
  }
  clone() {
    return new mJ(null, Zz(this.transform));
  }
  dependentFields() {
    return new Set();
  }
  producedFields() {
    return new Set();
  }
  hash() {
    return `SampleTransform ${rT(this.transform)}`;
  }
  assemble() {
    return { type: 'sample', size: this.transform.sample };
  }
}
function vJ(t) {
  let n = 0;
  return function e(r, i) {
    var o;
    if (
      (r instanceof WY &&
        !r.isGenerator &&
        !KH(r.data) &&
        (t.push(i), (i = { name: null, source: i.name, transform: [] })),
      r instanceof LY &&
        (r.parent instanceof WY && !i.source
          ? ((i.format = Object.assign(Object.assign({}, null !== (o = i.format) && void 0 !== o ? o : {}), {
              parse: r.assembleFormatParse(),
            })),
            i.transform.push(...r.assembleTransforms(!0)))
          : i.transform.push(...r.assembleTransforms())),
      r instanceof TY)
    )
      return (
        i.name || (i.name = 'data_' + n++),
        !i.source || i.transform.length > 0 ? (t.push(i), (r.data = i.name)) : (r.data = i.source),
        void t.push(...r.assemble())
      );
    switch (
      ((r instanceof IY ||
        r instanceof UY ||
        r instanceof iJ ||
        r instanceof $V ||
        r instanceof qV ||
        r instanceof aJ ||
        r instanceof zY ||
        r instanceof fJ ||
        r instanceof lX ||
        r instanceof aX ||
        r instanceof uJ ||
        r instanceof oJ ||
        r instanceof rJ ||
        r instanceof lJ ||
        r instanceof hJ ||
        r instanceof dJ ||
        r instanceof qY ||
        r instanceof mJ ||
        r instanceof pJ) &&
        i.transform.push(r.assemble()),
      (r instanceof _Y || r instanceof mG || r instanceof cJ || r instanceof cX || r instanceof sJ) &&
        i.transform.push(...r.assemble()),
      r instanceof dG &&
        (i.source && 0 === i.transform.length
          ? r.setSource(i.source)
          : r.parent instanceof dG
          ? r.setSource(i.name)
          : (i.name || (i.name = 'data_' + n++),
            r.setSource(i.name),
            1 === r.numChildren() && (t.push(i), (i = { name: null, source: i.name, transform: [] })))),
      r.numChildren())
    ) {
      case 0:
        r instanceof dG && (!i.source || i.transform.length > 0) && t.push(i);
        break;
      case 1:
        e(r.children[0], i);
        break;
      default: {
        i.name || (i.name = 'data_' + n++);
        let o = i.name;
        !i.source || i.transform.length > 0 ? t.push(i) : (o = i.source);
        for (const t of r.children) e(t, { name: null, source: o, transform: [] });
        break;
      }
    }
  };
}
function gJ(t, n) {
  var e;
  const { facet: r, config: i, child: o, component: u } = t;
  if (t.channelHasField(n)) {
    const s = r[n],
      a = WV('title', null, i, n);
    let c = nU(s, i, { allowDisabling: !0, includeDefault: void 0 === a || !!a });
    o.component.layoutHeaders[n].title &&
      ((c = K(c) ? c.join(', ') : c),
      (c += ` / ${o.component.layoutHeaders[n].title}`),
      (o.component.layoutHeaders[n].title = null));
    const l = WV('labelOrient', s.header, i, n),
      f = null !== s.header && ST(null === (e = s.header) || void 0 === e ? void 0 : e.labels, i.header.labels, !0),
      h = oT(['bottom', 'right'], l) ? 'footer' : 'header';
    u.layoutHeaders[n] = {
      title: null !== s.header ? c : null,
      facetFieldDef: s,
      [h]: 'facet' === n ? [] : [bJ(t, n, f)],
    };
  }
}
function bJ(t, n, e) {
  const r = 'row' === n ? 'height' : 'width';
  return {
    labels: e,
    sizeSignal: t.child.component.layoutSize.get(r) ? t.child.getSizeSignalRef(r) : void 0,
    axes: [],
  };
}
function yJ(t, n) {
  var e;
  const { child: r } = t;
  if (r.component.axes[n]) {
    const { layoutHeaders: o, resolve: u } = t.component;
    if (((u.axis[n] = fY(u, n)), 'shared' === u.axis[n])) {
      const u = 'x' === n ? 'column' : 'row',
        s = o[u];
      for (const o of r.component.axes[n]) {
        const n = 'top' === (i = o.get('orient')) || 'left' === i || MR(i) ? 'header' : 'footer';
        (null !== (e = s[n]) && void 0 !== e) || (s[n] = [bJ(t, u, !1)]);
        const r = SV(o, 'main', t.config, { header: !0 });
        r && s[n][0].axes.push(r), (o.mainExtracted = !0);
      }
    }
  }
  var i;
}
function wJ(t) {
  for (const n of t.children) n.parseLayoutSize();
}
function xJ(t, n) {
  var e;
  const r = aY(n),
    i = JP(r),
    o = t.component.resolve,
    u = t.component.layoutSize;
  let s;
  for (const n of t.children) {
    const u = n.component.layoutSize.getWithExplicit(r),
      a = null !== (e = o.scale[i]) && void 0 !== e ? e : lY(i, t);
    if ('independent' === a && 'step' === u.value) {
      s = void 0;
      break;
    }
    if (s) {
      if ('independent' === a && s.value !== u.value) {
        s = void 0;
        break;
      }
      s = QH(s, u, r, '');
    } else s = u;
  }
  if (s) {
    for (const e of t.children) t.renameSignal(e.getName(r), t.getName(n)), e.component.layoutSize.set(r, 'merged', !1);
    u.setWithExplicit(n, s);
  } else u.setWithExplicit(n, { explicit: !1, value: void 0 });
}
function OJ(t, n) {
  const e = t.config,
    r = t.getScaleComponent('width' === n ? 'x' : 'y');
  if (r) {
    const t = r.get('type'),
      i = r.get('range');
    if (Oq(t)) {
      const t = FW(e.view, n);
      return jR(i) || AW(t) ? 'step' : t;
    }
    return jW(e.view, n);
  }
  if (t.hasProjection || 'arc' === t.mark) return jW(e.view, n);
  {
    const t = FW(e.view, n);
    return AW(t) ? t.step : t;
  }
}
function kJ(t, n, e) {
  return JI(n, Object.assign({ suffix: `by_${JI(t)}` }, null != e ? e : {}));
}
class AJ extends eJ {
  constructor(t, n, e, r) {
    super(t, 'facet', n, e, r, t.resolve),
      (this.child = HJ(t.spec, this, this.getName('child'), void 0, r)),
      (this.children = [this.child]),
      (this.facet = this.initFacet(t.facet));
  }
  initFacet(t) {
    if (!$I(t)) return { facet: this.initFacetFieldDef(t, 'facet') };
    const n = vT(t),
      e = {};
    for (const r of n) {
      if (![RT, LT].includes(r)) {
        DL(hL(r, 'facet'));
        break;
      }
      const n = t[r];
      if (void 0 === n.field) {
        DL(fL(n, r));
        break;
      }
      e[r] = this.initFacetFieldDef(n, r);
    }
    return e;
  }
  initFacetFieldDef(t, n) {
    const e = cU(t, n);
    return e.header ? (e.header = kR(e.header)) : null === e.header && (e.header = null), e;
  }
  channelHasField(t) {
    return !!this.facet[t];
  }
  fieldDef(t) {
    return this.facet[t];
  }
  parseData() {
    (this.component.data = MJ(this)), this.child.parseData();
  }
  parseLayoutSize() {
    wJ(this);
  }
  parseSelections() {
    this.child.parseSelections(), (this.component.selection = this.child.component.selection);
  }
  parseMarkGroup() {
    this.child.parseMarkGroup();
  }
  parseAxesAndHeaders() {
    this.child.parseAxesAndHeaders(),
      (function (t) {
        for (const n of DP) gJ(t, n);
        yJ(t, 'x'), yJ(t, 'y');
      })(this);
  }
  assembleSelectionTopLevelSignals(t) {
    return this.child.assembleSelectionTopLevelSignals(t);
  }
  assembleSignals() {
    return this.child.assembleSignals(), [];
  }
  assembleSelectionData(t) {
    return this.child.assembleSelectionData(t);
  }
  getHeaderLayoutMixins() {
    var t, n, e;
    const r = {};
    for (const i of DP)
      for (const o of VV) {
        const u = this.component.layoutHeaders[i],
          s = u[o],
          { facetFieldDef: a } = u;
        if (a) {
          const n = WV('titleOrient', a.header, this.config, i);
          if (['right', 'bottom'].includes(n)) {
            const e = UV(i, n);
            (null !== (t = r.titleAnchor) && void 0 !== t) || (r.titleAnchor = {}), (r.titleAnchor[e] = 'end');
          }
        }
        if (null == s ? void 0 : s[0]) {
          const t = 'header' === o ? 'headerBand' : 'footerBand';
          'facet' === i ||
            this.child.component.layoutSize.get('row' === i ? 'height' : 'width') ||
            ((null !== (n = r[t]) && void 0 !== n) || (r[t] = {}), (r[t][i] = 0.5)),
            u.title &&
              ((null !== (e = r.offset) && void 0 !== e) || (r.offset = {}),
              (r.offset['row' === i ? 'rowTitle' : 'columnTitle'] = 10));
        }
      }
    return r;
  }
  assembleDefaultLayout() {
    const { column: t, row: n } = this.facet,
      e = t ? this.columnDistinctSignal() : n ? 1 : void 0;
    let r = 'all';
    return (
      ((n || 'independent' !== this.component.resolve.scale.x) &&
        (t || 'independent' !== this.component.resolve.scale.y)) ||
        (r = 'none'),
      Object.assign(Object.assign(Object.assign({}, this.getHeaderLayoutMixins()), e ? { columns: e } : {}), {
        bounds: 'full',
        align: r,
      })
    );
  }
  assembleLayoutSignals() {
    return this.child.assembleLayoutSignals();
  }
  columnDistinctSignal() {
    if (!(this.parent && this.parent instanceof AJ))
      return { signal: `length(data('${this.getName('column_domain')}'))` };
  }
  assembleGroupStyle() {}
  assembleGroup(t) {
    return this.parent && this.parent instanceof AJ
      ? Object.assign(
          Object.assign(
            {},
            this.channelHasField('column')
              ? { encode: { update: { columns: { field: JI(this.facet.column, { prefix: 'distinct' }) } } } }
              : {},
          ),
          super.assembleGroup(t),
        )
      : super.assembleGroup(t);
  }
  getCardinalityAggregateForChild() {
    const t = [],
      n = [],
      e = [];
    if (this.child instanceof AJ) {
      if (this.child.channelHasField('column')) {
        const r = JI(this.child.facet.column);
        t.push(r), n.push('distinct'), e.push(`distinct_${r}`);
      }
    } else
      for (const r of GP) {
        const i = this.child.component.scales[r];
        if (i && !i.merged) {
          const o = i.get('type'),
            u = i.get('range');
          if (Oq(o) && jR(u)) {
            const i = jX(DX(this.child, r));
            i ? (t.push(i), n.push('distinct'), e.push(`distinct_${i}`)) : DL(KR(r));
          }
        }
      }
    return { fields: t, ops: n, as: e };
  }
  assembleFacet() {
    const { name: t, data: n } = this.component.data.facetRoot,
      { row: e, column: r } = this.facet,
      { fields: i, ops: o, as: u } = this.getCardinalityAggregateForChild(),
      s = [];
    for (const t of DP) {
      const n = this.facet[t];
      if (n) {
        s.push(JI(n));
        const { bin: a, sort: c } = n;
        if ((gR(a) && s.push(JI(n, { binSuffix: 'end' })), kI(c))) {
          const { field: t, op: s = yI } = c,
            a = kJ(n, c);
          e && r ? (i.push(a), o.push('max'), u.push(a)) : (i.push(t), o.push(s), u.push(a));
        } else if (K(c)) {
          const e = IV(n, t);
          i.push(e), o.push('max'), u.push(e);
        }
      }
    }
    const a = !!e && !!r;
    return Object.assign(
      { name: t, data: n, groupby: s },
      a || i.length > 0
        ? {
            aggregate: Object.assign(
              Object.assign({}, a ? { cross: a } : {}),
              i.length ? { fields: i, ops: o, as: u } : {},
            ),
          }
        : {},
    );
  }
  facetSortFields(t) {
    const { facet: n } = this,
      e = n[t];
    return e
      ? kI(e.sort)
        ? [kJ(e, e.sort, { expr: 'datum' })]
        : K(e.sort)
        ? [IV(e, t, { expr: 'datum' })]
        : [JI(e, { expr: 'datum' })]
      : [];
  }
  facetSortOrder(t) {
    const { facet: n } = this,
      e = n[t];
    if (e) {
      const { sort: t } = e;
      return [(kI(t) ? t.order : !K(t) && t) || 'ascending'];
    }
    return [];
  }
  assembleLabelTitle() {
    var t;
    const { facet: n, config: e } = this;
    if (n.facet) return KV(n.facet, 'facet', e);
    const r = { row: ['top', 'bottom'], column: ['left', 'right'] };
    for (const i of GV)
      if (n[i]) {
        const o = WV('labelOrient', null === (t = n[i]) || void 0 === t ? void 0 : t.header, e, i);
        if (r[i].includes(o)) return KV(n[i], i, e);
      }
  }
  assembleMarks() {
    const { child: t } = this,
      n = (function (t) {
        const n = [],
          e = vJ(n);
        for (const n of t.children) e(n, { source: t.name, name: null, transform: [] });
        return n;
      })(this.component.data.facetRoot),
      e = t.assembleGroupEncodeEntry(!1),
      r = this.assembleLabelTitle() || t.assembleTitle(),
      i = t.assembleGroupStyle();
    return [
      Object.assign(
        Object.assign(
          Object.assign(
            Object.assign(
              Object.assign(
                Object.assign({ name: this.getName('cell'), type: 'group' }, r ? { title: r } : {}),
                i ? { style: i } : {},
              ),
              {
                from: { facet: this.assembleFacet() },
                sort: {
                  field: DP.map(t => this.facetSortFields(t)).flat(),
                  order: DP.map(t => this.facetSortOrder(t)).flat(),
                },
              },
            ),
            n.length > 0 ? { data: n } : {},
          ),
          e ? { encode: { update: e } } : {},
        ),
        t.assembleGroup(
          (function (t, n) {
            if (t.component.selection && vT(t.component.selection).length) {
              const e = rn(t.getName('cell'));
              n.unshift({
                name: 'facet',
                value: {},
                on: [{ events: JC('mousemove', 'scope'), update: `isTuple(facet) ? facet : group(${e}).datum` }],
              });
            }
            return fG(n);
          })(this, []),
        ),
      ),
    ];
  }
  getMapping() {
    return this.facet;
  }
}
function $J(t, n) {
  var e, r, i, o;
  for (const u of n) {
    const n = u.data;
    if (t.name && u.hasName() && t.name !== u.dataName) continue;
    const s = null === (e = t.format) || void 0 === e ? void 0 : e.mesh,
      a = null === (r = n.format) || void 0 === r ? void 0 : r.feature;
    if (s && a) continue;
    const c = null === (i = t.format) || void 0 === i ? void 0 : i.feature;
    if ((c || a) && c !== a) continue;
    const l = null === (o = n.format) || void 0 === o ? void 0 : o.mesh;
    if ((!s && !l) || s === l)
      if (tG(t) && tG(n)) {
        if (Qz(t.values, n.values)) return u;
      } else if (KH(t) && KH(n)) {
        if (t.url === n.url) return u;
      } else if (nG(t) && t.name === u.dataName) return u;
  }
  return null;
}
function MJ(t) {
  var n, e, r, i, o, u, s, a, c, l;
  let f = (function (t, n) {
    if (t.data || !t.parent) {
      if (null === t.data) {
        const t = new WY({ values: [] });
        return n.push(t), t;
      }
      const e = $J(t.data, n);
      if (e)
        return (
          eG(t.data) || (e.data.format = aT({}, t.data.format, e.data.format)),
          !e.hasName() && t.data.name && (e.dataName = t.data.name),
          e
        );
      {
        const e = new WY(t.data);
        return n.push(e), e;
      }
    }
    return t.parent.component.data.facetRoot ? t.parent.component.data.facetRoot : t.parent.component.data.main;
  })(t, t.component.data.sources);
  const { outputNodes: h, outputNodeRefCounts: d } = t.component.data,
    p = t.data,
    m = (p && (eG(p) || KH(p) || tG(p))) || !t.parent ? new ZH() : t.parent.component.data.ancestorParse.clone();
  eG(p)
    ? (rG(p) ? (f = new UY(f, p.sequence)) : oG(p) && (f = new IY(f, p.graticule)), (m.parseNothing = !0))
    : null === (null === (n = null == p ? void 0 : p.format) || void 0 === n ? void 0 : n.parse) &&
      (m.parseNothing = !0),
    (f = null !== (e = LY.makeExplicit(f, t, m)) && void 0 !== e ? e : f),
    (f = new qY(f));
  const v = t.parent && tJ(t.parent);
  (QX(t) || ZX(t)) && v && (f = null !== (r = _Y.makeFromEncoding(f, t)) && void 0 !== r ? r : f),
    t.transforms.length > 0 &&
      (f = (function (t, n, e) {
        var r, i;
        let o = 0;
        for (const u of n.transforms) {
          let s, a;
          if ($H(u)) (a = t = new qV(t, u)), (s = 'derived');
          else if (dH(u)) {
            const i = RY(u);
            (a = t = null !== (r = LY.makeWithAncestors(t, {}, i, e)) && void 0 !== r ? r : t),
              (t = new $V(t, n, u.filter));
          } else if (MH(u)) (a = t = _Y.makeFromTransform(t, u, n)), (s = 'number');
          else if (DH(u))
            (s = 'date'),
              void 0 === e.getWithExplicit(u.field).value && ((t = new LY(t, { [u.field]: s })), e.set(u.field, s, !1)),
              (a = t = mG.makeFromTransform(t, u));
          else if (FH(u)) (a = t = zY.makeFromTransform(t, u)), (s = 'number'), wV(n) && (t = new qY(t));
          else if (mH(u)) (a = t = fJ.make(t, n, u, o++)), (s = 'derived');
          else if (OH(u)) (a = t = new lX(t, u)), (s = 'number');
          else if (kH(u)) (a = t = new aX(t, u)), (s = 'number');
          else if (EH(u)) (a = t = cX.makeFromTransform(t, u)), (s = 'derived');
          else if (SH(u)) (a = t = new uJ(t, u)), (s = 'derived');
          else if (AH(u)) (a = t = new oJ(t, u)), (s = 'derived');
          else if (vH(u)) (a = t = new pJ(t, u)), (s = 'derived');
          else if (xH(u)) t = new mJ(t, u);
          else if (jH(u)) (a = t = cJ.makeFromTransform(t, u)), (s = 'derived');
          else if (gH(u)) (a = t = new rJ(t, u)), (s = 'derived');
          else if (bH(u)) (a = t = new hJ(t, u)), (s = 'derived');
          else if (yH(u)) (a = t = new dJ(t, u)), (s = 'derived');
          else {
            if (!wH(u)) {
              DL(oL(u));
              continue;
            }
            (a = t = new lJ(t, u)), (s = 'derived');
          }
          if (a && void 0 !== s)
            for (const t of null !== (i = a.producedFields()) && void 0 !== i ? i : []) e.set(t, s, !1);
        }
        return t;
      })(f, t, m));
  const g = (function (t) {
      const n = {};
      if (QX(t) && t.component.selection)
        for (const e of vT(t.component.selection)) {
          const r = t.component.selection[e];
          for (const t of r.project.items) !t.channel && ET(t.field) > 1 && (n[t.field] = 'flatten');
        }
      return n;
    })(t),
    b = (function (t) {
      const n = {};
      function e(t) {
        var e;
        hU(t)
          ? (n[t.field] = 'date')
          : 'quantitative' === t.type && Xt((e = t.aggregate)) && oT(['min', 'max'], e)
          ? (n[t.field] = 'number')
          : ET(t.field) > 1
          ? t.field in n || (n[t.field] = 'flatten')
          : HI(t) && kI(t.sort) && ET(t.sort.field) > 1 && (t.sort.field in n || (n[t.sort.field] = 'flatten'));
      }
      if (
        ((QX(t) || ZX(t)) &&
          t.forEachFieldDef((n, r) => {
            if (UI(n)) e(n);
            else {
              const i = zP(r),
                o = t.fieldDef(i);
              e(Object.assign(Object.assign({}, n), { type: o.type }));
            }
          }),
        QX(t))
      ) {
        const { mark: e, markDef: r, encoding: i } = t;
        if (Gq(e) && !t.encoding.order) {
          const t = i['horizontal' === r.orient ? 'y' : 'x'];
          TI(t) && 'quantitative' === t.type && !(t.field in n) && (n[t.field] = 'number');
        }
      }
      return n;
    })(t);
  (f = null !== (i = LY.makeWithAncestors(f, {}, Object.assign(Object.assign({}, g), b), m)) && void 0 !== i ? i : f),
    QX(t) && ((f = sJ.parseAll(f, t)), (f = aJ.parseAll(f, t))),
    (QX(t) || ZX(t)) &&
      (v || (f = null !== (o = _Y.makeFromEncoding(f, t)) && void 0 !== o ? o : f),
      (f = null !== (u = mG.makeFromEncoding(f, t)) && void 0 !== u ? u : f),
      (f = qV.parseAllForSortIndex(f, t)));
  const y = t.getDataName(uG.Raw),
    w = new dG(f, y, uG.Raw, d);
  if (((h[y] = w), (f = w), QX(t))) {
    const n = zY.makeFromEncoding(f, t);
    n && ((f = n), wV(t) && (f = new qY(f))),
      (f = null !== (s = cJ.makeFromEncoding(f, t)) && void 0 !== s ? s : f),
      (f = null !== (a = cX.makeFromEncoding(f, t)) && void 0 !== a ? a : f);
  }
  QX(t) && (f = null !== (c = iJ.make(f, t)) && void 0 !== c ? c : f);
  const x = t.getDataName(uG.Main),
    O = new dG(f, x, uG.Main, d);
  (h[x] = O),
    (f = O),
    QX(t) &&
      (function (t, n) {
        var e;
        for (const [r, i] of bT(null !== (e = t.component.selection) && void 0 !== e ? e : {})) {
          const e = t.getName(`lookup_${r}`);
          t.component.data.outputNodes[e] = i.materialized = new dG(
            new $V(n, t, { param: r }),
            e,
            uG.Lookup,
            t.component.data.outputNodeRefCounts,
          );
        }
      })(t, O);
  let k = null;
  if (ZX(t)) {
    const n = t.getName('facet');
    (f =
      null !==
        (l = (function (t, n) {
          const { row: e, column: r } = n;
          if (e && r) {
            let n = null;
            for (const i of [e, r])
              if (kI(i.sort)) {
                const { field: e, op: r = yI } = i.sort;
                t = n = new aX(t, {
                  joinaggregate: [{ op: r, field: e, as: kJ(i, i.sort, { forAs: !0 }) }],
                  groupby: [JI(i)],
                });
              }
            return n;
          }
          return null;
        })(f, t.facet)) && void 0 !== l
        ? l
        : f),
      (k = new TY(f, t, n, O.getSource())),
      (h[n] = k);
  }
  return Object.assign(Object.assign({}, t.component.data), {
    outputNodes: h,
    outputNodeRefCounts: d,
    raw: w,
    main: O,
    facetRoot: k,
    ancestorParse: m,
  });
}
class jJ extends nJ {
  constructor(t, n, e, r) {
    var i, o, u, s;
    super(t, 'concat', n, e, r, t.resolve),
      ('shared' !==
        (null === (o = null === (i = t.resolve) || void 0 === i ? void 0 : i.axis) || void 0 === o ? void 0 : o.x) &&
        'shared' !==
          (null === (s = null === (u = t.resolve) || void 0 === u ? void 0 : u.axis) || void 0 === s ? void 0 : s.y)) ||
        DL(
          'Axes cannot be shared in concatenated or repeated views yet (https://github.com/vega/vega-lite/issues/2415).',
        ),
      (this.children = this.getChildren(t).map((t, n) => HJ(t, this, this.getName(`concat_${n}`), void 0, r)));
  }
  parseData() {
    this.component.data = MJ(this);
    for (const t of this.children) t.parseData();
  }
  parseSelections() {
    this.component.selection = {};
    for (const t of this.children) {
      t.parseSelections();
      for (const n of vT(t.component.selection)) this.component.selection[n] = t.component.selection[n];
    }
  }
  parseMarkGroup() {
    for (const t of this.children) t.parseMarkGroup();
  }
  parseAxesAndHeaders() {
    for (const t of this.children) t.parseAxesAndHeaders();
  }
  getChildren(t) {
    return xW(t) ? t.vconcat : OW(t) ? t.hconcat : t.concat;
  }
  parseLayoutSize() {
    !(function (t) {
      wJ(t);
      const n = void 0 === t.layout.columns ? 'height' : 'childHeight';
      xJ(t, 1 === t.layout.columns ? 'width' : 'childWidth'), xJ(t, n);
    })(this);
  }
  parseAxisGroup() {
    return null;
  }
  assembleSelectionTopLevelSignals(t) {
    return this.children.reduce((t, n) => n.assembleSelectionTopLevelSignals(t), t);
  }
  assembleSignals() {
    return this.children.forEach(t => t.assembleSignals()), [];
  }
  assembleLayoutSignals() {
    const t = iY(this);
    for (const n of this.children) t.push(...n.assembleLayoutSignals());
    return t;
  }
  assembleSelectionData(t) {
    return this.children.reduce((t, n) => n.assembleSelectionData(t), t);
  }
  assembleMarks() {
    return this.children.map(t => {
      const n = t.assembleTitle(),
        e = t.assembleGroupStyle(),
        r = t.assembleGroupEncodeEntry(!1);
      return Object.assign(
        Object.assign(
          Object.assign(
            Object.assign({ type: 'group', name: t.getName('group') }, n ? { title: n } : {}),
            e ? { style: e } : {},
          ),
          r ? { encode: { update: r } } : {},
        ),
        t.assembleGroup(),
      );
    });
  }
  assembleGroupStyle() {}
  assembleDefaultLayout() {
    const t = this.layout.columns;
    return Object.assign(Object.assign({}, null != t ? { columns: t } : {}), { bounds: 'full', align: 'each' });
  }
}
const DJ = Object.assign(Object.assign({ disable: 1, gridScale: 1, scale: 1 }, wU), { labelExpr: 1, encode: 1 }),
  FJ = vT(DJ);
class EJ extends GH {
  constructor(t = {}, n = {}, e = !1) {
    super(), (this.explicit = t), (this.implicit = n), (this.mainExtracted = e);
  }
  clone() {
    return new EJ(Zz(this.explicit), Zz(this.implicit), this.mainExtracted);
  }
  hasAxisPart(t) {
    return !('axis' !== t && ('grid' === t || 'title' === t ? !this.get(t) : !1 === (n = this.get(t)) || null === n));
    var n;
  }
  hasOrientSignalRef() {
    return MR(this.explicit.orient);
  }
}
const SJ = { bottom: 'top', top: 'bottom', left: 'right', right: 'left' };
function CJ(t, n) {
  if (!t) return n.map(t => t.clone());
  {
    if (t.length !== n.length) return;
    const e = t.length;
    for (let r = 0; r < e; r++) {
      const e = t[r],
        i = n[r];
      if (!!e != !!i) return;
      if (e && i) {
        const n = e.getWithExplicit('orient'),
          o = i.getWithExplicit('orient');
        if (n.explicit && o.explicit && n.value !== o.value) return;
        t[r] = NJ(e, i);
      }
    }
  }
  return t;
}
function NJ(t, n) {
  for (const e of FJ) {
    const r = QH(t.getWithExplicit(e), n.getWithExplicit(e), e, 'axis', (t, n) => {
      switch (e) {
        case 'title':
          return YR(t, n);
        case 'gridScale':
          return { explicit: t.explicit, value: ST(t.value, n.value) };
      }
      return JH(t, n, e, 'axis');
    });
    t.setWithExplicit(e, r);
  }
  return t;
}
function BJ(t, n, e, r, i) {
  if ('disable' === n) return void 0 !== e;
  switch (((e = e || {}), n)) {
    case 'titleAngle':
    case 'labelAngle':
      return t === (MR(e.labelAngle) ? e.labelAngle : zT(e.labelAngle));
    case 'values':
      return !!e.values;
    case 'encode':
      return !!e.encoding || !!e.labelAngle;
    case 'title':
      if (t === LV(r, i)) return !0;
  }
  return t === e[n];
}
const _J = new Set([
  'grid',
  'translate',
  'format',
  'formatType',
  'orient',
  'labelExpr',
  'tickCount',
  'position',
  'tickMinStep',
]);
function zJ(t, n) {
  var e, r, i;
  let o = n.axis(t);
  const u = new EJ(),
    s = uU(n.encoding[t]),
    { mark: a, config: c } = n,
    l =
      (null == o ? void 0 : o.orient) ||
      (null === (e = c['x' === t ? 'axisX' : 'axisY']) || void 0 === e ? void 0 : e.orient) ||
      (null === (r = c.axis) || void 0 === r ? void 0 : r.orient) ||
      (function (t) {
        return 'x' === t ? 'bottom' : 'left';
      })(t),
    f = n.getScaleComponent(t).get('type'),
    h = (function (t, n, e, r) {
      const i =
          'band' === n
            ? ['axisDiscrete', 'axisBand']
            : 'point' === n
            ? ['axisDiscrete', 'axisPoint']
            : bq(n)
            ? ['axisQuantitative']
            : 'time' === n || 'utc' === n
            ? ['axisTemporal']
            : [],
        o = 'x' === t ? 'axisX' : 'axisY',
        u = MR(e) ? 'axisOrient' : `axis${kT(e)}`,
        s = [...i, ...i.map(t => o + t.substr(4))],
        a = ['axis', u, o];
      return { vlOnlyAxisConfig: NV(s, r, t, e), vgAxisConfig: NV(a, r, t, e), axisConfigStyle: BV([...a, ...s], r) };
    })(t, f, l, n.config),
    d = void 0 !== o ? !o : _V('disable', c.style, null == o ? void 0 : o.style, h).configValue;
  if ((u.set('disable', d, void 0 !== o), d)) return u;
  o = o || {};
  const p = (function (t, n, e, r, i) {
      const o = null == n ? void 0 : n.labelAngle;
      if (void 0 !== o) return MR(o) ? o : zT(o);
      {
        const { configValue: o } = _V('labelAngle', r, null == n ? void 0 : n.style, i);
        return void 0 !== o ? zT(o) : e !== IT || !oT([uq, iq], t.type) || (TI(t) && t.timeUnit) ? void 0 : 270;
      }
    })(s, o, t, c.style, h),
    m = {
      fieldOrDatumDef: s,
      axis: o,
      channel: t,
      model: n,
      scaleType: f,
      orient: l,
      labelAngle: p,
      mark: a,
      config: c,
    };
  for (const e of FJ) {
    const r = e in zV ? zV[e](m) : OU(e) ? o[e] : void 0,
      i = void 0 !== r,
      s = BJ(r, e, o, n, t);
    if (i && s) u.set(e, r, s);
    else {
      const { configValue: t, configFrom: n } = OU(e) && 'values' !== e ? _V(e, c.style, o.style, h) : {},
        a = void 0 !== t;
      i && !a ? u.set(e, r, s) : ('vgAxisConfig' !== n || (_J.has(e) && a) || gU(t) || MR(t)) && u.set(e, t, !1);
    }
  }
  const v = null !== (i = o.encoding) && void 0 !== i ? i : {},
    g = bU.reduce((e, r) => {
      var i;
      if (!u.hasAxisPart(r)) return e;
      const o = cY(null !== (i = v[r]) && void 0 !== i ? i : {}, n),
        s =
          'labels' === r
            ? (function (t, n, e) {
                var r;
                const { encoding: i, config: o } = t,
                  u = null !== (r = uU(i[n])) && void 0 !== r ? r : uU(i[PP(n)]),
                  s = t.axis(n) || {},
                  { format: a, formatType: c } = s;
                if (aI(c))
                  return Object.assign(
                    { text: hI({ fieldOrDatumDef: u, field: 'datum.value', format: a, formatType: c, config: o }) },
                    e,
                  );
                if (void 0 === a && void 0 === c && o.customFormatTypes) {
                  if ('quantitative' === PI(u)) {
                    if (GI(u) && 'normalize' === u.stack && o.normalizedNumberFormatType)
                      return Object.assign(
                        {
                          text: hI({
                            fieldOrDatumDef: u,
                            field: 'datum.value',
                            format: o.normalizedNumberFormat,
                            formatType: o.normalizedNumberFormatType,
                            config: o,
                          }),
                        },
                        e,
                      );
                    if (o.numberFormatType)
                      return Object.assign(
                        {
                          text: hI({
                            fieldOrDatumDef: u,
                            field: 'datum.value',
                            format: o.numberFormat,
                            formatType: o.numberFormatType,
                            config: o,
                          }),
                        },
                        e,
                      );
                  }
                  if ('temporal' === PI(u) && o.timeFormatType && TI(u) && !u.timeUnit)
                    return Object.assign(
                      {
                        text: hI({
                          fieldOrDatumDef: u,
                          field: 'datum.value',
                          format: o.timeFormat,
                          formatType: o.timeFormatType,
                          config: o,
                        }),
                      },
                      e,
                    );
                }
                return e;
              })(n, t, o)
            : o;
      return void 0 === s || mT(s) || (e[r] = { update: s }), e;
    }, {});
  return mT(g) || u.set('encode', g, !!o.encoding || void 0 !== o.labelAngle), u;
}
function TJ(t, n) {
  return Object.assign(
    Object.assign(
      Object.assign(
        Object.assign(
          Object.assign(
            Object.assign(
              {},
              XG(t, {
                align: 'ignore',
                baseline: 'ignore',
                color: 'include',
                size: 'include',
                orient: 'ignore',
                theta: 'ignore',
              }),
            ),
            zG('x', t, { defaultPos: 'mid' }),
          ),
          zG('y', t, { defaultPos: 'mid' }),
        ),
        NG('size', t),
      ),
      NG('angle', t),
    ),
    (function (t, n, e) {
      return e ? { shape: { value: e } } : NG('shape', t);
    })(t, 0, n),
  );
}
function PJ(t) {
  var n;
  const { config: e, markDef: r } = t,
    { orient: i } = r,
    o = 'horizontal' === i ? 'width' : 'height',
    u = t.getScaleComponent('horizontal' === i ? 'x' : 'y'),
    s = null !== (n = qR('size', r, e, { vgChannel: o })) && void 0 !== n ? n : e.tick.bandSize;
  if (void 0 !== s) return s;
  {
    const t = u ? u.get('range') : void 0;
    return t && jR(t) && Vt(t.step) ? (3 * t.step) / 4 : (3 * DW(e.view, o)) / 4;
  }
}
const RJ = {
  arc: {
    vgMark: 'arc',
    encodeEntry: t =>
      Object.assign(
        Object.assign(
          Object.assign(
            Object.assign(
              Object.assign(
                {},
                XG(t, {
                  align: 'ignore',
                  baseline: 'ignore',
                  color: 'include',
                  size: 'ignore',
                  orient: 'ignore',
                  theta: 'ignore',
                }),
              ),
              zG('x', t, { defaultPos: 'mid' }),
            ),
            zG('y', t, { defaultPos: 'mid' }),
          ),
          WG(t, 'radius'),
        ),
        WG(t, 'theta'),
      ),
  },
  area: {
    vgMark: 'area',
    encodeEntry: t =>
      Object.assign(
        Object.assign(
          Object.assign(
            Object.assign(
              {},
              XG(t, {
                align: 'ignore',
                baseline: 'ignore',
                color: 'include',
                orient: 'include',
                size: 'ignore',
                theta: 'ignore',
              }),
            ),
            qG('x', t, { defaultPos: 'zeroOrMin', defaultPos2: 'zeroOrMin', range: 'horizontal' === t.markDef.orient }),
          ),
          qG('y', t, { defaultPos: 'zeroOrMin', defaultPos2: 'zeroOrMin', range: 'vertical' === t.markDef.orient }),
        ),
        QG(t),
      ),
  },
  bar: {
    vgMark: 'rect',
    encodeEntry: t =>
      Object.assign(
        Object.assign(
          Object.assign(
            {},
            XG(t, {
              align: 'ignore',
              baseline: 'ignore',
              color: 'include',
              orient: 'ignore',
              size: 'ignore',
              theta: 'ignore',
            }),
          ),
          WG(t, 'x'),
        ),
        WG(t, 'y'),
      ),
  },
  circle: { vgMark: 'symbol', encodeEntry: t => TJ(t, 'circle') },
  geoshape: {
    vgMark: 'shape',
    encodeEntry: t =>
      Object.assign(
        {},
        XG(t, {
          align: 'ignore',
          baseline: 'ignore',
          color: 'include',
          size: 'ignore',
          orient: 'ignore',
          theta: 'ignore',
        }),
      ),
    postEncodingTransform: t => {
      const { encoding: n } = t,
        e = n.shape;
      return [
        Object.assign(
          { type: 'geoshape', projection: t.projectionName() },
          e && TI(e) && e.type === sq ? { field: JI(e, { expr: 'datum' }) } : {},
        ),
      ];
    },
  },
  image: {
    vgMark: 'image',
    encodeEntry: t =>
      Object.assign(
        Object.assign(
          Object.assign(
            Object.assign(
              {},
              XG(t, {
                align: 'ignore',
                baseline: 'ignore',
                color: 'ignore',
                orient: 'ignore',
                size: 'ignore',
                theta: 'ignore',
              }),
            ),
            WG(t, 'x'),
          ),
          WG(t, 'y'),
        ),
        DG(t, 'url'),
      ),
  },
  line: {
    vgMark: 'line',
    encodeEntry: t =>
      Object.assign(
        Object.assign(
          Object.assign(
            Object.assign(
              Object.assign(
                {},
                XG(t, {
                  align: 'ignore',
                  baseline: 'ignore',
                  color: 'include',
                  size: 'ignore',
                  orient: 'ignore',
                  theta: 'ignore',
                }),
              ),
              zG('x', t, { defaultPos: 'mid' }),
            ),
            zG('y', t, { defaultPos: 'mid' }),
          ),
          NG('size', t, { vgChannel: 'strokeWidth' }),
        ),
        QG(t),
      ),
  },
  point: { vgMark: 'symbol', encodeEntry: t => TJ(t) },
  rect: {
    vgMark: 'rect',
    encodeEntry: t =>
      Object.assign(
        Object.assign(
          Object.assign(
            {},
            XG(t, {
              align: 'ignore',
              baseline: 'ignore',
              color: 'include',
              orient: 'ignore',
              size: 'ignore',
              theta: 'ignore',
            }),
          ),
          WG(t, 'x'),
        ),
        WG(t, 'y'),
      ),
  },
  rule: {
    vgMark: 'rule',
    encodeEntry: t => {
      const { markDef: n } = t,
        e = n.orient;
      return t.encoding.x || t.encoding.y || t.encoding.latitude || t.encoding.longitude
        ? Object.assign(
            Object.assign(
              Object.assign(
                Object.assign(
                  {},
                  XG(t, {
                    align: 'ignore',
                    baseline: 'ignore',
                    color: 'include',
                    orient: 'ignore',
                    size: 'ignore',
                    theta: 'ignore',
                  }),
                ),
                qG('x', t, {
                  defaultPos: 'horizontal' === e ? 'zeroOrMax' : 'mid',
                  defaultPos2: 'zeroOrMin',
                  range: 'vertical' !== e,
                }),
              ),
              qG('y', t, {
                defaultPos: 'vertical' === e ? 'zeroOrMax' : 'mid',
                defaultPos2: 'zeroOrMin',
                range: 'horizontal' !== e,
              }),
            ),
            NG('size', t, { vgChannel: 'strokeWidth' }),
          )
        : {};
    },
  },
  square: { vgMark: 'symbol', encodeEntry: t => TJ(t, 'square') },
  text: {
    vgMark: 'text',
    encodeEntry: t => {
      const { config: n } = t;
      return Object.assign(
        Object.assign(
          Object.assign(
            Object.assign(
              Object.assign(
                Object.assign(
                  Object.assign(
                    Object.assign(
                      Object.assign(
                        Object.assign(
                          {},
                          XG(t, {
                            align: 'include',
                            baseline: 'include',
                            color: 'include',
                            size: 'ignore',
                            orient: 'ignore',
                            theta: 'include',
                          }),
                        ),
                        zG('x', t, { defaultPos: 'mid' }),
                      ),
                      zG('y', t, { defaultPos: 'mid' }),
                    ),
                    DG(t),
                  ),
                  NG('size', t, { vgChannel: 'fontSize' }),
                ),
                NG('angle', t),
              ),
              ZG(
                'align',
                (function (t, n, e) {
                  if (void 0 === qR('align', t, e)) return 'center';
                })(t.markDef, 0, n),
              ),
            ),
            ZG(
              'baseline',
              (function (t, n, e) {
                if (void 0 === qR('baseline', t, e)) return 'middle';
              })(t.markDef, 0, n),
            ),
          ),
          zG('radius', t, { defaultPos: null }),
        ),
        zG('theta', t, { defaultPos: null }),
      );
    },
  },
  tick: {
    vgMark: 'rect',
    encodeEntry: t => {
      const { config: n, markDef: e } = t,
        r = e.orient,
        i = 'horizontal' === r ? 'width' : 'height',
        o = 'horizontal' === r ? 'height' : 'width';
      return Object.assign(
        Object.assign(
          Object.assign(
            Object.assign(
              Object.assign(
                {},
                XG(t, {
                  align: 'ignore',
                  baseline: 'ignore',
                  color: 'include',
                  orient: 'ignore',
                  size: 'ignore',
                  theta: 'ignore',
                }),
              ),
              zG('x', t, { defaultPos: 'mid', vgChannel: 'xc' }),
            ),
            zG('y', t, { defaultPos: 'mid', vgChannel: 'yc' }),
          ),
          NG('size', t, { defaultValue: PJ(t), vgChannel: i }),
        ),
        { [o]: zR(qR('thickness', e, n)) },
      );
    },
  },
  trail: {
    vgMark: 'trail',
    encodeEntry: t =>
      Object.assign(
        Object.assign(
          Object.assign(
            Object.assign(
              Object.assign(
                {},
                XG(t, {
                  align: 'ignore',
                  baseline: 'ignore',
                  color: 'include',
                  size: 'include',
                  orient: 'ignore',
                  theta: 'ignore',
                }),
              ),
              zG('x', t, { defaultPos: 'mid' }),
            ),
            zG('y', t, { defaultPos: 'mid' }),
          ),
          NG('size', t),
        ),
        QG(t),
      ),
  },
};
const LJ = 'faceted_path_',
  qJ = 'stack_group_';
function IJ(t, n = { fromPrefix: '' }) {
  const { mark: e, markDef: r, encoding: i, config: o } = t,
    u = ST(
      r.clip,
      (function (t) {
        const n = t.getScaleComponent('x'),
          e = t.getScaleComponent('y');
        return (
          !(!(null == n ? void 0 : n.get('selectionExtent')) && !(null == e ? void 0 : e.get('selectionExtent'))) ||
          void 0
        );
      })(t),
      (function (t) {
        const n = t.component.projection;
        return !(!n || n.isFit) || void 0;
      })(t),
    ),
    s = LR(r),
    a = i.key,
    c = (function (t) {
      var n;
      const { encoding: e, stack: r, mark: i, markDef: o, config: u } = t,
        s = e.order;
      if (!((!K(s) && WI(s) && iT(s.value)) || (!s && iT(qR('order', o, u))))) {
        if ((K(s) || TI(s)) && !r) return HR(s, { expr: 'datum' });
        if (Gq(i)) {
          const r = 'horizontal' === o.orient ? 'y' : 'x',
            i = e[r];
          if (TI(i)) {
            const e = i.sort;
            return K(e)
              ? { field: JI(i, { prefix: r, suffix: 'sort_index', expr: 'datum' }) }
              : kI(e)
              ? { field: JI({ aggregate: FU(t.encoding) ? e.op : void 0, field: e.field }, { expr: 'datum' }) }
              : OI(e)
              ? { field: JI(t.fieldDef(e.encoding), { expr: 'datum' }), order: e.order }
              : null === e
              ? void 0
              : {
                  field: JI(i, {
                    binSuffix: (null === (n = t.stack) || void 0 === n ? void 0 : n.impute) ? 'mid' : void 0,
                    expr: 'datum',
                  }),
                };
          }
        }
      }
    })(t),
    l = (function (t) {
      if (!t.component.selection) return null;
      const n = vT(t.component.selection).length;
      let e = n,
        r = t.parent;
      for (; r && 0 === e; ) (e = vT(r.component.selection).length), (r = r.parent);
      return e ? { interactive: n > 0 || !!t.encoding.tooltip } : null;
    })(t),
    f = qR('aria', r, o),
    h = RJ[e].postEncodingTransform ? RJ[e].postEncodingTransform(t) : null;
  return [
    Object.assign(
      Object.assign(
        Object.assign(
          Object.assign(
            Object.assign(
              Object.assign(
                Object.assign(
                  Object.assign({ name: t.getName('marks'), type: RJ[e].vgMark }, u ? { clip: !0 } : {}),
                  s ? { style: s } : {},
                ),
                a ? { key: a.field } : {},
              ),
              c ? { sort: c } : {},
            ),
            l || {},
          ),
          !1 === f ? { aria: f } : {},
        ),
        { from: { data: n.fromPrefix + t.requestDataName(uG.Main) }, encode: { update: RJ[e].encodeEntry(t) } },
      ),
      h ? { transform: h } : {},
    ),
  ];
}
class UJ extends eJ {
  constructor(t, n, e, r = {}, i) {
    var o;
    super(t, 'unit', n, e, i, void 0, $W(t) ? t.view : void 0),
      (this.specifiedScales = {}),
      (this.specifiedAxes = {}),
      (this.specifiedLegends = {}),
      (this.specifiedProjection = {}),
      (this.selection = []),
      (this.children = []);
    const u = Xq(t.mark) ? Object.assign({}, t.mark) : { type: t.mark },
      s = u.type;
    void 0 === u.filled &&
      (u.filled = (function (t, n, { graticule: e }) {
        if (e) return !1;
        const r = IR('filled', t, n),
          i = t.type;
        return ST(r, i !== Tq && i !== zq && i !== Rq);
      })(u, i, { graticule: t.data && oG(t.data) }));
    const a = (this.encoding = (function (t, n, e, r) {
      const i = {};
      for (const n of vT(t)) NP(n) || DL(`${(o = n)}-encoding is dropped as ${o} is not a valid encoding channel.`);
      var o, u;
      for (let o of IP) {
        if (!t[o]) continue;
        const s = t[o];
        if (ZP(o)) {
          const t = qP(o),
            n = i[t];
          if (TI(n)) {
            if (('quantitative' === (u = n.type) || 'temporal' === u) && TI(s)) {
              DL(sL(t));
              continue;
            }
          } else (o = t), DL(aL(t));
        }
        if (
          ('angle' !== o ||
            'arc' !== n ||
            t.theta ||
            (DL('Arc marks uses theta channel rather than angle, replacing angle with theta.'), (o = JT)),
          SU(t, o, n))
        ) {
          if (o === uP && 'line' === n) {
            const n = oU(t[o]);
            if (null == n ? void 0 : n.aggregate) {
              DL('Line marks cannot encode size with a non-groupby field. You may want to use trail marks instead.');
              continue;
            }
          }
          if (o === eP && (e ? 'fill' in t : 'stroke' in t))
            DL(lL('encoding', { fill: 'fill' in t, stroke: 'stroke' in t }));
          else if (o === mP || (o === pP && !K(s) && !WI(s)) || (o === gP && K(s)))
            s && (i[o] = At(s).reduce((t, n) => (TI(n) ? t.push(cU(n, o)) : DL(fL(n, o)), t), []));
          else {
            if (o === gP && null === s) i[o] = null;
            else if (!(TI(s) || RI(s) || WI(s) || BI(s) || MR(s))) {
              DL(fL(s, o));
              continue;
            }
            i[o] = sU(s, o, r);
          }
        } else DL(hL(o, n));
      }
      return i;
    })(t.encoding || {}, s, u.filled, i));
    (this.markDef = (function (t, n, e) {
      const r = kR(t),
        i = qR('orient', r, e);
      if (
        ((r.orient = (function (t, n, e) {
          switch (t) {
            case Tq:
            case Uq:
            case Wq:
            case Lq:
            case Pq:
            case _q:
              return;
          }
          const { x: r, y: i, x2: o, y2: u } = n;
          switch (t) {
            case Bq:
              if (TI(r) && (bR(r.bin) || (TI(i) && i.aggregate && !r.aggregate))) return 'vertical';
              if (TI(i) && (bR(i.bin) || (TI(r) && r.aggregate && !i.aggregate))) return 'horizontal';
              if (u || o) {
                if (e) return e;
                if (!o && ((TI(r) && r.type === rq && !gR(r.bin)) || qI(r))) return 'horizontal';
                if (!u && ((TI(i) && i.type === rq && !gR(i.bin)) || qI(i))) return 'vertical';
              }
            case Rq:
              if (o && (!TI(r) || !bR(r.bin)) && u && (!TI(i) || !bR(i.bin))) return;
            case Nq:
              if (u) return TI(i) && bR(i.bin) ? 'horizontal' : 'vertical';
              if (o) return TI(r) && bR(r.bin) ? 'vertical' : 'horizontal';
              if (t === Rq) {
                if (r && !i) return 'vertical';
                if (i && !r) return 'horizontal';
              }
            case zq:
            case qq: {
              const n = LI(r),
                o = LI(i);
              if (e) return e;
              if (n && !o) return 'tick' !== t ? 'horizontal' : 'vertical';
              if (!n && o) return 'tick' !== t ? 'vertical' : 'horizontal';
              if (n && o) {
                const n = r.type === oq,
                  e = i.type === oq;
                return n && !e
                  ? 'tick' !== t
                    ? 'vertical'
                    : 'horizontal'
                  : !n && e
                  ? 'tick' !== t
                    ? 'horizontal'
                    : 'vertical'
                  : !r.aggregate && i.aggregate
                  ? 'tick' !== t
                    ? 'vertical'
                    : 'horizontal'
                  : r.aggregate && !i.aggregate && 'tick' !== t
                  ? 'horizontal'
                  : 'vertical';
              }
              return;
            }
          }
          return 'vertical';
        })(r.type, n, i)),
        void 0 !== i && i !== r.orient && DL(`Specified orient "${r.orient}" overridden with "${i}".`),
        'bar' === r.type && r.orient)
      ) {
        const t = qR('cornerRadiusEnd', r, e);
        if (void 0 !== t) {
          const e =
            ('horizontal' === r.orient && n.x2) || ('vertical' === r.orient && n.y2) ? ['cornerRadius'] : tI[r.orient];
          for (const n of e) r[n] = t;
          void 0 !== r.cornerRadiusEnd && delete r.cornerRadiusEnd;
        }
      }
      return (
        void 0 === qR('opacity', r, e) &&
          (r.opacity = (function (t, n) {
            if (oT([Tq, qq, Uq, Wq], t) && !FU(n)) return 0.7;
          })(r.type, n)),
        void 0 === qR('cursor', r, e) &&
          (r.cursor = (function (t, n, e) {
            return n.href || t.href || qR('href', t, e) ? 'pointer' : t.cursor;
          })(r, n, e)),
        r
      );
    })(u, a, i)),
      (this.size = (function ({ encoding: t, size: n }) {
        for (const e of GP) {
          const r = RP(e);
          AW(n[r]) && LI(t[e]) && (delete n[r], DL(xL(r)));
        }
        return n;
      })({
        encoding: a,
        size: $W(t)
          ? Object.assign(
              Object.assign(Object.assign({}, r), t.width ? { width: t.width } : {}),
              t.height ? { height: t.height } : {},
            )
          : r,
      })),
      (this.stack = XW(s, a)),
      (this.specifiedScales = this.initScales(s, a)),
      (this.specifiedAxes = this.initAxes(a)),
      (this.specifiedLegends = this.initLegends(a)),
      (this.specifiedProjection = t.projection),
      (this.selection = (null !== (o = t.params) && void 0 !== o ? o : []).filter(t => gW(t)));
  }
  get hasProjection() {
    const { encoding: t } = this,
      n = this.mark === Hq,
      e = t && AP.some(n => II(t[n]));
    return n || e;
  }
  scaleDomain(t) {
    const n = this.specifiedScales[t];
    return n ? n.domain : void 0;
  }
  axis(t) {
    return this.specifiedAxes[t];
  }
  legend(t) {
    return this.specifiedLegends[t];
  }
  initScales(t, n) {
    return eR.reduce((t, e) => {
      var r;
      const i = uU(n[e]);
      return i && (t[e] = this.initScale(null !== (r = i.scale) && void 0 !== r ? r : {})), t;
    }, {});
  }
  initScale(t) {
    const { domain: n, range: e } = t,
      r = kR(t);
    return K(n) && (r.domain = n.map(BR)), K(e) && (r.range = e.map(BR)), r;
  }
  initAxes(t) {
    return GP.reduce((n, e) => {
      const r = t[e];
      if (II(r) || (e === IT && II(t.x2)) || (e === UT && II(t.y2))) {
        const t = II(r) ? r.axis : void 0;
        n[e] = t ? this.initAxis(Object.assign({}, t)) : t;
      }
      return n;
    }, {});
  }
  initAxis(t) {
    const n = vT(t),
      e = {};
    for (const r of n) {
      const n = t[r];
      e[r] = gU(n) ? NR(n) : BR(n);
    }
    return e;
  }
  initLegends(t) {
    return tR.reduce((n, e) => {
      const r = uU(t[e]);
      if (
        r &&
        (function (t) {
          switch (t) {
            case eP:
            case rP:
            case iP:
            case uP:
            case oP:
            case aP:
            case fP:
            case hP:
              return !0;
            case cP:
            case lP:
            case sP:
              return !1;
          }
        })(e)
      ) {
        const t = r.legend;
        n[e] = t ? kR(t) : t;
      }
      return n;
    }, {});
  }
  parseData() {
    this.component.data = MJ(this);
  }
  parseLayoutSize() {
    !(function (t) {
      const { size: n, component: e } = t;
      for (const r of GP) {
        const i = RP(r);
        if (n[i]) {
          const t = n[i];
          e.layoutSize.set(i, AW(t) ? 'step' : t, !0);
        } else {
          const n = OJ(t, i);
          e.layoutSize.set(i, n, !1);
        }
      }
    })(this);
  }
  parseSelections() {
    this.component.selection = (function (t, n) {
      var e;
      const r = {},
        i = t.config.selection;
      if (!n || !n.length) return r;
      for (const o of n) {
        const n = wT(o.name),
          u = o.select,
          s = Xt(u) ? u : u.type,
          a = tt(u) ? Zz(u) : { type: s },
          c = i[s];
        for (const t in c)
          'fields' !== t &&
            'encodings' !== t &&
            ('mark' === t && (a[t] = Object.assign(Object.assign({}, c[t]), a[t])),
            (void 0 !== a[t] && !0 !== a[t]) || (a[t] = null !== (e = c[t]) && void 0 !== e ? e : a[t]));
        const l = (r[n] = Object.assign(Object.assign({}, a), {
          name: n,
          type: s,
          init: o.value,
          bind: o.bind,
          events: Xt(a.on) ? JC(a.on, 'scope') : At(Zz(a.on)),
        }));
        for (const n of bV) n.defined(l) && n.parse && n.parse(t, l, o);
      }
      return r;
    })(this, this.selection);
  }
  parseMarkGroup() {
    this.component.mark = (function (t) {
      if (oT([zq, Nq, Iq], t.mark)) {
        const n = BU(t.mark, t.encoding);
        if (n.length > 0)
          return (function (t, n) {
            return [
              {
                name: t.getName('pathgroup'),
                type: 'group',
                from: {
                  facet: { name: LJ + t.requestDataName(uG.Main), data: t.requestDataName(uG.Main), groupby: n },
                },
                encode: { update: { width: { field: { group: 'width' } }, height: { field: { group: 'height' } } } },
                marks: IJ(t, { fromPrefix: LJ }),
              },
            ];
          })(t, n);
      } else if (t.mark === Bq) {
        const n = SR.some(n => qR(n, t.markDef, t.config));
        if (t.stack && !t.fieldDef('size') && n)
          return (function (t) {
            var n;
            const [e] = IJ(t, { fromPrefix: qJ }),
              r = t.scaleName(t.stack.fieldChannel),
              i = (n = {}) => t.vgField(t.stack.fieldChannel, n),
              o = (t, n) =>
                `${t}(${[
                  i({ prefix: 'min', suffix: 'start', expr: n }),
                  i({ prefix: 'max', suffix: 'start', expr: n }),
                  i({ prefix: 'min', suffix: 'end', expr: n }),
                  i({ prefix: 'max', suffix: 'end', expr: n }),
                ]
                  .map(t => `scale('${r}',${t})`)
                  .join(',')})`;
            let u, s;
            'x' === t.stack.fieldChannel
              ? ((u = Object.assign(Object.assign({}, tT(e.encode.update, ['y', 'yc', 'y2', 'height', ...SR])), {
                  x: { signal: o('min', 'datum') },
                  x2: { signal: o('max', 'datum') },
                  clip: { value: !0 },
                })),
                (s = { x: { field: { group: 'x' }, mult: -1 }, height: { field: { group: 'height' } } }),
                (e.encode.update = Object.assign(Object.assign({}, nT(e.encode.update, ['y', 'yc', 'y2'])), {
                  height: { field: { group: 'height' } },
                })))
              : ((u = Object.assign(Object.assign({}, tT(e.encode.update, ['x', 'xc', 'x2', 'width'])), {
                  y: { signal: o('min', 'datum') },
                  y2: { signal: o('max', 'datum') },
                  clip: { value: !0 },
                })),
                (s = { y: { field: { group: 'y' }, mult: -1 }, width: { field: { group: 'width' } } }),
                (e.encode.update = Object.assign(Object.assign({}, nT(e.encode.update, ['x', 'xc', 'x2'])), {
                  width: { field: { group: 'width' } },
                })));
            for (const n of SR) {
              const r = IR(n, t.markDef, t.config);
              e.encode.update[n] ? ((u[n] = e.encode.update[n]), delete e.encode.update[n]) : r && (u[n] = zR(r)),
                r && (e.encode.update[n] = { value: 0 });
            }
            const a = [];
            if ((null === (n = t.stack.groupbyChannels) || void 0 === n ? void 0 : n.length) > 0)
              for (const n of t.stack.groupbyChannels) {
                const e = t.fieldDef(n),
                  r = JI(e);
                r && a.push(r),
                  ((null == e ? void 0 : e.bin) || (null == e ? void 0 : e.timeUnit)) &&
                    a.push(JI(e, { binSuffix: 'end' }));
              }
            return (
              (u = [
                'stroke',
                'strokeWidth',
                'strokeJoin',
                'strokeCap',
                'strokeDash',
                'strokeDashOffset',
                'strokeMiterLimit',
                'strokeOpacity',
              ].reduce((n, r) => {
                if (e.encode.update[r]) return Object.assign(Object.assign({}, n), { [r]: e.encode.update[r] });
                {
                  const e = IR(r, t.markDef, t.config);
                  return void 0 !== e ? Object.assign(Object.assign({}, n), { [r]: zR(e) }) : n;
                }
              }, u)),
              u.stroke && ((u.strokeForeground = { value: !0 }), (u.strokeOffset = { value: 0 })),
              [
                {
                  type: 'group',
                  from: {
                    facet: {
                      data: t.requestDataName(uG.Main),
                      name: qJ + t.requestDataName(uG.Main),
                      groupby: a,
                      aggregate: {
                        fields: [
                          i({ suffix: 'start' }),
                          i({ suffix: 'start' }),
                          i({ suffix: 'end' }),
                          i({ suffix: 'end' }),
                        ],
                        ops: ['min', 'max', 'min', 'max'],
                      },
                    },
                  },
                  encode: { update: u },
                  marks: [{ type: 'group', encode: { update: s }, marks: [e] }],
                },
              ]
            );
          })(t);
      }
      return IJ(t);
    })(this);
  }
  parseAxesAndHeaders() {
    var t;
    this.component.axes = ((t = this), GP.reduce((n, e) => (t.component.scales[e] && (n[e] = [zJ(e, t)]), n), {}));
  }
  assembleSelectionTopLevelSignals(t) {
    return (function (t, n) {
      var e;
      let r = !1;
      for (const i of gT(null !== (e = t.component.selection) && void 0 !== e ? e : {})) {
        const e = i.name,
          o = rn(e + pV);
        if (0 === n.filter(t => t.name === e).length) {
          const t = 'point' === i.type ? ', true, true)' : ')';
          n.push({ name: i.name, update: `${gV}(${o}, ${rn('global' === i.resolve ? 'union' : i.resolve)}${t}` });
        }
        r = !0;
        for (const e of bV) e.defined(i) && e.topLevelSignals && (n = e.topLevelSignals(t, i, n));
      }
      return (
        r &&
          0 === n.filter(t => 'unit' === t.name).length &&
          n.unshift({
            name: 'unit',
            value: {},
            on: [{ events: 'mousemove', update: 'isTuple(group()) ? group() : unit' }],
          }),
        fG(n)
      );
    })(this, t);
  }
  assembleSignals() {
    return [...CV(this), ...cG(this, [])];
  }
  assembleSelectionData(t) {
    return (function (t, n) {
      var e;
      const r = [...n],
        i = yV(t, { escape: !1 });
      for (const n of gT(null !== (e = t.component.selection) && void 0 !== e ? e : {})) {
        const t = { name: n.name + pV };
        if ((n.project.hasSelectionId && (t.transform = [{ type: 'collect', sort: { field: dW } }]), n.init)) {
          const e = n.project.items.map(t => sG(t, ['signals']));
          t.values = n.init.map(
            n.project.hasSelectionId
              ? t => ({ unit: i, [dW]: aG(t, !1)[0] })
              : t => ({ unit: i, fields: e, values: aG(t, !1) }),
          );
        }
        r.filter(t => t.name === n.name + pV).length || r.push(t);
      }
      return r;
    })(this, t);
  }
  assembleLayout() {
    return null;
  }
  assembleLayoutSignals() {
    return iY(this);
  }
  assembleMarks() {
    var t;
    let n = null !== (t = this.component.mark) && void 0 !== t ? t : [];
    return (this.parent && tJ(this.parent)) || (n = lG(this, n)), n.map(this.correctDataNames);
  }
  assembleGroupStyle() {
    const { style: t } = this.view || {};
    return void 0 !== t ? t : this.encoding.x || this.encoding.y ? 'cell' : void 0;
  }
  getMapping() {
    return this.encoding;
  }
  get mark() {
    return this.markDef.type;
  }
  channelHasField(t) {
    return MU(this.encoding, t);
  }
  fieldDef(t) {
    return oU(this.encoding[t]);
  }
  typedFieldDef(t) {
    const n = this.fieldDef(t);
    return UI(n) ? n : null;
  }
}
class WJ extends nJ {
  constructor(t, n, e, r, i) {
    super(t, 'layer', n, e, i, t.resolve, t.view);
    const o = Object.assign(
      Object.assign(Object.assign({}, r), t.width ? { width: t.width } : {}),
      t.height ? { height: t.height } : {},
    );
    this.children = t.layer.map((t, n) => {
      if (IW(t)) return new WJ(t, this, this.getName(`layer_${n}`), o, i);
      if (AU(t)) return new UJ(t, this, this.getName(`layer_${n}`), o, i);
      throw new Error(XR(t));
    });
  }
  parseData() {
    this.component.data = MJ(this);
    for (const t of this.children) t.parseData();
  }
  parseLayoutSize() {
    wJ(this), xJ(this, 'width'), xJ(this, 'height');
  }
  parseSelections() {
    this.component.selection = {};
    for (const t of this.children) {
      t.parseSelections();
      for (const n of vT(t.component.selection)) this.component.selection[n] = t.component.selection[n];
    }
  }
  parseMarkGroup() {
    for (const t of this.children) t.parseMarkGroup();
  }
  parseAxesAndHeaders() {
    !(function (t) {
      var n;
      const { axes: e, resolve: r } = t.component,
        i = { top: 0, bottom: 0, right: 0, left: 0 };
      for (const n of t.children) {
        n.parseAxesAndHeaders();
        for (const i of vT(n.component.axes))
          (r.axis[i] = fY(t.component.resolve, i)),
            'shared' === r.axis[i] &&
              ((e[i] = CJ(e[i], n.component.axes[i])), e[i] || ((r.axis[i] = 'independent'), delete e[i]));
      }
      for (const o of GP) {
        for (const u of t.children)
          if (u.component.axes[o]) {
            if ('independent' === r.axis[o]) {
              e[o] = (null !== (n = e[o]) && void 0 !== n ? n : []).concat(u.component.axes[o]);
              for (const t of u.component.axes[o]) {
                const { value: n, explicit: e } = t.getWithExplicit('orient');
                if (!MR(n)) {
                  if (i[n] > 0 && !e) {
                    const e = SJ[n];
                    i[n] > i[e] && t.set('orient', e, !1);
                  }
                  i[n]++;
                }
              }
            }
            delete u.component.axes[o];
          }
        if ('independent' === r.axis[o] && e[o] && e[o].length > 1)
          for (const t of e[o]) t.get('grid') && !t.explicit.grid && (t.implicit.grid = !1);
      }
    })(this);
  }
  assembleSelectionTopLevelSignals(t) {
    return this.children.reduce((t, n) => n.assembleSelectionTopLevelSignals(t), t);
  }
  assembleSignals() {
    return this.children.reduce((t, n) => t.concat(n.assembleSignals()), CV(this));
  }
  assembleLayoutSignals() {
    return this.children.reduce((t, n) => t.concat(n.assembleLayoutSignals()), iY(this));
  }
  assembleSelectionData(t) {
    return this.children.reduce((t, n) => n.assembleSelectionData(t), t);
  }
  assembleGroupStyle() {
    const t = new Set();
    for (const n of this.children) for (const e of At(n.assembleGroupStyle())) t.add(e);
    const n = Array.from(t);
    return n.length > 1 ? n : 1 === n.length ? n[0] : void 0;
  }
  assembleTitle() {
    let t = super.assembleTitle();
    if (t) return t;
    for (const n of this.children) if (((t = n.assembleTitle()), t)) return t;
  }
  assembleLayout() {
    return null;
  }
  assembleMarks() {
    return (function (t, n) {
      for (const e of t.children) QX(e) && (n = lG(e, n));
      return n;
    })(
      this,
      this.children.flatMap(t => t.assembleMarks()),
    );
  }
  assembleLegends() {
    return this.children.reduce((t, n) => t.concat(n.assembleLegends()), jY(this));
  }
}
function HJ(t, n, e, r, i) {
  if (jI(t)) return new AJ(t, n, e, i);
  if (IW(t)) return new WJ(t, n, e, r, i);
  if (AU(t)) return new UJ(t, n, e, r, i);
  if (
    (function (t) {
      return xW(t) || OW(t) || wW(t);
    })(t)
  )
    return new jJ(t, n, e, i);
  throw new Error(XR(t));
}
const GJ = Object.freeze({
  __proto__: null,
  version: '5.2.0',
  compile: function (t, n = {}) {
    n.logger && (jL = n.logger), n.fieldTitle && tU(n.fieldTitle);
    try {
      const e = TW(et(n.config, t.config)),
        r = RH(t, e),
        i = HJ(r, null, '', void 0, e);
      i.parse(),
        (function (t, n) {
          pX(t.sources);
          let e = 0,
            r = 0;
          for (let r = 0; r < 5 && vX(t, n, !0); r++) e++;
          t.sources.map(fX);
          for (let e = 0; e < 5 && vX(t, n, !1); e++) r++;
          pX(t.sources), 5 === Math.max(e, r) && DL('Maximum optimization runs(5) reached.');
        })(i.component.data, i);
      const o = (function (t, n, e = {}, r) {
        const i = t.config
            ? (function (t) {
                t = Zz(t);
                for (const n of RW) delete t[n];
                if (t.axis) for (const n in t.axis) gU(t.axis[n]) && delete t.axis[n];
                if (t.legend) for (const n of uW) delete t.legend[n];
                if (t.mark) {
                  for (const n of Qq) delete t.mark[n];
                  t.mark.tooltip && tt(t.mark.tooltip) && delete t.mark.tooltip;
                }
                t.params && ((t.signals = (t.signals || []).concat(yW(t.params))), delete t.params);
                for (const n of PW) {
                  for (const e of Qq) delete t[n][e];
                  const e = LW[n];
                  if (e) for (const r of e) delete t[n][r];
                  qW(t, n);
                }
                for (const n of vT(iW)) delete t[n];
                !(function (t) {
                  const { titleMarkConfig: n, subtitleMarkConfig: e, subtitle: r } = AR(t.title);
                  mT(n) || (t.style['group-title'] = Object.assign(Object.assign({}, t.style['group-title']), n)),
                    mT(e) ||
                      (t.style['group-subtitle'] = Object.assign(Object.assign({}, t.style['group-subtitle']), e)),
                    mT(r) ? delete t.title : (t.title = r);
                })(t);
                for (const n in t) tt(t[n]) && mT(t[n]) && delete t[n];
                return mT(t) ? void 0 : t;
              })(t.config)
            : void 0,
          o = [].concat(
            t.assembleSelectionData([]),
            (function (t, n) {
              var e, r;
              const i = [],
                o = vJ(i);
              let u = 0;
              for (const n of t.sources) {
                n.hasName() || (n.dataName = 'source_' + u++);
                const t = n.assemble();
                o(n, t);
              }
              for (const t of i) 0 === t.transform.length && delete t.transform;
              let s = 0;
              for (const [t, n] of i.entries())
                0 !== (null !== (e = n.transform) && void 0 !== e ? e : []).length ||
                  n.source ||
                  i.splice(s++, 0, i.splice(t, 1)[0]);
              for (const n of i)
                for (const e of null !== (r = n.transform) && void 0 !== r ? r : [])
                  'lookup' === e.type && (e.from = t.outputNodes[e.from].getSource());
              for (const t of i) t.name in n && (t.values = n[t.name]);
              return i;
            })(t.component.data, e),
          ),
          u = t.assembleProjections(),
          s = t.assembleTitle(),
          a = t.assembleGroupStyle(),
          c = t.assembleGroupEncodeEntry(!0);
        let l = t.assembleLayoutSignals();
        l = l.filter(
          t => ('width' !== t.name && 'height' !== t.name) || void 0 === t.value || ((n[t.name] = +t.value), !1),
        );
        const { params: f } = n,
          h = (function (t, n) {
            var e = {};
            for (var r in t) Object.prototype.hasOwnProperty.call(t, r) && n.indexOf(r) < 0 && (e[r] = t[r]);
            if (null != t && 'function' == typeof Object.getOwnPropertySymbols) {
              var i = 0;
              for (r = Object.getOwnPropertySymbols(t); i < r.length; i++)
                n.indexOf(r[i]) < 0 && Object.prototype.propertyIsEnumerable.call(t, r[i]) && (e[r[i]] = t[r[i]]);
            }
            return e;
          })(n, ['params']);
        return Object.assign(
          Object.assign(
            Object.assign(
              Object.assign(
                Object.assign(
                  Object.assign(
                    Object.assign(
                      Object.assign(
                        Object.assign(
                          Object.assign(
                            { $schema: 'https://vega.github.io/schema/vega/v5.json' },
                            t.description ? { description: t.description } : {},
                          ),
                          h,
                        ),
                        s ? { title: s } : {},
                      ),
                      a ? { style: a } : {},
                    ),
                    c ? { encode: { update: c } } : {},
                  ),
                  { data: o },
                ),
                u.length > 0 ? { projections: u } : {},
              ),
              t.assembleGroup([...l, ...t.assembleSelectionTopLevelSignals([]), ...yW(f)]),
            ),
            i ? { config: i } : {},
          ),
          r ? { usermeta: r } : {},
        );
      })(
        i,
        (function (t, n, e, r) {
          const i = r.component.layoutSize.get('width'),
            o = r.component.layoutSize.get('height');
          if (
            (void 0 === n
              ? ((n = { type: 'pad' }), r.hasAxisOrientSignalRef() && (n.resize = !0))
              : Xt(n) && (n = { type: n }),
            i && o && ('fit' === (u = n.type) || 'fit-x' === u || 'fit-y' === u))
          )
            if ('step' === i && 'step' === o) DL(ZR()), (n.type = 'pad');
            else if ('step' === i || 'step' === o) {
              const t = 'step' === i ? 'width' : 'height';
              DL(ZR(JP(t))),
                (n.type = (function (t) {
                  return t ? `fit-${JP(t)}` : 'fit';
                })('width' === t ? 'height' : 'width'));
            }
          var u;
          return Object.assign(
            Object.assign(
              Object.assign(
                {},
                1 === vT(n).length && n.type ? ('pad' === n.type ? {} : { autosize: n.type }) : { autosize: n },
              ),
              HH(e, !1),
            ),
            HH(t, !0),
          );
        })(t, r.autosize, e, i),
        t.datasets,
        t.usermeta,
      );
      return { spec: o, normalized: r };
    } finally {
      n.logger && (jL = ML), n.fieldTitle && tU(ZI);
    }
  },
  normalize: RH,
  deepEqual: Qz,
  duplicate: Zz,
  never: Kz,
  pick: tT,
  omit: nT,
  stringify: eT,
  hash: rT,
  isNullOrFalse: iT,
  contains: oT,
  some: uT,
  every: sT,
  mergeDeep: aT,
  unique: lT,
  isEqual: function (t, n) {
    const e = vT(t),
      r = vT(n);
    if (e.length !== r.length) return !1;
    for (const r of e) if (t[r] !== n[r]) return !1;
    return !0;
  },
  setEqual: fT,
  hasIntersection: hT,
  prefixGenerator: dT,
  fieldIntersection: pT,
  isEmpty: mT,
  keys: vT,
  vals: gT,
  entries: bT,
  isBoolean: yT,
  varName: wT,
  logicalExpr: xT,
  deleteNestedProperty: OT,
  titleCase: kT,
  accessPathWithDatum: AT,
  flatAccessWithDatum: $T,
  replacePathInField: jT,
  replaceAll: DT,
  removePathFromField: FT,
  accessPathDepth: ET,
  getFirstDefined: ST,
  uniqueId: NT,
  resetIdCounter: function () {
    CT = 42;
  },
  internalField: BT,
  isInternalField: _T,
  normalizeAngle: zT,
  isNumeric: TT,
});
function VJ(t) {
  const [n, e] = /schema\/([\w-]+)\/([\w\.\-]+)\.json$/g.exec(t).slice(1, 3);
  return { library: n, version: e };
}
const YJ = '#fff',
  XJ = '#888',
  JJ = {
    background: '#333',
    view: { stroke: XJ },
    title: { color: YJ, subtitleColor: YJ },
    style: { 'guide-label': { fill: YJ }, 'guide-title': { fill: YJ } },
    axis: { domainColor: YJ, gridColor: XJ, tickColor: YJ },
  },
  QJ = '#4572a7',
  ZJ = {
    background: '#fff',
    arc: { fill: QJ },
    area: { fill: QJ },
    line: { stroke: QJ, strokeWidth: 2 },
    path: { stroke: QJ },
    rect: { fill: QJ },
    shape: { stroke: QJ },
    symbol: { fill: QJ, strokeWidth: 1.5, size: 50 },
    axis: {
      bandPosition: 0.5,
      grid: !0,
      gridColor: '#000000',
      gridOpacity: 1,
      gridWidth: 0.5,
      labelPadding: 10,
      tickSize: 5,
      tickWidth: 0.5,
    },
    axisBand: { grid: !1, tickExtra: !0 },
    legend: { labelBaseline: 'middle', labelFontSize: 11, symbolSize: 50, symbolType: 'square' },
    range: {
      category: [
        '#4572a7',
        '#aa4643',
        '#8aa453',
        '#71598e',
        '#4598ae',
        '#d98445',
        '#94aace',
        '#d09393',
        '#b9cc98',
        '#a99cbc',
      ],
    },
  },
  KJ = '#30a2da',
  tQ = '#cbcbcb',
  nQ = '#f0f0f0',
  eQ = '#333',
  rQ = {
    arc: { fill: KJ },
    area: { fill: KJ },
    axis: {
      domainColor: tQ,
      grid: !0,
      gridColor: tQ,
      gridWidth: 1,
      labelColor: '#999',
      labelFontSize: 10,
      titleColor: '#333',
      tickColor: tQ,
      tickSize: 10,
      titleFontSize: 14,
      titlePadding: 10,
      labelPadding: 4,
    },
    axisBand: { grid: !1 },
    background: nQ,
    group: { fill: nQ },
    legend: {
      labelColor: eQ,
      labelFontSize: 11,
      padding: 1,
      symbolSize: 30,
      symbolType: 'square',
      titleColor: eQ,
      titleFontSize: 14,
      titlePadding: 10,
    },
    line: { stroke: KJ, strokeWidth: 2 },
    path: { stroke: KJ, strokeWidth: 0.5 },
    rect: { fill: KJ },
    range: {
      category: [
        '#30a2da',
        '#fc4f30',
        '#e5ae38',
        '#6d904f',
        '#8b8b8b',
        '#b96db8',
        '#ff9e27',
        '#56cc60',
        '#52d2ca',
        '#52689e',
        '#545454',
        '#9fe4f8',
      ],
      diverging: ['#cc0020', '#e77866', '#f6e7e1', '#d6e8ed', '#91bfd9', '#1d78b5'],
      heatmap: ['#d6e8ed', '#cee0e5', '#91bfd9', '#549cc6', '#1d78b5'],
    },
    point: { filled: !0, shape: 'circle' },
    shape: { stroke: KJ },
    bar: { binSpacing: 2, fill: KJ, stroke: null },
    title: { anchor: 'start', fontSize: 24, fontWeight: 600, offset: 20 },
  },
  iQ = '#000',
  oQ = {
    group: { fill: '#e5e5e5' },
    arc: { fill: iQ },
    area: { fill: iQ },
    line: { stroke: iQ },
    path: { stroke: iQ },
    rect: { fill: iQ },
    shape: { stroke: iQ },
    symbol: { fill: iQ, size: 40 },
    axis: {
      domain: !1,
      grid: !0,
      gridColor: '#FFFFFF',
      gridOpacity: 1,
      labelColor: '#7F7F7F',
      labelPadding: 4,
      tickColor: '#7F7F7F',
      tickSize: 5.67,
      titleFontSize: 16,
      titleFontWeight: 'normal',
    },
    legend: { labelBaseline: 'middle', labelFontSize: 11, symbolSize: 40 },
    range: {
      category: [
        '#000000',
        '#7F7F7F',
        '#1A1A1A',
        '#999999',
        '#333333',
        '#B0B0B0',
        '#4D4D4D',
        '#C9C9C9',
        '#666666',
        '#DCDCDC',
      ],
    },
  },
  uQ = 'Benton Gothic, sans-serif',
  sQ = '#82c6df',
  aQ = 'Benton Gothic Bold, sans-serif',
  cQ = 'normal',
  lQ = {
    'category-6': ['#ec8431', '#829eb1', '#c89d29', '#3580b1', '#adc839', '#ab7fb4'],
    'fire-7': ['#fbf2c7', '#f9e39c', '#f8d36e', '#f4bb6a', '#e68a4f', '#d15a40', '#ab4232'],
    'fireandice-6': ['#e68a4f', '#f4bb6a', '#f9e39c', '#dadfe2', '#a6b7c6', '#849eae'],
    'ice-7': ['#edefee', '#dadfe2', '#c4ccd2', '#a6b7c6', '#849eae', '#607785', '#47525d'],
  },
  fQ = {
    background: '#ffffff',
    title: { anchor: 'start', color: '#000000', font: aQ, fontSize: 22, fontWeight: 'normal' },
    arc: { fill: sQ },
    area: { fill: sQ },
    line: { stroke: sQ, strokeWidth: 2 },
    path: { stroke: sQ },
    rect: { fill: sQ },
    shape: { stroke: sQ },
    symbol: { fill: sQ, size: 30 },
    axis: {
      labelFont: uQ,
      labelFontSize: 11.5,
      labelFontWeight: 'normal',
      titleFont: aQ,
      titleFontSize: 13,
      titleFontWeight: cQ,
    },
    axisX: { labelAngle: 0, labelPadding: 4, tickSize: 3 },
    axisY: {
      labelBaseline: 'middle',
      maxExtent: 45,
      minExtent: 45,
      tickSize: 2,
      titleAlign: 'left',
      titleAngle: 0,
      titleX: -45,
      titleY: -11,
    },
    legend: {
      labelFont: uQ,
      labelFontSize: 11.5,
      symbolType: 'square',
      titleFont: aQ,
      titleFontSize: 13,
      titleFontWeight: cQ,
    },
    range: {
      category: lQ['category-6'],
      diverging: lQ['fireandice-6'],
      heatmap: lQ['fire-7'],
      ordinal: lQ['fire-7'],
      ramp: lQ['fire-7'],
    },
  },
  hQ = '#ab5787',
  dQ = '#979797',
  pQ = {
    background: '#f9f9f9',
    arc: { fill: hQ },
    area: { fill: hQ },
    line: { stroke: hQ },
    path: { stroke: hQ },
    rect: { fill: hQ },
    shape: { stroke: hQ },
    symbol: { fill: hQ, size: 30 },
    axis: {
      domainColor: dQ,
      domainWidth: 0.5,
      gridWidth: 0.2,
      labelColor: dQ,
      tickColor: dQ,
      tickWidth: 0.2,
      titleColor: dQ,
    },
    axisBand: { grid: !1 },
    axisX: { grid: !0, tickSize: 10 },
    axisY: { domain: !1, grid: !0, tickSize: 0 },
    legend: { labelFontSize: 11, padding: 1, symbolSize: 30, symbolType: 'square' },
    range: {
      category: [
        '#ab5787',
        '#51b2e5',
        '#703c5c',
        '#168dd9',
        '#d190b6',
        '#00609f',
        '#d365ba',
        '#154866',
        '#666666',
        '#c4c4c4',
      ],
    },
  },
  mQ = '#3e5c69',
  vQ = {
    background: '#fff',
    arc: { fill: mQ },
    area: { fill: mQ },
    line: { stroke: mQ },
    path: { stroke: mQ },
    rect: { fill: mQ },
    shape: { stroke: mQ },
    symbol: { fill: mQ },
    axis: { domainWidth: 0.5, grid: !0, labelPadding: 2, tickSize: 5, tickWidth: 0.5, titleFontWeight: 'normal' },
    axisBand: { grid: !1 },
    axisX: { gridWidth: 0.2 },
    axisY: { gridDash: [3], gridWidth: 0.4 },
    legend: { labelFontSize: 11, padding: 1, symbolType: 'square' },
    range: { category: ['#3e5c69', '#6793a6', '#182429', '#0570b0', '#3690c0', '#74a9cf', '#a6bddb', '#e2ddf2'] },
  },
  gQ = '#1696d2',
  bQ = '#000000',
  yQ = 'Lato',
  wQ = 'Lato',
  xQ = {
    'main-colors': ['#1696d2', '#d2d2d2', '#000000', '#fdbf11', '#ec008b', '#55b748', '#5c5859', '#db2b27'],
    'shades-blue': ['#CFE8F3', '#A2D4EC', '#73BFE2', '#46ABDB', '#1696D2', '#12719E', '#0A4C6A', '#062635'],
    'shades-gray': ['#F5F5F5', '#ECECEC', '#E3E3E3', '#DCDBDB', '#D2D2D2', '#9D9D9D', '#696969', '#353535'],
    'shades-yellow': ['#FFF2CF', '#FCE39E', '#FDD870', '#FCCB41', '#FDBF11', '#E88E2D', '#CA5800', '#843215'],
    'shades-magenta': ['#F5CBDF', '#EB99C2', '#E46AA7', '#E54096', '#EC008B', '#AF1F6B', '#761548', '#351123'],
    'shades-green': ['#DCEDD9', '#BCDEB4', '#98CF90', '#78C26D', '#55B748', '#408941', '#2C5C2D', '#1A2E19'],
    'shades-black': ['#D5D5D4', '#ADABAC', '#848081', '#5C5859', '#332D2F', '#262223', '#1A1717', '#0E0C0D'],
    'shades-red': ['#F8D5D4', '#F1AAA9', '#E9807D', '#E25552', '#DB2B27', '#A4201D', '#6E1614', '#370B0A'],
    'one-group': ['#1696d2', '#000000'],
    'two-groups-cat-1': ['#1696d2', '#000000'],
    'two-groups-cat-2': ['#1696d2', '#fdbf11'],
    'two-groups-cat-3': ['#1696d2', '#db2b27'],
    'two-groups-seq': ['#a2d4ec', '#1696d2'],
    'three-groups-cat': ['#1696d2', '#fdbf11', '#000000'],
    'three-groups-seq': ['#a2d4ec', '#1696d2', '#0a4c6a'],
    'four-groups-cat-1': ['#000000', '#d2d2d2', '#fdbf11', '#1696d2'],
    'four-groups-cat-2': ['#1696d2', '#ec0008b', '#fdbf11', '#5c5859'],
    'four-groups-seq': ['#cfe8f3', '#73bf42', '#1696d2', '#0a4c6a'],
    'five-groups-cat-1': ['#1696d2', '#fdbf11', '#d2d2d2', '#ec008b', '#000000'],
    'five-groups-cat-2': ['#1696d2', '#0a4c6a', '#d2d2d2', '#fdbf11', '#332d2f'],
    'five-groups-seq': ['#cfe8f3', '#73bf42', '#1696d2', '#0a4c6a', '#000000'],
    'six-groups-cat-1': ['#1696d2', '#ec008b', '#fdbf11', '#000000', '#d2d2d2', '#55b748'],
    'six-groups-cat-2': ['#1696d2', '#d2d2d2', '#ec008b', '#fdbf11', '#332d2f', '#0a4c6a'],
    'six-groups-seq': ['#cfe8f3', '#a2d4ec', '#73bfe2', '#46abdb', '#1696d2', '#12719e'],
    'diverging-colors': ['#ca5800', '#fdbf11', '#fdd870', '#fff2cf', '#cfe8f3', '#73bfe2', '#1696d2', '#0a4c6a'],
  },
  OQ = {
    background: '#FFFFFF',
    title: { anchor: 'start', fontSize: 18, font: yQ },
    axisX: {
      domain: !0,
      domainColor: bQ,
      domainWidth: 1,
      grid: !1,
      labelFontSize: 12,
      labelFont: wQ,
      labelAngle: 0,
      tickColor: bQ,
      tickSize: 5,
      titleFontSize: 12,
      titlePadding: 10,
      titleFont: yQ,
    },
    axisY: {
      domain: !1,
      domainWidth: 1,
      grid: !0,
      gridColor: '#DEDDDD',
      gridWidth: 1,
      labelFontSize: 12,
      labelFont: wQ,
      labelPadding: 8,
      ticks: !1,
      titleFontSize: 12,
      titlePadding: 10,
      titleFont: yQ,
      titleAngle: 0,
      titleY: -10,
      titleX: 18,
    },
    legend: {
      labelFontSize: 12,
      labelFont: wQ,
      symbolSize: 100,
      titleFontSize: 12,
      titlePadding: 10,
      titleFont: yQ,
      orient: 'right',
      offset: 10,
    },
    view: { stroke: 'transparent' },
    range: {
      category: xQ['six-groups-cat-1'],
      diverging: xQ['diverging-colors'],
      heatmap: xQ['diverging-colors'],
      ordinal: xQ['six-groups-seq'],
      ramp: xQ['shades-blue'],
    },
    area: { fill: gQ },
    rect: { fill: gQ },
    line: { color: gQ, stroke: gQ, strokeWidth: 5 },
    trail: { color: gQ, stroke: gQ, strokeWidth: 0, size: 1 },
    path: { stroke: gQ, strokeWidth: 0.5 },
    point: { filled: !0 },
    text: { font: 'Lato', color: gQ, fontSize: 11, align: 'center', fontWeight: 400, size: 11 },
    style: { bar: { fill: gQ, stroke: null } },
    arc: { fill: gQ },
    shape: { stroke: gQ },
    symbol: { fill: gQ, size: 30 },
  },
  kQ = '#3366CC',
  AQ = '#ccc',
  $Q = 'Arial, sans-serif',
  MQ = {
    arc: { fill: kQ },
    area: { fill: kQ },
    path: { stroke: kQ },
    rect: { fill: kQ },
    shape: { stroke: kQ },
    symbol: { stroke: kQ },
    circle: { fill: kQ },
    background: '#fff',
    padding: { top: 10, right: 10, bottom: 10, left: 10 },
    style: {
      'guide-label': { font: $Q, fontSize: 12 },
      'guide-title': { font: $Q, fontSize: 12 },
      'group-title': { font: $Q, fontSize: 12 },
    },
    title: { font: $Q, fontSize: 14, fontWeight: 'bold', dy: -3, anchor: 'start' },
    axis: { gridColor: AQ, tickColor: AQ, domain: !1, grid: !0 },
    range: {
      category: [
        '#4285F4',
        '#DB4437',
        '#F4B400',
        '#0F9D58',
        '#AB47BC',
        '#00ACC1',
        '#FF7043',
        '#9E9D24',
        '#5C6BC0',
        '#F06292',
        '#00796B',
        '#C2185B',
      ],
      heatmap: ['#c6dafc', '#5e97f6', '#2a56c6'],
    },
  },
  jQ = t => t * (1 / 3 + 1),
  DQ = jQ(9),
  FQ = jQ(10),
  EQ = jQ(12),
  SQ = 'Segoe UI',
  CQ = 'wf_standard-font, helvetica, arial, sans-serif',
  NQ = '#252423',
  BQ = '#605E5C',
  _Q = 'transparent',
  zQ = '#118DFF',
  TQ = '#DEEFFF',
  PQ = [TQ, zQ],
  RQ = Object.freeze({
    __proto__: null,
    dark: JJ,
    excel: ZJ,
    fivethirtyeight: rQ,
    ggplot2: oQ,
    googlecharts: MQ,
    latimes: fQ,
    powerbi: {
      view: { stroke: _Q },
      background: _Q,
      font: SQ,
      header: { titleFont: CQ, titleFontSize: EQ, titleColor: NQ, labelFont: SQ, labelFontSize: FQ, labelColor: BQ },
      axis: {
        ticks: !1,
        grid: !1,
        domain: !1,
        labelColor: BQ,
        labelFontSize: DQ,
        titleFont: CQ,
        titleColor: NQ,
        titleFontSize: EQ,
        titleFontWeight: 'normal',
      },
      axisQuantitative: { tickCount: 3, grid: !0, gridColor: '#C8C6C4', gridDash: [1, 5], labelFlush: !1 },
      axisBand: { tickExtra: !0 },
      axisX: { labelPadding: 5 },
      axisY: { labelPadding: 10 },
      bar: { fill: zQ },
      line: { stroke: zQ, strokeWidth: 3, strokeCap: 'round', strokeJoin: 'round' },
      text: { font: SQ, fontSize: DQ, fill: BQ },
      arc: { fill: zQ },
      area: { fill: zQ, line: !0, opacity: 0.6 },
      path: { stroke: zQ },
      rect: { fill: zQ },
      point: { fill: zQ, filled: !0, size: 75 },
      shape: { stroke: zQ },
      symbol: { fill: zQ, strokeWidth: 1.5, size: 50 },
      legend: {
        titleFont: SQ,
        titleFontWeight: 'bold',
        titleColor: BQ,
        labelFont: SQ,
        labelFontSize: FQ,
        labelColor: BQ,
        symbolType: 'circle',
        symbolSize: 75,
      },
      range: {
        category: [zQ, '#12239E', '#E66C37', '#6B007B', '#E044A7', '#744EC2', '#D9B300', '#D64550'],
        diverging: PQ,
        heatmap: PQ,
        ordinal: [TQ, '#c7e4ff', '#b0d9ff', '#9aceff', '#83c3ff', '#6cb9ff', '#55aeff', '#3fa3ff', '#2898ff', zQ],
      },
    },
    quartz: pQ,
    urbaninstitute: OQ,
    version: '2.12.1',
    vox: vQ,
  });
function LQ(t, n) {
  return JSON.stringify(
    t,
    (function (t) {
      const n = [];
      return function (e, r) {
        if ('object' != typeof r || null === r) return r;
        const i = n.indexOf(this) + 1;
        return (n.length = i), n.length > t ? '[Object]' : n.indexOf(r) >= 0 ? '[Circular]' : (n.push(r), r);
      };
    })(n),
  );
}
const qQ = 'vg-tooltip-element',
  IQ = {
    offsetX: 10,
    offsetY: 10,
    id: qQ,
    styleId: 'vega-tooltip-style',
    theme: 'light',
    disableDefaultStyle: !1,
    sanitize: function (t) {
      return String(t).replace(/&/g, '&amp;').replace(/</g, '&lt;');
    },
    maxDepth: 2,
    formatTooltip: function (t, n, e) {
      if (K(t)) return `[${t.map(t => n(Xt(t) ? t : LQ(t, e))).join(', ')}]`;
      if (tt(t)) {
        let r = '';
        const i = t,
          { title: o, image: u } = i,
          s = (function (t, n) {
            var e = {};
            for (var r in t) Object.prototype.hasOwnProperty.call(t, r) && n.indexOf(r) < 0 && (e[r] = t[r]);
            if (null != t && 'function' == typeof Object.getOwnPropertySymbols) {
              var i = 0;
              for (r = Object.getOwnPropertySymbols(t); i < r.length; i++)
                n.indexOf(r[i]) < 0 && Object.prototype.propertyIsEnumerable.call(t, r[i]) && (e[r[i]] = t[r[i]]);
            }
            return e;
          })(i, ['title', 'image']);
        o && (r += `<h2>${n(o)}</h2>`), u && (r += `<img src="${n(u)}">`);
        const a = Object.keys(s);
        if (a.length > 0) {
          r += '<table>';
          for (const t of a) {
            let i = s[t];
            void 0 !== i &&
              (tt(i) && (i = LQ(i, e)), (r += `<tr><td class="key">${n(t)}:</td><td class="value">${n(i)}</td></tr>`));
          }
          r += '</table>';
        }
        return r || '{}';
      }
      return n(t);
    },
  };
class UQ {
  constructor(t) {
    this.options = Object.assign(Object.assign({}, IQ), t);
    const n = this.options.id;
    if (
      ((this.el = null),
      (this.call = this.tooltipHandler.bind(this)),
      !this.options.disableDefaultStyle && !document.getElementById(this.options.styleId))
    ) {
      const t = document.createElement('style');
      t.setAttribute('id', this.options.styleId),
        (t.innerHTML = (function (t) {
          if (!/^[A-Za-z]+[-:.\w]*$/.test(t)) throw new Error('Invalid HTML ID');
          return '#vg-tooltip-element {\n  visibility: hidden;\n  padding: 8px;\n  position: fixed;\n  z-index: 1000;\n  font-family: sans-serif;\n  font-size: 11px;\n  border-radius: 3px;\n  box-shadow: 2px 2px 4px rgba(0, 0, 0, 0.1);\n  /* The default theme is the light theme. */\n  background-color: rgba(255, 255, 255, 0.95);\n  border: 1px solid #d9d9d9;\n  color: black;\n}\n#vg-tooltip-element.visible {\n  visibility: visible;\n}\n#vg-tooltip-element h2 {\n  margin-top: 0;\n  margin-bottom: 10px;\n  font-size: 13px;\n}\n#vg-tooltip-element img {\n  max-width: 200px;\n  max-height: 200px;\n}\n#vg-tooltip-element table {\n  border-spacing: 0;\n}\n#vg-tooltip-element table tr {\n  border: none;\n}\n#vg-tooltip-element table tr td {\n  overflow: hidden;\n  text-overflow: ellipsis;\n  padding-top: 2px;\n  padding-bottom: 2px;\n}\n#vg-tooltip-element table tr td.key {\n  color: #808080;\n  max-width: 150px;\n  text-align: right;\n  padding-right: 4px;\n}\n#vg-tooltip-element table tr td.value {\n  display: block;\n  max-width: 300px;\n  max-height: 7em;\n  text-align: left;\n}\n#vg-tooltip-element.dark-theme {\n  background-color: rgba(32, 32, 32, 0.9);\n  border: 1px solid #f5f5f5;\n  color: white;\n}\n#vg-tooltip-element.dark-theme td.key {\n  color: #bfbfbf;\n}\n'
            .toString()
            .replace(qQ, t);
        })(n));
      const e = document.head;
      e.childNodes.length > 0 ? e.insertBefore(t, e.childNodes[0]) : e.appendChild(t);
    }
  }
  tooltipHandler(t, n, e, r) {
    var i;
    if (
      ((this.el = document.getElementById(this.options.id)),
      this.el ||
        ((this.el = document.createElement('div')),
        this.el.setAttribute('id', this.options.id),
        this.el.classList.add('vg-tooltip'),
        (null !== (i = document.fullscreenElement) && void 0 !== i ? i : document.body).appendChild(this.el)),
      null == r || '' === r)
    )
      return void this.el.classList.remove('visible', `${this.options.theme}-theme`);
    (this.el.innerHTML = this.options.formatTooltip(r, this.options.sanitize, this.options.maxDepth)),
      this.el.classList.add('visible', `${this.options.theme}-theme`);
    const { x: o, y: u } = (function (t, n, e, r) {
      let i = t.clientX + e;
      i + n.width > window.innerWidth && (i = +t.clientX - e - n.width);
      let o = t.clientY + r;
      return o + n.height > window.innerHeight && (o = +t.clientY - r - n.height), { x: i, y: o };
    })(n, this.el.getBoundingClientRect(), this.options.offsetX, this.options.offsetY);
    (this.el.style.top = `${u}px`), (this.el.style.left = `${o}px`);
  }
}
function WQ(t) {
  return (
    (WQ =
      'function' == typeof Symbol && 'symbol' == typeof Symbol.iterator
        ? function (t) {
            return typeof t;
          }
        : function (t) {
            return t && 'function' == typeof Symbol && t.constructor === Symbol && t !== Symbol.prototype
              ? 'symbol'
              : typeof t;
          }),
    WQ(t)
  );
}
function HQ(t, n, e) {
  return (
    (n = (function (t) {
      var n = (function (t) {
        if ('object' !== WQ(t) || null === t) return t;
        var n = t[Symbol.toPrimitive];
        if (void 0 !== n) {
          var e = n.call(t, 'string');
          if ('object' !== WQ(e)) return e;
          throw new TypeError('@@toPrimitive must return a primitive value.');
        }
        return String(t);
      })(t);
      return 'symbol' === WQ(n) ? n : String(n);
    })(n)) in t
      ? Object.defineProperty(t, n, { value: e, enumerable: !0, configurable: !0, writable: !0 })
      : (t[n] = e),
    t
  );
}
function GQ(t, n, e, r, i, o, u) {
  try {
    var s = t[o](u),
      a = s.value;
  } catch (t) {
    return void e(t);
  }
  s.done ? n(a) : Promise.resolve(a).then(r, i);
}
function VQ(t) {
  return function () {
    var n = this,
      e = arguments;
    return new Promise(function (r, i) {
      var o = t.apply(n, e);
      function u(t) {
        GQ(o, r, i, u, s, 'next', t);
      }
      function s(t) {
        GQ(o, r, i, u, s, 'throw', t);
      }
      u(void 0);
    });
  };
}
var YQ,
  XQ = Object.prototype,
  JQ = XQ.hasOwnProperty,
  QQ = 'function' == typeof Symbol ? Symbol : {},
  ZQ = QQ.iterator || '@@iterator',
  KQ = QQ.asyncIterator || '@@asyncIterator',
  tZ = QQ.toStringTag || '@@toStringTag';
function nZ(t, n, e, r) {
  var i = Object.create((n && n.prototype instanceof aZ ? n : aZ).prototype),
    o = new xZ(r || []);
  return (
    (i._invoke = (function (t, n, e) {
      var r = rZ;
      return function (i, o) {
        if (r === oZ) throw new Error('Generator is already running');
        if (r === uZ) {
          if ('throw' === i) throw o;
          return kZ();
        }
        for (e.method = i, e.arg = o; ; ) {
          var u = e.delegate;
          if (u) {
            var s = bZ(u, e);
            if (s) {
              if (s === sZ) continue;
              return s;
            }
          }
          if ('next' === e.method) e.sent = e._sent = e.arg;
          else if ('throw' === e.method) {
            if (r === rZ) throw ((r = uZ), e.arg);
            e.dispatchException(e.arg);
          } else 'return' === e.method && e.abrupt('return', e.arg);
          r = oZ;
          var a = eZ(t, n, e);
          if ('normal' === a.type) {
            if (((r = e.done ? uZ : iZ), a.arg === sZ)) continue;
            return { value: a.arg, done: e.done };
          }
          'throw' === a.type && ((r = uZ), (e.method = 'throw'), (e.arg = a.arg));
        }
      };
    })(t, e, o)),
    i
  );
}
function eZ(t, n, e) {
  try {
    return { type: 'normal', arg: t.call(n, e) };
  } catch (t) {
    return { type: 'throw', arg: t };
  }
}
var rZ = 'suspendedStart',
  iZ = 'suspendedYield',
  oZ = 'executing',
  uZ = 'completed',
  sZ = {};
function aZ() {}
function cZ() {}
function lZ() {}
var fZ = {};
fZ[ZQ] = function () {
  return this;
};
var hZ = Object.getPrototypeOf,
  dZ = hZ && hZ(hZ(OZ([])));
dZ && dZ !== XQ && JQ.call(dZ, ZQ) && (fZ = dZ);
var pZ = (lZ.prototype = aZ.prototype = Object.create(fZ));
function mZ(t) {
  ['next', 'throw', 'return'].forEach(function (n) {
    t[n] = function (t) {
      return this._invoke(n, t);
    };
  });
}
function vZ(t) {
  var n = 'function' == typeof t && t.constructor;
  return !!n && (n === cZ || 'GeneratorFunction' === (n.displayName || n.name));
}
function gZ(t, n) {
  function e(r, i, o, u) {
    var s = eZ(t[r], t, i);
    if ('throw' !== s.type) {
      var a = s.arg,
        c = a.value;
      return c && 'object' == typeof c && JQ.call(c, '__await')
        ? n.resolve(c.__await).then(
            function (t) {
              e('next', t, o, u);
            },
            function (t) {
              e('throw', t, o, u);
            },
          )
        : n.resolve(c).then(
            function (t) {
              (a.value = t), o(a);
            },
            function (t) {
              return e('throw', t, o, u);
            },
          );
    }
    u(s.arg);
  }
  var r;
  this._invoke = function (t, i) {
    function o() {
      return new n(function (n, r) {
        e(t, i, n, r);
      });
    }
    return (r = r ? r.then(o, o) : o());
  };
}
function bZ(t, n) {
  var e = t.iterator[n.method];
  if (e === YQ) {
    if (((n.delegate = null), 'throw' === n.method)) {
      if (t.iterator.return && ((n.method = 'return'), (n.arg = YQ), bZ(t, n), 'throw' === n.method)) return sZ;
      (n.method = 'throw'), (n.arg = new TypeError("The iterator does not provide a 'throw' method"));
    }
    return sZ;
  }
  var r = eZ(e, t.iterator, n.arg);
  if ('throw' === r.type) return (n.method = 'throw'), (n.arg = r.arg), (n.delegate = null), sZ;
  var i = r.arg;
  return i
    ? i.done
      ? ((n[t.resultName] = i.value),
        (n.next = t.nextLoc),
        'return' !== n.method && ((n.method = 'next'), (n.arg = YQ)),
        (n.delegate = null),
        sZ)
      : i
    : ((n.method = 'throw'), (n.arg = new TypeError('iterator result is not an object')), (n.delegate = null), sZ);
}
function yZ(t) {
  var n = { tryLoc: t[0] };
  1 in t && (n.catchLoc = t[1]), 2 in t && ((n.finallyLoc = t[2]), (n.afterLoc = t[3])), this.tryEntries.push(n);
}
function wZ(t) {
  var n = t.completion || {};
  (n.type = 'normal'), delete n.arg, (t.completion = n);
}
function xZ(t) {
  (this.tryEntries = [{ tryLoc: 'root' }]), t.forEach(yZ, this), this.reset(!0);
}
function OZ(t) {
  if (t) {
    var n = t[ZQ];
    if (n) return n.call(t);
    if ('function' == typeof t.next) return t;
    if (!isNaN(t.length)) {
      var e = -1,
        r = function n() {
          for (; ++e < t.length; ) if (JQ.call(t, e)) return (n.value = t[e]), (n.done = !1), n;
          return (n.value = YQ), (n.done = !0), n;
        };
      return (r.next = r);
    }
  }
  return { next: kZ };
}
function kZ() {
  return { value: YQ, done: !0 };
}
(cZ.prototype = pZ.constructor = lZ),
  (lZ.constructor = cZ),
  (lZ[tZ] = cZ.displayName = 'GeneratorFunction'),
  mZ(gZ.prototype),
  (gZ.prototype[KQ] = function () {
    return this;
  }),
  mZ(pZ),
  (pZ[tZ] = 'Generator'),
  (pZ[ZQ] = function () {
    return this;
  }),
  (pZ.toString = function () {
    return '[object Generator]';
  }),
  (xZ.prototype = {
    constructor: xZ,
    reset: function (t) {
      if (
        ((this.prev = 0),
        (this.next = 0),
        (this.sent = this._sent = YQ),
        (this.done = !1),
        (this.delegate = null),
        (this.method = 'next'),
        (this.arg = YQ),
        this.tryEntries.forEach(wZ),
        !t)
      )
        for (var n in this) 't' === n.charAt(0) && JQ.call(this, n) && !isNaN(+n.slice(1)) && (this[n] = YQ);
    },
    stop: function () {
      this.done = !0;
      var t = this.tryEntries[0].completion;
      if ('throw' === t.type) throw t.arg;
      return this.rval;
    },
    dispatchException: function (t) {
      if (this.done) throw t;
      var n = this;
      function e(e, r) {
        return (o.type = 'throw'), (o.arg = t), (n.next = e), r && ((n.method = 'next'), (n.arg = YQ)), !!r;
      }
      for (var r = this.tryEntries.length - 1; r >= 0; --r) {
        var i = this.tryEntries[r],
          o = i.completion;
        if ('root' === i.tryLoc) return e('end');
        if (i.tryLoc <= this.prev) {
          var u = JQ.call(i, 'catchLoc'),
            s = JQ.call(i, 'finallyLoc');
          if (u && s) {
            if (this.prev < i.catchLoc) return e(i.catchLoc, !0);
            if (this.prev < i.finallyLoc) return e(i.finallyLoc);
          } else if (u) {
            if (this.prev < i.catchLoc) return e(i.catchLoc, !0);
          } else {
            if (!s) throw new Error('try statement without catch or finally');
            if (this.prev < i.finallyLoc) return e(i.finallyLoc);
          }
        }
      }
    },
    abrupt: function (t, n) {
      for (var e = this.tryEntries.length - 1; e >= 0; --e) {
        var r = this.tryEntries[e];
        if (r.tryLoc <= this.prev && JQ.call(r, 'finallyLoc') && this.prev < r.finallyLoc) {
          var i = r;
          break;
        }
      }
      i && ('break' === t || 'continue' === t) && i.tryLoc <= n && n <= i.finallyLoc && (i = null);
      var o = i ? i.completion : {};
      return (o.type = t), (o.arg = n), i ? ((this.method = 'next'), (this.next = i.finallyLoc), sZ) : this.complete(o);
    },
    complete: function (t, n) {
      if ('throw' === t.type) throw t.arg;
      return (
        'break' === t.type || 'continue' === t.type
          ? (this.next = t.arg)
          : 'return' === t.type
          ? ((this.rval = this.arg = t.arg), (this.method = 'return'), (this.next = 'end'))
          : 'normal' === t.type && n && (this.next = n),
        sZ
      );
    },
    finish: function (t) {
      for (var n = this.tryEntries.length - 1; n >= 0; --n) {
        var e = this.tryEntries[n];
        if (e.finallyLoc === t) return this.complete(e.completion, e.afterLoc), wZ(e), sZ;
      }
    },
    catch: function (t) {
      for (var n = this.tryEntries.length - 1; n >= 0; --n) {
        var e = this.tryEntries[n];
        if (e.tryLoc === t) {
          var r = e.completion;
          if ('throw' === r.type) {
            var i = r.arg;
            wZ(e);
          }
          return i;
        }
      }
      throw new Error('illegal catch attempt');
    },
    delegateYield: function (t, n, e) {
      return (
        (this.delegate = { iterator: OZ(t), resultName: n, nextLoc: e }), 'next' === this.method && (this.arg = YQ), sZ
      );
    },
  });
var AZ,
  $Z,
  MZ = {
    wrap: nZ,
    isGeneratorFunction: vZ,
    AsyncIterator: gZ,
    mark: function (t) {
      return (
        Object.setPrototypeOf
          ? Object.setPrototypeOf(t, lZ)
          : ((t.__proto__ = lZ), tZ in t || (t[tZ] = 'GeneratorFunction')),
        (t.prototype = Object.create(pZ)),
        t
      );
    },
    awrap: function (t) {
      return { __await: t };
    },
    async: function (t, n, e, r, i) {
      void 0 === i && (i = Promise);
      var o = new gZ(nZ(t, n, e, r), i);
      return vZ(n)
        ? o
        : o.next().then(function (t) {
            return t.done ? t.value : o.next();
          });
    },
    keys: function (t) {
      var n = [];
      for (var e in t) n.push(e);
      return (
        n.reverse(),
        function e() {
          for (; n.length; ) {
            var r = n.pop();
            if (r in t) return (e.value = r), (e.done = !1), e;
          }
          return (e.done = !0), e;
        }
      );
    },
    values: OZ,
  },
  jZ = DZ;
function DZ(t) {
  var n = this;
  if (
    (n instanceof DZ || (n = new DZ()),
    (n.tail = null),
    (n.head = null),
    (n.length = 0),
    t && 'function' == typeof t.forEach)
  )
    t.forEach(function (t) {
      n.push(t);
    });
  else if (arguments.length > 0) for (var e = 0, r = arguments.length; e < r; e++) n.push(arguments[e]);
  return n;
}
function FZ(t, n, e) {
  var r = n === t.head ? new CZ(e, null, n, t) : new CZ(e, n, n.next, t);
  return null === r.next && (t.tail = r), null === r.prev && (t.head = r), t.length++, r;
}
function EZ(t, n) {
  (t.tail = new CZ(n, t.tail, null, t)), t.head || (t.head = t.tail), t.length++;
}
function SZ(t, n) {
  (t.head = new CZ(n, null, t.head, t)), t.tail || (t.tail = t.head), t.length++;
}
function CZ(t, n, e, r) {
  if (!(this instanceof CZ)) return new CZ(t, n, e, r);
  (this.list = r),
    (this.value = t),
    n ? ((n.next = this), (this.prev = n)) : (this.prev = null),
    e ? ((e.prev = this), (this.next = e)) : (this.next = null);
}
(DZ.Node = CZ),
  (DZ.create = DZ),
  (DZ.prototype.removeNode = function (t) {
    if (t.list !== this) throw new Error('removing node which does not belong to this list');
    var n = t.next,
      e = t.prev;
    return (
      n && (n.prev = e),
      e && (e.next = n),
      t === this.head && (this.head = n),
      t === this.tail && (this.tail = e),
      t.list.length--,
      (t.next = null),
      (t.prev = null),
      (t.list = null),
      n
    );
  }),
  (DZ.prototype.unshiftNode = function (t) {
    if (t !== this.head) {
      t.list && t.list.removeNode(t);
      var n = this.head;
      (t.list = this), (t.next = n), n && (n.prev = t), (this.head = t), this.tail || (this.tail = t), this.length++;
    }
  }),
  (DZ.prototype.pushNode = function (t) {
    if (t !== this.tail) {
      t.list && t.list.removeNode(t);
      var n = this.tail;
      (t.list = this), (t.prev = n), n && (n.next = t), (this.tail = t), this.head || (this.head = t), this.length++;
    }
  }),
  (DZ.prototype.push = function () {
    for (var t = 0, n = arguments.length; t < n; t++) EZ(this, arguments[t]);
    return this.length;
  }),
  (DZ.prototype.unshift = function () {
    for (var t = 0, n = arguments.length; t < n; t++) SZ(this, arguments[t]);
    return this.length;
  }),
  (DZ.prototype.pop = function () {
    if (this.tail) {
      var t = this.tail.value;
      return (this.tail = this.tail.prev), this.tail ? (this.tail.next = null) : (this.head = null), this.length--, t;
    }
  }),
  (DZ.prototype.shift = function () {
    if (this.head) {
      var t = this.head.value;
      return (this.head = this.head.next), this.head ? (this.head.prev = null) : (this.tail = null), this.length--, t;
    }
  }),
  (DZ.prototype.forEach = function (t, n) {
    n = n || this;
    for (var e = this.head, r = 0; null !== e; r++) t.call(n, e.value, r, this), (e = e.next);
  }),
  (DZ.prototype.forEachReverse = function (t, n) {
    n = n || this;
    for (var e = this.tail, r = this.length - 1; null !== e; r--) t.call(n, e.value, r, this), (e = e.prev);
  }),
  (DZ.prototype.get = function (t) {
    for (var n = 0, e = this.head; null !== e && n < t; n++) e = e.next;
    if (n === t && null !== e) return e.value;
  }),
  (DZ.prototype.getReverse = function (t) {
    for (var n = 0, e = this.tail; null !== e && n < t; n++) e = e.prev;
    if (n === t && null !== e) return e.value;
  }),
  (DZ.prototype.map = function (t, n) {
    n = n || this;
    for (var e = new DZ(), r = this.head; null !== r; ) e.push(t.call(n, r.value, this)), (r = r.next);
    return e;
  }),
  (DZ.prototype.mapReverse = function (t, n) {
    n = n || this;
    for (var e = new DZ(), r = this.tail; null !== r; ) e.push(t.call(n, r.value, this)), (r = r.prev);
    return e;
  }),
  (DZ.prototype.reduce = function (t, n) {
    var e,
      r = this.head;
    if (arguments.length > 1) e = n;
    else {
      if (!this.head) throw new TypeError('Reduce of empty list with no initial value');
      (r = this.head.next), (e = this.head.value);
    }
    for (var i = 0; null !== r; i++) (e = t(e, r.value, i)), (r = r.next);
    return e;
  }),
  (DZ.prototype.reduceReverse = function (t, n) {
    var e,
      r = this.tail;
    if (arguments.length > 1) e = n;
    else {
      if (!this.tail) throw new TypeError('Reduce of empty list with no initial value');
      (r = this.tail.prev), (e = this.tail.value);
    }
    for (var i = this.length - 1; null !== r; i--) (e = t(e, r.value, i)), (r = r.prev);
    return e;
  }),
  (DZ.prototype.toArray = function () {
    for (var t = new Array(this.length), n = 0, e = this.head; null !== e; n++) (t[n] = e.value), (e = e.next);
    return t;
  }),
  (DZ.prototype.toArrayReverse = function () {
    for (var t = new Array(this.length), n = 0, e = this.tail; null !== e; n++) (t[n] = e.value), (e = e.prev);
    return t;
  }),
  (DZ.prototype.slice = function (t, n) {
    (n = n || this.length) < 0 && (n += this.length), (t = t || 0) < 0 && (t += this.length);
    var e = new DZ();
    if (n < t || n < 0) return e;
    t < 0 && (t = 0), n > this.length && (n = this.length);
    for (var r = 0, i = this.head; null !== i && r < t; r++) i = i.next;
    for (; null !== i && r < n; r++, i = i.next) e.push(i.value);
    return e;
  }),
  (DZ.prototype.sliceReverse = function (t, n) {
    (n = n || this.length) < 0 && (n += this.length), (t = t || 0) < 0 && (t += this.length);
    var e = new DZ();
    if (n < t || n < 0) return e;
    t < 0 && (t = 0), n > this.length && (n = this.length);
    for (var r = this.length, i = this.tail; null !== i && r > n; r--) i = i.prev;
    for (; null !== i && r > t; r--, i = i.prev) e.push(i.value);
    return e;
  }),
  (DZ.prototype.splice = function (t, n) {
    t > this.length && (t = this.length - 1), t < 0 && (t = this.length + t);
    for (var e = 0, r = this.head; null !== r && e < t; e++) r = r.next;
    var i = [];
    for (e = 0; r && e < n; e++) i.push(r.value), (r = this.removeNode(r));
    for (
      null === r && (r = this.tail), r !== this.head && r !== this.tail && (r = r.prev), e = 0;
      e < (arguments.length <= 2 ? 0 : arguments.length - 2);
      e++
    )
      r = FZ(this, r, e + 2 < 2 || arguments.length <= e + 2 ? void 0 : arguments[e + 2]);
    return i;
  }),
  (DZ.prototype.reverse = function () {
    for (var t = this.head, n = this.tail, e = t; null !== e; e = e.prev) {
      var r = e.prev;
      (e.prev = e.next), (e.next = r);
    }
    return (this.head = n), (this.tail = t), this;
  });
try {
  ($Z ||
    (($Z = 1),
    (AZ = function (t) {
      t.prototype[Symbol.iterator] = MZ.mark(function t() {
        var n;
        return MZ.wrap(
          function (t) {
            for (;;)
              switch ((t.prev = t.next)) {
                case 0:
                  n = this.head;
                case 1:
                  if (!n) {
                    t.next = 7;
                    break;
                  }
                  return (t.next = 4), n.value;
                case 4:
                  (n = n.next), (t.next = 1);
                  break;
                case 7:
                case 'end':
                  return t.stop();
              }
          },
          t,
          this,
        );
      });
    })),
  AZ)(DZ);
} catch (t) {}
var NZ = jZ,
  BZ = Symbol('max'),
  _Z = Symbol('length'),
  zZ = Symbol('lengthCalculator'),
  TZ = Symbol('allowStale'),
  PZ = Symbol('maxAge'),
  RZ = Symbol('dispose'),
  LZ = Symbol('noDisposeOnSet'),
  qZ = Symbol('lruList'),
  IZ = Symbol('cache'),
  UZ = Symbol('updateAgeOnGet'),
  WZ = () => 1,
  HZ = (t, n, e) => {
    var r = t[IZ].get(n);
    if (r) {
      var i = r.value;
      if (GZ(t, i)) {
        if ((YZ(t, r), !t[TZ])) return;
      } else e && (t[UZ] && (r.value.now = Date.now()), t[qZ].unshiftNode(r));
      return i.value;
    }
  },
  GZ = (t, n) => {
    if (!n || (!n.maxAge && !t[PZ])) return !1;
    var e = Date.now() - n.now;
    return n.maxAge ? e > n.maxAge : t[PZ] && e > t[PZ];
  },
  VZ = t => {
    if (t[_Z] > t[BZ])
      for (var n = t[qZ].tail; t[_Z] > t[BZ] && null !== n; ) {
        var e = n.prev;
        YZ(t, n), (n = e);
      }
  },
  YZ = (t, n) => {
    if (n) {
      var e = n.value;
      t[RZ] && t[RZ](e.key, e.value), (t[_Z] -= e.length), t[IZ].delete(e.key), t[qZ].removeNode(n);
    }
  };
class XZ {
  constructor(t, n, e, r, i) {
    (this.key = t), (this.value = n), (this.length = e), (this.now = r), (this.maxAge = i || 0);
  }
}
var JZ = (t, n, e, r) => {
    var i = e.value;
    GZ(t, i) && (YZ(t, e), t[TZ] || (i = void 0)), i && n.call(r, i.value, i.key, t);
  },
  QZ = ['includePrerelease', 'loose', 'rtl'],
  ZZ = t =>
    t ? ('object' != typeof t ? { loose: !0 } : QZ.filter(n => t[n]).reduce((t, n) => ((t[n] = !0), t), {})) : {},
  KZ = {},
  tK = {
    get exports() {
      return KZ;
    },
    set exports(t) {
      KZ = t;
    },
  },
  nK = {
    SEMVER_SPEC_VERSION: '2.0.0',
    MAX_LENGTH: 256,
    MAX_SAFE_INTEGER: Number.MAX_SAFE_INTEGER || 9007199254740991,
    MAX_SAFE_COMPONENT_LENGTH: 16,
  },
  eK =
    'object' == typeof process && process.env && process.env.NODE_DEBUG && /\bsemver\b/i.test(process.env.NODE_DEBUG)
      ? function () {
          for (var t = arguments.length, n = new Array(t), e = 0; e < t; e++) n[e] = arguments[e];
          return console.error('SEMVER', ...n);
        }
      : () => {};
!(function (t, n) {
  var e = nK.MAX_SAFE_COMPONENT_LENGTH,
    r = eK,
    i = ((n = tK.exports = {}).re = []),
    o = (n.src = []),
    u = (n.t = {}),
    s = 0,
    a = (t, n, e) => {
      var a = s++;
      r(t, a, n), (u[t] = a), (o[a] = n), (i[a] = new RegExp(n, e ? 'g' : void 0));
    };
  a('NUMERICIDENTIFIER', '0|[1-9]\\d*'),
    a('NUMERICIDENTIFIERLOOSE', '[0-9]+'),
    a('NONNUMERICIDENTIFIER', '\\d*[a-zA-Z-][a-zA-Z0-9-]*'),
    a(
      'MAINVERSION',
      '('.concat(o[u.NUMERICIDENTIFIER], ')\\.') +
        '('.concat(o[u.NUMERICIDENTIFIER], ')\\.') +
        '('.concat(o[u.NUMERICIDENTIFIER], ')'),
    ),
    a(
      'MAINVERSIONLOOSE',
      '('.concat(o[u.NUMERICIDENTIFIERLOOSE], ')\\.') +
        '('.concat(o[u.NUMERICIDENTIFIERLOOSE], ')\\.') +
        '('.concat(o[u.NUMERICIDENTIFIERLOOSE], ')'),
    ),
    a('PRERELEASEIDENTIFIER', '(?:'.concat(o[u.NUMERICIDENTIFIER], '|').concat(o[u.NONNUMERICIDENTIFIER], ')')),
    a(
      'PRERELEASEIDENTIFIERLOOSE',
      '(?:'.concat(o[u.NUMERICIDENTIFIERLOOSE], '|').concat(o[u.NONNUMERICIDENTIFIER], ')'),
    ),
    a('PRERELEASE', '(?:-('.concat(o[u.PRERELEASEIDENTIFIER], '(?:\\.').concat(o[u.PRERELEASEIDENTIFIER], ')*))')),
    a(
      'PRERELEASELOOSE',
      '(?:-?('.concat(o[u.PRERELEASEIDENTIFIERLOOSE], '(?:\\.').concat(o[u.PRERELEASEIDENTIFIERLOOSE], ')*))'),
    ),
    a('BUILDIDENTIFIER', '[0-9A-Za-z-]+'),
    a('BUILD', '(?:\\+('.concat(o[u.BUILDIDENTIFIER], '(?:\\.').concat(o[u.BUILDIDENTIFIER], ')*))')),
    a('FULLPLAIN', 'v?'.concat(o[u.MAINVERSION]).concat(o[u.PRERELEASE], '?').concat(o[u.BUILD], '?')),
    a('FULL', '^'.concat(o[u.FULLPLAIN], '$')),
    a('LOOSEPLAIN', '[v=\\s]*'.concat(o[u.MAINVERSIONLOOSE]).concat(o[u.PRERELEASELOOSE], '?').concat(o[u.BUILD], '?')),
    a('LOOSE', '^'.concat(o[u.LOOSEPLAIN], '$')),
    a('GTLT', '((?:<|>)?=?)'),
    a('XRANGEIDENTIFIERLOOSE', ''.concat(o[u.NUMERICIDENTIFIERLOOSE], '|x|X|\\*')),
    a('XRANGEIDENTIFIER', ''.concat(o[u.NUMERICIDENTIFIER], '|x|X|\\*')),
    a(
      'XRANGEPLAIN',
      '[v=\\s]*('.concat(o[u.XRANGEIDENTIFIER], ')') +
        '(?:\\.('.concat(o[u.XRANGEIDENTIFIER], ')') +
        '(?:\\.('.concat(o[u.XRANGEIDENTIFIER], ')') +
        '(?:'.concat(o[u.PRERELEASE], ')?').concat(o[u.BUILD], '?') +
        ')?)?',
    ),
    a(
      'XRANGEPLAINLOOSE',
      '[v=\\s]*('.concat(o[u.XRANGEIDENTIFIERLOOSE], ')') +
        '(?:\\.('.concat(o[u.XRANGEIDENTIFIERLOOSE], ')') +
        '(?:\\.('.concat(o[u.XRANGEIDENTIFIERLOOSE], ')') +
        '(?:'.concat(o[u.PRERELEASELOOSE], ')?').concat(o[u.BUILD], '?') +
        ')?)?',
    ),
    a('XRANGE', '^'.concat(o[u.GTLT], '\\s*').concat(o[u.XRANGEPLAIN], '$')),
    a('XRANGELOOSE', '^'.concat(o[u.GTLT], '\\s*').concat(o[u.XRANGEPLAINLOOSE], '$')),
    a(
      'COERCE',
      ''.concat('(^|[^\\d])(\\d{1,').concat(e, '})') +
        '(?:\\.(\\d{1,'.concat(e, '}))?') +
        '(?:\\.(\\d{1,'.concat(e, '}))?') +
        '(?:$|[^\\d])',
    ),
    a('COERCERTL', o[u.COERCE], !0),
    a('LONETILDE', '(?:~>?)'),
    a('TILDETRIM', '(\\s*)'.concat(o[u.LONETILDE], '\\s+'), !0),
    (n.tildeTrimReplace = '$1~'),
    a('TILDE', '^'.concat(o[u.LONETILDE]).concat(o[u.XRANGEPLAIN], '$')),
    a('TILDELOOSE', '^'.concat(o[u.LONETILDE]).concat(o[u.XRANGEPLAINLOOSE], '$')),
    a('LONECARET', '(?:\\^)'),
    a('CARETTRIM', '(\\s*)'.concat(o[u.LONECARET], '\\s+'), !0),
    (n.caretTrimReplace = '$1^'),
    a('CARET', '^'.concat(o[u.LONECARET]).concat(o[u.XRANGEPLAIN], '$')),
    a('CARETLOOSE', '^'.concat(o[u.LONECARET]).concat(o[u.XRANGEPLAINLOOSE], '$')),
    a('COMPARATORLOOSE', '^'.concat(o[u.GTLT], '\\s*(').concat(o[u.LOOSEPLAIN], ')$|^$')),
    a('COMPARATOR', '^'.concat(o[u.GTLT], '\\s*(').concat(o[u.FULLPLAIN], ')$|^$')),
    a(
      'COMPARATORTRIM',
      '(\\s*)'.concat(o[u.GTLT], '\\s*(').concat(o[u.LOOSEPLAIN], '|').concat(o[u.XRANGEPLAIN], ')'),
      !0,
    ),
    (n.comparatorTrimReplace = '$1$2$3'),
    a(
      'HYPHENRANGE',
      '^\\s*('.concat(o[u.XRANGEPLAIN], ')') + '\\s+-\\s+' + '('.concat(o[u.XRANGEPLAIN], ')') + '\\s*$',
    ),
    a(
      'HYPHENRANGELOOSE',
      '^\\s*('.concat(o[u.XRANGEPLAINLOOSE], ')') + '\\s+-\\s+' + '('.concat(o[u.XRANGEPLAINLOOSE], ')') + '\\s*$',
    ),
    a('STAR', '(<|>)?=?\\s*\\*'),
    a('GTE0', '^\\s*>=\\s*0\\.0\\.0\\s*$'),
    a('GTE0PRE', '^\\s*>=\\s*0\\.0\\.0-0\\s*$');
})(0, KZ);
var rK,
  iK,
  oK,
  uK,
  sK = /^[0-9]+$/,
  aK = eK,
  cK = nK.MAX_LENGTH,
  lK = nK.MAX_SAFE_INTEGER,
  fK = KZ.re,
  hK = KZ.t,
  dK = ZZ,
  pK = (t, n) => {
    var e = sK.test(t),
      r = sK.test(n);
    return e && r && ((t = +t), (n = +n)), t === n ? 0 : e && !r ? -1 : r && !e ? 1 : t < n ? -1 : 1;
  },
  mK = class t {
    constructor(n, e) {
      if (((e = dK(e)), n instanceof t)) {
        if (n.loose === !!e.loose && n.includePrerelease === !!e.includePrerelease) return n;
        n = n.version;
      } else if ('string' != typeof n) throw new TypeError('Invalid Version: '.concat(n));
      if (n.length > cK) throw new TypeError('version is longer than '.concat(cK, ' characters'));
      aK('SemVer', n, e),
        (this.options = e),
        (this.loose = !!e.loose),
        (this.includePrerelease = !!e.includePrerelease);
      var r = n.trim().match(e.loose ? fK[hK.LOOSE] : fK[hK.FULL]);
      if (!r) throw new TypeError('Invalid Version: '.concat(n));
      if (
        ((this.raw = n),
        (this.major = +r[1]),
        (this.minor = +r[2]),
        (this.patch = +r[3]),
        this.major > lK || this.major < 0)
      )
        throw new TypeError('Invalid major version');
      if (this.minor > lK || this.minor < 0) throw new TypeError('Invalid minor version');
      if (this.patch > lK || this.patch < 0) throw new TypeError('Invalid patch version');
      (this.prerelease = r[4]
        ? r[4].split('.').map(t => {
            if (/^[0-9]+$/.test(t)) {
              var n = +t;
              if (n >= 0 && n < lK) return n;
            }
            return t;
          })
        : []),
        (this.build = r[5] ? r[5].split('.') : []),
        this.format();
    }
    format() {
      return (
        (this.version = ''.concat(this.major, '.').concat(this.minor, '.').concat(this.patch)),
        this.prerelease.length && (this.version += '-'.concat(this.prerelease.join('.'))),
        this.version
      );
    }
    toString() {
      return this.version;
    }
    compare(n) {
      if ((aK('SemVer.compare', this.version, this.options, n), !(n instanceof t))) {
        if ('string' == typeof n && n === this.version) return 0;
        n = new t(n, this.options);
      }
      return n.version === this.version ? 0 : this.compareMain(n) || this.comparePre(n);
    }
    compareMain(n) {
      return (
        n instanceof t || (n = new t(n, this.options)),
        pK(this.major, n.major) || pK(this.minor, n.minor) || pK(this.patch, n.patch)
      );
    }
    comparePre(n) {
      if ((n instanceof t || (n = new t(n, this.options)), this.prerelease.length && !n.prerelease.length)) return -1;
      if (!this.prerelease.length && n.prerelease.length) return 1;
      if (!this.prerelease.length && !n.prerelease.length) return 0;
      var e = 0;
      do {
        var r = this.prerelease[e],
          i = n.prerelease[e];
        if ((aK('prerelease compare', e, r, i), void 0 === r && void 0 === i)) return 0;
        if (void 0 === i) return 1;
        if (void 0 === r) return -1;
        if (r !== i) return pK(r, i);
      } while (++e);
    }
    compareBuild(n) {
      n instanceof t || (n = new t(n, this.options));
      var e = 0;
      do {
        var r = this.build[e],
          i = n.build[e];
        if ((aK('prerelease compare', e, r, i), void 0 === r && void 0 === i)) return 0;
        if (void 0 === i) return 1;
        if (void 0 === r) return -1;
        if (r !== i) return pK(r, i);
      } while (++e);
    }
    inc(t, n) {
      switch (t) {
        case 'premajor':
          (this.prerelease.length = 0), (this.patch = 0), (this.minor = 0), this.major++, this.inc('pre', n);
          break;
        case 'preminor':
          (this.prerelease.length = 0), (this.patch = 0), this.minor++, this.inc('pre', n);
          break;
        case 'prepatch':
          (this.prerelease.length = 0), this.inc('patch', n), this.inc('pre', n);
          break;
        case 'prerelease':
          0 === this.prerelease.length && this.inc('patch', n), this.inc('pre', n);
          break;
        case 'major':
          (0 === this.minor && 0 === this.patch && 0 !== this.prerelease.length) || this.major++,
            (this.minor = 0),
            (this.patch = 0),
            (this.prerelease = []);
          break;
        case 'minor':
          (0 === this.patch && 0 !== this.prerelease.length) || this.minor++, (this.patch = 0), (this.prerelease = []);
          break;
        case 'patch':
          0 === this.prerelease.length && this.patch++, (this.prerelease = []);
          break;
        case 'pre':
          if (0 === this.prerelease.length) this.prerelease = [0];
          else {
            for (var e = this.prerelease.length; --e >= 0; )
              'number' == typeof this.prerelease[e] && (this.prerelease[e]++, (e = -2));
            -1 === e && this.prerelease.push(0);
          }
          n &&
            (0 === pK(this.prerelease[0], n)
              ? isNaN(this.prerelease[1]) && (this.prerelease = [n, 0])
              : (this.prerelease = [n, 0]));
          break;
        default:
          throw new Error('invalid increment argument: '.concat(t));
      }
      return this.format(), (this.raw = this.version), this;
    }
  },
  vK = mK,
  gK = (t, n, e) => new vK(t, e).compare(new vK(n, e)),
  bK = gK,
  yK = gK,
  wK = gK,
  xK = gK,
  OK = gK,
  kK = gK,
  AK = (t, n, e) => 0 === bK(t, n, e),
  $K = (t, n, e) => 0 !== yK(t, n, e),
  MK = (t, n, e) => wK(t, n, e) > 0,
  jK = (t, n, e) => xK(t, n, e) >= 0,
  DK = (t, n, e) => OK(t, n, e) < 0,
  FK = (t, n, e) => kK(t, n, e) <= 0,
  EK = (t, n, e, r) => {
    switch (n) {
      case '===':
        return 'object' == typeof t && (t = t.version), 'object' == typeof e && (e = e.version), t === e;
      case '!==':
        return 'object' == typeof t && (t = t.version), 'object' == typeof e && (e = e.version), t !== e;
      case '':
      case '=':
      case '==':
        return AK(t, e, r);
      case '!=':
        return $K(t, e, r);
      case '>':
        return MK(t, e, r);
      case '>=':
        return jK(t, e, r);
      case '<':
        return DK(t, e, r);
      case '<=':
        return FK(t, e, r);
      default:
        throw new TypeError('Invalid operator: '.concat(n));
    }
  };
function SK(t, n) {
  var e = ('undefined' != typeof Symbol && t[Symbol.iterator]) || t['@@iterator'];
  if (!e) {
    if (
      Array.isArray(t) ||
      (e = (function (t, n) {
        if (t) {
          if ('string' == typeof t) return CK(t, n);
          var e = Object.prototype.toString.call(t).slice(8, -1);
          return (
            'Object' === e && t.constructor && (e = t.constructor.name),
            'Map' === e || 'Set' === e
              ? Array.from(t)
              : 'Arguments' === e || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(e)
              ? CK(t, n)
              : void 0
          );
        }
      })(t)) ||
      (n && t && 'number' == typeof t.length)
    ) {
      e && (t = e);
      var r = 0,
        i = function () {};
      return {
        s: i,
        n: function () {
          return r >= t.length ? { done: !0 } : { done: !1, value: t[r++] };
        },
        e: function (t) {
          throw t;
        },
        f: i,
      };
    }
    throw new TypeError(
      'Invalid attempt to iterate non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.',
    );
  }
  var o,
    u = !0,
    s = !1;
  return {
    s: function () {
      e = e.call(t);
    },
    n: function () {
      var t = e.next();
      return (u = t.done), t;
    },
    e: function (t) {
      (s = !0), (o = t);
    },
    f: function () {
      try {
        u || null == e.return || e.return();
      } finally {
        if (s) throw o;
      }
    },
  };
}
function CK(t, n) {
  (null == n || n > t.length) && (n = t.length);
  for (var e = 0, r = new Array(n); e < n; e++) r[e] = t[e];
  return r;
}
var NK = (function t() {
    if (uK) return oK;
    uK = 1;
    class n {
      constructor(t, e) {
        if (((e = r(e)), t instanceof n))
          return t.loose === !!e.loose && t.includePrerelease === !!e.includePrerelease ? t : new n(t.raw, e);
        if (t instanceof i) return (this.raw = t.value), (this.set = [[t]]), this.format(), this;
        if (
          ((this.options = e),
          (this.loose = !!e.loose),
          (this.includePrerelease = !!e.includePrerelease),
          (this.raw = t),
          (this.set = t
            .split('||')
            .map(t => this.parseRange(t.trim()))
            .filter(t => t.length)),
          !this.set.length)
        )
          throw new TypeError('Invalid SemVer Range: '.concat(t));
        if (this.set.length > 1) {
          var o = this.set[0];
          if (((this.set = this.set.filter(t => !h(t[0]))), 0 === this.set.length)) this.set = [o];
          else if (this.set.length > 1) {
            var u,
              s = SK(this.set);
            try {
              for (s.s(); !(u = s.n()).done; ) {
                var a = u.value;
                if (1 === a.length && d(a[0])) {
                  this.set = [a];
                  break;
                }
              }
            } catch (t) {
              s.e(t);
            } finally {
              s.f();
            }
          }
        }
        this.format();
      }
      format() {
        return (
          (this.range = this.set
            .map(t => t.join(' ').trim())
            .join('||')
            .trim()),
          this.range
        );
      }
      toString() {
        return this.range;
      }
      parseRange(t) {
        t = t.trim();
        var n = Object.keys(this.options).join(','),
          r = 'parseRange:'.concat(n, ':').concat(t),
          u = e.get(r);
        if (u) return u;
        var d = this.options.loose;
        (t = t.replace(d ? s[a.HYPHENRANGELOOSE] : s[a.HYPHENRANGE], $(this.options.includePrerelease))),
          o('hyphen replace', t),
          (t = t.replace(s[a.COMPARATORTRIM], c)),
          o('comparator trim', t);
        var p = (t = (t = (t = t.replace(s[a.TILDETRIM], l)).replace(s[a.CARETTRIM], f)).split(/\s+/).join(' '))
          .split(' ')
          .map(t => m(t, this.options))
          .join(' ')
          .split(/\s+/)
          .map(t => A(t, this.options));
        d && (p = p.filter(t => (o('loose invalid filter', t, this.options), !!t.match(s[a.COMPARATORLOOSE])))),
          o('range list', p);
        var v,
          g = new Map(),
          b = p.map(t => new i(t, this.options)),
          y = SK(b);
        try {
          for (y.s(); !(v = y.n()).done; ) {
            var w = v.value;
            if (h(w)) return [w];
            g.set(w.value, w);
          }
        } catch (t) {
          y.e(t);
        } finally {
          y.f();
        }
        g.size > 1 && g.has('') && g.delete('');
        var x = [...g.values()];
        return e.set(r, x), x;
      }
      intersects(t, e) {
        if (!(t instanceof n)) throw new TypeError('a Range is required');
        return this.set.some(
          n => p(n, e) && t.set.some(t => p(t, e) && n.every(n => t.every(t => n.intersects(t, e)))),
        );
      }
      test(t) {
        if (!t) return !1;
        if ('string' == typeof t)
          try {
            t = new u(t, this.options);
          } catch (t) {
            return !1;
          }
        for (var n = 0; n < this.set.length; n++) if (M(this.set[n], t, this.options)) return !0;
        return !1;
      }
    }
    oK = n;
    var e = new (class {
        constructor(t) {
          if (
            ('number' == typeof t && (t = { max: t }), t || (t = {}), t.max && ('number' != typeof t.max || t.max < 0))
          )
            throw new TypeError('max must be a non-negative number');
          this[BZ] = t.max || 1 / 0;
          var n = t.length || WZ;
          if (
            ((this[zZ] = 'function' != typeof n ? WZ : n),
            (this[TZ] = t.stale || !1),
            t.maxAge && 'number' != typeof t.maxAge)
          )
            throw new TypeError('maxAge must be a number');
          (this[PZ] = t.maxAge || 0),
            (this[RZ] = t.dispose),
            (this[LZ] = t.noDisposeOnSet || !1),
            (this[UZ] = t.updateAgeOnGet || !1),
            this.reset();
        }
        set max(t) {
          if ('number' != typeof t || t < 0) throw new TypeError('max must be a non-negative number');
          (this[BZ] = t || 1 / 0), VZ(this);
        }
        get max() {
          return this[BZ];
        }
        set allowStale(t) {
          this[TZ] = !!t;
        }
        get allowStale() {
          return this[TZ];
        }
        set maxAge(t) {
          if ('number' != typeof t) throw new TypeError('maxAge must be a non-negative number');
          (this[PZ] = t), VZ(this);
        }
        get maxAge() {
          return this[PZ];
        }
        set lengthCalculator(t) {
          'function' != typeof t && (t = WZ),
            t !== this[zZ] &&
              ((this[zZ] = t),
              (this[_Z] = 0),
              this[qZ].forEach(t => {
                (t.length = this[zZ](t.value, t.key)), (this[_Z] += t.length);
              })),
            VZ(this);
        }
        get lengthCalculator() {
          return this[zZ];
        }
        get length() {
          return this[_Z];
        }
        get itemCount() {
          return this[qZ].length;
        }
        rforEach(t, n) {
          n = n || this;
          for (var e = this[qZ].tail; null !== e; ) {
            var r = e.prev;
            JZ(this, t, e, n), (e = r);
          }
        }
        forEach(t, n) {
          n = n || this;
          for (var e = this[qZ].head; null !== e; ) {
            var r = e.next;
            JZ(this, t, e, n), (e = r);
          }
        }
        keys() {
          return this[qZ].toArray().map(t => t.key);
        }
        values() {
          return this[qZ].toArray().map(t => t.value);
        }
        reset() {
          this[RZ] && this[qZ] && this[qZ].length && this[qZ].forEach(t => this[RZ](t.key, t.value)),
            (this[IZ] = new Map()),
            (this[qZ] = new NZ()),
            (this[_Z] = 0);
        }
        dump() {
          return this[qZ]
            .map(t => !GZ(this, t) && { k: t.key, v: t.value, e: t.now + (t.maxAge || 0) })
            .toArray()
            .filter(t => t);
        }
        dumpLru() {
          return this[qZ];
        }
        set(t, n, e) {
          if ((e = e || this[PZ]) && 'number' != typeof e) throw new TypeError('maxAge must be a number');
          var r = e ? Date.now() : 0,
            i = this[zZ](n, t);
          if (this[IZ].has(t)) {
            if (i > this[BZ]) return YZ(this, this[IZ].get(t)), !1;
            var o = this[IZ].get(t).value;
            return (
              this[RZ] && (this[LZ] || this[RZ](t, o.value)),
              (o.now = r),
              (o.maxAge = e),
              (o.value = n),
              (this[_Z] += i - o.length),
              (o.length = i),
              this.get(t),
              VZ(this),
              !0
            );
          }
          var u = new XZ(t, n, i, r, e);
          return u.length > this[BZ]
            ? (this[RZ] && this[RZ](t, n), !1)
            : ((this[_Z] += u.length), this[qZ].unshift(u), this[IZ].set(t, this[qZ].head), VZ(this), !0);
        }
        has(t) {
          if (!this[IZ].has(t)) return !1;
          var n = this[IZ].get(t).value;
          return !GZ(this, n);
        }
        get(t) {
          return HZ(this, t, !0);
        }
        peek(t) {
          return HZ(this, t, !1);
        }
        pop() {
          var t = this[qZ].tail;
          return t ? (YZ(this, t), t.value) : null;
        }
        del(t) {
          YZ(this, this[IZ].get(t));
        }
        load(t) {
          this.reset();
          for (var n = Date.now(), e = t.length - 1; e >= 0; e--) {
            var r = t[e],
              i = r.e || 0;
            if (0 === i) this.set(r.k, r.v);
            else {
              var o = i - n;
              o > 0 && this.set(r.k, r.v, o);
            }
          }
        }
        prune() {
          this[IZ].forEach((t, n) => HZ(this, n, !1));
        }
      })({ max: 1e3 }),
      r = ZZ,
      i = (function () {
        if (iK) return rK;
        iK = 1;
        var n = Symbol('SemVer ANY');
        class e {
          static get ANY() {
            return n;
          }
          constructor(t, i) {
            if (((i = r(i)), t instanceof e)) {
              if (t.loose === !!i.loose) return t;
              t = t.value;
            }
            s('comparator', t, i),
              (this.options = i),
              (this.loose = !!i.loose),
              this.parse(t),
              (this.value = this.semver === n ? '' : this.operator + this.semver.version),
              s('comp', this);
          }
          parse(t) {
            var e = t.match(this.options.loose ? i[o.COMPARATORLOOSE] : i[o.COMPARATOR]);
            if (!e) throw new TypeError('Invalid comparator: '.concat(t));
            (this.operator = void 0 !== e[1] ? e[1] : ''),
              '=' === this.operator && (this.operator = ''),
              (this.semver = e[2] ? new a(e[2], this.options.loose) : n);
          }
          toString() {
            return this.value;
          }
          test(t) {
            if ((s('Comparator.test', t, this.options.loose), this.semver === n || t === n)) return !0;
            if ('string' == typeof t)
              try {
                t = new a(t, this.options);
              } catch (t) {
                return !1;
              }
            return u(t, this.operator, this.semver, this.options);
          }
          intersects(t, n) {
            if (!(t instanceof e)) throw new TypeError('a Comparator is required');
            if (((n && 'object' == typeof n) || (n = { loose: !!n, includePrerelease: !1 }), '' === this.operator))
              return '' === this.value || new c(t.value, n).test(this.value);
            if ('' === t.operator) return '' === t.value || new c(this.value, n).test(t.semver);
            var r = !(('>=' !== this.operator && '>' !== this.operator) || ('>=' !== t.operator && '>' !== t.operator)),
              i = !(('<=' !== this.operator && '<' !== this.operator) || ('<=' !== t.operator && '<' !== t.operator)),
              o = this.semver.version === t.semver.version,
              s = !(('>=' !== this.operator && '<=' !== this.operator) || ('>=' !== t.operator && '<=' !== t.operator)),
              a =
                u(this.semver, '<', t.semver, n) &&
                ('>=' === this.operator || '>' === this.operator) &&
                ('<=' === t.operator || '<' === t.operator),
              l =
                u(this.semver, '>', t.semver, n) &&
                ('<=' === this.operator || '<' === this.operator) &&
                ('>=' === t.operator || '>' === t.operator);
            return r || i || (o && s) || a || l;
          }
        }
        rK = e;
        var r = ZZ,
          i = KZ.re,
          o = KZ.t,
          u = EK,
          s = eK,
          a = mK,
          c = t();
        return rK;
      })(),
      o = eK,
      u = mK,
      s = KZ.re,
      a = KZ.t,
      c = KZ.comparatorTrimReplace,
      l = KZ.tildeTrimReplace,
      f = KZ.caretTrimReplace,
      h = t => '<0.0.0-0' === t.value,
      d = t => '' === t.value,
      p = (t, n) => {
        for (var e = !0, r = t.slice(), i = r.pop(); e && r.length; )
          (e = r.every(t => i.intersects(t, n))), (i = r.pop());
        return e;
      },
      m = (t, n) => (
        o('comp', t, n),
        (t = y(t, n)),
        o('caret', t),
        (t = g(t, n)),
        o('tildes', t),
        (t = x(t, n)),
        o('xrange', t),
        (t = k(t, n)),
        o('stars', t),
        t
      ),
      v = t => !t || 'x' === t.toLowerCase() || '*' === t,
      g = (t, n) =>
        t
          .trim()
          .split(/\s+/)
          .map(t => b(t, n))
          .join(' '),
      b = (t, n) =>
        t.replace(n.loose ? s[a.TILDELOOSE] : s[a.TILDE], (n, e, r, i, u) => {
          var s;
          return (
            o('tilde', t, n, e, r, i, u),
            v(e)
              ? (s = '')
              : v(r)
              ? (s = '>='.concat(e, '.0.0 <').concat(+e + 1, '.0.0-0'))
              : v(i)
              ? (s = '>='
                  .concat(e, '.')
                  .concat(r, '.0 <')
                  .concat(e, '.')
                  .concat(+r + 1, '.0-0'))
              : u
              ? (o('replaceTilde pr', u),
                (s = '>='
                  .concat(e, '.')
                  .concat(r, '.')
                  .concat(i, '-')
                  .concat(u, ' <')
                  .concat(e, '.')
                  .concat(+r + 1, '.0-0')))
              : (s = '>='
                  .concat(e, '.')
                  .concat(r, '.')
                  .concat(i, ' <')
                  .concat(e, '.')
                  .concat(+r + 1, '.0-0')),
            o('tilde return', s),
            s
          );
        }),
      y = (t, n) =>
        t
          .trim()
          .split(/\s+/)
          .map(t => w(t, n))
          .join(' '),
      w = (t, n) => {
        o('caret', t, n);
        var e = n.includePrerelease ? '-0' : '';
        return t.replace(n.loose ? s[a.CARETLOOSE] : s[a.CARET], (n, r, i, u, s) => {
          var a;
          return (
            o('caret', t, n, r, i, u, s),
            v(r)
              ? (a = '')
              : v(i)
              ? (a = '>='
                  .concat(r, '.0.0')
                  .concat(e, ' <')
                  .concat(+r + 1, '.0.0-0'))
              : v(u)
              ? (a =
                  '0' === r
                    ? '>='
                        .concat(r, '.')
                        .concat(i, '.0')
                        .concat(e, ' <')
                        .concat(r, '.')
                        .concat(+i + 1, '.0-0')
                    : '>='
                        .concat(r, '.')
                        .concat(i, '.0')
                        .concat(e, ' <')
                        .concat(+r + 1, '.0.0-0'))
              : s
              ? (o('replaceCaret pr', s),
                (a =
                  '0' === r
                    ? '0' === i
                      ? '>='
                          .concat(r, '.')
                          .concat(i, '.')
                          .concat(u, '-')
                          .concat(s, ' <')
                          .concat(r, '.')
                          .concat(i, '.')
                          .concat(+u + 1, '-0')
                      : '>='
                          .concat(r, '.')
                          .concat(i, '.')
                          .concat(u, '-')
                          .concat(s, ' <')
                          .concat(r, '.')
                          .concat(+i + 1, '.0-0')
                    : '>='
                        .concat(r, '.')
                        .concat(i, '.')
                        .concat(u, '-')
                        .concat(s, ' <')
                        .concat(+r + 1, '.0.0-0')))
              : (o('no pr'),
                (a =
                  '0' === r
                    ? '0' === i
                      ? '>='
                          .concat(r, '.')
                          .concat(i, '.')
                          .concat(u)
                          .concat(e, ' <')
                          .concat(r, '.')
                          .concat(i, '.')
                          .concat(+u + 1, '-0')
                      : '>='
                          .concat(r, '.')
                          .concat(i, '.')
                          .concat(u)
                          .concat(e, ' <')
                          .concat(r, '.')
                          .concat(+i + 1, '.0-0')
                    : '>='
                        .concat(r, '.')
                        .concat(i, '.')
                        .concat(u, ' <')
                        .concat(+r + 1, '.0.0-0'))),
            o('caret return', a),
            a
          );
        });
      },
      x = (t, n) => (
        o('replaceXRanges', t, n),
        t
          .split(/\s+/)
          .map(t => O(t, n))
          .join(' ')
      ),
      O = (t, n) =>
        (t = t.trim()).replace(n.loose ? s[a.XRANGELOOSE] : s[a.XRANGE], (e, r, i, u, s, a) => {
          o('xRange', t, e, r, i, u, s, a);
          var c = v(i),
            l = c || v(u),
            f = l || v(s);
          return (
            '=' === r && f && (r = ''),
            (a = n.includePrerelease ? '-0' : ''),
            c
              ? (e = '>' === r || '<' === r ? '<0.0.0-0' : '*')
              : r && f
              ? (l && (u = 0),
                (s = 0),
                '>' === r
                  ? ((r = '>='), l ? ((i = +i + 1), (u = 0), (s = 0)) : ((u = +u + 1), (s = 0)))
                  : '<=' === r && ((r = '<'), l ? (i = +i + 1) : (u = +u + 1)),
                '<' === r && (a = '-0'),
                (e = ''
                  .concat(r + i, '.')
                  .concat(u, '.')
                  .concat(s)
                  .concat(a)))
              : l
              ? (e = '>='
                  .concat(i, '.0.0')
                  .concat(a, ' <')
                  .concat(+i + 1, '.0.0-0'))
              : f &&
                (e = '>='
                  .concat(i, '.')
                  .concat(u, '.0')
                  .concat(a, ' <')
                  .concat(i, '.')
                  .concat(+u + 1, '.0-0')),
            o('xRange return', e),
            e
          );
        }),
      k = (t, n) => (o('replaceStars', t, n), t.trim().replace(s[a.STAR], '')),
      A = (t, n) => (o('replaceGTE0', t, n), t.trim().replace(s[n.includePrerelease ? a.GTE0PRE : a.GTE0], '')),
      $ = t => (n, e, r, i, o, u, s, a, c, l, f, h) => (
        (e = v(r)
          ? ''
          : v(i)
          ? '>='.concat(r, '.0.0').concat(t ? '-0' : '')
          : v(o)
          ? '>='
              .concat(r, '.')
              .concat(i, '.0')
              .concat(t ? '-0' : '')
          : u
          ? '>='.concat(e)
          : '>='.concat(e).concat(t ? '-0' : '')),
        (a = v(c)
          ? ''
          : v(l)
          ? '<'.concat(+c + 1, '.0.0-0')
          : v(f)
          ? '<'.concat(c, '.').concat(+l + 1, '.0-0')
          : h
          ? '<='.concat(c, '.').concat(l, '.').concat(f, '-').concat(h)
          : t
          ? '<'
              .concat(c, '.')
              .concat(l, '.')
              .concat(+f + 1, '-0')
          : '<='.concat(a)),
        ''.concat(e, ' ').concat(a).trim()
      ),
      M = (t, n, e) => {
        for (var r = 0; r < t.length; r++) if (!t[r].test(n)) return !1;
        if (n.prerelease.length && !e.includePrerelease) {
          for (var u = 0; u < t.length; u++)
            if ((o(t[u].semver), t[u].semver !== i.ANY && t[u].semver.prerelease.length > 0)) {
              var s = t[u].semver;
              if (s.major === n.major && s.minor === n.minor && s.patch === n.patch) return !0;
            }
          return !1;
        }
        return !0;
      };
    return oK;
  })(),
  BK = (t, n, e) => {
    try {
      n = new NK(n, e);
    } catch (t) {
      return !1;
    }
    return n.test(t);
  };
function _K(t, n, e) {
  var r = t.open(n),
    i = new URL(n).origin,
    o = 40;
  t.addEventListener(
    'message',
    function n(e) {
      e.source === r && ((o = 0), t.removeEventListener('message', n, !1));
    },
    !1,
  ),
    setTimeout(function t() {
      o <= 0 || (r.postMessage(e, i), setTimeout(t, 250), (o -= 1));
    }, 250);
}
var zK,
  TK =
    '.vega-embed {\n  position: relative;\n  display: inline-block;\n  box-sizing: border-box;\n}\n.vega-embed.has-actions {\n  padding-right: 38px;\n}\n.vega-embed details:not([open]) > :not(summary) {\n  display: none !important;\n}\n.vega-embed summary {\n  list-style: none;\n  position: absolute;\n  top: 0;\n  right: 0;\n  padding: 6px;\n  z-index: 1000;\n  background: white;\n  box-shadow: 1px 1px 3px rgba(0, 0, 0, 0.1);\n  color: #1b1e23;\n  border: 1px solid #aaa;\n  border-radius: 999px;\n  opacity: 0.2;\n  transition: opacity 0.4s ease-in;\n  cursor: pointer;\n  line-height: 0px;\n}\n.vega-embed summary::-webkit-details-marker {\n  display: none;\n}\n.vega-embed summary:active {\n  box-shadow: #aaa 0px 0px 0px 1px inset;\n}\n.vega-embed summary svg {\n  width: 14px;\n  height: 14px;\n}\n.vega-embed details[open] summary {\n  opacity: 0.7;\n}\n.vega-embed:hover summary, .vega-embed:focus-within summary {\n  opacity: 1 !important;\n  transition: opacity 0.2s ease;\n}\n.vega-embed .vega-actions {\n  position: absolute;\n  z-index: 1001;\n  top: 35px;\n  right: -9px;\n  display: flex;\n  flex-direction: column;\n  padding-bottom: 8px;\n  padding-top: 8px;\n  border-radius: 4px;\n  box-shadow: 0 2px 8px 0 rgba(0, 0, 0, 0.2);\n  border: 1px solid #d9d9d9;\n  background: white;\n  animation-duration: 0.15s;\n  animation-name: scale-in;\n  animation-timing-function: cubic-bezier(0.2, 0, 0.13, 1.5);\n  text-align: left;\n}\n.vega-embed .vega-actions a {\n  padding: 8px 16px;\n  font-family: sans-serif;\n  font-size: 14px;\n  font-weight: 600;\n  white-space: nowrap;\n  color: #434a56;\n  text-decoration: none;\n}\n.vega-embed .vega-actions a:hover, .vega-embed .vega-actions a:focus {\n  background-color: #f7f7f9;\n  color: black;\n}\n.vega-embed .vega-actions::before, .vega-embed .vega-actions::after {\n  content: "";\n  display: inline-block;\n  position: absolute;\n}\n.vega-embed .vega-actions::before {\n  left: auto;\n  right: 14px;\n  top: -16px;\n  border: 8px solid rgba(0, 0, 0, 0);\n  border-bottom-color: #d9d9d9;\n}\n.vega-embed .vega-actions::after {\n  left: auto;\n  right: 15px;\n  top: -14px;\n  border: 7px solid rgba(0, 0, 0, 0);\n  border-bottom-color: #fff;\n}\n.vega-embed .chart-wrapper.fit-x {\n  width: 100%;\n}\n.vega-embed .chart-wrapper.fit-y {\n  height: 100%;\n}\n\n.vega-embed-wrapper {\n  max-width: 100%;\n  overflow: auto;\n  padding-right: 14px;\n}\n\n@keyframes scale-in {\n  from {\n    opacity: 0;\n    transform: scale(0.6);\n  }\n  to {\n    opacity: 1;\n    transform: scale(1);\n  }\n}\n';
function PK(t) {
  for (var n = arguments.length, e = new Array(n > 1 ? n - 1 : 0), r = 1; r < n; r++) e[r - 1] = arguments[r];
  for (var i = 0, o = e; i < o.length; i++) {
    var u = o[i];
    RK(t, u);
  }
  return t;
}
function RK(t, n) {
  for (var e = 0, r = Object.keys(n); e < r.length; e++) {
    var i = r[e];
    rt(t, i, n[i], !0);
  }
}
function LK(t, n) {
  var e = ('undefined' != typeof Symbol && t[Symbol.iterator]) || t['@@iterator'];
  if (!e) {
    if (
      Array.isArray(t) ||
      (e = (function (t, n) {
        if (t) {
          if ('string' == typeof t) return qK(t, n);
          var e = Object.prototype.toString.call(t).slice(8, -1);
          return (
            'Object' === e && t.constructor && (e = t.constructor.name),
            'Map' === e || 'Set' === e
              ? Array.from(t)
              : 'Arguments' === e || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(e)
              ? qK(t, n)
              : void 0
          );
        }
      })(t)) ||
      (n && t && 'number' == typeof t.length)
    ) {
      e && (t = e);
      var r = 0,
        i = function () {};
      return {
        s: i,
        n: function () {
          return r >= t.length ? { done: !0 } : { done: !1, value: t[r++] };
        },
        e: function (t) {
          throw t;
        },
        f: i,
      };
    }
    throw new TypeError(
      'Invalid attempt to iterate non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.',
    );
  }
  var o,
    u = !0,
    s = !1;
  return {
    s: function () {
      e = e.call(t);
    },
    n: function () {
      var t = e.next();
      return (u = t.done), t;
    },
    e: function (t) {
      (s = !0), (o = t);
    },
    f: function () {
      try {
        u || null == e.return || e.return();
      } finally {
        if (s) throw o;
      }
    },
  };
}
function qK(t, n) {
  (null == n || n > t.length) && (n = t.length);
  for (var e = 0, r = new Array(n); e < n; e++) r[e] = t[e];
  return r;
}
function IK(t, n) {
  var e = Object.keys(t);
  if (Object.getOwnPropertySymbols) {
    var r = Object.getOwnPropertySymbols(t);
    n &&
      (r = r.filter(function (n) {
        return Object.getOwnPropertyDescriptor(t, n).enumerable;
      })),
      e.push.apply(e, r);
  }
  return e;
}
function UK(t) {
  for (var n = 1; n < arguments.length; n++) {
    var e = null != arguments[n] ? arguments[n] : {};
    n % 2
      ? IK(Object(e), !0).forEach(function (n) {
          HQ(t, n, e[n]);
        })
      : Object.getOwnPropertyDescriptors
      ? Object.defineProperties(t, Object.getOwnPropertyDescriptors(e))
      : IK(Object(e)).forEach(function (n) {
          Object.defineProperty(t, n, Object.getOwnPropertyDescriptor(e, n));
        });
  }
  return t;
}
String.prototype.startsWith ||
  (String.prototype.startsWith = function (t, n) {
    return this.substr(!n || n < 0 ? 0 : +n, t.length) === t;
  });
var WK = Nz,
  HK = GJ,
  GK = 'undefined' != typeof window ? window : void 0;
void 0 === HK && null != GK && null !== (zK = GK.vl) && void 0 !== zK && zK.compile && (HK = GK.vl);
var VK = { export: { svg: !0, png: !0 }, source: !0, compiled: !0, editor: !0 },
  YK = {
    CLICK_TO_VIEW_ACTIONS: 'Click to view actions',
    COMPILED_ACTION: 'View Compiled Vega',
    EDITOR_ACTION: 'Open in Vega Editor',
    PNG_ACTION: 'Save as PNG',
    SOURCE_ACTION: 'View Source',
    SVG_ACTION: 'Save as SVG',
  },
  XK = { vega: 'Vega', 'vega-lite': 'Vega-Lite' },
  JK = { vega: WK.version, 'vega-lite': HK ? HK.version : 'not available' },
  QK = { vega: t => t, 'vega-lite': (t, n) => HK.compile(t, { config: n }).spec },
  ZK =
    '\n<svg viewBox="0 0 16 16" fill="currentColor" stroke="none" stroke-width="1" stroke-linecap="round" stroke-linejoin="round">\n  <circle r="2" cy="8" cx="2"></circle>\n  <circle r="2" cy="8" cx="8"></circle>\n  <circle r="2" cy="8" cx="14"></circle>\n</svg>',
  KK = 'chart-wrapper';
function t0(t) {
  return 'function' == typeof t;
}
function n0(t, n, e, r) {
  var i = '<html><head>'.concat(n, '</head><body><pre><code class="json">'),
    o = '</code></pre>'.concat(e, '</body></html>'),
    u = window.open('');
  u.document.write(i + t + o), (u.document.title = ''.concat(XK[r], ' JSON Source'));
}
function e0(t, n) {
  if (t.$schema) {
    var e,
      r = VJ(t.$schema);
    n &&
      n !== r.library &&
      console.warn(
        'The given visualization spec is written in '
          .concat(XK[r.library], ', but mode argument sets ')
          .concat(null !== (e = XK[n]) && void 0 !== e ? e : n, '.'),
      );
    var i = r.library;
    return (
      BK(JK[i], '^'.concat(r.version.slice(1))) ||
        console.warn(
          'The input spec uses '
            .concat(XK[i], ' ')
            .concat(r.version, ', but the current version of ')
            .concat(XK[i], ' is v')
            .concat(JK[i], '.'),
        ),
      i
    );
  }
  return 'mark' in t ||
    'encoding' in t ||
    'layer' in t ||
    'hconcat' in t ||
    'vconcat' in t ||
    'facet' in t ||
    'repeat' in t
    ? 'vega-lite'
    : 'marks' in t || 'signals' in t || 'scales' in t || 'axes' in t
    ? 'vega'
    : null != n
    ? n
    : 'vega';
}
function r0(t) {
  return (n = t) && 'load' in n ? t : WK.loader(t);
  var n;
}
function i0(t) {
  var n,
    e,
    r = null !== (n = null === (e = t.usermeta) || void 0 === e ? void 0 : e.embedOptions) && void 0 !== n ? n : {};
  return Xt(r.defaultStyle) && (r.defaultStyle = !1), r;
}
function o0() {
  return (
    (o0 = VQ(
      MZ.mark(function t(n, e) {
        var r,
          i,
          o,
          u,
          s,
          a,
          c,
          l,
          f,
          h,
          d,
          p = arguments;
        return MZ.wrap(function (t) {
          for (;;)
            switch ((t.prev = t.next)) {
              case 0:
                if (((o = p.length > 2 && void 0 !== p[2] ? p[2] : {}), !Xt(e))) {
                  t.next = 10;
                  break;
                }
                return (s = r0(o.loader)), (t.t0 = JSON), (t.next = 6), s.load(e);
              case 6:
                (t.t1 = t.sent), (u = t.t0.parse.call(t.t0, t.t1)), (t.next = 11);
                break;
              case 10:
                u = e;
              case 11:
                return (
                  (a = i0(u)),
                  (c = a.loader),
                  (s && !c) || (s = r0(null !== (l = o.loader) && void 0 !== l ? l : c)),
                  (t.next = 16),
                  u0(a, s)
                );
              case 16:
                return (f = t.sent), (t.next = 19), u0(o, s);
              case 19:
                return (
                  (d = UK(
                    UK({}, PK((h = t.sent), f)),
                    {},
                    {
                      config: et(
                        null !== (r = h.config) && void 0 !== r ? r : {},
                        null !== (i = f.config) && void 0 !== i ? i : {},
                      ),
                    },
                  )),
                  (t.next = 23),
                  c0(n, u, d, s)
                );
              case 23:
                return t.abrupt('return', t.sent);
              case 24:
              case 'end':
                return t.stop();
            }
        }, t);
      }),
    )),
    o0.apply(this, arguments)
  );
}
function u0(t, n) {
  return s0.apply(this, arguments);
}
function s0() {
  return (
    (s0 = VQ(
      MZ.mark(function t(n, e) {
        var r, i, o;
        return MZ.wrap(function (t) {
          for (;;)
            switch ((t.prev = t.next)) {
              case 0:
                if (!Xt(n.config)) {
                  t.next = 8;
                  break;
                }
                return (t.t1 = JSON), (t.next = 4), e.load(n.config);
              case 4:
                (t.t2 = t.sent), (t.t0 = t.t1.parse.call(t.t1, t.t2)), (t.next = 9);
                break;
              case 8:
                t.t0 = null !== (r = n.config) && void 0 !== r ? r : {};
              case 9:
                if (((i = t.t0), !Xt(n.patch))) {
                  t.next = 18;
                  break;
                }
                return (t.t4 = JSON), (t.next = 14), e.load(n.patch);
              case 14:
                (t.t5 = t.sent), (t.t3 = t.t4.parse.call(t.t4, t.t5)), (t.next = 19);
                break;
              case 18:
                t.t3 = n.patch;
              case 19:
                return (o = t.t3), t.abrupt('return', UK(UK(UK({}, n), o ? { patch: o } : {}), i ? { config: i } : {}));
              case 21:
              case 'end':
                return t.stop();
            }
        }, t);
      }),
    )),
    s0.apply(this, arguments)
  );
}
function a0(t) {
  var n,
    e = t.getRootNode ? t.getRootNode() : document;
  return e instanceof ShadowRoot
    ? { root: e, rootContainer: e }
    : { root: document, rootContainer: null !== (n = document.head) && void 0 !== n ? n : document.body };
}
function c0(t, n) {
  return l0.apply(this, arguments);
}
function l0() {
  return (
    (l0 = VQ(
      MZ.mark(function t(n, e) {
        var r,
          i,
          o,
          u,
          s,
          a,
          c,
          l,
          f,
          h,
          d,
          p,
          m,
          v,
          g,
          b,
          y,
          w,
          x,
          O,
          k,
          $,
          M,
          j,
          D,
          F,
          E,
          S,
          C,
          N,
          B,
          z,
          T,
          P,
          R,
          L,
          q,
          I,
          U,
          W,
          H,
          G,
          V,
          Y,
          X,
          J,
          Q,
          Z,
          K = arguments;
        return MZ.wrap(
          function (t) {
            for (;;)
              switch ((t.prev = t.next)) {
                case 0:
                  if (
                    ((Z = function () {
                      R && document.removeEventListener('click', R), B.finalize();
                    }),
                    (f = K.length > 3 ? K[3] : void 0),
                    (h = (l = K.length > 2 && void 0 !== K[2] ? K[2] : {}).theme
                      ? et(RQ[l.theme], null !== (r = l.config) && void 0 !== r ? r : {})
                      : l.config),
                    (d = Wt(l.actions) ? l.actions : PK({}, VK, null !== (i = l.actions) && void 0 !== i ? i : {})),
                    (p = UK(UK({}, YK), l.i18n)),
                    (m = null !== (o = l.renderer) && void 0 !== o ? o : 'canvas'),
                    (v = null !== (u = l.logLevel) && void 0 !== u ? u : WK.Warn),
                    (g = null !== (s = l.downloadFileName) && void 0 !== s ? s : 'visualization'),
                    (b = 'string' == typeof n ? document.querySelector(n) : n))
                  ) {
                    t.next = 12;
                    break;
                  }
                  throw new Error(''.concat(n, ' does not exist'));
                case 12:
                  if (
                    (!1 !== l.defaultStyle &&
                      ((y = 'vega-embed-style'),
                      (w = a0(b)),
                      (x = w.rootContainer),
                      w.root.getElementById(y) ||
                        (((O = document.createElement('style')).id = y),
                        (O.innerHTML =
                          void 0 === l.defaultStyle || !0 === l.defaultStyle ? TK.toString() : l.defaultStyle),
                        x.appendChild(O))),
                    (k = e0(e, l.mode)),
                    ($ = QK[k](e, h)),
                    'vega-lite' === k &&
                      $.$schema &&
                      ((M = VJ($.$schema)),
                      BK(JK.vega, '^'.concat(M.version.slice(1))) ||
                        console.warn(
                          'The compiled spec uses Vega '
                            .concat(M.version, ', but current version is v')
                            .concat(JK.vega, '.'),
                        )),
                    b.classList.add('vega-embed'),
                    d && b.classList.add('has-actions'),
                    (b.innerHTML = ''),
                    (j = b),
                    d && ((D = document.createElement('div')).classList.add(KK), b.appendChild(D), (j = D)),
                    (F = l.patch) && ($ = F instanceof Function ? F($) : A($, F, !0, !1).newDocument),
                    l.formatLocale && WK.formatLocale(l.formatLocale),
                    l.timeFormatLocale && WK.timeFormatLocale(l.timeFormatLocale),
                    l.expressionFunctions)
                  )
                    for (E in l.expressionFunctions)
                      'fn' in (S = l.expressionFunctions[E])
                        ? WK.expressionFunction(E, S.fn, S.visitor)
                        : S instanceof Function && WK.expressionFunction(E, S);
                  return (
                    (N = WK.parse($, 'vega-lite' === k ? {} : h, { ast: (C = l.ast) })),
                    (B = new (l.viewClass || WK.View)(
                      N,
                      UK(
                        { loader: f, logLevel: v, renderer: m },
                        C
                          ? {
                              expr:
                                null !== (a = null !== (c = WK.expressionInterpreter) && void 0 !== c ? c : l.expr) &&
                                void 0 !== a
                                  ? a
                                  : Uz,
                            }
                          : {},
                      ),
                    )).addSignalListener('autosize', (t, n) => {
                      var e = n.type;
                      'fit-x' == e
                        ? (j.classList.add('fit-x'), j.classList.remove('fit-y'))
                        : 'fit-y' == e
                        ? (j.classList.remove('fit-x'), j.classList.add('fit-y'))
                        : 'fit' == e
                        ? j.classList.add('fit-x', 'fit-y')
                        : j.classList.remove('fit-x', 'fit-y');
                    }),
                    !1 !== l.tooltip &&
                      ((z = t0(l.tooltip) ? l.tooltip : new UQ(!0 === l.tooltip ? {} : l.tooltip).call), B.tooltip(z)),
                    void 0 === (T = l.hover) && (T = 'vega' === k),
                    T && B.hover((P = 'boolean' == typeof T ? {} : T).hoverSet, P.updateSet),
                    l &&
                      (null != l.width && B.width(l.width),
                      null != l.height && B.height(l.height),
                      null != l.padding && B.padding(l.padding)),
                    (t.next = 37),
                    B.initialize(j, l.bind).runAsync()
                  );
                case 37:
                  if (!1 === d) {
                    t.next = 63;
                    break;
                  }
                  if (
                    ((L = b),
                    !1 !== l.defaultStyle &&
                      (((q = document.createElement('details')).title = p.CLICK_TO_VIEW_ACTIONS),
                      b.append(q),
                      (L = q),
                      ((I = document.createElement('summary')).innerHTML = ZK),
                      q.append(I),
                      (R = t => {
                        q.contains(t.target) || q.removeAttribute('open');
                      }),
                      document.addEventListener('click', R)),
                    (U = document.createElement('div')),
                    L.append(U),
                    U.classList.add('vega-actions'),
                    !0 !== d && !1 === d.export)
                  ) {
                    t.next = 60;
                    break;
                  }
                  (W = LK(['svg', 'png'])),
                    (t.prev = 45),
                    (G = MZ.mark(function t() {
                      var n, e, r, i;
                      return MZ.wrap(function (t) {
                        for (;;)
                          switch ((t.prev = t.next)) {
                            case 0:
                              (n = H.value),
                                (!0 === d || !0 === d.export || d.export[n]) &&
                                  ((e = p[''.concat(n.toUpperCase(), '_ACTION')]),
                                  (r = document.createElement('a')),
                                  (i = tt(l.scaleFactor) ? l.scaleFactor[n] : l.scaleFactor),
                                  (r.text = e),
                                  (r.href = '#'),
                                  (r.target = '_blank'),
                                  (r.download = ''.concat(g, '.').concat(n)),
                                  r.addEventListener(
                                    'mousedown',
                                    (function () {
                                      var t = VQ(
                                        MZ.mark(function t(e) {
                                          return MZ.wrap(
                                            function (t) {
                                              for (;;)
                                                switch ((t.prev = t.next)) {
                                                  case 0:
                                                    return e.preventDefault(), (t.next = 3), B.toImageURL(n, i);
                                                  case 3:
                                                    this.href = t.sent;
                                                  case 5:
                                                  case 'end':
                                                    return t.stop();
                                                }
                                            },
                                            t,
                                            this,
                                          );
                                        }),
                                      );
                                      return function (n) {
                                        return t.apply(this, arguments);
                                      };
                                    })(),
                                  ),
                                  U.append(r));
                            case 2:
                            case 'end':
                              return t.stop();
                          }
                      }, t);
                    })),
                    W.s();
                case 48:
                  if ((H = W.n()).done) {
                    t.next = 52;
                    break;
                  }
                  return t.delegateYield(G(), 't0', 50);
                case 50:
                  t.next = 48;
                  break;
                case 52:
                  t.next = 57;
                  break;
                case 54:
                  (t.prev = 54), (t.t1 = t.catch(45)), W.e(t.t1);
                case 57:
                  return (t.prev = 57), W.f(), t.finish(57);
                case 60:
                  (!0 !== d && !1 === d.source) ||
                    (((V = document.createElement('a')).text = p.SOURCE_ACTION),
                    (V.href = '#'),
                    V.addEventListener('click', function (t) {
                      var n, r;
                      n0(
                        _(e),
                        null !== (n = l.sourceHeader) && void 0 !== n ? n : '',
                        null !== (r = l.sourceFooter) && void 0 !== r ? r : '',
                        k,
                      ),
                        t.preventDefault();
                    }),
                    U.append(V)),
                    'vega-lite' !== k ||
                      (!0 !== d && !1 === d.compiled) ||
                      (((Y = document.createElement('a')).text = p.COMPILED_ACTION),
                      (Y.href = '#'),
                      Y.addEventListener('click', function (t) {
                        var n, e;
                        n0(
                          _($),
                          null !== (n = l.sourceHeader) && void 0 !== n ? n : '',
                          null !== (e = l.sourceFooter) && void 0 !== e ? e : '',
                          'vega',
                        ),
                          t.preventDefault();
                      }),
                      U.append(Y)),
                    (!0 !== d && !1 === d.editor) ||
                      ((J = null !== (X = l.editorUrl) && void 0 !== X ? X : 'https://vega.github.io/editor/'),
                      ((Q = document.createElement('a')).text = p.EDITOR_ACTION),
                      (Q.href = '#'),
                      Q.addEventListener('click', function (t) {
                        _K(window, J, { config: h, mode: k, renderer: m, spec: _(e) }), t.preventDefault();
                      }),
                      U.append(Q));
                case 63:
                  return t.abrupt('return', { view: B, spec: e, vgSpec: $, finalize: Z, embedOptions: l });
                case 64:
                case 'end':
                  return t.stop();
              }
          },
          t,
          null,
          [[45, 54, 57, 60]],
        );
      }),
    )),
    l0.apply(this, arguments)
  );
}
const f0 = {
    en: {
      dateTime: '%x, %X',
      date: '%-m/%-d/%Y',
      time: '%-I:%M:%S %p',
      periods: ['AM', 'PM'],
      days: ['Sunday', 'Monday', 'Tuesday', 'Wednesday', 'Thursday', 'Friday', 'Saturday'],
      shortDays: ['Sun', 'Mon', 'Tue', 'Wed', 'Thu', 'Fri', 'Sat'],
      months: [
        'January',
        'February',
        'March',
        'April',
        'May',
        'June',
        'July',
        'August',
        'September',
        'October',
        'November',
        'December',
      ],
      shortMonths: ['Jan', 'Feb', 'Mar', 'Apr', 'May', 'Jun', 'Jul', 'Aug', 'Sep', 'Oct', 'Nov', 'Dec'],
    },
    de: {
      dateTime: '%A, der %e. %B %Y, %X',
      date: '%d.%m.%Y',
      time: '%H:%M:%S',
      periods: ['AM', 'PM'],
      days: ['Sonntag', 'Montag', 'Dienstag', 'Mittwoch', 'Donnerstag', 'Freitag', 'Samstag'],
      shortDays: ['So', 'Mo', 'Di', 'Mi', 'Do', 'Fr', 'Sa'],
      months: [
        'Januar',
        'Februar',
        'März',
        'April',
        'Mai',
        'Juni',
        'Juli',
        'August',
        'September',
        'Oktober',
        'November',
        'Dezember',
      ],
      shortMonths: ['Jan', 'Feb', 'Mrz', 'Apr', 'Mai', 'Jun', 'Jul', 'Aug', 'Sep', 'Okt', 'Nov', 'Dez'],
    },
  },
  h0 = class {
    constructor(e) {
      t(this, e),
        (this.chartComponentReady = n(this, 'chartComponentReady', 7)),
        (this.chartClicked = n(this, 'chartClicked', 7)),
        (this.defaultVisualizationSpec = {}),
        (this.defaultEmbedOptions = { actions: !1, renderer: 'svg' }),
        (this.visualizationSpec = void 0),
        (this.embedOptions = void 0);
    }
    componentWillLoad() {
      u(this.root);
    }
    handleChartClick(t, n) {
      this.chartClicked.emit(n);
    }
    async componentDidRender() {
      const t = o(this.root);
      await (function (t, n) {
        return o0.apply(this, arguments);
      })(
        this.chartContainer,
        Object.assign({}, this.defaultVisualizationSpec, this.visualizationSpec),
        Object.assign({ timeFormatLocale: f0[t] }, this.defaultEmbedOptions, this.embedOptions, {
          patch: t => (
            (null == t ? void 0 : t.signals) || (t.signals = []),
            t.signals.push({ name: 'chartClick', value: 0, on: [{ events: 'rect:mousedown', update: 'datum' }] }),
            t
          ),
        }),
      ).then(t => {
        t.view.addSignalListener('chartClick', (t, n) => this.handleChartClick(t, n));
      });
    }
    componentDidLoad() {
      this.chartComponentReady.emit();
    }
    render() {
      return e('div', { ref: t => (this.chartContainer = t) });
    }
    get root() {
      return r(this);
    }
  };
h0.style =
  ':host{height:fit-content}text{fill:#2e394c}.role-axis-domain{fill:#2e394c}.role-axis-label text{fill:#596373}.mark-rule.role-axis-domain line{stroke:#2e394c}';
export { h0 as gux_visualization_beta };
